<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\umbraco.cms\businesslogic\web\Access.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Xml;
using System.Xml.Linq;
using System.Web.Security;
using Umbraco.Core;
using Umbraco.Core.Models;
using Umbraco.Core.Security;
using Umbraco.Core.Services;

namespace umbraco.cms.businesslogic.web
{
    /// &lt;summary&gt;
    /// Summary description for Access.
    /// &lt;/summary&gt;
    [Obsolete(&quot;Use Umbraco.Core.Service.IPublicAccessService instead&quot;)]
    public class Access
    {

        [Obsolete(&quot;Do not access this property directly, it is not thread safe, use GetXmlDocumentCopy instead&quot;)]
        public static XmlDocument AccessXml
        {
            get { return GetXmlDocumentCopy(); }
        }

        //NOTE: This is here purely for backwards compat
        [Obsolete(&quot;This should never be used, the data is stored in the database now&quot;)]
        public static XmlDocument GetXmlDocumentCopy()
        {
            var allAccessEntries = ApplicationContext.Current.Services.PublicAccessService.GetAll().ToArray();

            var xml = XDocument.Parse(&quot;&lt;access/&gt;&quot;);
            foreach (var entry in allAccessEntries)
            {
                var pageXml = new XElement(&quot;page&quot;,
                    new XAttribute(&quot;id&quot;, entry.ProtectedNodeId),
                    new XAttribute(&quot;loginPage&quot;, entry.LoginNodeId),
                    new XAttribute(&quot;noRightsPage&quot;, entry.NoAccessNodeId));

                foreach (var rule in entry.Rules)
                {
                    if (rule.RuleType == Constants.Conventions.PublicAccess.MemberUsernameRuleType)
                    {
                        //if there is a member id claim then it is &#39;simple&#39; (this is how legacy worked)
                        pageXml.Add(new XAttribute(&quot;simple&quot;, &quot;True&quot;));
                        pageXml.Add(new XAttribute(&quot;memberId&quot;, rule.RuleValue));
                    }
                    else if (rule.RuleType == Constants.Conventions.PublicAccess.MemberRoleRuleType)
                    {
                        pageXml.Add(new XElement(&quot;group&quot;, new XAttribute(&quot;id&quot;, rule.RuleValue)));
                    }
                }

                xml.Root.Add(pageXml);
            }

            return xml.ToXmlDocument();
        }

        #region Manipulation methods

        public static void AddMembershipRoleToDocument(int documentId, string role)
        {
            //event
            var doc = new Document(documentId);
            var e = new AddMemberShipRoleToDocumentEventArgs();
            new Access().FireBeforeAddMemberShipRoleToDocument(doc, role, e);

            if (e.Cancel) return;


            var entry = ApplicationContext.Current.Services.PublicAccessService.AddRule(
                doc.ContentEntity,
                Constants.Conventions.PublicAccess.MemberRoleRuleType,
                role);

            if (entry.Success == false &amp;&amp; entry.Result.Entity == null)
            {
                throw new Exception(&quot;Document is not protected!&quot;);
            }

            Save();

            new Access().FireAfterAddMemberShipRoleToDocument(doc, role, e);
        }
        

        [Obsolete(&quot;This method is no longer supported. Use the ASP.NET MemberShip methods instead&quot;, true)]
        public static void AddMemberGroupToDocument(int DocumentId, int MemberGroupId)
        {
            var content = ApplicationContext.Current.Services.ContentService.GetById(DocumentId);

            if (content == null)
                throw new Exception(&quot;No content found with document id &quot; + DocumentId);

            if (ApplicationContext.Current.Services.PublicAccessService.AddRule(
                content,
                Constants.Conventions.PublicAccess.MemberGroupIdRuleType,
                MemberGroupId.ToString(CultureInfo.InvariantCulture)))
            {
                Save();
            }
            
        }

        [Obsolete(&quot;This method is no longer supported. Use the ASP.NET MemberShip methods instead&quot;, true)]
        public static void AddMemberToDocument(int DocumentId, int MemberId)
        {
            var content = ApplicationContext.Current.Services.ContentService.GetById(DocumentId);

            if (content == null)
                throw new Exception(&quot;No content found with document id &quot; + DocumentId);

            if (ApplicationContext.Current.Services.PublicAccessService.AddRule(
                content,
                Constants.Conventions.PublicAccess.MemberIdRuleType,
                MemberId.ToString(CultureInfo.InvariantCulture)))
            {
                Save();
            }
            
        }

        public static void AddMembershipUserToDocument(int documentId, string membershipUserName)
        {
            //event
            var doc = new Document(documentId);
            var e = new AddMembershipUserToDocumentEventArgs();
            new Access().FireBeforeAddMembershipUserToDocument(doc, membershipUserName, e);

            if (e.Cancel) return;

            var entry = ApplicationContext.Current.Services.PublicAccessService.AddRule(
                doc.ContentEntity, 
                Constants.Conventions.PublicAccess.MemberUsernameRuleType, 
                membershipUserName);

            if (entry.Success == false &amp;&amp; entry.Result.Entity == null)
            {
                throw new Exception(&quot;Document is not protected!&quot;);
            }

            if (entry)
            {
                Save();
                new Access().FireAfterAddMembershipUserToDocument(doc, membershipUserName, e);
            }
            
        }

        [Obsolete(&quot;This method is no longer supported. Use the ASP.NET MemberShip methods instead&quot;, true)]
        public static void RemoveMemberGroupFromDocument(int DocumentId, int MemberGroupId)
        {
            var doc = new Document(DocumentId);

            var entry = ApplicationContext.Current.Services.PublicAccessService.AddRule(
                doc.ContentEntity, 
                Constants.Conventions.PublicAccess.MemberGroupIdRuleType, 
                MemberGroupId.ToString(CultureInfo.InvariantCulture));

            if (entry.Success == false &amp;&amp; entry.Result.Entity == null)
            {
                throw new Exception(&quot;Document is not protected!&quot;);
            }

            if (entry)
            {
                Save();
            }
        }

        public static void RemoveMembershipRoleFromDocument(int documentId, string role)
        {
            var doc = new Document(documentId);
            var e = new RemoveMemberShipRoleFromDocumentEventArgs();
            new Access().FireBeforeRemoveMemberShipRoleFromDocument(doc, role, e);

            if (e.Cancel) return;

            if (ApplicationContext.Current.Services.PublicAccessService.RemoveRule(
                doc.ContentEntity,
                Constants.Conventions.PublicAccess.MemberRoleRuleType,
                role))
            {
                Save();
                new Access().FireAfterRemoveMemberShipRoleFromDocument(doc, role, e);
            };
            
        }

        public static bool RenameMemberShipRole(string oldRolename, string newRolename)
        {
            var hasChange = ApplicationContext.Current.Services.PublicAccessService.RenameMemberGroupRoleRules(oldRolename, newRolename);
            
            if (hasChange)
                Save();

            return hasChange;
        }

        public static void ProtectPage(bool Simple, int DocumentId, int LoginDocumentId, int ErrorDocumentId)
        {
            var doc = new Document(DocumentId);
            var e = new AddProtectionEventArgs();
            new Access().FireBeforeAddProtection(doc, e);

            if (e.Cancel) return;

            var loginContent = ApplicationContext.Current.Services.ContentService.GetById(LoginDocumentId);
            if (loginContent == null) throw new NullReferenceException(&quot;No content item found with id &quot; + LoginDocumentId);
            var noAccessContent = ApplicationContext.Current.Services.ContentService.GetById(ErrorDocumentId);
            if (noAccessContent == null) throw new NullReferenceException(&quot;No content item found with id &quot; + ErrorDocumentId);

            var entry = ApplicationContext.Current.Services.PublicAccessService.GetEntryForContent(doc.ContentEntity.Id.ToString());
            if (entry != null)
            {
                if (Simple)
                {
                    // if using simple mode, make sure that all existing groups are removed
                    entry.ClearRules();    
                }
                
                //ensure the correct ids are applied
                entry.LoginNodeId = loginContent.Id;
                entry.NoAccessNodeId = noAccessContent.Id;
            }
            else
            {
                entry = new PublicAccessEntry(doc.ContentEntity, 
                    ApplicationContext.Current.Services.ContentService.GetById(LoginDocumentId),
                    ApplicationContext.Current.Services.ContentService.GetById(ErrorDocumentId),
                    new List&lt;PublicAccessRule&gt;());
            }

            if (ApplicationContext.Current.Services.PublicAccessService.Save(entry))
            {
                Save();
                new Access().FireAfterAddProtection(new Document(DocumentId), e);
            }
            
        }

        public static void RemoveProtection(int DocumentId)
        {
            //event
            var doc = new Document(DocumentId);
            var e = new RemoveProtectionEventArgs();
            new Access().FireBeforeRemoveProtection(doc, e);

            if (e.Cancel) return;

            var entry = ApplicationContext.Current.Services.PublicAccessService.GetEntryForContent(doc.ContentEntity);
            if (entry != null)
            {
                ApplicationContext.Current.Services.PublicAccessService.Delete(entry);
            }

            Save();

            new Access().FireAfterRemoveProtection(doc, e);
        } 
        #endregion

        #region Reading methods

        [Obsolete(&quot;This method is no longer supported. Use the ASP.NET MemberShip methods instead&quot;, true)]
        public static bool IsProtectedByGroup(int DocumentId, int GroupId)
        {
            var d = new Document(DocumentId);

            var entry = ApplicationContext.Current.Services.PublicAccessService.GetEntryForContent(d.ContentEntity);
            if (entry == null) return false;

            return entry.Rules
                .Any(x =&gt; x.RuleType == Constants.Conventions.PublicAccess.MemberGroupIdRuleType 
                    &amp;&amp; x.RuleValue == GroupId.ToString(CultureInfo.InvariantCulture));

        }

        public static bool IsProtectedByMembershipRole(int documentId, string role)
        {
            var content = ApplicationContext.Current.Services.ContentService.GetById(documentId);

            var entry = ApplicationContext.Current.Services.PublicAccessService.GetEntryForContent(content);
            if (entry == null) return false;

            return entry.Rules
                .Any(x =&gt; x.RuleType == Constants.Conventions.PublicAccess.MemberRoleRuleType
                    &amp;&amp; x.RuleValue == role);

        }

        public static string[] GetAccessingMembershipRoles(int documentId, string path)
        {
            var entry = ApplicationContext.Current.Services.PublicAccessService.GetEntryForContent(path.EnsureEndsWith(&quot;,&quot; + documentId));
            if (entry == null) return new string[] { };

            var memberGroupRoleRules = entry.Rules.Where(x =&gt; x.RuleType == Constants.Conventions.PublicAccess.MemberRoleRuleType);
            return memberGroupRoleRules.Select(x =&gt; x.RuleValue).ToArray();

        }

        [Obsolete(&quot;This method is no longer supported. Use the ASP.NET MemberShip methods instead&quot;, true)]
        public static member.MemberGroup[] GetAccessingGroups(int DocumentId)
        {
            var content = ApplicationContext.Current.Services.ContentService.GetById(DocumentId);
            if (content == null) return null;

            var entry = ApplicationContext.Current.Services.PublicAccessService.GetEntryForContent(content);
            if (entry == null) return null;

            var memberGroupIdRules = entry.Rules.Where(x =&gt; x.RuleType == Constants.Conventions.PublicAccess.MemberGroupIdRuleType);

            return memberGroupIdRules.Select(x =&gt; new member.MemberGroup(int.Parse(x.RuleValue))).ToArray();

        }

        [Obsolete(&quot;This method is no longer supported. Use the ASP.NET MemberShip methods instead&quot;, true)]
        public static member.Member GetAccessingMember(int DocumentId)
        {
            var content = ApplicationContext.Current.Services.ContentService.GetById(DocumentId);
            if (content == null) return null;

            var entry = ApplicationContext.Current.Services.PublicAccessService.GetEntryForContent(content);
            if (entry == null) return null;

            //legacy would throw an exception here if it was not &#39;simple&#39; and simple means based on a member id in this case
            if (entry.Rules.All(x =&gt; x.RuleType != Constants.Conventions.PublicAccess.MemberIdRuleType))
            {
                throw new Exception(&quot;Document isn&#39;t protected using Simple mechanism. Use GetAccessingMemberGroups instead&quot;);
            }
            
            var memberIdRule = entry.Rules.First(x =&gt; x.RuleType == Constants.Conventions.PublicAccess.MemberIdRuleType);
            return new member.Member(int.Parse(memberIdRule.RuleValue));

        }

        public static MembershipUser GetAccessingMembershipUser(int documentId)
        {
            var content = ApplicationContext.Current.Services.ContentService.GetById(documentId);
            if (content == null) return null;

            var entry = ApplicationContext.Current.Services.PublicAccessService.GetEntryForContent(content);
            if (entry == null) return null;

            //legacy would throw an exception here if it was not &#39;simple&#39; and simple means based on a username
            if (entry.Rules.All(x =&gt; x.RuleType != Constants.Conventions.PublicAccess.MemberUsernameRuleType))
            {                
                throw new Exception(&quot;Document isn&#39;t protected using Simple mechanism. Use GetAccessingMemberGroups instead&quot;);
            }

            var provider = MembershipProviderExtensions.GetMembersMembershipProvider();
            var usernameRule = entry.Rules.First(x =&gt; x.RuleType == Constants.Conventions.PublicAccess.MemberUsernameRuleType);
            return provider.GetUser(usernameRule.RuleValue, false);

        }


        [Obsolete(&quot;This method is no longer supported. Use the ASP.NET MemberShip methods instead&quot;, true)]
        public static bool HasAccess(int DocumentId, member.Member Member)
        {
            var content = ApplicationContext.Current.Services.ContentService.GetById(DocumentId);
            if (content == null) return true;

            var entry = ApplicationContext.Current.Services.PublicAccessService.GetEntryForContent(content);
            if (entry == null) return true;

            var memberGroupIds = Member.Groups.Values.Cast&lt;MemberGroup&gt;().Select(x =&gt; x.Id.ToString(CultureInfo.InvariantCulture)).ToArray();
            return entry.Rules.Any(x =&gt; x.RuleType == Constants.Conventions.PublicAccess.MemberGroupIdRuleType
                                        &amp;&amp; memberGroupIds.Contains(x.RuleValue));

        }

        [Obsolete(&quot;This method has been replaced because of a spelling mistake. Use the HasAccess method instead.&quot;, false)]
        public static bool HasAccces(int documentId, object memberId)
        {
            // Call the correctly named version of this method
            return HasAccess(documentId, memberId);
        }

        public static bool HasAccess(int documentId, object memberId)
        {
            return ApplicationContext.Current.Services.PublicAccessService.HasAccess(
                documentId, 
                memberId, 
                ApplicationContext.Current.Services.ContentService,
                MembershipProviderExtensions.GetMembersMembershipProvider(),
                //TODO: This should really be targeting a specific provider by name!!
                Roles.Provider);
        }

        public static bool HasAccess(int documentId, string path, MembershipUser member)
        {
            return ApplicationContext.Current.Services.PublicAccessService.HasAccess(
                 path,
                 member,
                //TODO: This should really be targeting a specific provider by name!!
                 Roles.Provider);
        }

        public static ProtectionType GetProtectionType(int DocumentId)
        {
            var content = ApplicationContext.Current.Services.ContentService.GetById(DocumentId);
            if (content == null) return ProtectionType.NotProtected;

            var entry = ApplicationContext.Current.Services.PublicAccessService.GetEntryForContent(content);
            if (entry == null) return ProtectionType.NotProtected;

            //legacy states that if it is protected by a member id then it is &#39;simple&#39;
            return entry.Rules.Any(x =&gt; x.RuleType == Constants.Conventions.PublicAccess.MemberIdRuleType)
                ? ProtectionType.Simple 
                : ProtectionType.Advanced;

        }

        public static bool IsProtected(int DocumentId, string Path)
        {
            return ApplicationContext.Current.Services.PublicAccessService.IsProtected(Path.EnsureEndsWith(&quot;,&quot; + DocumentId));             
        }

        //return the protection status of this exact document - not based on inheritance
        public static bool IsProtected(int DocumentId)
        {
            return ApplicationContext.Current.Services.PublicAccessService.IsProtected(DocumentId.ToString());
        }

        public static int GetErrorPage(string Path)
        {
            var entry = ApplicationContext.Current.Services.PublicAccessService.GetEntryForContent(Path);
            if (entry == null) return -1;
            var entity = ApplicationContext.Current.Services.EntityService.Get(entry.NoAccessNodeId, UmbracoObjectTypes.Document, false);
            return entity.Id;

        }

        public static int GetLoginPage(string Path)
        {
            var entry = ApplicationContext.Current.Services.PublicAccessService.GetEntryForContent(Path);
            if (entry == null) return -1;
            var entity = ApplicationContext.Current.Services.EntityService.Get(entry.LoginNodeId, UmbracoObjectTypes.Document, false);
            return entity.Id;

        } 
        #endregion


        //NOTE: This is purely here for backwards compat for events
        private static void Save()
        {
            var e = new SaveEventArgs();

            new Access().FireBeforeSave(e);

            if (e.Cancel) return;

            new Access().FireAfterSave(e);
        }


        //Event delegates
        public delegate void SaveEventHandler(Access sender, SaveEventArgs e);

        public delegate void AddProtectionEventHandler(Document sender, AddProtectionEventArgs e);
        public delegate void RemoveProtectionEventHandler(Document sender, RemoveProtectionEventArgs e);

        public delegate void AddMemberShipRoleToDocumentEventHandler(Document sender, string role, AddMemberShipRoleToDocumentEventArgs e);
        public delegate void RemoveMemberShipRoleFromDocumentEventHandler(Document sender, string role, RemoveMemberShipRoleFromDocumentEventArgs e);

        public delegate void RemoveMemberShipUserFromDocumentEventHandler(Document sender, string MembershipUserName, RemoveMemberShipUserFromDocumentEventArgs e);
        public delegate void AddMembershipUserToDocumentEventHandler(Document sender, string MembershipUserName, AddMembershipUserToDocumentEventArgs e);

        //Events

        public static event SaveEventHandler BeforeSave;
        protected virtual void FireBeforeSave(SaveEventArgs e)
        {
            if (BeforeSave != null)
                BeforeSave(this, e);
        }

        public static event SaveEventHandler AfterSave;
        protected virtual void FireAfterSave(SaveEventArgs e)
        {
            if (AfterSave != null)
                AfterSave(this, e);
        }

        public static event AddProtectionEventHandler BeforeAddProtection;
        protected virtual void FireBeforeAddProtection(Document doc, AddProtectionEventArgs e)
        {
            if (BeforeAddProtection != null)
                BeforeAddProtection(doc, e);
        }

        public static event AddProtectionEventHandler AfterAddProtection;
        protected virtual void FireAfterAddProtection(Document doc, AddProtectionEventArgs e)
        {
            if (AfterAddProtection != null)
                AfterAddProtection(doc, e);
        }

        public static event RemoveProtectionEventHandler BeforeRemoveProtection;
        protected virtual void FireBeforeRemoveProtection(Document doc, RemoveProtectionEventArgs e)
        {
            if (BeforeRemoveProtection != null)
                BeforeRemoveProtection(doc, e);
        }

        public static event RemoveProtectionEventHandler AfterRemoveProtection;
        protected virtual void FireAfterRemoveProtection(Document doc, RemoveProtectionEventArgs e)
        {
            if (AfterRemoveProtection != null)
                AfterRemoveProtection(doc, e);
        }

        public static event AddMemberShipRoleToDocumentEventHandler BeforeAddMemberShipRoleToDocument;
        protected virtual void FireBeforeAddMemberShipRoleToDocument(Document doc, string role, AddMemberShipRoleToDocumentEventArgs e)
        {
            if (BeforeAddMemberShipRoleToDocument != null)
                BeforeAddMemberShipRoleToDocument(doc, role, e);
        }

        public static event AddMemberShipRoleToDocumentEventHandler AfterAddMemberShipRoleToDocument;
        protected virtual void FireAfterAddMemberShipRoleToDocument(Document doc, string role, AddMemberShipRoleToDocumentEventArgs e)
        {
            if (AfterAddMemberShipRoleToDocument != null)
                AfterAddMemberShipRoleToDocument(doc, role, e);
        }

        public static event RemoveMemberShipRoleFromDocumentEventHandler BeforeRemoveMemberShipRoleToDocument;
        protected virtual void FireBeforeRemoveMemberShipRoleFromDocument(Document doc, string role, RemoveMemberShipRoleFromDocumentEventArgs e)
        {
            if (BeforeRemoveMemberShipRoleToDocument != null)
                BeforeRemoveMemberShipRoleToDocument(doc, role, e);
        }

        public static event RemoveMemberShipRoleFromDocumentEventHandler AfterRemoveMemberShipRoleToDocument;
        protected virtual void FireAfterRemoveMemberShipRoleFromDocument(Document doc, string role, RemoveMemberShipRoleFromDocumentEventArgs e)
        {
            if (AfterRemoveMemberShipRoleToDocument != null)
                AfterRemoveMemberShipRoleToDocument(doc, role, e);
        }

        public static event RemoveMemberShipUserFromDocumentEventHandler BeforeRemoveMembershipUserFromDocument;
        protected virtual void FireBeforeRemoveMembershipUserFromDocument(Document doc, string username, RemoveMemberShipUserFromDocumentEventArgs e)
        {
            if (BeforeRemoveMembershipUserFromDocument != null)
                BeforeRemoveMembershipUserFromDocument(doc, username, e);
        }

        public static event RemoveMemberShipUserFromDocumentEventHandler AfterRemoveMembershipUserFromDocument;
        protected virtual void FireAfterRemoveMembershipUserFromDocument(Document doc, string username, RemoveMemberShipUserFromDocumentEventArgs e)
        {
            if (AfterRemoveMembershipUserFromDocument != null)
                AfterRemoveMembershipUserFromDocument(doc, username, e);
        }

        public static event AddMembershipUserToDocumentEventHandler BeforeAddMembershipUserToDocument;
        protected virtual void FireBeforeAddMembershipUserToDocument(Document doc, string username, AddMembershipUserToDocumentEventArgs e)
        {
            if (BeforeAddMembershipUserToDocument != null)
                BeforeAddMembershipUserToDocument(doc, username, e);
        }

        public static event AddMembershipUserToDocumentEventHandler AfterAddMembershipUserToDocument;
        protected virtual void FireAfterAddMembershipUserToDocument(Document doc, string username, AddMembershipUserToDocumentEventArgs e)
        {
            if (AfterAddMembershipUserToDocument != null)
                AfterAddMembershipUserToDocument(doc, username, e);
        }
    }

    public enum ProtectionType
    {
        NotProtected,
        Simple,
        Advanced
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[25,17,25,18,0],[25,19,25,47,0],[25,48,25,49,0],[31,9,31,10,0],[32,13,32,111,0],[34,13,34,52,0],[35,13,35,20,0],[35,22,35,31,0],[35,32,35,34,0],[35,35,35,51,0],[36,13,36,14,0],[37,17,40,75,0],[42,17,42,24,0],[42,26,42,34,0],[42,35,42,37,0],[42,38,42,49,0],[43,17,43,18,0],[44,21,44,100,0],[45,21,45,22,0],[47,25,47,71,0],[48,25,48,81,0],[49,21,49,22,0],[50,26,50,101,0],[51,21,51,22,0],[52,25,52,98,0],[53,21,53,22,0],[54,17,54,18,0],[56,17,56,39,0],[57,13,57,14,0],[59,13,59,40,0],[60,9,60,10,0],[65,9,65,10,0],[67,13,67,48,0],[68,13,68,64,0],[69,13,69,78,0],[71,13,71,26,0],[71,27,71,34,0],[74,13,77,23,0],[79,13,79,71,0],[80,13,80,14,0],[81,17,81,67,0],[84,13,84,20,0],[86,13,86,77,0],[87,9,87,10,0],[92,9,92,10,0],[93,13,93,98,0],[95,13,95,33,0],[96,17,96,88,0],[98,13,101,71,0],[102,13,102,14,0],[103,17,103,24,0],[104,13,104,14,0],[106,9,106,10,0],[110,9,110,10,0],[111,13,111,98,0],[113,13,113,33,0],[114,17,114,88,0],[116,13,119,66,0],[120,13,120,14,0],[121,17,121,24,0],[122,13,122,14,0],[124,9,124,10,0],[127,9,127,10,0],[129,13,129,48,0],[130,13,130,64,0],[131,13,131,92,0],[133,13,133,26,0],[133,27,133,34,0],[135,13,138,37,0],[140,13,140,71,0],[141,13,141,14,0],[142,17,142,67,0],[145,13,145,23,0],[146,13,146,14,0],[147,17,147,24,0],[148,17,148,95,0],[149,13,149,14,0],[151,9,151,10,0],[155,9,155,10,0],[156,13,156,48,0],[158,13,161,71,0],[163,13,163,71,0],[164,13,164,14,0],[165,17,165,67,0],[168,13,168,23,0],[169,13,169,14,0],[170,17,170,24,0],[171,13,171,14,0],[172,9,172,10,0],[175,9,175,10,0],[176,13,176,48,0],[177,13,177,69,0],[178,13,178,83,0],[180,13,180,26,0],[180,27,180,34,0],[182,13,185,23,0],[186,13,186,14,0],[187,17,187,24,0],[188,17,188,86,0],[189,13,189,14,0],[189,14,189,15,0],[191,9,191,10,0],[194,9,194,10,0],[195,13,195,138,0],[197,13,197,27,0],[198,17,198,24,0],[200,13,200,30,0],[201,9,201,10,0],[204,9,204,10,0],[205,13,205,48,0],[206,13,206,50,0],[207,13,207,58,0],[209,13,209,26,0],[209,27,209,34,0],[211,13,211,108,0],[212,13,212,38,0],[212,39,212,124,0],[213,13,213,111,0],[214,13,214,41,0],[214,42,214,127,0],[216,13,216,133,0],[217,13,217,31,0],[218,13,218,14,0],[219,17,219,28,0],[220,17,220,18,0],[222,21,222,40,0],[223,17,223,18,0],[226,17,226,53,0],[227,17,227,59,0],[228,13,228,14,0],[230,13,230,14,0],[231,17,234,51,0],[235,13,235,14,0],[237,13,237,85,0],[238,13,238,14,0],[239,17,239,24,0],[240,17,240,82,0],[241,13,241,14,0],[243,9,243,10,0],[246,9,246,10,0],[248,13,248,48,0],[249,13,249,53,0],[250,13,250,61,0],[252,13,252,26,0],[252,27,252,34,0],[254,13,254,119,0],[255,13,255,31,0],[256,13,256,14,0],[257,17,257,87,0],[258,13,258,14,0],[260,13,260,20,0],[262,13,262,60,0],[263,9,263,10,0],[270,9,270,10,0],[271,13,271,46,0],[273,13,273,117,0],[274,13,274,31,0],[274,32,274,45,0],[276,13,277,27,0],[277,27,278,85,0],[278,85,278,87,0],[276,13,278,87,0],[280,9,280,10,0],[283,9,283,10,0],[284,13,284,98,0],[286,13,286,109,0],[287,13,287,31,0],[287,32,287,45,0],[289,13,290,27,0],[290,27,291,43,0],[291,43,291,45,0],[289,13,291,45,0],[293,9,293,10,0],[296,9,296,10,0],[297,13,297,139,0],[298,13,298,31,0],[298,32,298,56,0],[300,13,300,63,0],[300,63,300,130,0],[300,130,300,132,0],[300,13,300,132,0],[301,13,301,53,0],[301,53,301,64,0],[301,64,301,76,0],[301,13,301,76,0],[303,9,303,10,0],[307,9,307,10,0],[308,13,308,98,0],[309,13,309,33,0],[309,34,309,46,0],[311,13,311,109,0],[312,13,312,31,0],[312,32,312,44,0],[314,13,314,61,0],[314,61,314,131,0],[314,131,314,133,0],[314,13,314,133,0],[316,13,316,51,0],[316,51,316,97,0],[316,97,316,109,0],[316,13,316,109,0],[318,9,318,10,0],[322,9,322,10,0],[323,13,323,98,0],[324,13,324,33,0],[324,34,324,46,0],[326,13,326,109,0],[327,13,327,31,0],[327,32,327,44,0],[330,13,330,38,0],[330,38,330,103,0],[330,103,330,105,0],[330,13,330,105,0],[331,13,331,14,0],[332,17,332,126,0],[335,13,335,55,0],[335,55,335,120,0],[335,120,335,122,0],[335,13,335,122,0],[336,13,336,73,0],[338,9,338,10,0],[341,9,341,10,0],[342,13,342,98,0],[343,13,343,33,0],[343,34,343,46,0],[345,13,345,109,0],[346,13,346,31,0],[346,32,346,44,0],[349,13,349,38,0],[349,38,349,109,0],[349,109,349,111,0],[349,13,349,111,0],[350,13,350,14,0],[351,17,351,126,0],[354,13,354,88,0],[355,13,355,55,0],[355,55,355,126,0],[355,126,355,128,0],[355,13,355,128,0],[356,13,356,68,0],[358,9,358,10,0],[363,9,363,10,0],[364,13,364,98,0],[365,13,365,33,0],[365,34,365,46,0],[367,13,367,109,0],[368,13,368,31,0],[368,32,368,44,0],[370,13,370,87,0],[370,87,370,130,0],[370,130,370,142,0],[370,13,370,142,0],[371,13,371,41,0],[371,41,372,80,0],[372,80,372,82,0],[371,13,372,82,0],[374,9,374,10,0],[378,9,378,10,0],[380,13,380,52,0],[381,9,381,10,0],[384,9,384,10,0],[385,13,391,33,0],[392,9,392,10,0],[395,9,395,10,0],[396,13,400,34,0],[401,9,401,10,0],[404,9,404,10,0],[405,13,405,98,0],[406,13,406,33,0],[406,34,406,69,0],[408,13,408,109,0],[409,13,409,31,0],[409,32,409,67,0],[412,13,412,41,0],[412,41,412,106,0],[412,106,414,43,0],[412,13,414,43,0],[416,9,416,10,0],[419,9,419,10,0],[420,13,420,127,0],[421,9,421,10,0],[425,9,425,10,0],[426,13,426,111,0],[427,9,427,10,0],[430,9,430,10,0],[431,13,431,106,0],[432,13,432,31,0],[432,32,432,42,0],[433,13,433,138,0],[434,13,434,30,0],[436,9,436,10,0],[439,9,439,10,0],[440,13,440,106,0],[441,13,441,31,0],[441,32,441,42,0],[442,13,442,135,0],[443,13,443,30,0],[445,9,445,10,0],[451,9,451,10,0],[452,13,452,41,0],[454,13,454,44,0],[456,13,456,26,0],[456,27,456,34,0],[458,13,458,43,0],[459,9,459,10,0],[478,9,478,10,0],[479,13,479,36,0],[480,17,480,37,0],[481,9,481,10,0],[485,9,485,10,0],[486,13,486,35,0],[487,17,487,36,0],[488,9,488,10,0],[492,9,492,10,0],[493,13,493,45,0],[494,17,494,45,0],[495,9,495,10,0],[499,9,499,10,0],[500,13,500,44,0],[501,17,501,44,0],[502,9,502,10,0],[506,9,506,10,0],[507,13,507,48,0],[508,17,508,48,0],[509,9,509,10,0],[513,9,513,10,0],[514,13,514,47,0],[515,17,515,47,0],[516,9,516,10,0],[520,9,520,10,0],[521,13,521,59,0],[522,17,522,65,0],[523,9,523,10,0],[527,9,527,10,0],[528,13,528,58,0],[529,17,529,64,0],[530,9,530,10,0],[534,9,534,10,0],[535,13,535,62,0],[536,17,536,68,0],[537,9,537,10,0],[541,9,541,10,0],[542,13,542,61,0],[543,17,543,67,0],[544,9,544,10,0],[548,9,548,10,0],[549,13,549,64,0],[550,17,550,74,0],[551,9,551,10,0],[555,9,555,10,0],[556,13,556,63,0],[557,17,557,73,0],[558,9,558,10,0],[562,9,562,10,0],[563,13,563,59,0],[564,17,564,69,0],[565,9,565,10,0],[569,9,569,10,0],[570,13,570,58,0],[571,17,571,68,0],[572,9,572,10,0]]);
    </script>
  </body>
</html>