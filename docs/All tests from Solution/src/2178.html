<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Dynamics\ExtensionMethodFinder.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Linq.Expressions;
using System.Text;
using System.Web.Services.Description;
using Umbraco.Core.Cache;
using Umbraco.Core.Logging;

namespace Umbraco.Core.Dynamics
{
	/// &lt;summary&gt;
	/// Utility class for finding extension methods on a type to execute
	/// &lt;/summary&gt;
    internal static class ExtensionMethodFinder
	{
        /// &lt;summary&gt;
        /// The static cache for extension methods found that match the criteria that we are looking for
        /// &lt;/summary&gt;
        private static readonly ConcurrentDictionary&lt;Tuple&lt;Type, string, int&gt;, MethodInfo[]&gt; MethodCache = new ConcurrentDictionary&lt;Tuple&lt;Type, string, int&gt;, MethodInfo[]&gt;();

	    private static IEnumerable&lt;Type&gt; GetTypes(Assembly a)
	    {
	        try
	        {
	            return TypeFinder.GetTypesWithFormattedException(a);
	        }
	        catch (ReflectionTypeLoadException ex)
	        {
                // is this going to flood the log?
                LogHelper.Error(typeof (ExtensionMethodFinder), &quot;Failed to get types.&quot;, ex);
                return Enumerable.Empty&lt;Type&gt;();
	        }
        }

        /// &lt;summary&gt;
        /// Returns the enumerable of all extension method info&#39;s in the app domain = USE SPARINGLY!!!
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// We cache this as a sliding 5 minute exiration, in unit tests there&#39;s over 1100 methods found, surely that will eat up a bit of memory so we want
        /// to make sure we give it back.
        /// &lt;/remarks&gt;
	    private static IEnumerable&lt;MethodInfo&gt; GetAllExtensionMethodsInAppDomain(IRuntimeCacheProvider runtimeCacheProvider)
        {
            if (runtimeCacheProvider == null) throw new ArgumentNullException(&quot;runtimeCacheProvider&quot;);

            return runtimeCacheProvider.GetCacheItem&lt;MethodInfo[]&gt;(typeof (ExtensionMethodFinder).Name, () =&gt; TypeFinder.GetAssembliesWithKnownExclusions()
                // assemblies that contain extension methods
                .Where(a =&gt; a.IsDefined(typeof (ExtensionAttribute), false))
                // types that contain extension methods
                .SelectMany(a =&gt; GetTypes(a)
                    .Where(t =&gt; t.IsDefined(typeof (ExtensionAttribute), false) &amp;&amp; t.IsSealed &amp;&amp; t.IsGenericType == false &amp;&amp; t.IsNested == false))
                // actual extension methods
                .SelectMany(t =&gt; t.GetMethods(BindingFlags.Static | BindingFlags.Public)
                    .Where(m =&gt; m.IsDefined(typeof (ExtensionAttribute), false)))
                // and also IEnumerable&lt;T&gt; extension methods - because the assembly is excluded
                .Concat(typeof (Enumerable).GetMethods(BindingFlags.Static | BindingFlags.Public))
                //If we don&#39;t do this then we&#39;ll be scanning all assemblies each time!
                .ToArray(),

                //only cache for 5 minutes
                timeout: TimeSpan.FromMinutes(5),

                //each time this is accessed it will be for 5 minutes longer
                isSliding:true);
        }

	    /// &lt;summary&gt;
	    /// Returns all extension methods found matching the definition
	    /// &lt;/summary&gt;
	    /// &lt;param name=&quot;runtimeCache&quot;&gt;
	    /// The runtime cache is used to temporarily cache all extension methods found in the app domain so that
	    /// while we search for individual extension methods, the process will be reasonably &#39;quick&#39;. We then statically
	    /// cache the MethodInfo&#39;s that we are looking for and then the runtime cache will expire and give back all that memory.
	    /// &lt;/param&gt;
	    /// &lt;param name=&quot;thisType&quot;&gt;&lt;/param&gt;
	    /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt;
	    /// &lt;param name=&quot;argumentCount&quot;&gt;
	    /// The arguments EXCLUDING the &#39;this&#39; argument in an extension method
	    /// &lt;/param&gt;
	    /// &lt;returns&gt;&lt;/returns&gt;
	    /// &lt;remarks&gt;
	    /// NOTE: This will be an intensive method to call! Results will be cached based on the key (args) of this method
	    /// &lt;/remarks&gt;
	    internal static IEnumerable&lt;MethodInfo&gt; GetAllExtensionMethods(IRuntimeCacheProvider runtimeCache, Type thisType, string name, int argumentCount)
		{
		    var key = new Tuple&lt;Type, string, int&gt;(thisType, name, argumentCount);

		    return MethodCache.GetOrAdd(key, tuple =&gt;
		    {
                var candidates = GetAllExtensionMethodsInAppDomain(runtimeCache);

                // filter by name
                var filtr1 = candidates.Where(m =&gt; m.Name == name);

                // filter by args count
                // ensure we add + 1 to the arg count because the &#39;this&#39; arg is not included in the count above!
                var filtr2 = filtr1.Where(m =&gt; m.GetParameters().Length == argumentCount + 1);

                // filter by first parameter type (target of the extension method)
                // ie find the right overload that can take genericParameterType
                // (which will be either DynamicNodeList or List&lt;DynamicNode&gt; which is IEnumerable)
                var filtr3 = filtr2.Select(x =&gt;
                {
                    var t = x.GetParameters()[0].ParameterType; // exists because of +1 above
                    var bindings = new Dictionary&lt;string, Type&gt;();
                    if (TypeHelper.MatchType(thisType, t, bindings) == false) return null;

                    // create the generic method if necessary
                    if (x.ContainsGenericParameters == false) return x;
                    var targs = t.GetGenericArguments().Select(y =&gt; bindings[y.Name]).ToArray();
                    return x.MakeGenericMethod(targs);
                }).Where(x =&gt; x != null);

		        return filtr3.ToArray();
		    });

        }

        private static MethodInfo DetermineMethodFromParams(IEnumerable&lt;MethodInfo&gt; methods, Type genericType, IEnumerable&lt;object&gt; args)
		{
			MethodInfo methodToExecute = null;

            //Given the args, lets get the types and compare the type sequence to try and find the correct overload
            var argTypes = args.Select(o =&gt;
            {
                var oe = (o as Expression);
                return oe != null ? oe.Type : o.GetType();
            });

            var methodsWithArgTypes = methods.Select(method =&gt; new
            {
                method,
                //skip the first arg because that is the extension method type (&#39;this&#39;) that we are looking for
                types = method.GetParameters().Select(pi =&gt; pi.ParameterType).Skip(1)
            });

            //This type comparer will check
            var typeComparer = new DelegateEqualityComparer&lt;Type&gt;(
                //Checks if the argument type passed in can be assigned from the parameter type in the method. For
                // example, if the argument type is HtmlHelper&lt;MyModel&gt; but the method parameter type is HtmlHelper then
                // it will match because the argument is assignable to that parameter type and will be able to execute
                TypeHelper.IsTypeAssignableFrom,
                //This will not ever execute but if it does we need to get the hash code of the string because the hash
                // code of a type is random
                type =&gt; type.FullName.GetHashCode());

            var firstMatchingOverload = methodsWithArgTypes
                .FirstOrDefault(m =&gt; m.types.SequenceEqual(argTypes, typeComparer));

            if (firstMatchingOverload != null)
            {
                methodToExecute = firstMatchingOverload.method;
            }

			return methodToExecute;
		}

        public static MethodInfo FindExtensionMethod(IRuntimeCacheProvider runtimeCache, Type thisType, object[] args, string name, bool argsContainsThis)
        {
            Type genericType = null;
            if (thisType.IsGenericType)
            {
                genericType = thisType.GetGenericArguments()[0];
            }

            args = args
                //if the args contains &#39;this&#39;, remove the first one since that is &#39;this&#39; and we don&#39;t want to use
                //that in the method searching
                .Skip(argsContainsThis ? 1 : 0)
                .ToArray();

            var methods = GetAllExtensionMethods(runtimeCache, thisType, name, args.Length).ToArray();

            return DetermineMethodFromParams(methods, genericType, args);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[23,9,23,175,1],[26,6,26,7,1],[28,10,28,11,1],[29,14,29,66,1],[31,10,31,48,0],[32,10,32,11,0],[34,17,34,93,0],[35,17,35,49,0],[37,9,37,10,1],[48,9,48,10,1],[49,13,49,46,1],[49,47,49,103,0],[51,13,51,111,1],[51,111,53,29,1],[53,29,53,76,1],[53,76,55,34,1],[55,34,56,33,1],[56,33,56,145,1],[56,145,56,146,1],[55,34,56,146,1],[56,146,58,34,1],[58,34,59,33,1],[59,33,59,80,1],[59,80,59,81,1],[58,34,59,81,1],[59,81,63,27,1],[51,111,63,27,1],[63,27,69,33,1],[51,13,69,33,1],[70,9,70,10,1],[90,3,90,4,1],[91,7,91,77,1],[93,7,94,7,1],[94,7,94,8,1],[94,8,95,17,1],[95,17,95,82,1],[95,82,98,17,1],[98,17,98,52,1],[98,52,98,66,1],[98,66,98,68,1],[98,17,98,68,1],[98,68,102,17,1],[102,17,102,48,1],[102,48,102,93,1],[102,93,102,95,1],[102,17,102,95,1],[102,95,107,17,1],[107,17,108,17,1],[108,17,108,18,1],[108,18,109,21,1],[109,21,109,64,1],[109,64,110,21,1],[110,21,110,67,1],[110,67,111,21,1],[111,21,111,78,1],[111,78,111,79,1],[111,79,111,91,1],[111,91,114,21,1],[114,21,114,62,1],[114,62,114,63,1],[114,63,114,72,1],[114,72,115,21,1],[115,21,115,69,1],[115,69,115,85,1],[115,85,115,97,1],[115,21,115,97,1],[115,97,116,21,1],[116,21,116,55,1],[116,55,117,17,1],[117,17,117,18,1],[117,18,117,31,1],[117,31,117,40,1],[117,40,117,42,1],[107,17,117,42,1],[117,42,119,11,1],[119,11,119,35,1],[119,35,120,7,1],[120,7,120,8,1],[120,8,120,10,1],[93,7,120,10,1],[122,9,122,10,1],[125,3,125,4,1],[126,4,126,38,1],[129,13,130,13,1],[130,13,130,14,1],[130,14,131,17,1],[131,17,131,44,1],[131,44,132,17,1],[132,17,132,59,1],[132,59,133,13,1],[133,13,133,14,1],[133,14,133,16,1],[129,13,133,16,1],[135,13,135,64,1],[135,64,139,61,1],[139,61,139,77,1],[139,77,140,14,1],[135,64,140,14,1],[140,14,140,16,1],[135,13,140,16,1],[143,13,150,25,1],[150,25,150,52,0],[150,52,150,54,1],[143,13,150,54,1],[152,13,153,38,1],[153,38,153,83,1],[153,83,153,85,1],[152,13,153,85,1],[155,13,155,47,1],[156,13,156,14,1],[157,17,157,64,1],[158,13,158,14,1],[160,4,160,27,1],[161,3,161,4,1],[164,9,164,10,1],[165,13,165,37,1],[166,13,166,40,1],[167,13,167,14,1],[168,17,168,65,1],[169,13,169,14,1],[171,13,175,28,1],[177,13,177,103,1],[179,13,179,74,1],[180,9,180,10,1]]);
    </script>
  </body>
</html>