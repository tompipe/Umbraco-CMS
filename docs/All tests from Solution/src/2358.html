<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\UmbracoExamine\LocalStorage\LocalTempStorageIndexer.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Specialized;
using System.IO;
using System.Linq;
using System.Threading;
using System.Web;
using System.Web.Compilation;
using Examine.LuceneEngine;
using Lucene.Net.Analysis;
using Lucene.Net.Index;
using Lucene.Net.Store;
using Umbraco.Core;
using Umbraco.Core.IO;
using Umbraco.Core.Logging;
using Directory = System.IO.Directory;

namespace UmbracoExamine.LocalStorage
{
    internal enum InitializeDirectoryFlags
    {
        Success = 0,
        SuccessNoIndexExists = 1,

        FailedCorrupt = 100,
        FailedLocked = 101,
        FailedFileSync = 102
    }

    internal class LocalTempStorageIndexer
    {
        public Lucene.Net.Store.Directory LuceneDirectory { get; private set; }
        private readonly object _locker = new object();
        public SnapshotDeletionPolicy Snapshotter { get; private set; }

        public string TempPath { get; private set; }


        public LocalTempStorageIndexer()
        {
            IndexDeletionPolicy policy = new KeepOnlyLastCommitDeletionPolicy();
            Snapshotter = new SnapshotDeletionPolicy(policy);
        }

        public void Initialize(NameValueCollection config, string configuredPath, FSDirectory baseLuceneDirectory, Analyzer analyzer, LocalStorageType localStorageType)
        {
            //this is the default
            ILocalStorageDirectory localStorageDir = new CodeGenLocalStorageDirectory();
            if (config[&quot;tempStorageDirectory&quot;] != null)
            {
                //try to get the type
                var dirType = BuildManager.GetType(config[&quot;tempStorageDirectory&quot;], false);
                if (dirType != null)
                {
                    try
                    {
                        localStorageDir = (ILocalStorageDirectory)Activator.CreateInstance(dirType);
                    }
                    catch (Exception ex)
                    {
                        LogHelper.Error&lt;LocalTempStorageIndexer&gt;(
                            string.Format(&quot;Could not create a temp storage location of type {0}, reverting to use the &quot; + typeof (CodeGenLocalStorageDirectory).FullName, dirType),
                            ex);
                    }
                }
            }

            var tempPath = localStorageDir.GetLocalStorageDirectory(config, configuredPath);
            if (tempPath == null) throw new InvalidOperationException(&quot;Could not resolve a temp location from the &quot; + localStorageDir.GetType() + &quot; specified&quot;);
            TempPath = tempPath.FullName;

            switch (localStorageType)
            {
                case LocalStorageType.Sync:
                    var success = InitializeLocalIndexAndDirectory(baseLuceneDirectory, analyzer, configuredPath);

                    //create the custom lucene directory which will keep the main and temp FS&#39;s in sync
                    LuceneDirectory = LocalTempStorageDirectoryTracker.Current.GetDirectory(
                        new DirectoryInfo(TempPath),
                        baseLuceneDirectory,
                        //flag to disable the mirrored folder if not successful
                        (int)success &gt;= 100);

                    //If the master index simply doesn&#39;t exist, we don&#39;t continue to try to open anything since there will
                    // actually be nothing there.
                    if (success == InitializeDirectoryFlags.SuccessNoIndexExists)
                    {
                        return;
                    }

                    //Try to open the reader, this will fail if the index is corrupt and we&#39;ll need to handle that
                    var result = DelegateExtensions.RetryUntilSuccessOrMaxAttempts(i =&gt;
                    {
                        try
                        {
                            using (IndexReader.Open(
                                LuceneDirectory,
                                DeletePolicyTracker.Current.GetPolicy(LuceneDirectory),
                                true))
                            {
                            }

                            return Attempt.Succeed(true);
                        }
                        catch (Exception ex)
                        {
                            LogHelper.WarnWithException&lt;LocalTempStorageIndexer&gt;(
                                string.Format(&quot;Could not open an index reader, local temp storage index is empty or corrupt... retrying... {0}&quot;, configuredPath),
                                ex);
                        }
                        return Attempt.Fail(false);
                    }, 5, TimeSpan.FromSeconds(1));

                    if (result.Success == false)
                    {
                        LogHelper.Warn&lt;LocalTempStorageIndexer&gt;(
                                string.Format(&quot;Could not open an index reader, local temp storage index is empty or corrupt... attempting to clear index files in local temp storage, will operate from main storage only {0}&quot;, configuredPath));

                        ClearFilesInPath(TempPath);

                        //create the custom lucene directory which will keep the main and temp FS&#39;s in sync
                        LuceneDirectory = LocalTempStorageDirectoryTracker.Current.GetDirectory(
                            new DirectoryInfo(TempPath),
                            baseLuceneDirectory,
                            //Disable mirrored index, we&#39;re kind of screwed here only use master index
                            true);
                    }

                    break;
                case LocalStorageType.LocalOnly:
                    if (Directory.Exists(TempPath) == false)
                    {
                        Directory.CreateDirectory(TempPath);
                    }
                    LuceneDirectory = DirectoryTracker.Current.GetDirectory(new DirectoryInfo(TempPath));
                    break;
                default:
                    throw new ArgumentOutOfRangeException(&quot;localStorageType&quot;);
            }
        }

        private void ClearFilesInPath(string path)
        {
            if (Directory.Exists(path))
            {
                foreach (var file in Directory.GetFiles(path))
                {
                    try
                    {
                        File.Delete(file);
                    }
                    catch (Exception exInner)
                    {
                        LogHelper.Error&lt;LocalTempStorageIndexer&gt;(&quot;Could not delete local temp storage index file&quot;, exInner);
                    }
                }
            }
        }

        private bool ClearLuceneDirFiles(Lucene.Net.Store.Directory baseLuceneDirectory)
        {
            try
            {
                //unlock it!
                IndexWriter.Unlock(baseLuceneDirectory);

                var fileLuceneDirectory = baseLuceneDirectory as FSDirectory;
                if (fileLuceneDirectory != null)
                {
                    foreach (var file in fileLuceneDirectory.ListAll())
                    {
                        try
                        {
                            fileLuceneDirectory.DeleteFile(file);
                        }
                        catch (IOException)
                        {
                            if (file.InvariantEquals(&quot;write.lock&quot;))
                            {
                                LogHelper.Warn&lt;LocalTempStorageIndexer&gt;(&quot;The lock file could not be deleted but should be removed when the writer is disposed&quot;);
                            }

                        }
                    }
                    return true;
                }
                return false;
            }
            catch (Exception ex)
            {
                LogHelper.Error&lt;LocalTempStorageIndexer&gt;(&quot;Could not clear corrupt index from main index folder, the index cannot be used&quot;, ex);
                return false;
            }
        }

        private Attempt&lt;IndexWriter&gt; TryCreateWriter(Lucene.Net.Store.Directory baseLuceneDirectory, Analyzer analyzer)
        {
            try
            {
                var w = new IndexWriter(
                    //read from the underlying/default directory, not the temp codegen dir
                    baseLuceneDirectory,
                    analyzer,
                    Snapshotter,
                    IndexWriter.MaxFieldLength.UNLIMITED);

                //Done!
                return Attempt.Succeed(w);
            }
            catch (Exception ex)
            {
                LogHelper.WarnWithException&lt;LocalTempStorageIndexer&gt;(&quot;Could not create index writer with snapshot policy for copying... retrying...&quot;, ex);
                return Attempt&lt;IndexWriter&gt;.Fail(ex);
            }
        }

        /// &lt;summary&gt;
        /// Attempts to create an index writer, it will retry on failure 5 times and on the last time will try to forcefully unlock the index files
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;baseLuceneDirectory&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;analyzer&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private Attempt&lt;IndexWriter&gt; TryCreateWriterWithRetry(Lucene.Net.Store.Directory baseLuceneDirectory, Analyzer analyzer)
        {
            var maxTries = 5;

            var result = DelegateExtensions.RetryUntilSuccessOrMaxAttempts((currentTry) =&gt;
            {
                //last try...
                if (currentTry == maxTries)
                {
                    LogHelper.Info&lt;LocalTempStorageIndexer&gt;(&quot;Could not acquire index lock, attempting to force unlock it...&quot;);
                    //unlock it!
                    IndexWriter.Unlock(baseLuceneDirectory);
                }

                var writerAttempt = TryCreateWriter(baseLuceneDirectory, analyzer);
                if (writerAttempt) return writerAttempt;
                LogHelper.Info&lt;LocalTempStorageIndexer&gt;(&quot;Could not create writer on {0}, retrying ....&quot;, baseLuceneDirectory.ToString);
                return Attempt&lt;IndexWriter&gt;.Fail();
            }, 5, TimeSpan.FromSeconds(1));

            return result;
        }

        private bool TryWaitForDirectoryUnlock(Lucene.Net.Store.Directory dir)
        {
            var maxTries = 5;

            var result = DelegateExtensions.RetryUntilSuccessOrMaxAttempts((currentTry) =&gt;
            {
                //last try...
                if (currentTry == maxTries)
                {
                    LogHelper.Info&lt;LocalTempStorageIndexer&gt;(&quot;Could not acquire directory lock, attempting to force unlock it...&quot;);
                    //unlock it!
                    IndexWriter.Unlock(dir);
                }

                if (IndexWriter.IsLocked(dir) == false) return Attempt.Succeed(true);
                LogHelper.Info&lt;LocalTempStorageIndexer&gt;(&quot;Could not acquire directory lock for {0} writer, retrying ....&quot;, dir.ToString);
                return Attempt&lt;bool&gt;.Fail();
            }, 5, TimeSpan.FromSeconds(1));

            return result;
        }

        private InitializeDirectoryFlags InitializeLocalIndexAndDirectory(Lucene.Net.Store.Directory baseLuceneDirectory, Analyzer analyzer, string configuredPath)
        {
            lock (_locker)
            {
                if (Directory.Exists(TempPath) == false)
                {
                    Directory.CreateDirectory(TempPath);
                }

                //copy index if it exists, don&#39;t do anything if it&#39;s not there
                if (IndexReader.IndexExists(baseLuceneDirectory) == false) return InitializeDirectoryFlags.SuccessNoIndexExists;

                var writerAttempt = TryCreateWriterWithRetry(baseLuceneDirectory, analyzer);

                if (writerAttempt.Success == false)
                {
                    LogHelper.Error&lt;LocalTempStorageIndexer&gt;(&quot;Could not create index writer with snapshot policy for copying, the index cannot be used&quot;, writerAttempt.Exception);
                    return InitializeDirectoryFlags.FailedLocked;
                }

                //Try to open the reader from the source, this will fail if the index is corrupt and we&#39;ll need to handle that
                try
                {
                    //NOTE: To date I&#39;ve not seen this error occur
                    using (writerAttempt.Result.GetReader())
                    {
                    }
                }
                catch (Exception ex)
                {
                    writerAttempt.Result.Dispose();

                    LogHelper.Error&lt;LocalTempStorageIndexer&gt;(
                        string.Format(&quot;Could not open an index reader, {0} is empty or corrupt... attempting to clear index files in master folder&quot;, configuredPath),
                        ex);

                    if (ClearLuceneDirFiles(baseLuceneDirectory) == false)
                    {
                        //hrm, not much we can do in this situation, but this shouldn&#39;t happen
                        LogHelper.Error&lt;LocalTempStorageIndexer&gt;(&quot;Could not open an index reader, index is corrupt.&quot;, ex);
                        return InitializeDirectoryFlags.FailedCorrupt;
                    }

                    //the main index is now blank, we&#39;ll proceed as normal with a new empty index...
                    writerAttempt = TryCreateWriter(baseLuceneDirectory, analyzer);
                    if (writerAttempt.Success == false)
                    {
                        //ultra fail...
                        LogHelper.Error&lt;LocalTempStorageIndexer&gt;(&quot;Could not create index writer with snapshot policy for copying, the index cannot be used&quot;, writerAttempt.Exception);
                        return InitializeDirectoryFlags.FailedLocked;
                    }
                }

                using (writerAttempt.Result)
                {
                    try
                    {
                        var basePath = IOHelper.MapPath(configuredPath);

                        var commit = Snapshotter.Snapshot();
                        var allSnapshotFiles = commit.GetFileNames()
                            .Concat(new[]
                            {
                                commit.GetSegmentsFileName(), 
                                //we need to manually include the segments.gen file
                                &quot;segments.gen&quot;
                            })
                            .Distinct()
                            .ToArray();

                        var tempDir = new DirectoryInfo(TempPath);

                        //Get all files in the temp storage that don&#39;t exist in the snapshot collection, we want to remove these
                        var toRemove = tempDir.GetFiles()
                            .Select(x =&gt; x.Name)
                            .Except(allSnapshotFiles);

                        using (var tempDirectory = new SimpleFSDirectory(tempDir))
                        {
                            if (TryWaitForDirectoryUnlock(tempDirectory))
                            {
                                foreach (var file in toRemove)
                                {
                                    try
                                    {
                                        File.Delete(Path.Combine(TempPath, file));
                                    }
                                    catch (IOException ex)
                                    {
                                        if (file.InvariantEquals(&quot;write.lock&quot;))
                                        {
                                            //This might happen if the writer is open
                                            LogHelper.Warn&lt;LocalTempStorageIndexer&gt;(&quot;The lock file could not be deleted but should be removed when the writer is disposed&quot;);
                                        }

                                        LogHelper.Debug&lt;LocalTempStorageIndexer&gt;(&quot;Could not delete non synced index file file, index sync will continue but old index files will remain - this shouldn&#39;t affect indexing/searching operations. {0}&quot;, () =&gt; ex.ToString());

                                    }
                                }
                            }
                            else
                            {
                                //quit here, this shouldn&#39;t happen with all the checks above.
                                LogHelper.Warn&lt;LocalTempStorageIndexer&gt;(&quot;Cannot sync index files from main storage, the temp file index is currently locked&quot;);
                                return InitializeDirectoryFlags.FailedLocked;
                            }


                            foreach (var fileName in allSnapshotFiles.Where(f =&gt; f.IsNullOrWhiteSpace() == false))
                            {
                                var destination = Path.Combine(TempPath, Path.GetFileName(fileName));

                                //don&#39;t copy if it&#39;s already there, lucene is &#39;write once&#39; so this file is meant to be there already
                                if (File.Exists(destination)) continue;

                                try
                                {
                                    File.Copy(
                                        Path.Combine(basePath, &quot;Index&quot;, fileName),
                                        destination);
                                }
                                catch (IOException ex)
                                {
                                    LogHelper.Error&lt;LocalTempStorageIndexer&gt;(&quot;Could not copy index file, could not sync from main storage&quot;, ex);

                                    //quit here
                                    return InitializeDirectoryFlags.FailedFileSync;
                                }
                            }
                        }
                    }
                    finally
                    {
                        Snapshotter.Release();
                    }
                }

                LogHelper.Info&lt;LocalTempStorageIndexer&gt;(&quot;Successfully sync&#39;d main index to local temp storage for index: {0}&quot;, () =&gt; configuredPath);
                return InitializeDirectoryFlags.Success;
            }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[31,61,31,65,1],[31,66,31,78,0],[32,9,32,56,1],[33,53,33,57,0],[33,58,33,70,1],[35,34,35,38,0],[35,39,35,51,0],[38,9,38,41,1],[39,9,39,10,1],[40,13,40,81,1],[41,13,41,62,1],[42,9,42,10,1],[45,9,45,10,0],[47,13,47,89,0],[48,13,48,56,0],[49,13,49,14,0],[51,17,51,91,0],[52,17,52,37,0],[53,17,53,18,0],[55,21,55,22,0],[56,25,56,101,0],[57,21,57,22,0],[58,21,58,41,0],[59,21,59,22,0],[60,25,62,33,0],[63,21,63,22,0],[64,17,64,18,0],[65,13,65,14,0],[67,13,67,93,0],[68,13,68,34,0],[68,35,68,161,0],[69,13,69,42,0],[71,13,71,38,0],[74,21,74,115,0],[77,21,81,46,0],[85,21,85,82,0],[86,21,86,22,0],[87,25,87,32,0],[91,21,92,21,0],[92,21,92,22,0],[92,22,94,25,0],[94,25,94,26,0],[94,26,95,29,0],[95,29,98,39,0],[98,39,99,29,0],[99,29,99,30,0],[99,30,100,29,0],[100,29,100,30,0],[100,30,102,29,0],[102,29,102,58,0],[102,58,104,25,0],[104,25,104,45,0],[104,45,105,25,0],[105,25,105,26,0],[105,26,106,29,0],[106,29,108,37,0],[108,37,109,25,0],[109,25,109,26,0],[109,26,110,25,0],[110,25,110,52,0],[110,52,111,21,0],[111,21,111,22,0],[111,22,111,52,0],[91,21,111,52,0],[113,21,113,49,0],[114,21,114,22,0],[115,25,116,242,0],[118,25,118,52,0],[121,25,125,35,0],[126,21,126,22,0],[128,21,128,27,0],[130,21,130,61,0],[131,21,131,22,0],[132,25,132,61,0],[133,21,133,22,0],[134,21,134,106,0],[135,21,135,27,0],[137,21,137,79,0],[139,9,139,10,0],[142,9,142,10,0],[143,13,143,40,0],[144,13,144,14,0],[145,17,145,24,0],[145,26,145,34,0],[145,35,145,37,0],[145,38,145,62,0],[146,17,146,18,0],[148,21,148,22,0],[149,25,149,43,0],[150,21,150,22,0],[151,21,151,46,0],[152,21,152,22,0],[153,25,153,125,0],[154,21,154,22,0],[155,17,155,18,0],[156,13,156,14,0],[157,9,157,10,0],[160,9,160,10,0],[162,13,162,14,0],[164,17,164,57,0],[166,17,166,78,0],[167,17,167,49,0],[168,17,168,18,0],[169,21,169,28,0],[169,30,169,38,0],[169,39,169,41,0],[169,42,169,71,0],[170,21,170,22,0],[172,25,172,26,0],[173,29,173,66,0],[174,25,174,26,0],[175,25,175,44,0],[176,25,176,26,0],[177,29,177,68,0],[178,29,178,30,0],[179,33,179,161,0],[180,29,180,30,0],[182,25,182,26,0],[183,21,183,22,0],[184,21,184,33,0],[186,17,186,30,0],[188,13,188,33,0],[189,13,189,14,0],[190,17,190,144,0],[191,17,191,30,0],[193,9,193,10,0],[196,9,196,10,0],[198,13,198,14,0],[199,17,204,59,0],[207,17,207,43,0],[209,13,209,33,0],[210,13,210,14,0],[211,17,211,155,0],[212,17,212,54,0],[214,9,214,10,0],[223,9,223,10,0],[224,13,224,30,0],[226,13,227,13,0],[227,13,227,14,0],[227,14,229,17,0],[229,17,229,44,0],[229,44,230,17,0],[230,17,230,18,0],[230,18,231,21,0],[231,21,231,127,0],[231,127,233,21,0],[233,21,233,61,0],[233,61,234,17,0],[234,17,234,18,0],[234,18,236,17,0],[236,17,236,84,0],[236,84,237,17,0],[237,17,237,35,0],[237,35,237,36,0],[237,36,237,57,0],[237,57,238,17,0],[238,17,238,136,0],[238,136,239,17,0],[239,17,239,52,0],[239,52,240,13,0],[240,13,240,14,0],[240,14,240,44,0],[226,13,240,44,0],[242,13,242,27,0],[243,9,243,10,0],[246,9,246,10,0],[247,13,247,30,0],[249,13,250,13,0],[250,13,250,14,0],[250,14,252,17,0],[252,17,252,44,0],[252,44,253,17,0],[253,17,253,18,0],[253,18,254,21,0],[254,21,254,131,0],[254,131,256,21,0],[256,21,256,45,0],[256,45,257,17,0],[257,17,257,18,0],[257,18,259,17,0],[259,17,259,56,0],[259,56,259,57,0],[259,57,259,86,0],[259,86,260,17,0],[260,17,260,137,0],[260,137,261,17,0],[261,17,261,45,0],[261,45,262,13,0],[262,13,262,14,0],[262,14,262,44,0],[249,13,262,44,0],[264,13,264,27,0],[265,9,265,10,0],[268,9,268,10,0],[269,13,269,27,0],[270,13,270,14,0],[271,17,271,57,0],[272,17,272,18,0],[273,21,273,57,0],[274,17,274,18,0],[277,17,277,75,0],[277,76,277,129,0],[279,17,279,93,0],[281,17,281,52,0],[282,17,282,18,0],[283,21,283,179,0],[284,21,284,66,0],[289,17,289,18,0],[291,21,291,61,0],[292,21,292,22,0],[293,21,293,22,0],[294,17,294,18,0],[295,17,295,37,0],[296,17,296,18,0],[297,21,297,52,0],[299,21,301,29,0],[303,21,303,75,0],[304,21,304,22,0],[306,25,306,123,0],[307,25,307,71,0],[311,21,311,84,0],[312,21,312,56,0],[313,21,313,22,0],[315,25,315,183,0],[316,25,316,70,0],[318,17,318,18,0],[320,17,320,45,0],[321,17,321,18,0],[323,21,323,22,0],[324,25,324,73,0],[326,25,326,61,0],[327,25,335,40,0],[337,25,337,67,0],[340,25,341,42,0],[341,42,341,48,0],[341,48,342,55,0],[340,25,342,55,0],[344,32,344,82,0],[345,25,345,26,0],[346,29,346,74,0],[347,29,347,30,0],[348,33,348,40,0],[348,42,348,50,0],[348,51,348,53,0],[348,54,348,62,0],[349,33,349,34,0],[351,37,351,38,0],[352,41,352,83,0],[353,37,353,38,0],[354,37,354,59,0],[355,37,355,38,0],[356,41,356,80,0],[357,41,357,42,0],[359,45,359,173,0],[360,41,360,42,0],[362,41,362,252,0],[362,252,362,265,0],[362,265,362,267,0],[362,41,362,267,0],[364,37,364,38,0],[365,33,365,34,0],[366,29,366,30,0],[368,29,368,30,0],[370,33,370,159,0],[371,33,371,78,0],[375,29,375,36,0],[375,38,375,50,0],[375,51,375,53,0],[375,54,375,82,0],[375,82,375,113,0],[375,113,375,114,0],[375,54,375,114,0],[376,29,376,30,0],[377,33,377,102,0],[380,33,380,62,0],[380,63,380,72,0],[383,33,383,34,0],[384,37,386,54,0],[387,33,387,34,0],[388,33,388,55,0],[389,33,389,34,0],[390,37,390,145,0],[393,37,393,84,0],[395,29,395,30,0],[396,25,396,26,0],[397,21,397,22,0],[399,21,399,22,0],[400,25,400,47,0],[401,21,401,22,0],[402,17,402,18,0],[404,17,404,134,0],[404,134,404,148,0],[404,148,404,150,0],[404,17,404,150,0],[405,17,405,57,0],[407,9,407,10,0]]);
    </script>
  </body>
</html>