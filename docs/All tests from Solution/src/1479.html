<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Packaging\PackageInstallation.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using System.Xml.XPath;
using Umbraco.Core.Configuration;
using Umbraco.Core.IO;
using Umbraco.Core.Models;
using Umbraco.Core.Packaging.Models;
using Umbraco.Core.Services;
using umbraco.interfaces;
using File = System.IO.File;

namespace Umbraco.Core.Packaging
{
    internal class PackageInstallation : IPackageInstallation
    {
        private readonly IFileService _fileService;
        private readonly IMacroService _macroService;
        private readonly IPackagingService _packagingService;
        private IConflictingPackageData _conflictingPackageData;
        private readonly IPackageExtraction _packageExtraction;
        private string _fullPathToRoot;

        public PackageInstallation(IPackagingService packagingService, IMacroService macroService,
            IFileService fileService, IPackageExtraction packageExtraction)
            : this(packagingService, macroService, fileService, packageExtraction, GlobalSettings.FullpathToRoot)
        {}

        public PackageInstallation(IPackagingService packagingService, IMacroService macroService,
            IFileService fileService, IPackageExtraction packageExtraction, string fullPathToRoot)
        {
            if (packageExtraction != null) _packageExtraction = packageExtraction; 
            else throw new ArgumentNullException(&quot;packageExtraction&quot;);
            
            if (macroService != null) _macroService = macroService;
            else throw new ArgumentNullException(&quot;macroService&quot;);
            
            if (fileService != null) _fileService = fileService;
            else throw new ArgumentNullException(&quot;fileService&quot;);

            if (packagingService != null) _packagingService = packagingService;
            else throw new ArgumentNullException(&quot;packagingService&quot;);

            _fullPathToRoot = fullPathToRoot;
        }
        
        public IConflictingPackageData ConflictingPackageData
        {
            private get
            {
                return _conflictingPackageData ??
                       (_conflictingPackageData = new ConflictingPackageData(_macroService, _fileService));
            }
            set
            {
                if (_conflictingPackageData != null)
                {
                    throw new PropertyConstraintException(&quot;This property already have a value&quot;);
                }
                _conflictingPackageData = value;
            }
        }

        public string FullPathToRoot
        {
            private get { return _fullPathToRoot; }
            set
            {

                if (_fullPathToRoot != null)
                {
                    throw new PropertyConstraintException(&quot;This property already have a value&quot;);
                }

                _fullPathToRoot = value;
            }
        }
        
        public MetaData GetMetaData(string packageFilePath)
        {
            try
            {
                XElement rootElement = GetConfigXmlElement(packageFilePath);
                return GetMetaData(rootElement);
            }
            catch (Exception e)
            {
                throw new Exception(&quot;Error reading &quot; + packageFilePath, e);
            }
        }

        public PreInstallWarnings GetPreInstallWarnings(string packageFilePath)
        {
            try
            {
                XElement rootElement = GetConfigXmlElement(packageFilePath);
                return GetPreInstallWarnings(packageFilePath, rootElement);
            }
            catch (Exception e)
            {
                throw new Exception(&quot;Error reading &quot; + packageFilePath, e);
            }
        }

        public InstallationSummary InstallPackage(string packageFile, int userId)
        {
            XElement dataTypes;
            XElement languages;
            XElement dictionaryItems;
            XElement macroes;
            XElement files;
            XElement templates;
            XElement documentTypes;
            XElement styleSheets;
            XElement documentSet;
            XElement documents;
            XElement actions;
            MetaData metaData;
            InstallationSummary installationSummary;
            
            try
            {
                XElement rootElement = GetConfigXmlElement(packageFile);
                PackageSupportedCheck(rootElement);
                PackageStructureSanetyCheck(packageFile, rootElement);
                dataTypes = rootElement.Element(Constants.Packaging.DataTypesNodeName);
                languages = rootElement.Element(Constants.Packaging.LanguagesNodeName);
                dictionaryItems = rootElement.Element(Constants.Packaging.DictionaryItemsNodeName);
                macroes = rootElement.Element(Constants.Packaging.MacrosNodeName);
                files = rootElement.Element(Constants.Packaging.FilesNodeName);
                templates = rootElement.Element(Constants.Packaging.TemplatesNodeName);
                documentTypes = rootElement.Element(Constants.Packaging.DocumentTypesNodeName);
                styleSheets = rootElement.Element(Constants.Packaging.StylesheetsNodeName);
                documentSet = rootElement.Element(Constants.Packaging.DocumentSetNodeName);
                documents = rootElement.Element(Constants.Packaging.DocumentsNodeName);
                actions = rootElement.Element(Constants.Packaging.ActionsNodeName);

                metaData = GetMetaData(rootElement);
                installationSummary = new InstallationSummary {MetaData = metaData};
            }
            catch (Exception e)
            {
                throw new Exception(&quot;Error reading &quot; + packageFile, e);
            }

            try
            {
                var dataTypeDefinitions = EmptyEnumerableIfNull&lt;IDataTypeDefinition&gt;(dataTypes) ?? InstallDataTypes(dataTypes, userId);
                installationSummary.DataTypesInstalled = dataTypeDefinitions;

                var languagesInstalled = EmptyEnumerableIfNull&lt;ILanguage&gt;(languages) ?? InstallLanguages(languages, userId);
                installationSummary.LanguagesInstalled = languagesInstalled;

                var dictionaryInstalled = EmptyEnumerableIfNull&lt;IDictionaryItem&gt;(dictionaryItems) ?? InstallDictionaryItems(dictionaryItems);
                installationSummary.DictionaryItemsInstalled = dictionaryInstalled;

                var macros = EmptyEnumerableIfNull&lt;IMacro&gt;(macroes) ?? InstallMacros(macroes, userId);
                installationSummary.MacrosInstalled = macros;

                var keyValuePairs = EmptyEnumerableIfNull&lt;string&gt;(packageFile) ?? InstallFiles(packageFile, files);
                installationSummary.FilesInstalled = keyValuePairs;

                var templatesInstalled = EmptyEnumerableIfNull&lt;ITemplate&gt;(templates) ?? InstallTemplats(templates, userId);
                installationSummary.TemplatesInstalled = templatesInstalled;

                var documentTypesInstalled = EmptyEnumerableIfNull&lt;IContentType&gt;(documentTypes) ?? InstallDocumentTypes(documentTypes, userId);
                installationSummary.ContentTypesInstalled =documentTypesInstalled;

                var stylesheetsInstalled = EmptyEnumerableIfNull&lt;IFile&gt;(styleSheets) ?? InstallStylesheets(styleSheets, userId);
                installationSummary.StylesheetsInstalled = stylesheetsInstalled;

                var documentsInstalled = documents != null ? InstallDocuments(documents, userId) 
                    : EmptyEnumerableIfNull&lt;IContent&gt;(documentSet) 
                    ?? InstallDocuments(documentSet, userId);
                installationSummary.ContentInstalled = documentsInstalled;

                var packageActions = EmptyEnumerableIfNull&lt;PackageAction&gt;(actions) ?? GetPackageActions(actions, metaData.Name);
                installationSummary.Actions = packageActions;

                installationSummary.PackageInstalled = true;

                return installationSummary;
            }
            catch (Exception e)
            {
                throw new Exception(&quot;Error installing package &quot; + packageFile, e);
            }
        }

        /// &lt;summary&gt;
        /// Temperary check to test that we support stylesheets
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;rootElement&quot;&gt;&lt;/param&gt;
        private void PackageSupportedCheck(XElement rootElement)
        {
            XElement styleSheets = rootElement.Element(Constants.Packaging.StylesheetsNodeName);
            if (styleSheets != null &amp;&amp; styleSheets.Elements().Any())
                throw new NotSupportedException(&quot;Stylesheets is not suported in this version of umbraco&quot;);
        }

        private static T[] EmptyArrayIfNull&lt;T&gt;(object obj)
        {
            return obj == null ? new T[0] : null;
        }

        private static IEnumerable&lt;T&gt; EmptyEnumerableIfNull&lt;T&gt;(object obj)
        {
            return obj == null ? Enumerable.Empty&lt;T&gt;() : null;
        }

        private XDocument GetConfigXmlDoc(string packageFilePath)
        {
            string filePathInPackage;
            string configXmlContent = _packageExtraction.ReadTextFileFromArchive(packageFilePath,
                Constants.Packaging.PackageXmlFileName, out filePathInPackage);

            return XDocument.Parse(configXmlContent);
        }

        public XElement GetConfigXmlElement(string packageFilePath)
        {
            XDocument document = GetConfigXmlDoc(packageFilePath);
            if (document.Root == null ||
                document.Root.Name.LocalName.Equals(Constants.Packaging.UmbPackageNodeName) == false)
            {
                throw new ArgumentException(&quot;xml does not have a root node called \&quot;umbPackage\&quot;&quot;, packageFilePath);
            }
            return document.Root;
        }

        internal void PackageStructureSanetyCheck(string packageFilePath)
        {
            XElement rootElement = GetConfigXmlElement(packageFilePath);
            PackageStructureSanetyCheck(packageFilePath, rootElement);
        }

        private void PackageStructureSanetyCheck(string packageFilePath, XElement rootElement)
        {
            XElement filesElement = rootElement.Element(Constants.Packaging.FilesNodeName);
            if (filesElement != null)
            {
                var sourceDestination = ExtractSourceDestinationFileInformation(filesElement).ToArray();

                var missingFiles = _packageExtraction.FindMissingFiles(packageFilePath, sourceDestination.Select(i =&gt; i.Key)).ToArray();

                if (missingFiles.Any())
                {
                    throw new Exception(&quot;The following file(s) are missing in the package: &quot; +
                                        string.Join(&quot;, &quot;, missingFiles.Select(
                                            mf =&gt;
                                            {
                                                var sd = sourceDestination.Single(fi =&gt; fi.Key == mf);
                                                return string.Format(&quot;source: \&quot;{0}\&quot; destination: \&quot;{1}\&quot;&quot;,
                                                    sd.Key, sd.Value);
                                            })));
                }

                IEnumerable&lt;string&gt; dubletFileNames = _packageExtraction.FindDubletFileNames(packageFilePath).ToArray();

                if (dubletFileNames.Any())
                {
                    throw new Exception(&quot;The following filename(s) are found more than one time in the package, since the filename is used ad primary key, this is not allowed: &quot; +
                                        string.Join(&quot;, &quot;, dubletFileNames));
                }
            }
        }

        private static IEnumerable&lt;PackageAction&gt; GetPackageActions(XElement actionsElement, string packageName)
        {
            if (actionsElement == null) { return new PackageAction[0]; }

            if (string.Equals(Constants.Packaging.ActionsNodeName, actionsElement.Name.LocalName) == false)
            {
                throw new ArgumentException(&quot;Must be \&quot;&quot; + Constants.Packaging.ActionsNodeName + &quot;\&quot; as root&quot;,
                    &quot;actionsElement&quot;);
            }

            return actionsElement.Elements(Constants.Packaging.ActionNodeName)
                .Select(elemet =&gt;
                {
                    XAttribute aliasAttr = elemet.Attribute(Constants.Packaging.AliasNodeNameCapital);
                    if (aliasAttr == null)
                        throw new ArgumentException(
                            &quot;missing \&quot;&quot; + Constants.Packaging.AliasNodeNameCapital + &quot;\&quot; atribute in alias element&quot;,
                            &quot;actionsElement&quot;);

                    var packageAction = new PackageAction
                    {
                        XmlData = elemet, 
                        Alias = aliasAttr.Value,
                        PackageName = packageName,
                    };


                    XAttribute attr = elemet.Attribute(Constants.Packaging.RunatNodeAttribute);

                    ActionRunAt runAt;
                    if (attr != null &amp;&amp; Enum.TryParse(attr.Value, true, out runAt)) { packageAction.RunAt = runAt; }

                    attr = elemet.Attribute(Constants.Packaging.UndoNodeAttribute);

                    bool undo;
                    if (attr != null &amp;&amp; bool.TryParse(attr.Value, out undo)) { packageAction.Undo = undo; }


                    return packageAction;
                }).ToArray();
        }

        private IEnumerable&lt;IContent&gt; InstallDocuments(XElement documentsElement, int userId = 0)
        {
            if ((string.Equals(Constants.Packaging.DocumentSetNodeName, documentsElement.Name.LocalName) == false)
                &amp;&amp; (string.Equals(Constants.Packaging.DocumentsNodeName, documentsElement.Name.LocalName) == false))
            {
                throw new ArgumentException(&quot;Must be \&quot;&quot; + Constants.Packaging.DocumentsNodeName + &quot;\&quot; as root&quot;,
                    &quot;documentsElement&quot;);
            }

            if (string.Equals(Constants.Packaging.DocumentSetNodeName, documentsElement.Name.LocalName))
                return _packagingService.ImportContent(documentsElement, -1, userId);

            return
                documentsElement.Elements(Constants.Packaging.DocumentSetNodeName)
                    .SelectMany(documentSetElement =&gt; _packagingService.ImportContent(documentSetElement, -1, userId))
                    .ToArray();
        }

        private IEnumerable&lt;IFile&gt; InstallStylesheets(XElement styleSheetsElement, int userId = 0)
        {
            if (string.Equals(Constants.Packaging.StylesheetsNodeName, styleSheetsElement.Name.LocalName) == false)
            {
                throw new ArgumentException(&quot;Must be \&quot;&quot; + Constants.Packaging.StylesheetsNodeName + &quot;\&quot; as root&quot;,
                    &quot;styleSheetsElement&quot;);
            }

            // TODO: Call _packagingService when import stylesheets import has been implimentet
            if (styleSheetsElement.HasElements == false) { return new List&lt;IFile&gt;(); }

            throw new NotImplementedException(&quot;The packaging service do not yes have a method for importing stylesheets&quot;);
        }

        private IEnumerable&lt;IContentType&gt; InstallDocumentTypes(XElement documentTypes, int userId = 0)
        {
            if (string.Equals(Constants.Packaging.DocumentTypesNodeName, documentTypes.Name.LocalName) == false)
            {
                if (string.Equals(Constants.Packaging.DocumentTypeNodeName, documentTypes.Name.LocalName) == false)
                    throw new ArgumentException(
                        &quot;Must be \&quot;&quot; + Constants.Packaging.DocumentTypesNodeName + &quot;\&quot; as root&quot;, &quot;documentTypes&quot;);

                documentTypes = new XElement(Constants.Packaging.DocumentTypesNodeName, documentTypes);
            }

            return _packagingService.ImportContentTypes(documentTypes, userId);
        }

        private IEnumerable&lt;ITemplate&gt; InstallTemplats(XElement templateElement, int userId = 0)
        {
            if (string.Equals(Constants.Packaging.TemplatesNodeName, templateElement.Name.LocalName) == false)
            {
                throw new ArgumentException(&quot;Must be \&quot;&quot; + Constants.Packaging.TemplatesNodeName + &quot;\&quot; as root&quot;,
                    &quot;templateElement&quot;);
            }
            return _packagingService.ImportTemplates(templateElement, userId);
        }

        private IEnumerable&lt;string&gt; InstallFiles(string packageFilePath, XElement filesElement)
        {
            var sourceDestination = ExtractSourceDestinationFileInformation(filesElement);
            sourceDestination = AppendRootToDestination(FullPathToRoot, sourceDestination);

            _packageExtraction.CopyFilesFromArchive(packageFilePath, sourceDestination);
            
            return sourceDestination.Select(sd =&gt; sd.Value).ToArray();
        }

        private KeyValuePair&lt;string, string&gt;[] AppendRootToDestination(string fullpathToRoot, IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; sourceDestination)
        {
            return
                sourceDestination.Select(
                    sd =&gt; new KeyValuePair&lt;string, string&gt;(sd.Key, Path.Combine(fullpathToRoot, sd.Value))).ToArray();
        }

        private IEnumerable&lt;IMacro&gt; InstallMacros(XElement macroElements, int userId = 0)
        {
            if (string.Equals(Constants.Packaging.MacrosNodeName, macroElements.Name.LocalName) == false)
            {
                throw new ArgumentException(&quot;Must be \&quot;&quot; + Constants.Packaging.MacrosNodeName + &quot;\&quot; as root&quot;,
                    &quot;macroElements&quot;);
            }
            return _packagingService.ImportMacros(macroElements, userId);
        }

        private IEnumerable&lt;IDictionaryItem&gt; InstallDictionaryItems(XElement dictionaryItemsElement)
        {
            if (string.Equals(Constants.Packaging.DictionaryItemsNodeName, dictionaryItemsElement.Name.LocalName) ==
                false)
            {
                throw new ArgumentException(&quot;Must be \&quot;&quot; + Constants.Packaging.DictionaryItemsNodeName + &quot;\&quot; as root&quot;,
                    &quot;dictionaryItemsElement&quot;);
            }
            return _packagingService.ImportDictionaryItems(dictionaryItemsElement);
        }

        private IEnumerable&lt;ILanguage&gt; InstallLanguages(XElement languageElement, int userId = 0)
        {
            if (string.Equals(Constants.Packaging.LanguagesNodeName, languageElement.Name.LocalName) == false)
            {
                throw new ArgumentException(&quot;Must be \&quot;&quot; + Constants.Packaging.LanguagesNodeName + &quot;\&quot; as root&quot;, &quot;languageElement&quot;);
            }
            return _packagingService.ImportLanguages(languageElement, userId);
        }

        private IEnumerable&lt;IDataTypeDefinition&gt; InstallDataTypes(XElement dataTypeElements, int userId = 0)
        {
            if (string.Equals(Constants.Packaging.DataTypesNodeName, dataTypeElements.Name.LocalName) == false)
            {
                if (string.Equals(Constants.Packaging.DataTypeNodeName, dataTypeElements.Name.LocalName) == false)
                {
                    throw new ArgumentException(&quot;Must be \&quot;&quot; + Constants.Packaging.DataTypeNodeName + &quot;\&quot; as root&quot;, &quot;dataTypeElements&quot;);
                }
            }
            return _packagingService.ImportDataTypeDefinitions(dataTypeElements, userId);
        }

        private PreInstallWarnings GetPreInstallWarnings(string packagePath, XElement rootElement)
        {
            XElement files = rootElement.Element(Constants.Packaging.FilesNodeName);
            XElement styleSheets = rootElement.Element(Constants.Packaging.StylesheetsNodeName);
            XElement templates = rootElement.Element(Constants.Packaging.TemplatesNodeName);
            XElement alias = rootElement.Element(Constants.Packaging.MacrosNodeName);
            
            var sourceDestination = EmptyArrayIfNull&lt;KeyValuePair&lt;string, string&gt;&gt;(files) ?? ExtractSourceDestinationFileInformation(files);

            var installWarnings = new PreInstallWarnings();

            var macroAliases = EmptyEnumerableIfNull&lt;IMacro&gt;(alias) ?? ConflictingPackageData.FindConflictingMacros(alias);
            installWarnings.ConflictingMacroAliases = macroAliases;

            var templateAliases = EmptyEnumerableIfNull&lt;ITemplate&gt;(templates) ?? ConflictingPackageData.FindConflictingTemplates(templates);
            installWarnings.ConflictingTemplateAliases = templateAliases;

            var stylesheetNames = EmptyEnumerableIfNull&lt;IFile&gt;(styleSheets) ?? ConflictingPackageData.FindConflictingStylesheets(styleSheets);
            installWarnings.ConflictingStylesheetNames = stylesheetNames;
            
            installWarnings.UnsecureFiles = FindUnsecureFiles(sourceDestination);
            installWarnings.FilesReplaced = FindFilesToBeReplaced(sourceDestination);
            installWarnings.AssembliesWithLegacyPropertyEditors = FindLegacyPropertyEditors(packagePath, sourceDestination);
            
            return installWarnings;
        }

        private KeyValuePair&lt;string, string&gt;[] FindFilesToBeReplaced(IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; sourceDestination)
        {
            return sourceDestination.Where(sd =&gt; File.Exists(Path.Combine(FullPathToRoot, sd.Value))).ToArray();
        }

        private IEnumerable&lt;string&gt; FindLegacyPropertyEditors(string packagePath, IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; sourceDestinationPair)
        {
            var dlls = sourceDestinationPair.Where(
                sd =&gt; (Path.GetExtension(sd.Value) ?? string.Empty).Equals(&quot;.dll&quot;, StringComparison.InvariantCultureIgnoreCase)).Select(sd =&gt; sd.Key).ToArray();

            if (dlls.Any() == false) { return new List&lt;string&gt;(); }
            
            // Now we want to see if the DLLs contain any legacy data types since we want to warn people about that
            string[] assemblyErrors;
            IEnumerable&lt;byte[]&gt; assemblyesToScan =_packageExtraction.ReadFilesFromArchive(packagePath, dlls);
            return PackageBinaryInspector.ScanAssembliesForTypeReference&lt;IDataType&gt;(assemblyesToScan, out assemblyErrors).ToArray();
        }

        private KeyValuePair&lt;string, string&gt;[] FindUnsecureFiles(IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; sourceDestinationPair)
        {
            return sourceDestinationPair.Where(sd =&gt; IsFileDestinationUnsecure(sd.Value)).ToArray();
        }

        private bool IsFileDestinationUnsecure(string destination)
        {
            var unsecureDirNames = new[] {&quot;bin&quot;, &quot;app_code&quot;};
            if(unsecureDirNames.Any(ud =&gt; destination.StartsWith(ud, StringComparison.InvariantCultureIgnoreCase)))
                return true;

            string extension = Path.GetExtension(destination);
            return extension != null &amp;&amp; extension.Equals(&quot;.dll&quot;, StringComparison.InvariantCultureIgnoreCase);
        }
        
        private KeyValuePair&lt;string, string&gt;[] ExtractSourceDestinationFileInformation(XElement filesElement)
        {
            if (string.Equals(Constants.Packaging.FilesNodeName, filesElement.Name.LocalName) == false)
            {
                throw new ArgumentException(&quot;the root element must be \&quot;Files\&quot;&quot;, &quot;filesElement&quot;);
            }

            return filesElement.Elements(Constants.Packaging.FileNodeName)
                .Select(e =&gt;
                {
                    XElement guidElement = e.Element(Constants.Packaging.GuidNodeName);
                    if (guidElement == null)
                    {
                        throw new ArgumentException(&quot;Missing element \&quot;&quot; + Constants.Packaging.GuidNodeName + &quot;\&quot;&quot;,
                            &quot;filesElement&quot;);
                    }

                    XElement orgPathElement = e.Element(Constants.Packaging.OrgPathNodeName);
                    if (orgPathElement == null)
                    {
                        throw new ArgumentException(&quot;Missing element \&quot;&quot; + Constants.Packaging.OrgPathNodeName + &quot;\&quot;&quot;,
                            &quot;filesElement&quot;);
                    }

                    XElement orgNameElement = e.Element(Constants.Packaging.OrgNameNodeName);
                    if (orgNameElement == null)
                    {
                        throw new ArgumentException(&quot;Missing element \&quot;&quot; + Constants.Packaging.OrgNameNodeName + &quot;\&quot;&quot;,
                            &quot;filesElement&quot;);
                    }

                    var fileName = PrepareAsFilePathElement(orgNameElement.Value);
                    var relativeDir = UpdatePathPlaceholders(PrepareAsFilePathElement(orgPathElement.Value));

                    var relativePath = Path.Combine(relativeDir, fileName);
                    

                    return new KeyValuePair&lt;string, string&gt;(guidElement.Value, relativePath);
                }).ToArray();
        }

        private static string PrepareAsFilePathElement(string pathElement)
        {
            return pathElement.TrimStart(new[] {&#39;\\&#39;, &#39;/&#39;, &#39;~&#39;}).Replace(&quot;/&quot;, &quot;\\&quot;);
        }

        private MetaData GetMetaData(XElement xRootElement)
        {
            XElement infoElement = xRootElement.Element(Constants.Packaging.InfoNodeName);

            if (infoElement == null)
            {
                throw new ArgumentException(&quot;Did not hold a \&quot;&quot; + Constants.Packaging.InfoNodeName + &quot;\&quot; element&quot;,
                    &quot;xRootElement&quot;);
            }

            var majorElement = infoElement.XPathSelectElement(Constants.Packaging.PackageRequirementsMajorXpath);
            var minorElement = infoElement.XPathSelectElement(Constants.Packaging.PackageRequirementsMinorXpath);
            var patchElement = infoElement.XPathSelectElement(Constants.Packaging.PackageRequirementsPatchXpath);
            var nameElement = infoElement.XPathSelectElement(Constants.Packaging.PackageNameXpath);
            var versionElement = infoElement.XPathSelectElement(Constants.Packaging.PackageVersionXpath);
            var urlElement = infoElement.XPathSelectElement(Constants.Packaging.PackageUrlXpath);
            var licenseElement = infoElement.XPathSelectElement(Constants.Packaging.PackageLicenseXpath);
            var authorNameElement = infoElement.XPathSelectElement(Constants.Packaging.AuthorNameXpath);
            var authorUrlElement = infoElement.XPathSelectElement(Constants.Packaging.AuthorWebsiteXpath);
            var readmeElement = infoElement.XPathSelectElement(Constants.Packaging.ReadmeXpath);

            XElement controlElement = xRootElement.Element(Constants.Packaging.ControlNodeName);

            return new MetaData
                   {
                       Name = StringValue(nameElement),
                       Version = StringValue(versionElement),
                       Url = StringValue(urlElement),
                       License = StringValue(licenseElement),
                       LicenseUrl = StringAttribute(licenseElement, Constants.Packaging.PackageLicenseXpathUrlAttribute),
                       AuthorName = StringValue(authorNameElement),
                       AuthorUrl = StringValue(authorUrlElement),
                       Readme = StringValue(readmeElement),
                       Control = StringValue(controlElement),
                       ReqMajor = IntValue(majorElement),
                       ReqMinor = IntValue(minorElement),
                       ReqPatch = IntValue(patchElement)
                   };
        }

        private static string StringValue(XElement xElement, string defaultValue = &quot;&quot;)
        {
            return xElement == null ? defaultValue : xElement.Value;
        }

        private static string StringAttribute(XElement xElement, string attribute, string defaultValue = &quot;&quot;)
        {
            return xElement == null
                        ? defaultValue
                        : xElement.HasAttributes ? xElement.AttributeValue&lt;string&gt;(attribute) : defaultValue;
        }

        private static int IntValue(XElement xElement, int defaultValue = 0)
        {
            int val;
            return xElement == null ? defaultValue : int.TryParse(xElement.Value, out val) ? val : defaultValue;
        }
        
        private static string UpdatePathPlaceholders(string path)
        {
            if (path.Contains(&quot;[$&quot;))
            {
                //this is experimental and undocumented...
                path = path.Replace(&quot;[$UMBRACO]&quot;, SystemDirectories.Umbraco);
                path = path.Replace(&quot;[$UMBRACOCLIENT]&quot;, SystemDirectories.UmbracoClient);
                path = path.Replace(&quot;[$CONFIG]&quot;, SystemDirectories.Config);
                path = path.Replace(&quot;[$DATA]&quot;, SystemDirectories.Data);
            }
            return path;
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[29,15,29,114,1],[30,9,30,10,1],[30,10,30,11,1],[32,9,33,99,1],[34,9,34,10,1],[35,13,35,43,1],[35,44,35,83,1],[36,18,36,71,0],[38,13,38,38,1],[38,39,38,68,1],[39,18,39,66,0],[41,13,41,37,1],[41,38,41,65,1],[42,18,42,65,0],[44,13,44,42,1],[44,43,44,80,1],[45,18,45,70,0],[47,13,47,46,1],[48,9,48,10,1],[53,13,53,14,1],[54,17,55,108,1],[56,13,56,14,1],[58,13,58,14,0],[59,17,59,53,0],[60,17,60,18,0],[61,21,61,97,0],[63,17,63,49,0],[64,13,64,14,0],[69,25,69,26,1],[69,27,69,50,1],[69,51,69,52,1],[71,13,71,14,0],[73,17,73,45,0],[74,17,74,18,0],[75,21,75,97,0],[78,17,78,41,0],[79,13,79,14,0],[83,9,83,10,1],[85,13,85,14,1],[86,17,86,77,1],[87,17,87,49,1],[89,13,89,32,0],[90,13,90,14,0],[91,17,91,76,0],[93,9,93,10,1],[96,9,96,10,1],[98,13,98,14,1],[99,17,99,77,1],[100,17,100,76,1],[102,13,102,32,0],[103,13,103,14,0],[104,17,104,76,0],[106,9,106,10,1],[109,9,109,10,1],[125,13,125,14,1],[126,17,126,73,1],[127,17,127,52,1],[128,17,128,71,1],[129,17,129,88,1],[130,17,130,88,1],[131,17,131,100,1],[132,17,132,83,1],[133,17,133,80,1],[134,17,134,88,1],[135,17,135,96,1],[136,17,136,92,1],[137,17,137,92,1],[138,17,138,88,1],[139,17,139,84,1],[141,17,141,53,1],[142,17,142,85,1],[143,13,143,14,1],[144,13,144,32,0],[145,13,145,14,0],[146,17,146,72,0],[150,13,150,14,1],[151,17,151,136,1],[152,17,152,78,1],[154,17,154,125,1],[155,17,155,77,1],[157,17,157,142,1],[158,17,158,84,1],[160,17,160,103,1],[161,17,161,62,1],[163,17,163,116,1],[164,17,164,68,1],[166,17,166,124,1],[167,17,167,77,1],[169,17,169,144,1],[170,17,170,83,1],[172,17,172,129,1],[173,17,173,81,1],[175,17,177,62,1],[178,17,178,75,1],[180,17,180,129,1],[181,17,181,62,1],[183,17,183,61,1],[185,17,185,44,1],[187,13,187,32,0],[188,13,188,14,0],[189,17,189,83,0],[191,9,191,10,1],[198,9,198,10,1],[199,13,199,97,1],[200,13,200,69,1],[201,17,201,107,0],[202,9,202,10,1],[205,9,205,10,1],[206,13,206,50,1],[207,9,207,10,1],[210,9,210,10,1],[211,13,211,63,1],[212,9,212,10,1],[215,9,215,10,1],[217,13,218,80,1],[220,13,220,54,1],[221,9,221,10,1],[224,9,224,10,1],[225,13,225,67,1],[226,13,227,102,1],[228,13,228,14,0],[229,17,229,117,0],[231,13,231,34,1],[232,9,232,10,1],[235,9,235,10,0],[236,13,236,73,0],[237,13,237,71,0],[238,9,238,10,0],[241,9,241,10,1],[242,13,242,92,1],[243,13,243,38,1],[244,13,244,14,1],[245,17,245,105,1],[247,17,247,119,1],[247,119,247,124,1],[247,124,247,137,1],[247,17,247,137,1],[249,17,249,40,1],[250,17,250,18,0],[251,21,254,45,0],[254,45,254,46,0],[254,46,255,49,0],[255,49,255,89,0],[255,89,255,101,0],[255,101,255,103,0],[255,49,255,103,0],[255,103,256,49,0],[256,49,257,71,0],[257,71,258,45,0],[258,45,258,46,0],[258,46,258,50,0],[251,21,258,50,0],[261,17,261,121,1],[263,17,263,43,1],[264,17,264,18,0],[265,21,266,77,0],[268,13,268,14,1],[269,9,269,10,1],[272,9,272,10,0],[273,13,273,40,0],[273,41,273,42,0],[273,43,273,71,0],[275,13,275,108,0],[276,13,276,14,0],[277,17,278,39,0],[281,13,283,17,0],[283,17,283,18,0],[283,18,284,21,0],[284,21,284,103,0],[284,103,285,21,0],[285,21,285,43,0],[285,43,286,25,0],[286,25,288,47,0],[288,47,290,21,0],[290,21,295,23,0],[295,23,298,21,0],[298,21,298,96,0],[298,96,301,21,0],[301,21,301,84,0],[301,84,301,85,0],[301,85,301,86,0],[301,86,301,87,0],[301,87,301,115,0],[301,115,301,116,0],[301,116,301,117,0],[301,117,303,21,0],[303,21,303,84,0],[303,84,306,21,0],[306,21,306,77,0],[306,77,306,78,0],[306,78,306,79,0],[306,79,306,80,0],[306,80,306,106,0],[306,106,306,107,0],[306,107,306,108,0],[306,108,309,21,0],[309,21,309,42,0],[309,42,310,17,0],[310,17,310,18,0],[310,18,310,30,0],[281,13,310,30,0],[311,9,311,10,0],[314,9,314,10,0],[315,13,316,117,0],[317,13,317,14,0],[318,17,319,41,0],[322,13,322,105,0],[323,17,323,86,0],[325,13,327,55,0],[327,55,327,118,0],[327,118,328,32,0],[325,13,328,32,0],[329,9,329,10,0],[332,9,332,10,1],[333,13,333,116,1],[334,13,334,14,0],[335,17,336,43,0],[340,13,340,57,1],[340,58,340,59,1],[340,60,340,85,1],[342,13,342,123,0],[343,9,343,10,1],[346,9,346,10,1],[347,13,347,113,1],[348,13,348,14,0],[349,17,349,116,0],[350,21,351,115,0],[353,17,353,104,0],[354,13,354,14,0],[356,13,356,80,1],[357,9,357,10,1],[360,9,360,10,1],[361,13,361,111,1],[362,13,362,14,0],[363,17,364,40,0],[366,13,366,79,1],[367,9,367,10,1],[370,9,370,10,1],[371,13,371,91,1],[372,13,372,92,1],[374,13,374,89,1],[376,13,376,51,1],[376,51,376,59,1],[376,59,376,71,1],[376,13,376,71,1],[377,9,377,10,1],[380,9,380,10,1],[381,13,383,27,1],[383,27,383,107,1],[383,107,383,119,1],[381,13,383,119,1],[384,9,384,10,1],[387,9,387,10,1],[388,13,388,106,1],[389,13,389,14,0],[390,17,391,38,0],[393,13,393,74,1],[394,9,394,10,1],[397,9,397,10,1],[398,13,399,23,1],[400,13,400,14,0],[401,17,402,47,0],[404,13,404,84,1],[405,9,405,10,1],[408,9,408,10,1],[409,13,409,111,1],[410,13,410,14,0],[411,17,411,133,0],[413,13,413,79,1],[414,9,414,10,1],[417,9,417,10,1],[418,13,418,112,1],[419,13,419,14,0],[420,17,420,115,0],[421,17,421,18,0],[422,21,422,137,0],[424,13,424,14,0],[425,13,425,90,1],[426,9,426,10,1],[429,9,429,10,1],[430,13,430,85,1],[431,13,431,97,1],[432,13,432,93,1],[433,13,433,86,1],[435,13,435,141,1],[437,13,437,60,1],[439,13,439,124,1],[440,13,440,68,1],[442,13,442,141,1],[443,13,443,74,1],[445,13,445,143,1],[446,13,446,74,1],[448,13,448,82,1],[449,13,449,86,1],[450,13,450,125,1],[452,13,452,36,1],[453,9,453,10,1],[456,9,456,10,1],[457,13,457,50,1],[457,50,457,101,1],[457,101,457,113,1],[457,13,457,113,1],[458,9,458,10,1],[461,9,461,10,1],[462,13,463,23,1],[463,23,463,128,1],[463,128,463,143,1],[463,143,463,149,1],[463,149,463,161,1],[462,13,463,161,1],[465,13,465,37,1],[465,38,465,39,0],[465,40,465,66,0],[469,13,469,110,1],[470,13,470,133,1],[471,9,471,10,1],[474,9,474,10,1],[475,13,475,54,1],[475,54,475,89,1],[475,89,475,101,1],[475,13,475,101,1],[476,9,476,10,1],[479,9,479,10,1],[480,13,480,62,1],[481,13,481,43,1],[481,43,481,114,1],[481,114,481,116,1],[481,13,481,116,1],[482,17,482,29,1],[484,13,484,63,0],[485,13,485,111,0],[486,9,486,10,1],[489,9,489,10,1],[490,13,490,104,1],[491,13,491,14,0],[492,17,492,99,0],[495,13,497,17,1],[497,17,497,18,1],[497,18,498,21,1],[498,21,498,88,1],[498,88,499,21,1],[499,21,499,45,1],[499,45,500,21,1],[500,21,500,22,0],[500,22,501,25,1],[501,25,502,45,0],[502,45,505,21,1],[505,21,505,94,1],[505,94,506,21,1],[506,21,506,48,1],[506,48,507,21,1],[507,21,507,22,0],[507,22,508,25,1],[508,25,509,45,0],[509,45,512,21,1],[512,21,512,94,1],[512,94,513,21,1],[513,21,513,48,1],[513,48,514,21,1],[514,21,514,22,0],[514,22,515,25,1],[515,25,516,45,0],[516,45,519,21,1],[519,21,519,83,1],[519,83,520,21,1],[520,21,520,110,1],[520,110,522,21,1],[522,21,522,76,1],[522,76,525,21,1],[525,21,525,94,1],[525,94,526,17,1],[526,17,526,18,1],[526,18,526,30,1],[495,13,526,30,1],[527,9,527,10,1],[530,9,530,10,1],[531,13,531,85,1],[532,9,532,10,1],[535,9,535,10,1],[536,13,536,91,1],[538,13,538,37,1],[539,13,539,14,0],[540,17,541,37,0],[544,13,544,114,1],[545,13,545,114,1],[546,13,546,114,1],[547,13,547,100,1],[548,13,548,106,1],[549,13,549,98,1],[550,13,550,106,1],[551,13,551,105,1],[552,13,552,107,1],[553,13,553,97,1],[555,13,555,97,1],[557,13,571,22,1],[572,9,572,10,1],[575,9,575,10,1],[576,13,576,69,1],[577,9,577,10,1],[580,9,580,10,1],[581,13,583,110,1],[584,9,584,10,1],[587,9,587,10,1],[589,13,589,113,1],[590,9,590,10,1],[593,9,593,10,1],[594,13,594,37,1],[595,13,595,14,0],[597,17,597,78,0],[598,17,598,90,0],[599,17,599,76,0],[600,17,600,72,0],[601,13,601,14,0],[602,13,602,25,1],[603,9,603,10,1]]);
    </script>
  </body>
</html>