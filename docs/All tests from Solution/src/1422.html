<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\TypeExtensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using Umbraco.Core.Strings;

namespace Umbraco.Core
{
	public static class TypeExtensions
	{
        /// &lt;summary&gt;
        /// Tries to return a value based on a property name for an object but ignores case sensitivity
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;target&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;memberName&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// Currenty this will only work for ProperCase and camelCase properties, see the TODO below to enable complete case insensitivity
        /// &lt;/remarks&gt;
        internal static Attempt&lt;object&gt; GetMemberIgnoreCase(this Type type, object target, string memberName)
	    {
            Func&lt;string, Attempt&lt;object&gt;&gt; getMember =
                memberAlias =&gt;
                {
                    try
                    {
                        return Attempt&lt;object&gt;.Succeed(
                                                   type.InvokeMember(memberAlias,
                                                                                  System.Reflection.BindingFlags.GetProperty |
                                                                                  System.Reflection.BindingFlags.Instance |
                                                                                  System.Reflection.BindingFlags.Public,
                                                                                  null,
                                                                                  target,
                                                                                  null));
                    }
                    catch (MissingMethodException ex)
                    {
                        return Attempt&lt;object&gt;.Fail(ex);
                    }
                };

            //try with the current casing
            var attempt = getMember(memberName);
            if (attempt.Success == false)
            {
                //if we cannot get with the current alias, try changing it&#39;s case
                attempt = memberName[0].IsUpperCase()
                    ? getMember(memberName.ToCleanString(CleanStringType.Ascii | CleanStringType.ConvertCase | CleanStringType.CamelCase))
                    : getMember(memberName.ToCleanString(CleanStringType.Ascii | CleanStringType.ConvertCase | CleanStringType.PascalCase));

                //TODO: If this still fails then we should get a list of properties from the object and then compare - doing the above without listing
                // all properties will surely be faster than using reflection to get ALL properties first and then query against them.
            }

            return attempt;
	    }

		public static object GetDefaultValue(this Type t)
		{
			return t.IsValueType
			       	? Activator.CreateInstance(t)
			       	: null;
		}
        internal static MethodInfo GetGenericMethod(this Type type, string name, params Type[] parameterTypes)
        {
            var methods = type.GetMethods().Where(method =&gt; method.Name == name);

            foreach (var method in methods)
            {
                if (method.HasParameters(parameterTypes))
                    return method;
            }

            return null;
        }

		/// &lt;summary&gt;
		/// Checks if the type is an anonymous type
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		/// &lt;remarks&gt;
		/// reference: http://jclaes.blogspot.com/2011/05/checking-for-anonymous-types.html
		/// &lt;/remarks&gt;
		public static bool IsAnonymousType(this Type type)
		{
			if (type == null) throw new ArgumentNullException(&quot;type&quot;);


			return Attribute.IsDefined(type, typeof(CompilerGeneratedAttribute), false)
			       &amp;&amp; type.IsGenericType &amp;&amp; type.Name.Contains(&quot;AnonymousType&quot;)
			       &amp;&amp; (type.Name.StartsWith(&quot;&lt;&gt;&quot;) || type.Name.StartsWith(&quot;VB$&quot;))
			       &amp;&amp; (type.Attributes &amp; TypeAttributes.NotPublic) == TypeAttributes.NotPublic;
		}

		public static T GetCustomAttribute&lt;T&gt;(this Type type, bool inherit)
			where T : Attribute
		{
			return type.GetCustomAttributes&lt;T&gt;(inherit).SingleOrDefault();
		}

		public static IEnumerable&lt;T&gt; GetCustomAttributes&lt;T&gt;(this Type type, bool inherited)
			where T : Attribute
		{
			if (type == null) return Enumerable.Empty&lt;T&gt;();
			return type.GetCustomAttributes(typeof (T), inherited).OfType&lt;T&gt;();		
		}


	    /// &lt;summary&gt;
	    /// Determines whether the specified type is enumerable.
	    /// &lt;/summary&gt;
	    /// &lt;param name=&quot;method&quot;&gt;The type.&lt;/param&gt;
	    /// &lt;param name=&quot;parameterTypes&quot;&gt;&lt;/param&gt;
	    internal static bool HasParameters(this MethodInfo method, params Type[] parameterTypes)
        {
            var methodParameters = method.GetParameters().Select(parameter =&gt; parameter.ParameterType).ToArray();

            if (methodParameters.Length != parameterTypes.Length)
                return false;

            for (int i = 0; i &lt; methodParameters.Length; i++)
                if (methodParameters[i].ToString() != parameterTypes[i].ToString())
                    return false;

            return true;
        }
        
        public static IEnumerable&lt;Type&gt; GetBaseTypes(this Type type, bool andSelf)
        {
            if (andSelf)
                yield return type;

            while ((type = type.BaseType) != null)
                yield return type;
        }

        public static IEnumerable&lt;MethodInfo&gt; AllMethods(this Type target)
        {
            //var allTypes = target.AllInterfaces().ToList();
            var allTypes = target.GetInterfaces().ToList(); // GetInterfaces is ok here
            allTypes.Add(target);

            return allTypes.SelectMany(t =&gt; t.GetMethods());
        }
 
		/// &lt;returns&gt;
		///   &lt;c&gt;true&lt;/c&gt; if the specified type is enumerable; otherwise, &lt;c&gt;false&lt;/c&gt;.
		/// &lt;/returns&gt;
		public static bool IsEnumerable(this Type type)
		{
			if (type.IsGenericType)
			{
				if (type.GetGenericTypeDefinition().GetInterfaces().Contains(typeof(IEnumerable)))
					return true;
			}
			else
			{
				if (type.GetInterfaces().Contains(typeof(IEnumerable)))
					return true;
			}
			return false;
		}

		/// &lt;summary&gt;
		/// Determines whether [is of generic type] [the specified type].
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;type&quot;&gt;The type.&lt;/param&gt;
		/// &lt;param name=&quot;genericType&quot;&gt;Type of the generic.&lt;/param&gt;
		/// &lt;returns&gt;
		///   &lt;c&gt;true&lt;/c&gt; if [is of generic type] [the specified type]; otherwise, &lt;c&gt;false&lt;/c&gt;.
		/// &lt;/returns&gt;
		public static bool IsOfGenericType(this Type type, Type genericType)
		{
			Type[] args;
			return type.TryGetGenericArguments(genericType, out args);
		}

		/// &lt;summary&gt;
		/// Will find the generic type of the &#39;type&#39; parameter passed in that is equal to the &#39;genericType&#39; parameter passed in
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;genericType&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;genericArgType&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static bool TryGetGenericArguments(this Type type, Type genericType, out Type[] genericArgType)
		{
			if (type == null)
			{
				throw new ArgumentNullException(&quot;type&quot;);
			}
			if (genericType == null)
			{
				throw new ArgumentNullException(&quot;genericType&quot;);
			}
			if (genericType.IsGenericType == false)
			{
				throw new ArgumentException(&quot;genericType must be a generic type&quot;);
			}

			Func&lt;Type, Type, Type[]&gt; checkGenericType = (@int, t) =&gt;
				{
					if (@int.IsGenericType)
					{
						var def = @int.GetGenericTypeDefinition();
						if (def == t)
						{
							return @int.GetGenericArguments();
						}
					}
					return null;
				};

			//first, check if the type passed in is already the generic type
			genericArgType = checkGenericType(type, genericType);
			if (genericArgType != null)
				return true;

			//if we&#39;re looking for interfaces, enumerate them:
			if (genericType.IsInterface)
			{
				foreach (Type @interface in type.GetInterfaces())
				{
					genericArgType = checkGenericType(@interface, genericType);
					if (genericArgType != null)
						return true;
				}
			}
			else
			{
				//loop back into the base types as long as they are generic
				while (type.BaseType != null &amp;&amp; type.BaseType != typeof(object))
				{
					genericArgType = checkGenericType(type.BaseType, genericType);
					if (genericArgType != null)
						return true;
					type = type.BaseType;
				}

			}

			return false;

		}

        /// &lt;summary&gt;
        /// Gets all properties in a flat hierarchy
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Includes both Public and Non-Public properties&lt;/remarks&gt;
        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static PropertyInfo[] GetAllProperties(this Type type)
        {
            if (type.IsInterface)
            {
                var propertyInfos = new List&lt;PropertyInfo&gt;();

                var considered = new List&lt;Type&gt;();
                var queue = new Queue&lt;Type&gt;();
                considered.Add(type);
                queue.Enqueue(type);
                while (queue.Count &gt; 0)
                {
                    var subType = queue.Dequeue();
                    foreach (var subInterface in subType.GetInterfaces())
                    {
                        if (considered.Contains(subInterface)) continue;

                        considered.Add(subInterface);
                        queue.Enqueue(subInterface);
                    }

                    var typeProperties = subType.GetProperties(
                        BindingFlags.FlattenHierarchy
                        | BindingFlags.Public
                        | BindingFlags.NonPublic
                        | BindingFlags.Instance);

                    var newPropertyInfos = typeProperties
                        .Where(x =&gt; !propertyInfos.Contains(x));

                    propertyInfos.InsertRange(0, newPropertyInfos);
                }

                return propertyInfos.ToArray();
            }

            return type.GetProperties(BindingFlags.FlattenHierarchy
                | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        }

        /// &lt;summary&gt;
        /// Returns all public properties including inherited properties even for interfaces
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// taken from http://stackoverflow.com/questions/358835/getproperties-to-return-all-properties-for-an-interface-inheritance-hierarchy
        /// &lt;/remarks&gt;
        public static PropertyInfo[] GetPublicProperties(this Type type)
        {
            if (type.IsInterface)
            {
                var propertyInfos = new List&lt;PropertyInfo&gt;();

                var considered = new List&lt;Type&gt;();
                var queue = new Queue&lt;Type&gt;();
                considered.Add(type);
                queue.Enqueue(type);
                while (queue.Count &gt; 0)
                {
                    var subType = queue.Dequeue();
                    foreach (var subInterface in subType.GetInterfaces())
                    {
                        if (considered.Contains(subInterface)) continue;

                        considered.Add(subInterface);
                        queue.Enqueue(subInterface);
                    }

                    var typeProperties = subType.GetProperties(
                        BindingFlags.FlattenHierarchy
                        | BindingFlags.Public
                        | BindingFlags.Instance);

                    var newPropertyInfos = typeProperties
                        .Where(x =&gt; !propertyInfos.Contains(x));

                    propertyInfos.InsertRange(0, newPropertyInfos);
                }

                return propertyInfos.ToArray();
            }

            return type.GetProperties(BindingFlags.FlattenHierarchy
                | BindingFlags.Public | BindingFlags.Instance);
        }

        /// &lt;summary&gt;
		/// Determines whether the specified actual type is type.
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
		/// &lt;param name=&quot;actualType&quot;&gt;The actual type.&lt;/param&gt;
		/// &lt;returns&gt;
		///   &lt;c&gt;true&lt;/c&gt; if the specified actual type is type; otherwise, &lt;c&gt;false&lt;/c&gt;.
		/// &lt;/returns&gt;
		public static bool IsType&lt;T&gt;(this Type actualType)
		{
			return TypeHelper.IsTypeAssignableFrom&lt;T&gt;(actualType);
		}

        public static bool Inherits&lt;TBase&gt;(this Type type)
        {
            return typeof (TBase).IsAssignableFrom(type);
        }

	    public static bool Inherits(this Type type, Type tbase)
	    {
	        return tbase.IsAssignableFrom(type);
	    }

        public static bool Implements&lt;TInterface&gt;(this Type type)
        {
            return typeof (TInterface).IsAssignableFrom(type);
        }

        public static TAttribute FirstAttribute&lt;TAttribute&gt;(this Type type)
        {
            return type.FirstAttribute&lt;TAttribute&gt;(true);
        }

        public static TAttribute FirstAttribute&lt;TAttribute&gt;(this Type type, bool inherit)
        {
            var attrs = type.GetCustomAttributes(typeof(TAttribute), inherit);
            return (TAttribute)(attrs.Length &gt; 0 ? attrs[0] : null);
        }

        public static TAttribute FirstAttribute&lt;TAttribute&gt;(this PropertyInfo propertyInfo)
        {
            return propertyInfo.FirstAttribute&lt;TAttribute&gt;(true);
        }

        public static TAttribute FirstAttribute&lt;TAttribute&gt;(this PropertyInfo propertyInfo, bool inherit)
        {
            var attrs = propertyInfo.GetCustomAttributes(typeof(TAttribute), inherit);
            return (TAttribute)(attrs.Length &gt; 0 ? attrs[0] : null);
        }

        public static IEnumerable&lt;TAttribute&gt; MultipleAttribute&lt;TAttribute&gt;(this PropertyInfo propertyInfo)
        {
            return propertyInfo.MultipleAttribute&lt;TAttribute&gt;(true);
        }

        public static IEnumerable&lt;TAttribute&gt; MultipleAttribute&lt;TAttribute&gt;(this PropertyInfo propertyInfo, bool inherit)
        {
            var attrs = propertyInfo.GetCustomAttributes(typeof(TAttribute), inherit);
            return (attrs.Length &gt; 0 ? attrs.ToList().ConvertAll(input =&gt; (TAttribute)input) : null);
        }

		/// &lt;summary&gt;
		/// Returns the full type name with the assembly but without all of the assembly specific version information.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		/// &lt;remarks&gt;
		/// This method is like an &#39;inbetween&#39; of Type.FullName and Type.AssemblyQualifiedName which returns the type and the assembly separated
		/// by a comma.
		/// &lt;/remarks&gt;
		/// &lt;example&gt;
		/// The output of this class would be:
		/// 
		/// Umbraco.Core.TypeExtensions, Umbraco.Core
		/// &lt;/example&gt;
		public static string GetFullNameWithAssembly(this Type type)
		{
		    var assemblyName = type.Assembly.GetName();

			return string.Concat(type.FullName, &quot;, &quot;,
                assemblyName.FullName.StartsWith(&quot;App_Code.&quot;) ? &quot;App_Code&quot; : assemblyName.Name);
		}



    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[27,6,27,7,1],[28,13,30,17,1],[30,17,30,18,1],[30,18,32,21,1],[32,21,32,22,1],[32,22,33,25,1],[33,25,40,90,1],[40,90,42,21,1],[42,21,42,54,1],[42,54,43,21,1],[43,21,43,22,1],[43,22,44,25,1],[44,25,44,57,1],[44,57,46,17,1],[46,17,46,18,1],[46,18,46,19,1],[28,13,46,19,1],[49,13,49,49,1],[50,13,50,42,1],[51,13,51,14,1],[53,17,55,141,1],[59,13,59,14,1],[61,13,61,28,1],[62,6,62,7,1],[65,3,65,4,1],[66,4,68,19,1],[69,3,69,4,1],[71,9,71,10,0],[72,13,72,61,0],[72,61,72,80,0],[72,80,72,82,0],[72,13,72,82,0],[74,13,74,20,0],[74,22,74,32,0],[74,33,74,35,0],[74,36,74,43,0],[75,13,75,14,0],[76,17,76,58,0],[77,21,77,35,0],[78,13,78,14,0],[80,13,80,25,0],[81,9,81,10,0],[92,3,92,4,0],[93,4,93,21,0],[93,22,93,62,0],[96,4,99,87,0],[100,3,100,4,0],[104,3,104,4,1],[105,4,105,66,1],[106,3,106,4,1],[110,3,110,4,1],[111,4,111,21,1],[111,22,111,51,0],[112,4,112,71,1],[113,3,113,4,1],[122,9,122,10,0],[123,13,123,79,0],[123,79,123,102,0],[123,102,123,114,0],[123,13,123,114,0],[125,13,125,66,0],[126,17,126,30,0],[128,18,128,27,0],[128,29,128,56,0],[128,58,128,61,0],[129,17,129,84,0],[130,21,130,34,0],[132,13,132,25,0],[133,9,133,10,0],[145,9,145,10,0],[147,13,147,60,0],[148,13,148,34,0],[150,13,150,45,0],[150,45,150,59,0],[150,59,150,61,0],[150,13,150,61,0],[151,9,151,10,0],[157,3,157,4,0],[158,4,158,27,0],[159,4,159,5,0],[160,5,160,87,0],[161,6,161,18,0],[162,4,162,5,0],[164,4,164,5,0],[165,5,165,60,0],[166,6,166,18,0],[167,4,167,5,0],[168,4,168,17,0],[169,3,169,4,0],[180,3,180,4,0],[182,4,182,62,0],[183,3,183,4,0],[193,3,193,4,0],[194,4,194,21,0],[195,4,195,5,0],[196,5,196,45,0],[198,4,198,28,0],[199,4,199,5,0],[200,5,200,52,0],[202,4,202,43,0],[203,4,203,5,0],[204,5,204,71,0],[207,4,208,5,0],[208,5,208,6,0],[208,6,209,6,0],[209,6,209,29,0],[209,29,210,6,0],[210,6,210,7,0],[210,7,211,7,0],[211,7,211,49,0],[211,49,212,7,0],[212,7,212,20,0],[212,20,213,7,0],[213,7,213,8,0],[213,8,214,8,0],[214,8,214,42,0],[214,42,216,6,0],[216,6,216,7,0],[216,7,217,6,0],[217,6,217,18,0],[217,18,218,5,0],[218,5,218,6,0],[218,6,218,7,0],[207,4,218,7,0],[221,4,221,57,0],[222,4,222,31,0],[223,5,223,17,0],[226,4,226,32,0],[227,4,227,5,0],[228,5,228,12,0],[228,14,228,29,0],[228,30,228,32,0],[228,33,228,53,0],[229,5,229,6,0],[230,6,230,65,0],[231,6,231,33,0],[232,7,232,19,0],[233,5,233,6,0],[234,4,234,5,0],[236,4,236,5,0],[238,5,238,69,0],[239,5,239,6,0],[240,6,240,68,0],[241,6,241,33,0],[242,7,242,19,0],[243,6,243,27,0],[244,5,244,6,0],[246,4,246,5,0],[248,4,248,17,0],[250,3,250,4,0],[259,9,259,10,0],[260,13,260,34,0],[261,13,261,14,0],[262,17,262,62,0],[264,17,264,51,0],[265,17,265,47,0],[266,17,266,38,0],[267,17,267,37,0],[268,17,268,40,0],[269,17,269,18,0],[270,21,270,51,0],[271,21,271,28,0],[271,30,271,46,0],[271,47,271,49,0],[271,50,271,73,0],[272,21,272,22,0],[273,25,273,63,0],[273,64,273,73,0],[275,25,275,54,0],[276,25,276,53,0],[277,21,277,22,0],[279,21,283,50,0],[285,21,286,37,0],[286,37,286,63,0],[286,63,286,65,0],[285,21,286,65,0],[288,21,288,68,0],[289,17,289,18,0],[291,17,291,48,0],[294,13,295,89,0],[296,9,296,10,0],[307,9,307,10,1],[308,13,308,34,1],[309,13,309,14,1],[310,17,310,62,1],[312,17,312,51,1],[313,17,313,47,1],[314,17,314,38,1],[315,17,315,37,1],[316,17,316,40,1],[317,17,317,18,1],[318,21,318,51,1],[319,21,319,28,1],[319,30,319,46,1],[319,47,319,49,1],[319,50,319,73,1],[320,21,320,22,1],[321,25,321,63,1],[321,64,321,73,1],[323,25,323,54,1],[324,25,324,53,1],[325,21,325,22,1],[327,21,330,50,1],[332,21,333,37,1],[333,37,333,63,1],[333,63,333,65,1],[332,21,333,65,1],[335,21,335,68,1],[336,17,336,18,1],[338,17,338,48,1],[341,13,342,64,0],[343,9,343,10,1],[354,3,354,4,1],[355,4,355,58,1],[356,3,356,4,1],[359,9,359,10,0],[360,13,360,58,0],[361,9,361,10,0],[364,6,364,7,1],[365,10,365,46,1],[366,6,366,7,1],[369,9,369,10,1],[370,13,370,63,1],[371,9,371,10,1],[374,9,374,10,1],[375,13,375,58,1],[376,9,376,10,1],[379,9,379,10,1],[380,13,380,79,1],[381,13,381,69,1],[382,9,382,10,1],[385,9,385,10,1],[386,13,386,66,1],[387,9,387,10,1],[390,9,390,10,1],[391,13,391,87,1],[392,13,392,69,1],[393,9,393,10,1],[396,9,396,10,1],[397,13,397,69,1],[398,9,398,10,1],[401,9,401,10,1],[402,13,402,87,1],[403,13,403,75,1],[403,75,403,92,1],[403,92,403,102,1],[403,13,403,102,1],[404,9,404,10,1],[421,3,421,4,0],[422,7,422,50,0],[424,4,425,97,0],[426,3,426,4,0]]);
    </script>
  </body>
</html>