<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Tests\CoreXml\NavigableNavigatorTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Xsl;
using umbraco;
using Umbraco.Core;
using Umbraco.Core.Xml;
using Umbraco.Core.Xml.XPath;
using NUnit.Framework;

namespace Umbraco.Tests.CoreXml
{
    [TestFixture]
    public class NavigableNavigatorTests
    {
        [Test]
        public void NewNavigatorIsAtRoot()
        {
            const string xml = @&quot;&lt;root&gt;&lt;item1 /&gt;&lt;item2 /&gt;&lt;/root&gt;&quot;;
            var doc = XmlHelper.CreateXPathDocument(xml);
            var nav = doc.CreateNavigator();

            Assert.AreEqual(XPathNodeType.Root, nav.NodeType);
            Assert.AreEqual(string.Empty, nav.Name);

            var source = new TestSource5();
            nav = new NavigableNavigator(source);

            Assert.AreEqual(XPathNodeType.Root, nav.NodeType);
            Assert.AreEqual(string.Empty, nav.Name);
        }

        [Test]
        public void NativeXmlValues()
        {
            const string xml = @&quot;&lt;root&gt;
    &lt;wrap&gt;
        &lt;item1 /&gt;
        &lt;item2&gt;&lt;/item2&gt;
        &lt;item2a&gt; &lt;/item2a&gt;
        &lt;item2b&gt;
        &lt;/item2b&gt;
        &lt;item2c&gt;&lt;![CDATA[
        ]]&gt;&lt;/item2c&gt;
        &lt;item3&gt;blah&lt;/item3&gt;
        &lt;item3a&gt;
            blah
        &lt;/item3a&gt;
        &lt;item4&gt;
            &lt;subitem x=&quot;&quot;1&quot;&quot;&gt;bam&lt;/subitem&gt;
        &lt;/item4&gt;
        &lt;item5&gt;&lt;![CDATA[
        ]]&gt;&lt;/item5&gt;
    &lt;/wrap&gt;
&lt;/root&gt;&quot;;
            var doc = XmlHelper.CreateXPathDocument(xml);
            var nav = doc.CreateNavigator();

            NavigatorValues(nav, true);
        }

        [Test]
        public void NavigableXmlValues()
        {
            var source = new TestSource6();
            var nav = new NavigableNavigator(source);

            NavigatorValues(nav, false);
        }

        static void NavigatorValues(XPathNavigator nav, bool native)
        {
            // in non-native we can&#39;t have Value dump everything, else
            // we&#39;d dump the entire database? Makes not much sense.

            Assert.AreEqual(native ? &quot;\n        blah\n            blah\n        bam\n        &quot; : string.Empty, nav.Value.Lf()); // !!
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(&quot;root&quot;, nav.Name);
            Assert.AreEqual(native ? &quot;\n        blah\n            blah\n        bam\n        &quot; : string.Empty, nav.Value.Lf()); // !!
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(&quot;wrap&quot;, nav.Name);
            Assert.AreEqual(native ? &quot;\n        blah\n            blah\n        bam\n        &quot; : string.Empty, nav.Value.Lf()); // !!

            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(&quot;item1&quot;, nav.Name);
            Assert.AreEqual(string.Empty, nav.Value);
            Assert.IsFalse(nav.MoveToFirstChild());

            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(&quot;item2&quot;, nav.Name);
            Assert.AreEqual(string.Empty, nav.Value);
            Assert.IsFalse(nav.MoveToFirstChild()); // !!

            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(&quot;item2a&quot;, nav.Name);
            Assert.AreEqual(string.Empty, nav.Value);
            Assert.IsFalse(nav.MoveToFirstChild()); // !!

            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(&quot;item2b&quot;, nav.Name);
            Assert.AreEqual(string.Empty, nav.Value);
            Assert.IsFalse(nav.MoveToFirstChild()); // !!

            // we have no way to tell the navigable that a value is CDATA
            // so the rule is, if it&#39;s null it&#39;s not there, anything else is there
            // and the filtering has to be done when building the content

            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(&quot;item2c&quot;, nav.Name);
            Assert.AreEqual(&quot;\n        &quot;, nav.Value.Lf()); // ok since it&#39;s a property
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(XPathNodeType.Text, nav.NodeType);
            Assert.AreEqual(string.Empty, nav.Name);
            Assert.AreEqual(&quot;\n        &quot;, nav.Value.Lf());
            Assert.IsTrue(nav.MoveToParent());

            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(&quot;item3&quot;, nav.Name);
            Assert.AreEqual(&quot;blah&quot;, nav.Value); // ok since it&#39;s a property
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(XPathNodeType.Text, nav.NodeType);
            Assert.AreEqual(string.Empty, nav.Name);
            Assert.AreEqual(&quot;blah&quot;, nav.Value);
            Assert.IsTrue(nav.MoveToParent());

            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(&quot;item3a&quot;, nav.Name);
            Assert.AreEqual(&quot;\n            blah\n        &quot;, nav.Value.Lf()); // ok since it&#39;s a property
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(XPathNodeType.Text, nav.NodeType);
            Assert.AreEqual(string.Empty, nav.Name);
            Assert.AreEqual(&quot;\n            blah\n        &quot;, nav.Value.Lf());
            Assert.IsTrue(nav.MoveToParent());

            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(&quot;item4&quot;, nav.Name);
            Assert.AreEqual(&quot;bam&quot;, nav.Value); // ok since it&#39;s a property
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(&quot;subitem&quot;, nav.Name);
            Assert.AreEqual(&quot;bam&quot;, nav.Value); // ok since we&#39;re in a fragment
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(XPathNodeType.Text, nav.NodeType);
            Assert.AreEqual(string.Empty, nav.Name);
            Assert.AreEqual(&quot;bam&quot;, nav.Value);
            Assert.IsFalse(nav.MoveToNext());
            Assert.IsTrue(nav.MoveToParent());
            Assert.AreEqual(&quot;subitem&quot;, nav.Name);
            Assert.IsFalse(nav.MoveToNext());
            Assert.IsTrue(nav.MoveToParent());
            Assert.AreEqual(&quot;item4&quot;, nav.Name);

            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(&quot;item5&quot;, nav.Name);
            Assert.AreEqual(&quot;\n        &quot;, nav.Value.Lf());
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(XPathNodeType.Text, nav.NodeType);
            Assert.AreEqual(&quot;\n        &quot;, nav.Value.Lf());
        }

        [Test]
        public void Navigate()
        {
            var source = new TestSource1();
            var nav = new NavigableNavigator(source);

            nav.MoveToRoot();
            Assert.AreEqual(&quot;&quot;, nav.Name); // because we&#39;re at root
            nav.MoveToFirstChild();
            Assert.AreEqual(&quot;root&quot;, nav.Name);
            nav.MoveToFirstChild();
            Assert.AreEqual(&quot;type1&quot;, nav.Name); // our first content
            nav.MoveToFirstAttribute();
            Assert.AreEqual(&quot;id&quot;, nav.Name);
            Assert.AreEqual(&quot;1&quot;, nav.Value);
            nav.MoveToNextAttribute();
            Assert.AreEqual(&quot;prop1&quot;, nav.Name);
            Assert.AreEqual(&quot;1:p1&quot;, nav.Value);
            nav.MoveToNextAttribute();
            Assert.AreEqual(&quot;prop2&quot;, nav.Name);
            Assert.AreEqual(&quot;1:p2&quot;, nav.Value);
            Assert.IsFalse(nav.MoveToNextAttribute());
            nav.MoveToParent();
            nav.MoveToFirstChild();
            Assert.AreEqual(&quot;prop3&quot;, nav.Name);
            Assert.AreEqual(&quot;1:p3&quot;, nav.Value);

            Assert.IsFalse(nav.MoveToNext());
        }

        [Test]
        public void NavigateMixed()
        {
            var source = new TestSource2();
            var nav = new NavigableNavigator(source);

            nav.MoveToRoot();
            nav.MoveToFirstChild();
            Assert.AreEqual(&quot;root&quot;, nav.Name);
            nav.MoveToFirstChild();
            Assert.AreEqual(&quot;type1&quot;, nav.Name); // our content
            nav.MoveToFirstChild();
            Assert.AreEqual(&quot;prop1&quot;, nav.Name); // our property
            Assert.AreEqual(XPathNodeType.Element, nav.NodeType);
            nav.MoveToFirstChild();

            // &quot;&lt;data&gt;&lt;item1&gt;poo&lt;/item1&gt;&lt;item2 xx=\&quot;33\&quot; /&gt;&lt;item2 xx=\&quot;34\&quot; /&gt;&lt;/data&gt;&quot;

            Assert.AreEqual(XPathNodeType.Element, nav.NodeType);
            Assert.AreEqual(&quot;data&quot;, nav.Name);

            nav.MoveToFirstChild();
            Assert.AreEqual(XPathNodeType.Element, nav.NodeType);
            Assert.AreEqual(&quot;item1&quot;, nav.Name);

            nav.MoveToNext();
            Assert.AreEqual(XPathNodeType.Element, nav.NodeType);
            Assert.AreEqual(&quot;item2&quot;, nav.Name);

            nav.MoveToParent();
            Assert.AreEqual(XPathNodeType.Element, nav.NodeType);
            Assert.AreEqual(&quot;data&quot;, nav.Name);

            nav.MoveToParent();
            Assert.AreEqual(XPathNodeType.Element, nav.NodeType);
            Assert.AreEqual(&quot;prop1&quot;, nav.Name);
        }

        [Test]
        public void OuterXmlBasic()
        {
            const string xml = @&quot;&lt;root id=&quot;&quot;-1&quot;&quot; /&gt;&quot;;

            var doc = XmlHelper.CreateXPathDocument(xml);
            var nnav = doc.CreateNavigator();
            Assert.AreEqual(xml, nnav.OuterXml);

            var source = new TestSource0();
            var nav = new NavigableNavigator(source);
            Assert.AreEqual(xml, nav.OuterXml);
        }

        [Test]
        public void OuterXml()
        {
            var source = new TestSource1();
            var nav = new NavigableNavigator(source);

            const string xml = @&quot;&lt;root id=&quot;&quot;-1&quot;&quot; prop1=&quot;&quot;&quot;&quot; prop2=&quot;&quot;&quot;&quot;&gt;
  &lt;type1 id=&quot;&quot;1&quot;&quot; prop1=&quot;&quot;1:p1&quot;&quot; prop2=&quot;&quot;1:p2&quot;&quot;&gt;
    &lt;prop3&gt;1:p3&lt;/prop3&gt;
  &lt;/type1&gt;
&lt;/root&gt;&quot;;

            Assert.AreEqual(xml.Lf(), nav.OuterXml.Lf());
        }

        [Test]
        public void OuterXmlMixed()
        {
            var source = new TestSource2();
            var nav = new NavigableNavigator(source);

            nav.MoveToRoot();

            const string outerXml = @&quot;&lt;root id=&quot;&quot;-1&quot;&quot;&gt;
  &lt;type1 id=&quot;&quot;1&quot;&quot;&gt;
    &lt;prop1&gt;
      &lt;data&gt;
        &lt;item1&gt;poo&lt;/item1&gt;
        &lt;item2 xx=&quot;&quot;33&quot;&quot; /&gt;
        &lt;item2 xx=&quot;&quot;34&quot;&quot; /&gt;
      &lt;/data&gt;
    &lt;/prop1&gt;
  &lt;/type1&gt;
&lt;/root&gt;&quot;;

            Assert.AreEqual(outerXml.Lf(), nav.OuterXml.Lf());
        }

        [Test]
        public void Query()
        {
            var source = new TestSource1();
            var nav = new NavigableNavigator(source);

            var iterator = nav.Select(&quot;//type1&quot;);
            Assert.AreEqual(1, iterator.Count);
            iterator.MoveNext();
            Assert.AreEqual(&quot;type1&quot;, iterator.Current.Name);

            iterator = nav.Select(&quot;//* [@prop1=&#39;1:p1&#39;]&quot;);
            Assert.AreEqual(1, iterator.Count);
            iterator.MoveNext();
            Assert.AreEqual(&quot;type1&quot;, iterator.Current.Name);
        }

        [Test]
        public void QueryMixed()
        {
            var source = new TestSource2();
            var nav = new NavigableNavigator(source);

            var doc = XmlHelper.CreateXPathDocument(&quot;&lt;data&gt;&lt;item1&gt;poo&lt;/item1&gt;&lt;item2 xx=\&quot;33\&quot; /&gt;&lt;item2 xx=\&quot;34\&quot; /&gt;&lt;/data&gt;&quot;);
            var docNav = doc.CreateNavigator();
            var docIter = docNav.Select(&quot;//item2 [@xx=33]&quot;);
            Assert.AreEqual(1, docIter.Count);
            Assert.AreEqual(&quot;&quot;, docIter.Current.Name);
            docIter.MoveNext();
            Assert.AreEqual(&quot;item2&quot;, docIter.Current.Name);

            var iterator = nav.Select(&quot;//item2 [@xx=33]&quot;);
            Assert.AreEqual(1, iterator.Count);
            Assert.AreEqual(&quot;&quot;, iterator.Current.Name);
            iterator.MoveNext();
            Assert.AreEqual(&quot;item2&quot;, iterator.Current.Name);
        }

        [Test]
        public void QueryWithVariables()
        {
            var source = new TestSource1();
            var nav = new NavigableNavigator(source);

            var iterator = nav.Select(&quot;//* [@prop1=$var]&quot;, new XPathVariable(&quot;var&quot;, &quot;1:p1&quot;));
            Assert.AreEqual(1, iterator.Count);
            iterator.MoveNext();
            Assert.AreEqual(&quot;type1&quot;, iterator.Current.Name);
        }

        [Test]
        public void QueryMixedWithVariables()
        {
            var source = new TestSource2();
            var nav = new NavigableNavigator(source);

            var iterator = nav.Select(&quot;//item2 [@xx=$var]&quot;, new XPathVariable(&quot;var&quot;, &quot;33&quot;));
            Assert.AreEqual(1, iterator.Count);
            iterator.MoveNext();
            Assert.AreEqual(&quot;item2&quot;, iterator.Current.Name);
        }

        [Test]
        public void MixedWithNoValue()
        {
            var source = new TestSource4();
            var nav = new NavigableNavigator(source);

            var doc = XmlHelper.CreateXPathDocument(@&quot;&lt;root id=&quot;&quot;-1&quot;&quot;&gt;
                        &lt;type1 id=&quot;&quot;1&quot;&quot;&gt;&lt;prop1&gt;&lt;data value=&quot;&quot;value&quot;&quot;/&gt;&lt;/prop1&gt;&lt;prop2&gt;dang&lt;/prop2&gt;&lt;/type1&gt;
                        &lt;type1 id=&quot;&quot;2&quot;&quot;&gt;&lt;prop1 /&gt;&lt;prop2&gt;&lt;/prop2&gt;&lt;/type1&gt;
                        &lt;type1 id=&quot;&quot;3&quot;&quot;&gt;&lt;prop1 /&gt;&lt;prop2 /&gt;&lt;/type1&gt;
                    &lt;/root&gt;&quot;);
            var docNav = doc.CreateNavigator();

            docNav.MoveToRoot();
            Assert.IsTrue(docNav.MoveToFirstChild());
            Assert.AreEqual(&quot;root&quot;, docNav.Name);
            Assert.IsTrue(docNav.MoveToFirstChild());
            Assert.AreEqual(&quot;type1&quot;, docNav.Name);
            Assert.IsTrue(docNav.MoveToNext());
            Assert.AreEqual(&quot;type1&quot;, docNav.Name);
            Assert.IsTrue(docNav.MoveToNext());
            Assert.AreEqual(&quot;type1&quot;, docNav.Name);
            Assert.IsFalse(docNav.MoveToNext());

            docNav.MoveToRoot();
            var docOuter = docNav.OuterXml;

            nav.MoveToRoot();
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(&quot;root&quot;, nav.Name);
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(&quot;type1&quot;, nav.Name);
            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(&quot;type1&quot;, nav.Name);
            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(&quot;type1&quot;, nav.Name);
            Assert.IsFalse(nav.MoveToNext());

            nav.MoveToRoot();
            var outer = nav.OuterXml;

            Assert.AreEqual(docOuter, outer);
        }

        [Test]
        [Ignore(&quot;NavigableNavigator does not implement IHasXmlNode.&quot;)]
        public void XmlNodeList()
        {
            var source = new TestSource1();
            var nav = new NavigableNavigator(source);

            var iterator = nav.Select(&quot;/*&quot;);

            // but, that requires that the underlying navigator implements IHasXmlNode
            // so it is possible to obtain nodes from the navigator - not possible yet
            var nodes = XmlNodeListFactory.CreateNodeList(iterator);

            Assert.AreEqual(nodes.Count, 1);
            var node = nodes[0];

            Assert.AreEqual(3, node.Attributes.Count);
            Assert.AreEqual(&quot;1&quot;, node.Attributes[&quot;id&quot;].Value);
            Assert.AreEqual(&quot;1:p1&quot;, node.Attributes[&quot;prop1&quot;].Value);
            Assert.AreEqual(&quot;1:p2&quot;, node.Attributes[&quot;prop2&quot;].Value);
            Assert.AreEqual(1, node.ChildNodes.Count);
            Assert.AreEqual(&quot;prop3&quot;, node.FirstChild.Name);
            Assert.AreEqual(&quot;1:p3&quot;, node.FirstChild.Value);
        }

        [Test]
        public void CloneIsSafe()
        {
            var source = new TestSource5();
            var nav = new NavigableNavigator(source);
            TestContent content;

            Assert.AreEqual(NavigableNavigator.StatePosition.Root, nav.InternalState.Position);
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(&quot;root&quot;, nav.Name); // at -1
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(1, (nav.UnderlyingObject as TestContent).Id);
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(NavigableNavigator.StatePosition.PropertyElement, nav.InternalState.Position);
            Assert.AreEqual(&quot;prop1&quot;, nav.Name);
            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(NavigableNavigator.StatePosition.PropertyElement, nav.InternalState.Position);
            Assert.AreEqual(&quot;prop2&quot;, nav.Name);
            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(3, (nav.UnderlyingObject as TestContent).Id);

            // at that point nav is at /root/1/3

            var clone = nav.Clone() as NavigableNavigator;

            // move nav to /root/1/5 and ensure that clone stays at /root/1/3
            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(5, (nav.UnderlyingObject as TestContent).Id);
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, clone.InternalState.Position);
            Assert.AreEqual(3, (clone.UnderlyingObject as TestContent).Id);

            // move nav to /root/2
            Assert.IsTrue(nav.MoveToParent());
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(1, (nav.UnderlyingObject as TestContent).Id);
            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(2, (nav.UnderlyingObject as TestContent).Id);
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(NavigableNavigator.StatePosition.PropertyElement, nav.InternalState.Position);
            Assert.AreEqual(&quot;prop1&quot;, nav.Name);
            Assert.AreEqual(&quot;p21&quot;, nav.Value);

            // move clone to .. /root/1
            Assert.IsTrue(clone.MoveToParent());

            // clone has not been corrupted by nav
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, clone.InternalState.Position);
            Assert.AreEqual(1, (clone.UnderlyingObject as TestContent).Id);
        }

        [TestCase(1)]
        [TestCase(2)]
        [TestCase(3)]
        [TestCase(4)]
        [TestCase(5)]
        [TestCase(6)]
        public void SelectById(int id)
        {
            var source = new TestSource5();
            var nav = new NavigableNavigator(source);

            var iter = nav.Select(string.Format(&quot;//* [@id={0}]&quot;, id));
            Assert.IsTrue(iter.MoveNext());
            var current = iter.Current as NavigableNavigator;
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, current.InternalState.Position);
            Assert.AreEqual(id, (current.UnderlyingObject as TestContent).Id);
        }

        [TestCase(1)]
        [TestCase(2)]
        [TestCase(3)]
        [TestCase(4)]
        [TestCase(5)]
        [TestCase(6)]
        public void SelectByIdWithVariable(int id)
        {
            var source = new TestSource5();
            var nav = new NavigableNavigator(source);
            
            var iter = nav.Select(&quot;//* [@id=$id]&quot;, new XPathVariable(&quot;id&quot;, id.ToString(CultureInfo.InvariantCulture)));
            Assert.IsTrue(iter.MoveNext());
            var current = iter.Current as NavigableNavigator;
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, current.InternalState.Position);
            Assert.AreEqual(id, (current.UnderlyingObject as TestContent).Id);
        }

        [Test]
        public void MoveToId()
        {
            var source = new TestSource5();
            var nav = new NavigableNavigator(source);

            // move to /root/1/3
            Assert.IsTrue(nav.MoveToId(&quot;3&quot;));
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(3, (nav.UnderlyingObject as TestContent).Id);

            // move to /root/1
            Assert.IsTrue(nav.MoveToParent());
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(1, (nav.UnderlyingObject as TestContent).Id);

            // move to /root
            Assert.IsTrue(nav.MoveToParent());
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(-1, (nav.UnderlyingObject as TestContent).Id);

            // move up
            Assert.IsTrue(nav.MoveToParent());
            Assert.AreEqual(NavigableNavigator.StatePosition.Root, nav.InternalState.Position);
            Assert.IsFalse(nav.MoveToParent());

            // move to /root/1
            Assert.IsTrue(nav.MoveToId(&quot;1&quot;));
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(1, (nav.UnderlyingObject as TestContent).Id);

            // move to /root
            Assert.IsTrue(nav.MoveToParent());
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(-1, (nav.UnderlyingObject as TestContent).Id);

            // move up
            Assert.IsTrue(nav.MoveToParent());
            Assert.AreEqual(NavigableNavigator.StatePosition.Root, nav.InternalState.Position);
            Assert.IsFalse(nav.MoveToParent());

            // move to /root
            Assert.IsTrue(nav.MoveToId(&quot;-1&quot;));
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(-1, (nav.UnderlyingObject as TestContent).Id);

            // move up
            Assert.IsTrue(nav.MoveToParent());
            Assert.AreEqual(NavigableNavigator.StatePosition.Root, nav.InternalState.Position);
            Assert.IsFalse(nav.MoveToParent());

            // get lost
            Assert.IsFalse(nav.MoveToId(&quot;666&quot;));
        }

        [Test]
        public void RootedNavigator()
        {
            var source = new TestSource5();
            var nav = new NavigableNavigator(source, source.Get(1));

            // go to (/root) /1
            Assert.IsTrue(nav.MoveToFirstChild());
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(1, (nav.UnderlyingObject as TestContent).Id);

            // go to (/root) /1/prop1
            Assert.IsTrue(nav.MoveToFirstChild());
            // go to (/root) /1/prop2
            Assert.IsTrue(nav.MoveToNext());
            // go to (/root) /1/3
            Assert.IsTrue(nav.MoveToNext());
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(3, (nav.UnderlyingObject as TestContent).Id);

            // go to (/root) /1
            Assert.IsTrue(nav.MoveToParent());
            Assert.AreEqual(NavigableNavigator.StatePosition.Element, nav.InternalState.Position);
            Assert.AreEqual(1, (nav.UnderlyingObject as TestContent).Id);

            // go to (/root) ie root
            Assert.IsTrue(nav.MoveToParent());
            Assert.AreEqual(NavigableNavigator.StatePosition.Root, nav.InternalState.Position);
            Assert.IsFalse(nav.MoveToParent());

            // can&#39;t go there
            Assert.IsFalse(nav.MoveToId(&quot;2&quot;));
        }

        [TestCase(true, true)]
        [TestCase(true, false)]
        [TestCase(false, true)]
        [TestCase(false, false)]
        public void XsltDebugModeAndSortOrder(bool native, bool debug)
        {
            const string xml = @&quot;&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;UTF-8&quot;&quot;?&gt;
&lt;root&gt;
    &lt;node id=&quot;&quot;1&quot;&quot; isDoc=&quot;&quot;1&quot;&quot;&gt;
        &lt;title&gt;title-1&lt;/title&gt;
        &lt;node id=&quot;&quot;3&quot;&quot; isDoc=&quot;&quot;1&quot;&quot;&gt;
            &lt;title&gt;title-3&lt;/title&gt;
            &lt;node id=&quot;&quot;7&quot;&quot; isDoc=&quot;&quot;1&quot;&quot;&gt;
                &lt;title&gt;title-7&lt;/title&gt;
            &lt;/node&gt;
            &lt;node id=&quot;&quot;8&quot;&quot; isDoc=&quot;&quot;1&quot;&quot;&gt;
                &lt;title&gt;title-8&lt;/title&gt;
            &lt;/node&gt;
        &lt;/node&gt;
        &lt;node id=&quot;&quot;5&quot;&quot; isDoc=&quot;&quot;1&quot;&quot;&gt;
            &lt;title&gt;title-5&lt;/title&gt;
        &lt;/node&gt;
    &lt;/node&gt;
    &lt;node id=&quot;&quot;2&quot;&quot; isDoc=&quot;&quot;1&quot;&quot;&gt;
        &lt;title&gt;title-2&lt;/title&gt;
        &lt;node id=&quot;&quot;4&quot;&quot; isDoc=&quot;&quot;1&quot;&quot;&gt;
            &lt;title&gt;title-4&lt;/title&gt;
        &lt;/node&gt;
        &lt;node id=&quot;&quot;6&quot;&quot; isDoc=&quot;&quot;1&quot;&quot;&gt;
            &lt;title&gt;title-6&lt;/title&gt;
        &lt;/node&gt;
    &lt;/node&gt;
&lt;/root&gt;
&quot;;

            const string xslt = @&quot;&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;UTF-8&quot;&quot;?&gt;
&lt;!DOCTYPE xsl:stylesheet [
    &lt;!ENTITY nbsp &quot;&quot;&amp;#x00A0;&quot;&quot;&gt;
]&gt;
&lt;xsl:stylesheet
  version=&quot;&quot;1.0&quot;&quot;
  xmlns:xsl=&quot;&quot;http://www.w3.org/1999/XSL/Transform&quot;&quot;
  xmlns:msxml=&quot;&quot;urn:schemas-microsoft-com:xslt&quot;&quot;
	xmlns:umbraco.library=&quot;&quot;urn:umbraco.library&quot;&quot; xmlns:Exslt.ExsltCommon=&quot;&quot;urn:Exslt.ExsltCommon&quot;&quot; xmlns:Exslt.ExsltDatesAndTimes=&quot;&quot;urn:Exslt.ExsltDatesAndTimes&quot;&quot; xmlns:Exslt.ExsltMath=&quot;&quot;urn:Exslt.ExsltMath&quot;&quot; xmlns:Exslt.ExsltRegularExpressions=&quot;&quot;urn:Exslt.ExsltRegularExpressions&quot;&quot; xmlns:Exslt.ExsltStrings=&quot;&quot;urn:Exslt.ExsltStrings&quot;&quot; xmlns:Exslt.ExsltSets=&quot;&quot;urn:Exslt.ExsltSets&quot;&quot; xmlns:Examine=&quot;&quot;urn:Examine&quot;&quot; 
	exclude-result-prefixes=&quot;&quot;msxml umbraco.library Exslt.ExsltCommon Exslt.ExsltDatesAndTimes Exslt.ExsltMath Exslt.ExsltRegularExpressions Exslt.ExsltStrings Exslt.ExsltSets Examine &quot;&quot;&gt;

    &lt;xsl:output method=&quot;&quot;xml&quot;&quot; omit-xml-declaration=&quot;&quot;yes&quot;&quot; /&gt;
    &lt;xsl:param name=&quot;&quot;currentPage&quot;&quot;/&gt;

    &lt;xsl:template match=&quot;&quot;/&quot;&quot;&gt;
		&lt;!-- &lt;xsl:for-each select=&quot;&quot;/root/* [@isDoc]&quot;&quot;&gt; --&gt;
        &lt;!-- &lt;xsl:for-each select=&quot;&quot;$currentPage/root/* [@isDoc]&quot;&quot;&gt; --&gt;
        &lt;xsl:for-each select=&quot;&quot;/macro/nav/root/* [@isDoc]&quot;&quot;&gt;
&lt;xsl:text&gt;! &lt;/xsl:text&gt;&lt;xsl:value-of select=&quot;&quot;title&quot;&quot; /&gt;&lt;xsl:text&gt;
&lt;/xsl:text&gt;
			&lt;xsl:for-each select=&quot;&quot;./* [@isDoc]&quot;&quot;&gt;
&lt;xsl:text&gt;!! &lt;/xsl:text&gt;&lt;xsl:value-of select=&quot;&quot;title&quot;&quot; /&gt;&lt;xsl:text&gt;
&lt;/xsl:text&gt;
    			&lt;xsl:for-each select=&quot;&quot;./* [@isDoc]&quot;&quot;&gt;
&lt;xsl:text&gt;!!! &lt;/xsl:text&gt;&lt;xsl:value-of select=&quot;&quot;title&quot;&quot; /&gt;&lt;xsl:text&gt;
&lt;/xsl:text&gt;
	    		&lt;/xsl:for-each&gt;
			&lt;/xsl:for-each&gt;
		&lt;/xsl:for-each&gt;
    &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
&quot;;
            const string expected = @&quot;! title-1
!! title-3
!!! title-7
!!! title-8
!! title-5
! title-2
!! title-4
!! title-6
&quot;;

            // see http://www.onenaught.com/posts/352/xslt-performance-tip-dont-indent-output
            // why aren&#39;t we using an XmlWriter here?

            var transform = new XslCompiledTransform(debug);
            var xmlReader = new XmlTextReader(new StringReader(xslt))
                {
                    EntityHandling = EntityHandling.ExpandEntities
                };
            var xslResolver = new XmlUrlResolver
                {
                    Credentials = CredentialCache.DefaultCredentials
                };
            var args = new XsltArgumentList();

            // .Default is more restrictive than .TrustedXslt
            transform.Load(xmlReader, XsltSettings.Default, xslResolver);

            XPathNavigator macro;
            if (!native)
            {
                var source = new TestSource7();
                var nav = new NavigableNavigator(source);
                //args.AddParam(&quot;currentPage&quot;, string.Empty, nav.Clone());

                var x = new XmlDocument();
                x.LoadXml(xml);
                
                macro = new MacroNavigator(new[]
                {
                    // it even fails like that =&gt; macro nav. issue?
                    new MacroNavigator.MacroParameter(&quot;nav&quot;, x.CreateNavigator()) // nav.Clone())
                }
                );
            }
            else
            {
                var doc = new XmlDocument();
                doc.LoadXml(&quot;&lt;macro /&gt;&quot;);
                var nav = doc.CreateElement(&quot;nav&quot;);
                doc.DocumentElement.AppendChild(nav);
                var x = new XmlDocument();
                x.LoadXml(xml);
                nav.AppendChild(doc.ImportNode(x.DocumentElement, true));
                macro = doc.CreateNavigator();
            }

            var writer = new StringWriter();
            transform.Transform(macro, args, writer);

            // this was working with native, debug and non-debug
            // this was working with macro nav, non-debug
            // but was NOT working (changing the order of nodes) with macro nav, debug
            // was due to an issue with macro nav IsSamePosition, fixed

            //Debug.Print(&quot;--------&quot;);
            //Debug.Print(writer.ToString());
            Assert.AreEqual(expected.Lf(), writer.ToString().Lf());
        }

        [Test]
        public void WhiteSpacesAndEmptyValues()
        {

            // &quot;When Microsoftâ€™s DOM builder receives a text node from the parser
            // that contains only white space, it is thrown away.&quot; - so if it&#39;s ONLY
            // spaces, it&#39;s nothing, but spaces are NOT trimmed.

            // For attributes, spaces are preserved even when there&#39;s only spaces.

            var doc = XmlHelper.CreateXPathDocument(@&quot;&lt;root&gt;
                        &lt;item&gt;&lt;prop/&gt;&lt;/item&gt;
                        &lt;item&gt;&lt;prop&gt;&lt;/prop&gt;&lt;/item&gt;
                        &lt;item&gt;&lt;prop&gt; &lt;/prop&gt;&lt;/item&gt;
                        &lt;item&gt;&lt;prop&gt; 
                            &lt;/prop&gt;&lt;/item&gt;
                        &lt;item&gt;&lt;prop&gt; ooo &lt;/prop&gt;&lt;/item&gt;
                        &lt;item&gt;&lt;prop&gt; ooo 
                            &lt;/prop&gt;&lt;/item&gt;
                        &lt;item x=&quot;&quot;&quot;&quot;/&gt;
                        &lt;item x=&quot;&quot; &quot;&quot;/&gt;
                    &lt;/root&gt;&quot;);

            var docNav = doc.CreateNavigator();

            Assert.AreEqual(@&quot;&lt;root&gt;
  &lt;item&gt;
    &lt;prop /&gt;
  &lt;/item&gt;
  &lt;item&gt;
    &lt;prop&gt;&lt;/prop&gt;
  &lt;/item&gt;
  &lt;item&gt;
    &lt;prop&gt;&lt;/prop&gt;
  &lt;/item&gt;
  &lt;item&gt;
    &lt;prop&gt;&lt;/prop&gt;
  &lt;/item&gt;
  &lt;item&gt;
    &lt;prop&gt; ooo &lt;/prop&gt;
  &lt;/item&gt;
  &lt;item&gt;
    &lt;prop&gt; ooo 
                            &lt;/prop&gt;
  &lt;/item&gt;
  &lt;item x=&quot;&quot;&quot;&quot; /&gt;
  &lt;item x=&quot;&quot; &quot;&quot; /&gt;
&lt;/root&gt;&quot;.Lf(), docNav.OuterXml.Lf());

            docNav.MoveToRoot();
            Assert.IsTrue(docNav.MoveToFirstChild());
            Assert.IsTrue(docNav.MoveToFirstChild());
            Assert.IsTrue(docNav.MoveToFirstChild()); // prop
            Assert.IsTrue(docNav.IsEmptyElement);
            Assert.IsTrue(docNav.MoveToParent());
            Assert.IsTrue(docNav.MoveToNext());
            Assert.IsTrue(docNav.MoveToFirstChild()); // prop
            Assert.IsFalse(docNav.IsEmptyElement);
            Assert.AreEqual(&quot;&quot;, docNav.Value); // contains an empty text node
            Assert.IsTrue(docNav.MoveToParent());
            Assert.IsTrue(docNav.MoveToNext());
            Assert.IsTrue(docNav.MoveToFirstChild()); // prop
            Assert.IsFalse(docNav.IsEmptyElement);
            Assert.AreEqual(&quot;&quot;, docNav.Value); // contains an empty text node

            var source = new TestSource8();
            var nav = new NavigableNavigator(source);

            // shows how whitespaces are handled by NavigableNavigator
            Assert.AreEqual(@&quot;&lt;root id=&quot;&quot;-1&quot;&quot; attr=&quot;&quot;&quot;&quot;&gt;
  &lt;item id=&quot;&quot;1&quot;&quot; attr=&quot;&quot;&quot;&quot;&gt;
    &lt;prop /&gt;
  &lt;/item&gt;
  &lt;item id=&quot;&quot;2&quot;&quot; attr=&quot;&quot;&quot;&quot;&gt;
    &lt;prop&gt;&lt;/prop&gt;
  &lt;/item&gt;
  &lt;item id=&quot;&quot;3&quot;&quot; attr=&quot;&quot;   &quot;&quot;&gt;
    &lt;prop&gt;   &lt;/prop&gt;
  &lt;/item&gt;
  &lt;item id=&quot;&quot;4&quot;&quot; attr=&quot;&quot;&quot;&quot;&gt;
    &lt;prop&gt;
&lt;/prop&gt;
  &lt;/item&gt;
  &lt;item id=&quot;&quot;5&quot;&quot; attr=&quot;&quot;  ooo  &quot;&quot;&gt;
    &lt;prop&gt;   ooo   &lt;/prop&gt;
  &lt;/item&gt;
&lt;/root&gt;&quot;.Lf(), nav.OuterXml.Lf());
        }
    }

    #region Navigable implementation

    class TestPropertyType : INavigableFieldType
    {
        public TestPropertyType(string name, bool isXmlContent = false, Func&lt;object, string&gt; xmlStringConverter = null)
        {
            Name = name;
            IsXmlContent = isXmlContent;
            XmlStringConverter = xmlStringConverter;
        }

        public string Name { get; private set; }
        public bool IsXmlContent { get; private set; }
        public Func&lt;object, string&gt; XmlStringConverter { get; private set; }
    }

    class TestContentType : INavigableContentType
    {
        public TestContentType(TestSourceBase source, string name, params INavigableFieldType[] properties)
        {
            Source = source;
            Name = name;
            FieldTypes = properties;
        }

        public TestSourceBase Source { get; private set; }
        public string Name { get; private set; }
        public INavigableFieldType[] FieldTypes { get; protected set; }
    }

    class TestRootContentType : TestContentType
    {
        public TestRootContentType(TestSourceBase source, params INavigableFieldType[] properties)
            : base(source, &quot;root&quot;)
        {
            FieldTypes = properties;
        }

        public TestContentType CreateType(string name, params INavigableFieldType[] properties)
        {
            return new TestContentType(Source, name, FieldTypes.Union(properties).ToArray());
        }
    }

    class TestContent : INavigableContent
    {
        public TestContent(TestContentType type, int id, int parentId)
        {
            _type = type;
            Id = id;
            ParentId = parentId;
        }

        private readonly TestContentType _type;
        public int Id { get; private set; }
        public int ParentId { get; private set; }
        public INavigableContentType Type { get { return _type; } }
        public IList&lt;int&gt; ChildIds { get; private set; }

        public object Value(int id)
        {
            var fieldType = _type.FieldTypes[id] as TestPropertyType;
            if (fieldType == null) throw new Exception(&quot;Oops&quot;);

            var value = FieldValues[id];
            var isAttr = id &lt;= _type.Source.LastAttributeIndex;

            // null =&gt; return null
            if (value == null) return null;

			// attribute =&gt; return string value
            if (isAttr) return value.ToString();
            
			// has a converter =&gt; use the converter
            if (fieldType.XmlStringConverter != null) 
                return fieldType.XmlStringConverter(value);

            // not a string =&gt; return value as a string
            var s = value as string;
            if (s == null) return value.ToString();

            // xml content... try xml
            if (fieldType.IsXmlContent)
            {
                XPathDocument doc;
                if (XmlHelper.TryCreateXPathDocumentFromPropertyValue(s, out doc))
                    return doc.CreateNavigator();
            }

            // return the string
            // even if it&#39;s xml that can&#39;t be parsed...
            return s;
        }

        // locals
        public object[] FieldValues { get; private set; }

        public TestContent WithChildren(params int[] childIds)
        {
            ChildIds = childIds;
            return this;
        }

        public TestContent WithValues(params object[] values)
        {
            FieldValues = values == null ? new object[] {null} : values;
            return this;
        }
    }

    class TestRootContent : TestContent
    {
        public TestRootContent(TestContentType type)
            : base(type, -1, -1)
        { }
    }

    abstract class TestSourceBase : INavigableSource
    {
        protected readonly Dictionary&lt;int, TestContent&gt; Content = new Dictionary&lt;int, TestContent&gt;();

        public INavigableContent Get(int id)
        {
            return Content.ContainsKey(id) ? Content[id] : null;
        }

        public int LastAttributeIndex { get; protected set; }

        public INavigableContent Root { get; protected set; }
    }

    #endregion

    #region Navigable sources

    class TestSource0 : TestSourceBase
    {
        public TestSource0()
        {
            LastAttributeIndex = -1;
            var type = new TestRootContentType(this);
            Root = new TestRootContent(type);
        }
    }

    class TestSource1 : TestSourceBase
    {
        public TestSource1()
        {
            // last attribute index is 1 -  meaning properties 0 and 1 are attributes, 2+ are elements
            // then, fieldValues must have adequate number of items
            LastAttributeIndex = 1;

            var prop1 = new TestPropertyType(&quot;prop1&quot;);
            var prop2 = new TestPropertyType(&quot;prop2&quot;);
            var prop3 = new TestPropertyType(&quot;prop3&quot;);
            var type = new TestRootContentType(this, prop1, prop2);
            var type1 = type.CreateType(&quot;type1&quot;, prop3);

            Content[1] = new TestContent(type1, 1, -1).WithValues(&quot;1:p1&quot;, &quot;1:p2&quot;, &quot;1:p3&quot;);

            Root = new TestRootContent(type).WithValues(&quot;&quot;, &quot;&quot;).WithChildren(1);
        }
    }

    class TestSource2 : TestSourceBase
    {
        public TestSource2()
        {
            LastAttributeIndex = -1;

            var prop1 = new TestPropertyType(&quot;prop1&quot;, true);
            var type = new TestRootContentType(this);
            var type1 = type.CreateType(&quot;type1&quot;, prop1);

            const string xml = &quot;&lt;data&gt;&lt;item1&gt;poo&lt;/item1&gt;&lt;item2 xx=\&quot;33\&quot; /&gt;&lt;item2 xx=\&quot;34\&quot; /&gt;&lt;/data&gt;&quot;;
            Content[1] = new TestContent(type1, 1, 1).WithValues(xml);

            Root = new TestRootContent(type).WithChildren(1);
        }
    }

    class TestSource3 : TestSourceBase
    {
        public TestSource3()
        {
            LastAttributeIndex = 1;

            var prop1 = new TestPropertyType(&quot;prop1&quot;);
            var prop2 = new TestPropertyType(&quot;prop2&quot;);
            var prop3 = new TestPropertyType(&quot;prop3&quot;);
            var type = new TestRootContentType(this, prop1, prop2);
            var type1 = type.CreateType(&quot;type1&quot;, prop3);

            Content[1] = new TestContent(type1, 1, 1).WithValues(&quot;1:p1&quot;, &quot;1:p2&quot;, &quot;1:p3&quot;).WithChildren(2);
            Content[2] = new TestContent(type1, 2, 1).WithValues(&quot;2:p1&quot;, &quot;2:p2&quot;, &quot;2:p3&quot;);

            Root = new TestRootContent(type).WithChildren(1);
        }    
    }

    class TestSource4 : TestSourceBase
    {
        public TestSource4()
        {
            LastAttributeIndex = -1;

            var prop1 = new TestPropertyType(&quot;prop1&quot;, true);
            var prop2 = new TestPropertyType(&quot;prop2&quot;);
            var type = new TestRootContentType(this);
            var type1 = type.CreateType(&quot;type1&quot;, prop1, prop2);

            Content[1] = new TestContent(type1, 1, -1).WithValues(&quot;&lt;data value=\&quot;value\&quot;/&gt;&quot;, &quot;dang&quot;);
            Content[2] = new TestContent(type1, 2, -1).WithValues(null, &quot;&quot;);
            Content[3] = new TestContent(type1, 3, -1).WithValues(null, null);

            Root = new TestRootContent(type).WithChildren(1, 2, 3);
        }
    }

    class TestSource5 : TestSourceBase
    {
        public TestSource5()
        {
            LastAttributeIndex = -1;

            var prop1 = new TestPropertyType(&quot;prop1&quot;);
            var prop2 = new TestPropertyType(&quot;prop2&quot;);
            var type = new TestRootContentType(this);
            var type1 = type.CreateType(&quot;type1&quot;, prop1, prop2);

            Content[1] = new TestContent(type1, 1, -1).WithValues(&quot;p11&quot;, &quot;p12&quot;).WithChildren(3, 5);
            Content[2] = new TestContent(type1, 2, -1).WithValues(&quot;p21&quot;, &quot;p22&quot;).WithChildren(4, 6);
            Content[3] = new TestContent(type1, 3, 1).WithValues(&quot;p31&quot;, &quot;p32&quot;);
            Content[4] = new TestContent(type1, 4, 2).WithValues(&quot;p41&quot;, &quot;p42&quot;);
            Content[5] = new TestContent(type1, 5, 1).WithValues(&quot;p51&quot;, &quot;p52&quot;);
            Content[6] = new TestContent(type1, 6, 2).WithValues(&quot;p61&quot;, &quot;p62&quot;);

            Root = new TestRootContent(type).WithChildren(1, 2);
        }
    }

    class TestSource6 : TestSourceBase
    {
        //&lt;root&gt;
        //    &lt;wrap&gt;
        //        &lt;item1 /&gt;
        //        &lt;item2&gt;&lt;/item2&gt;
        //        &lt;item2a&gt; &lt;/item2a&gt;
        //        &lt;item2b&gt;
        //        &lt;/item2b&gt;
        //        &lt;item2c&gt;&lt;![CDATA[
        //        ]]&gt;&lt;/item2c&gt;
        //        &lt;item3&gt;blah&lt;/item3&gt;
        //        &lt;item4&gt;
        //            &lt;subitem x=&quot;&quot;1&quot;&quot;&gt;bam&lt;/subitem&gt;
        //        &lt;/item4&gt;
        //        &lt;item5&gt;
        //        &lt;/item5&gt;
        //    &lt;/wrap&gt;
        //&lt;/root&gt;
        
        public TestSource6()
        {
            LastAttributeIndex = -1;

            var type = new TestRootContentType(this);
            var type1 = type.CreateType(&quot;wrap&quot;, 
                new TestPropertyType(&quot;item1&quot;),
                new TestPropertyType(&quot;item2&quot;),
                new TestPropertyType(&quot;item2a&quot;),
                new TestPropertyType(&quot;item2b&quot;),
                new TestPropertyType(&quot;item2c&quot;),
                new TestPropertyType(&quot;item3&quot;),
                new TestPropertyType(&quot;item3a&quot;),
                new TestPropertyType(&quot;item4&quot;, true),
                new TestPropertyType(&quot;item5&quot;, true)
            );

            Content[1] = new TestContent(type1, 1, -1)
                .WithValues(
                    null,
                    null, 
                    null, 
                    null, 
                    &quot;\n        &quot;, 
                    &quot;blah&quot;, 
                    &quot;\n            blah\n        &quot;,
                    &quot;&lt;subitem x=\&quot;1\&quot;&gt;bam&lt;/subitem&gt;&quot;,
                    &quot;\n        &quot;
                );

            Root = new TestRootContent(type).WithChildren(1);
        }
    }

    class TestSource7 : TestSourceBase
    {
        public TestSource7()
        {
            LastAttributeIndex = 0;

            var prop1 = new TestPropertyType(&quot;isDoc&quot;);
            var prop2 = new TestPropertyType(&quot;title&quot;);
            var type = new TestRootContentType(this, prop1);
            var type1 = type.CreateType(&quot;node&quot;, prop1, prop2);

            Content[1] = new TestContent(type1, 1, -1).WithValues(1, &quot;title-1&quot;).WithChildren(3, 5);
            Content[2] = new TestContent(type1, 2, -1).WithValues(1, &quot;title-2&quot;).WithChildren(4, 6);
            Content[3] = new TestContent(type1, 3, 1).WithValues(1, &quot;title-3&quot;).WithChildren(7, 8);
            Content[4] = new TestContent(type1, 4, 2).WithValues(1, &quot;title-4&quot;);
            Content[5] = new TestContent(type1, 5, 1).WithValues(1, &quot;title-5&quot;);
            Content[6] = new TestContent(type1, 6, 2).WithValues(1, &quot;title-6&quot;);

            Content[7] = new TestContent(type1, 7, 3).WithValues(1, &quot;title-7&quot;);
            Content[8] = new TestContent(type1, 8, 3).WithValues(1, &quot;title-8&quot;);

            Root = new TestRootContent(type).WithValues(null).WithChildren(1, 2);
        }
    }

    class TestSource8 : TestSourceBase
    {
        public TestSource8()
        {
            LastAttributeIndex = 0;

            var attr = new TestPropertyType(&quot;attr&quot;);
            var prop = new TestPropertyType(&quot;prop&quot;);
            var type = new TestRootContentType(this, attr);
            var type1 = type.CreateType(&quot;item&quot;, attr, prop);
            Content[1] = new TestContent(type1, 1, -1).WithValues(null, null);
            Content[2] = new TestContent(type1, 2, -1).WithValues(&quot;&quot;, &quot;&quot;);
            Content[3] = new TestContent(type1, 3, -1).WithValues(&quot;   &quot;, &quot;   &quot;);
            Content[4] = new TestContent(type1, 4, -1).WithValues(&quot;&quot;, &quot;\n&quot;);
            Content[5] = new TestContent(type1, 5, -1).WithValues(&quot;  ooo  &quot;, &quot;   ooo   &quot;);
            Root = new TestRootContent(type).WithValues(null).WithChildren(1, 2, 3, 4, 5);
        }
    }

    #endregion
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[24,9,24,10,1],[26,13,26,58,1],[27,13,27,45,1],[29,13,29,63,1],[30,13,30,53,1],[32,13,32,44,1],[33,13,33,50,1],[35,13,35,63,1],[36,13,36,53,1],[37,9,37,10,1],[41,9,41,10,1],[62,13,62,58,1],[63,13,63,45,1],[65,13,65,40,1],[66,9,66,10,1],[70,9,70,10,1],[71,13,71,44,1],[72,13,72,54,1],[74,13,74,41,1],[75,9,75,10,1],[78,9,78,10,1],[82,13,82,128,1],[83,13,83,51,1],[84,13,84,47,1],[85,13,85,128,1],[86,13,86,51,1],[87,13,87,47,1],[88,13,88,128,1],[90,13,90,51,1],[91,13,91,48,1],[92,13,92,54,1],[93,13,93,52,1],[95,13,95,45,1],[96,13,96,48,1],[97,13,97,54,1],[98,13,98,52,1],[100,13,100,45,1],[101,13,101,49,1],[102,13,102,54,1],[103,13,103,52,1],[105,13,105,45,1],[106,13,106,49,1],[107,13,107,54,1],[108,13,108,52,1],[114,13,114,45,1],[115,13,115,49,1],[116,13,116,59,1],[117,13,117,51,1],[118,13,118,63,1],[119,13,119,53,1],[120,13,120,59,1],[121,13,121,47,1],[123,13,123,45,1],[124,13,124,48,1],[125,13,125,48,1],[126,13,126,51,1],[127,13,127,63,1],[128,13,128,53,1],[129,13,129,48,1],[130,13,130,47,1],[132,13,132,45,1],[133,13,133,49,1],[134,13,134,77,1],[135,13,135,51,1],[136,13,136,63,1],[137,13,137,53,1],[138,13,138,77,1],[139,13,139,47,1],[141,13,141,45,1],[142,13,142,48,1],[143,13,143,47,1],[144,13,144,51,1],[145,13,145,50,1],[146,13,146,47,1],[147,13,147,51,1],[148,13,148,63,1],[149,13,149,53,1],[150,13,150,47,1],[151,13,151,46,1],[152,13,152,47,1],[153,13,153,50,1],[154,13,154,46,1],[155,13,155,47,1],[156,13,156,48,1],[158,13,158,45,1],[159,13,159,48,1],[160,13,160,59,1],[161,13,161,51,1],[162,13,162,63,1],[163,13,163,59,1],[164,9,164,10,1],[168,9,168,10,1],[169,13,169,44,1],[170,13,170,54,1],[172,13,172,30,1],[173,13,173,43,1],[174,13,174,36,1],[175,13,175,47,1],[176,13,176,36,1],[177,13,177,48,1],[178,13,178,40,1],[179,13,179,45,1],[180,13,180,45,1],[181,13,181,39,1],[182,13,182,48,1],[183,13,183,48,1],[184,13,184,39,1],[185,13,185,48,1],[186,13,186,48,1],[187,13,187,55,1],[188,13,188,32,1],[189,13,189,36,1],[190,13,190,48,1],[191,13,191,48,1],[193,13,193,46,1],[194,9,194,10,1],[198,9,198,10,1],[199,13,199,44,1],[200,13,200,54,1],[202,13,202,30,1],[203,13,203,36,1],[204,13,204,47,1],[205,13,205,36,1],[206,13,206,48,1],[207,13,207,36,1],[208,13,208,48,1],[209,13,209,66,1],[210,13,210,36,1],[214,13,214,66,1],[215,13,215,47,1],[217,13,217,36,1],[218,13,218,66,1],[219,13,219,48,1],[221,13,221,30,1],[222,13,222,66,1],[223,13,223,48,1],[225,13,225,32,1],[226,13,226,66,1],[227,13,227,47,1],[229,13,229,32,1],[230,13,230,66,1],[231,13,231,48,1],[232,9,232,10,1],[236,9,236,10,1],[239,13,239,58,1],[240,13,240,46,1],[241,13,241,49,1],[243,13,243,44,1],[244,13,244,54,1],[245,13,245,48,1],[246,9,246,10,1],[250,9,250,10,1],[251,13,251,44,1],[252,13,252,54,1],[260,13,260,58,1],[261,9,261,10,1],[265,9,265,10,1],[266,13,266,44,1],[267,13,267,54,1],[269,13,269,30,1],[283,13,283,63,1],[284,9,284,10,1],[288,9,288,10,1],[289,13,289,44,1],[290,13,290,54,1],[292,13,292,50,1],[293,13,293,48,1],[294,13,294,33,1],[295,13,295,61,1],[297,13,297,58,1],[298,13,298,48,1],[299,13,299,33,1],[300,13,300,61,1],[301,9,301,10,1],[305,9,305,10,1],[306,13,306,44,1],[307,13,307,54,1],[309,13,309,126,1],[310,13,310,48,1],[311,13,311,61,1],[312,13,312,47,1],[313,13,313,55,1],[314,13,314,32,1],[315,13,315,60,1],[317,13,317,59,1],[318,13,318,48,1],[319,13,319,56,1],[320,13,320,33,1],[321,13,321,61,1],[322,9,322,10,1],[326,9,326,10,1],[327,13,327,44,1],[328,13,328,54,1],[330,13,330,94,1],[331,13,331,48,1],[332,13,332,33,1],[333,13,333,61,1],[334,9,334,10,1],[338,9,338,10,1],[339,13,339,44,1],[340,13,340,54,1],[342,13,342,93,1],[343,13,343,48,1],[344,13,344,33,1],[345,13,345,61,1],[346,9,346,10,1],[350,9,350,10,1],[351,13,351,44,1],[352,13,352,54,1],[354,13,358,31,1],[359,13,359,48,1],[361,13,361,33,1],[362,13,362,54,1],[363,13,363,50,1],[364,13,364,54,1],[365,13,365,51,1],[366,13,366,48,1],[367,13,367,51,1],[368,13,368,48,1],[369,13,369,51,1],[370,13,370,49,1],[372,13,372,33,1],[373,13,373,44,1],[375,13,375,30,1],[376,13,376,51,1],[377,13,377,47,1],[378,13,378,51,1],[379,13,379,48,1],[380,13,380,45,1],[381,13,381,48,1],[382,13,382,45,1],[383,13,383,48,1],[384,13,384,46,1],[386,13,386,30,1],[387,13,387,38,1],[389,13,389,46,1],[390,9,390,10,1],[395,9,395,10,0],[396,13,396,44,0],[397,13,397,54,0],[399,13,399,45,0],[403,13,403,69,0],[405,13,405,45,0],[406,13,406,33,0],[408,13,408,55,0],[409,13,409,63,0],[410,13,410,69,0],[411,13,411,69,0],[412,13,412,55,0],[413,13,413,60,0],[414,13,414,60,0],[415,9,415,10,0],[419,9,419,10,1],[420,13,420,44,1],[421,13,421,54,1],[424,13,424,96,1],[425,13,425,51,1],[426,13,426,99,1],[427,13,427,47,1],[428,13,428,51,1],[429,13,429,99,1],[430,13,430,74,1],[431,13,431,51,1],[432,13,432,107,1],[433,13,433,48,1],[434,13,434,45,1],[435,13,435,107,1],[436,13,436,48,1],[437,13,437,45,1],[438,13,438,99,1],[439,13,439,74,1],[443,13,443,59,1],[446,13,446,45,1],[447,13,447,99,1],[448,13,448,74,1],[449,13,449,101,1],[450,13,450,76,1],[453,13,453,47,1],[454,13,454,99,1],[455,13,455,74,1],[456,13,456,45,1],[457,13,457,99,1],[458,13,458,74,1],[459,13,459,51,1],[460,13,460,107,1],[461,13,461,48,1],[462,13,462,47,1],[465,13,465,49,1],[468,13,468,101,1],[469,13,469,76,1],[470,9,470,10,1],[479,9,479,10,1],[480,13,480,44,1],[481,13,481,54,1],[483,13,483,71,1],[484,13,484,44,1],[485,13,485,62,1],[486,13,486,103,1],[487,13,487,79,1],[488,9,488,10,1],[497,9,497,10,1],[498,13,498,44,1],[499,13,499,54,1],[501,13,501,120,1],[502,13,502,44,1],[503,13,503,62,1],[504,13,504,103,1],[505,13,505,79,1],[506,9,506,10,1],[510,9,510,10,1],[511,13,511,44,1],[512,13,512,54,1],[515,13,515,46,1],[516,13,516,99,1],[517,13,517,74,1],[520,13,520,47,1],[521,13,521,99,1],[522,13,522,74,1],[525,13,525,47,1],[526,13,526,99,1],[527,13,527,75,1],[530,13,530,47,1],[531,13,531,96,1],[532,13,532,48,1],[535,13,535,46,1],[536,13,536,99,1],[537,13,537,74,1],[540,13,540,47,1],[541,13,541,99,1],[542,13,542,75,1],[545,13,545,47,1],[546,13,546,96,1],[547,13,547,48,1],[550,13,550,47,1],[551,13,551,99,1],[552,13,552,75,1],[555,13,555,47,1],[556,13,556,96,1],[557,13,557,48,1],[560,13,560,49,1],[561,9,561,10,1],[565,9,565,10,1],[566,13,566,44,1],[567,13,567,69,1],[570,13,570,51,1],[571,13,571,99,1],[572,13,572,74,1],[575,13,575,51,1],[577,13,577,45,1],[579,13,579,45,1],[580,13,580,99,1],[581,13,581,74,1],[584,13,584,47,1],[585,13,585,99,1],[586,13,586,74,1],[589,13,589,47,1],[590,13,590,96,1],[591,13,591,48,1],[594,13,594,47,1],[595,9,595,10,1],[602,9,602,10,1],[678,13,678,61,1],[679,13,682,19,1],[683,13,686,19,1],[687,13,687,47,1],[690,13,690,74,1],[693,13,693,25,1],[694,13,694,14,1],[695,17,695,48,1],[696,17,696,58,1],[699,17,699,43,1],[700,17,700,32,1],[702,17,707,19,1],[708,13,708,14,1],[710,13,710,14,1],[711,17,711,45,1],[712,17,712,42,1],[713,17,713,52,1],[714,17,714,54,1],[715,17,715,43,1],[716,17,716,32,1],[717,17,717,74,1],[718,17,718,47,1],[719,13,719,14,1],[721,13,721,45,1],[722,13,722,54,1],[731,13,731,68,1],[732,9,732,10,1],[736,9,736,10,1],[744,13,755,31,1],[757,13,757,48,1],[759,13,781,38,1],[783,13,783,33,1],[784,13,784,54,1],[785,13,785,54,1],[786,13,786,54,1],[787,13,787,50,1],[788,13,788,50,1],[789,13,789,48,1],[790,13,790,54,1],[791,13,791,51,1],[792,13,792,47,1],[793,13,793,50,1],[794,13,794,48,1],[795,13,795,54,1],[796,13,796,51,1],[797,13,797,47,1],[799,13,799,44,1],[800,13,800,54,1],[803,13,820,35,1],[821,9,821,10,1],[828,9,828,120,1],[829,9,829,10,1],[830,13,830,25,1],[831,13,831,41,1],[832,13,832,53,1],[833,9,833,10,1],[835,30,835,34,1],[835,35,835,47,1],[836,36,836,40,1],[836,41,836,53,1],[837,58,837,62,1],[837,63,837,75,1],[842,9,842,108,1],[843,9,843,10,1],[844,13,844,29,1],[845,13,845,25,1],[846,13,846,37,1],[847,9,847,10,1],[849,40,849,44,1],[849,45,849,57,1],[850,30,850,34,1],[850,35,850,47,1],[851,51,851,55,1],[851,56,851,70,1],[857,15,857,35,1],[858,9,858,10,1],[859,13,859,37,1],[860,9,860,10,1],[863,9,863,10,1],[864,13,864,94,1],[865,9,865,10,1],[870,9,870,71,1],[871,9,871,10,1],[872,13,872,26,1],[873,13,873,21,1],[874,13,874,33,1],[875,9,875,10,1],[878,25,878,29,1],[878,30,878,42,1],[879,31,879,35,1],[879,36,879,48,1],[880,49,880,50,1],[880,51,880,64,1],[880,65,880,66,1],[881,38,881,42,1],[881,43,881,55,1],[884,9,884,10,1],[885,13,885,70,1],[886,13,886,35,1],[886,36,886,64,0],[888,13,888,41,1],[889,13,889,64,1],[892,13,892,31,1],[892,32,892,44,1],[895,13,895,24,1],[895,25,895,49,1],[898,13,898,54,1],[899,17,899,60,0],[902,13,902,37,1],[903,13,903,27,1],[903,28,903,52,0],[906,13,906,40,1],[907,13,907,14,1],[909,17,909,83,1],[910,21,910,50,1],[911,13,911,14,1],[915,13,915,22,1],[916,9,916,10,1],[919,39,919,43,1],[919,44,919,56,1],[922,9,922,10,1],[923,13,923,33,1],[924,13,924,25,1],[925,9,925,10,1],[928,9,928,10,1],[929,13,929,73,1],[930,13,930,25,1],[931,9,931,10,1],[937,15,937,33,1],[938,9,938,10,1],[938,11,938,12,1],[943,9,943,102,1],[946,9,946,10,1],[947,13,947,65,1],[948,9,948,10,1],[950,41,950,45,1],[950,46,950,60,1],[952,41,952,45,1],[952,46,952,60,1],[961,9,961,29,1],[962,9,962,10,1],[963,13,963,37,1],[964,13,964,54,1],[965,13,965,46,1],[966,9,966,10,1],[971,9,971,29,1],[972,9,972,10,1],[975,13,975,36,1],[977,13,977,55,1],[978,13,978,55,1],[979,13,979,55,1],[980,13,980,68,1],[981,13,981,57,1],[983,13,983,91,1],[985,13,985,81,1],[986,9,986,10,1],[991,9,991,29,1],[992,9,992,10,1],[993,13,993,37,1],[995,13,995,61,1],[996,13,996,54,1],[997,13,997,57,1],[1000,13,1000,71,1],[1002,13,1002,62,1],[1003,9,1003,10,1],[1008,9,1008,29,0],[1009,9,1009,10,0],[1010,13,1010,36,0],[1012,13,1012,55,0],[1013,13,1013,55,0],[1014,13,1014,55,0],[1015,13,1015,68,0],[1016,13,1016,57,0],[1018,13,1018,106,0],[1019,13,1019,90,0],[1021,13,1021,62,0],[1022,9,1022,10,0],[1027,9,1027,29,1],[1028,9,1028,10,1],[1029,13,1029,37,1],[1031,13,1031,61,1],[1032,13,1032,55,1],[1033,13,1033,54,1],[1034,13,1034,64,1],[1036,13,1036,102,1],[1037,13,1037,77,1],[1038,13,1038,79,1],[1040,13,1040,68,1],[1041,9,1041,10,1],[1046,9,1046,29,1],[1047,9,1047,10,1],[1048,13,1048,37,1],[1050,13,1050,55,1],[1051,13,1051,55,1],[1052,13,1052,54,1],[1053,13,1053,64,1],[1055,13,1055,100,1],[1056,13,1056,100,1],[1057,13,1057,80,1],[1058,13,1058,80,1],[1059,13,1059,80,1],[1060,13,1060,80,1],[1062,13,1062,65,1],[1063,9,1063,10,1],[1086,9,1086,29,1],[1087,9,1087,10,1],[1088,13,1088,37,1],[1090,13,1090,54,1],[1091,13,1101,15,1],[1103,13,1114,19,1],[1116,13,1116,62,1],[1117,9,1117,10,1],[1122,9,1122,29,1],[1123,9,1123,10,1],[1124,13,1124,36,1],[1126,13,1126,55,1],[1127,13,1127,55,1],[1128,13,1128,61,1],[1129,13,1129,63,1],[1131,13,1131,100,1],[1132,13,1132,100,1],[1133,13,1133,99,1],[1134,13,1134,80,1],[1135,13,1135,80,1],[1136,13,1136,80,1],[1138,13,1138,80,1],[1139,13,1139,80,1],[1141,13,1141,82,1],[1142,9,1142,10,1],[1147,9,1147,29,1],[1148,9,1148,10,1],[1149,13,1149,36,1],[1151,13,1151,53,1],[1152,13,1152,53,1],[1153,13,1153,60,1],[1154,13,1154,61,1],[1155,13,1155,79,1],[1156,13,1156,75,1],[1157,13,1157,81,1],[1158,13,1158,77,1],[1159,13,1159,91,1],[1160,13,1160,91,1],[1161,9,1161,10,1]]);
    </script>
  </body>
</html>