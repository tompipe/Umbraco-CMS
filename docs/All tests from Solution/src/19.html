<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Tests\Plugins\TypeHelperTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data.Odbc;
using System.Data.OleDb;
using System.Data.SqlClient;
using System.Linq;
using System.Reflection;
using NUnit.Framework;
using Umbraco.Core;
using Umbraco.Core.Models;
using Umbraco.Tests.DynamicsAndReflection;
using Umbraco.Web.Cache;
using Umbraco.Web.Models;
using Umbraco.Web.Scheduling;
using UmbracoExamine.DataServices;

namespace Umbraco.Tests.Plugins
{
    /// &lt;summary&gt;
    /// Tests for TypeHelper
    /// &lt;/summary&gt;
    [TestFixture]
    public class TypeHelperTests
    {

   


        class Base&lt;T&gt; { }

        interface IBase&lt;T&gt; { }

        interface IDerived&lt;T&gt; : IBase&lt;T&gt; { }

        class Derived&lt;T&gt; : Base&lt;T&gt;, IBase&lt;T&gt; { }

        class Derived2&lt;T&gt; : Derived&lt;T&gt; { }

        class DerivedI&lt;T&gt; : IDerived&lt;T&gt; { }

        [Test]
        public void Is_Static_Class()
        {
            Assert.IsTrue(TypeHelper.IsStaticClass(typeof(TypeHelper)));
            Assert.IsFalse(TypeHelper.IsStaticClass(typeof(TypeHelperTests)));
        }

        [Test]
        public void Find_Common_Base_Class()
        {
            var t1 = TypeHelper.GetLowestBaseType(typeof (OleDbCommand),
                                                  typeof (OdbcCommand),
                                                  typeof (SqlCommand));
            Assert.IsFalse(t1.Success);

            var t2 = TypeHelper.GetLowestBaseType(typeof (OleDbCommand),
                                                  typeof (OdbcCommand),
                                                  typeof (SqlCommand),
                                                  typeof (Component));
            Assert.IsTrue(t2.Success);
            Assert.AreEqual(typeof(Component), t2.Result);

            var t3 = TypeHelper.GetLowestBaseType(typeof (OleDbCommand),
                                                  typeof (OdbcCommand),
                                                  typeof (SqlCommand),
                                                  typeof (Component),
                                                  typeof (Component).BaseType);
            Assert.IsTrue(t3.Success);
            Assert.AreEqual(typeof(MarshalByRefObject), t3.Result);

            var t4 = TypeHelper.GetLowestBaseType(typeof(OleDbCommand),
                                                   typeof(OdbcCommand),
                                                   typeof(SqlCommand),
                                                   typeof(Component),
                                                   typeof(Component).BaseType,
                                                   typeof(int));
            Assert.IsFalse(t4.Success);

            var t5 = TypeHelper.GetLowestBaseType(typeof(PropertyAliasDto));
            Assert.IsTrue(t5.Success);
            Assert.AreEqual(typeof(PropertyAliasDto), t5.Result);

            var t6 = TypeHelper.GetLowestBaseType(typeof (IApplicationEventHandler),
                                                  typeof (Scheduler),
                                                  typeof(CacheRefresherEventHandler));
            Assert.IsTrue(t6.Success);
            Assert.AreEqual(typeof(IApplicationEventHandler), t6.Result);

        }

        [Test]
        public void MatchTypesTest()
        {
            var bindings = new Dictionary&lt;string, Type&gt;();
            Assert.IsTrue(TypeHelper.MatchType(typeof(int), typeof(int), bindings));
            Assert.AreEqual(0, bindings.Count);

            bindings = new Dictionary&lt;string, Type&gt;();
            Assert.IsFalse(TypeHelper.MatchType(typeof(int), typeof(string), bindings));
            Assert.AreEqual(0, bindings.Count);

            bindings = new Dictionary&lt;string, Type&gt;();
            Assert.IsTrue(TypeHelper.MatchType(typeof(List&lt;int&gt;), typeof(System.Collections.IEnumerable), bindings));
            Assert.AreEqual(0, bindings.Count);

            var t1 = typeof(IList&lt;&gt;); // IList&lt;&gt;
            var a1 = t1.GetGenericArguments()[0]; // &lt;T&gt;
            t1 = t1.MakeGenericType(a1); // IList&lt;T&gt;
            var t2 = a1;

            bindings = new Dictionary&lt;string, Type&gt;();
            Assert.IsTrue(TypeHelper.MatchType(typeof(int), t2, bindings));
            Assert.AreEqual(1, bindings.Count);
            Assert.AreEqual(typeof(int), bindings[&quot;T&quot;]);

            bindings = new Dictionary&lt;string, Type&gt;();
            Assert.IsTrue(TypeHelper.MatchType(typeof(IList&lt;int&gt;), t1, bindings));
            Assert.AreEqual(1, bindings.Count);
            Assert.AreEqual(typeof(int), bindings[&quot;T&quot;]);

            bindings = new Dictionary&lt;string, Type&gt;();
            Assert.IsTrue(TypeHelper.MatchType(typeof(List&lt;int&gt;), typeof(IList&lt;int&gt;), bindings));
            Assert.AreEqual(0, bindings.Count);

            bindings = new Dictionary&lt;string, Type&gt;();
            Assert.IsTrue(TypeHelper.MatchType(typeof(List&lt;int&gt;), t1, bindings));
            Assert.AreEqual(1, bindings.Count);
            Assert.AreEqual(typeof(int), bindings[&quot;T&quot;]);

            bindings = new Dictionary&lt;string, Type&gt;();
            Assert.IsTrue(TypeHelper.MatchType(typeof(Dictionary&lt;int, string&gt;), typeof(IDictionary&lt;,&gt;), bindings));
            Assert.AreEqual(2, bindings.Count);
            Assert.AreEqual(typeof(int), bindings[&quot;TKey&quot;]);
            Assert.AreEqual(typeof(string), bindings[&quot;TValue&quot;]);

            t1 = typeof(IDictionary&lt;,&gt;); // IDictionary&lt;,&gt;
            a1 = t1.GetGenericArguments()[0]; // &lt;TKey&gt;
            t1 = t1.MakeGenericType(a1, a1); // IDictionary&lt;TKey,TKey&gt;

            bindings = new Dictionary&lt;string, Type&gt;();
            Assert.IsFalse(TypeHelper.MatchType(typeof(Dictionary&lt;int, string&gt;), t1, bindings));

            bindings = new Dictionary&lt;string, Type&gt;();
            Assert.IsTrue(TypeHelper.MatchType(typeof(Dictionary&lt;int, int&gt;), t1, bindings));
            Assert.AreEqual(1, bindings.Count);
            Assert.AreEqual(typeof(int), bindings[&quot;TKey&quot;]);
        }

        [Test]
        public void MatchType()
        {
            // both are OK
            Assert.IsTrue(TypeHelper.MatchType(typeof(List&lt;int&gt;), typeof(IEnumerable&lt;&gt;)));

            var t1 = typeof (IDictionary&lt;,&gt;); // IDictionary&lt;,&gt;
            var a1 = t1.GetGenericArguments()[0];
            t1 = t1.MakeGenericType(a1, a1); // IDictionary&lt;T,T&gt;

            // both are OK

            Assert.IsTrue(TypeHelper.MatchType(typeof(Dictionary&lt;int, int&gt;), t1));

            Assert.IsFalse(TypeHelper.MatchType(typeof(Dictionary&lt;int, string&gt;), t1));

            // these are all of there from Is_Assignable_To_Generic_Type
            Assert.IsTrue(TypeHelper.MatchType(typeof(Derived&lt;int&gt;), typeof(Base&lt;&gt;)));
            Assert.IsTrue(TypeHelper.MatchType(typeof(List&lt;int&gt;), typeof(IEnumerable&lt;&gt;)));
            Assert.IsTrue(TypeHelper.MatchType(typeof(Derived&lt;int&gt;), typeof(Derived&lt;&gt;)));
            Assert.IsTrue(TypeHelper.MatchType(typeof(Derived2&lt;int&gt;), typeof(Base&lt;&gt;)));
            Assert.IsTrue(TypeHelper.MatchType(typeof(DerivedI&lt;int&gt;), typeof(IBase&lt;&gt;)));
            Assert.IsTrue(TypeHelper.MatchType(typeof(Derived2&lt;int&gt;), typeof(IBase&lt;&gt;)));
            Assert.IsTrue(TypeHelper.MatchType(typeof(int?), typeof(Nullable&lt;&gt;)));


            Assert.IsTrue(TypeHelper.MatchType(typeof(Derived&lt;int&gt;), typeof(Object)));
            Assert.IsFalse(TypeHelper.MatchType(typeof(Derived&lt;int&gt;), typeof(List&lt;&gt;)));
            Assert.IsFalse(TypeHelper.MatchType(typeof(Derived&lt;int&gt;), typeof(IEnumerable&lt;&gt;)));
            Assert.IsTrue(TypeHelper.MatchType(typeof(Derived&lt;int&gt;), typeof(Base&lt;int&gt;)));
            Assert.IsTrue(TypeHelper.MatchType(typeof(List&lt;int&gt;), typeof(IEnumerable&lt;int&gt;)));
            Assert.IsFalse(TypeHelper.MatchType(typeof(int), typeof(Nullable&lt;&gt;)));

            //This get&#39;s the &quot;Type&quot; from the Count extension method on IEnumerable&lt;T&gt;, however the type IEnumerable&lt;T&gt; isn&#39;t
            // IEnumerable&lt;&gt; and it is not a generic definition, this attempts to explain that:
            // http://blogs.msdn.com/b/haibo_luo/archive/2006/02/17/534480.aspx

            var genericEnumerableNonGenericDefinition = typeof(Enumerable).GetMethods(BindingFlags.Static | BindingFlags.Public)
                .Single(x =&gt; x.Name == &quot;Count&quot; &amp;&amp; x.GetParameters().Count() == 1)
                .GetParameters()
                .Single()
                .ParameterType;

            Assert.IsTrue(TypeHelper.MatchType(typeof(List&lt;int&gt;), genericEnumerableNonGenericDefinition));

        }


        [Test]
        public void CreateOpenGenericTypes()
        {
            // readings
            // http://stackoverflow.com/questions/13466078/create-open-constructed-type-from-string
            // http://stackoverflow.com/questions/6704722/c-sharp-language-how-to-get-type-of-bound-but-open-generic-class

            // note that FullName returns &quot;The fully qualified name of the type, including its namespace but not its
            // assembly; or null if the current instance represents a generic type parameter, an array type, pointer
            // type, or byref type based on a type parameter, or a generic type that is not a generic type definition
            // but contains unresolved type parameters.&quot;

            var t = Type.GetType(&quot;System.Collections.Generic.IList`1&quot;);
            Assert.IsNotNull(t);
            Assert.IsTrue(t.IsGenericTypeDefinition);
            Assert.AreEqual(&quot;IList`1&quot;, t.Name);
            Assert.AreEqual(&quot;System.Collections.Generic.IList`1&quot;, t.FullName);
            Assert.AreEqual(&quot;System.Collections.Generic.IList`1[T]&quot;, t.ToString());

            t = typeof (IList&lt;&gt;);
            Assert.IsTrue(t.IsGenericTypeDefinition);
            Assert.AreEqual(&quot;IList`1&quot;, t.Name);
            Assert.AreEqual(&quot;System.Collections.Generic.IList`1&quot;, t.FullName);
            Assert.AreEqual(&quot;System.Collections.Generic.IList`1[T]&quot;, t.ToString());

            t = typeof(IDictionary&lt;,&gt;);
            Assert.IsTrue(t.IsGenericTypeDefinition);
            Assert.AreEqual(&quot;IDictionary`2&quot;, t.Name);
            Assert.AreEqual(&quot;System.Collections.Generic.IDictionary`2&quot;, t.FullName);
            Assert.AreEqual(&quot;System.Collections.Generic.IDictionary`2[TKey,TValue]&quot;, t.ToString());

            t = typeof(IDictionary&lt;,&gt;);
            t = t.MakeGenericType(t.GetGenericArguments()[0], t.GetGenericArguments()[1]); 
            Assert.AreEqual(&quot;IDictionary`2&quot;, t.Name);
            Assert.AreEqual(&quot;System.Collections.Generic.IDictionary`2&quot;, t.FullName);
            Assert.AreEqual(&quot;System.Collections.Generic.IDictionary`2[TKey,TValue]&quot;, t.ToString());

            t = typeof(IDictionary&lt;,&gt;);
            t = t.MakeGenericType(t.GetGenericArguments()[0], t.GetGenericArguments()[0]);
            Assert.IsFalse(t.IsGenericTypeDefinition); // not anymore
            Assert.AreEqual(&quot;IDictionary`2&quot;, t.Name);
            Assert.IsNull(t.FullName); // see note above
            Assert.AreEqual(&quot;System.Collections.Generic.IDictionary`2[TKey,TKey]&quot;, t.ToString());

            t = typeof(IList&lt;&gt;);
            Assert.IsTrue(t.IsGenericTypeDefinition);
            t = t.MakeGenericType(t.GetGenericArguments()[0]);
            Assert.AreEqual(&quot;IList`1&quot;, t.Name);
            Assert.AreEqual(&quot;System.Collections.Generic.IList`1&quot;, t.FullName);
            Assert.AreEqual(&quot;System.Collections.Generic.IList`1[T]&quot;, t.ToString());

            t = typeof(IList&lt;int&gt;);
            Assert.AreEqual(&quot;System.Collections.Generic.IList`1[System.Int32]&quot;, t.ToString());

            t = typeof (IDictionary&lt;,&gt;);
            t = t.MakeGenericType(typeof(int), t.GetGenericArguments()[1]);
            Assert.IsFalse(t.IsGenericTypeDefinition); // not anymore
            Assert.AreEqual(&quot;IDictionary`2&quot;, t.Name);
            Assert.IsNull(t.FullName); // see note above
            Assert.AreEqual(&quot;System.Collections.Generic.IDictionary`2[System.Int32,TValue]&quot;, t.ToString());
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[45,9,45,10,1],[46,13,46,73,1],[47,13,47,79,1],[48,9,48,10,1],[52,9,52,10,1],[53,13,55,72,1],[56,13,56,40,1],[58,13,61,71,1],[62,13,62,39,1],[63,13,63,59,1],[65,13,69,80,1],[70,13,70,39,1],[71,13,71,68,1],[73,13,78,65,1],[79,13,79,40,1],[81,13,81,77,1],[82,13,82,39,1],[83,13,83,66,1],[85,13,87,87,1],[88,13,88,39,1],[89,13,89,74,1],[91,9,91,10,1],[95,9,95,10,1],[96,13,96,59,1],[97,13,97,85,1],[98,13,98,48,1],[100,13,100,55,1],[101,13,101,89,1],[102,13,102,48,1],[104,13,104,55,1],[105,13,105,118,1],[106,13,106,48,1],[108,13,108,38,1],[109,13,109,50,1],[110,13,110,41,1],[111,13,111,25,1],[113,13,113,55,1],[114,13,114,76,1],[115,13,115,48,1],[116,13,116,57,1],[118,13,118,55,1],[119,13,119,83,1],[120,13,120,48,1],[121,13,121,57,1],[123,13,123,55,1],[124,13,124,98,1],[125,13,125,48,1],[127,13,127,55,1],[128,13,128,82,1],[129,13,129,48,1],[130,13,130,57,1],[132,13,132,55,1],[133,13,133,116,1],[134,13,134,48,1],[135,13,135,60,1],[136,13,136,65,1],[138,13,138,41,1],[139,13,139,46,1],[140,13,140,45,1],[142,13,142,55,1],[143,13,143,97,1],[145,13,145,55,1],[146,13,146,93,1],[147,13,147,48,1],[148,13,148,60,1],[149,9,149,10,1],[153,9,153,10,1],[155,13,155,91,1],[157,13,157,46,1],[158,13,158,50,1],[159,13,159,45,1],[163,13,163,83,1],[165,13,165,87,1],[168,13,168,87,1],[169,13,169,91,1],[170,13,170,90,1],[171,13,171,88,1],[172,13,172,89,1],[173,13,173,89,1],[174,13,174,83,1],[177,13,177,87,1],[178,13,178,88,1],[179,13,179,95,1],[180,13,180,90,1],[181,13,181,94,1],[182,13,182,83,1],[188,13,189,30,1],[189,30,189,81,1],[189,81,192,32,1],[188,13,192,32,1],[194,13,194,107,1],[196,9,196,10,1],[201,9,201,10,1],[211,13,211,72,1],[212,13,212,33,1],[213,13,213,54,1],[214,13,214,48,1],[215,13,215,79,1],[216,13,216,84,1],[218,13,218,34,1],[219,13,219,54,1],[220,13,220,48,1],[221,13,221,79,1],[222,13,222,84,1],[224,13,224,40,1],[225,13,225,54,1],[226,13,226,54,1],[227,13,227,85,1],[228,13,228,100,1],[230,13,230,40,1],[231,13,231,91,1],[232,13,232,54,1],[233,13,233,85,1],[234,13,234,100,1],[236,13,236,40,1],[237,13,237,91,1],[238,13,238,55,1],[239,13,239,54,1],[240,13,240,39,1],[241,13,241,98,1],[243,13,243,33,1],[244,13,244,54,1],[245,13,245,63,1],[246,13,246,48,1],[247,13,247,79,1],[248,13,248,84,1],[250,13,250,36,1],[251,13,251,95,1],[253,13,253,41,1],[254,13,254,76,1],[255,13,255,55,1],[256,13,256,54,1],[257,13,257,39,1],[258,13,258,108,1],[259,9,259,10,1]]);
    </script>
  </body>
</html>