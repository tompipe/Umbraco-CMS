<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\umbraco.presentation\content.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using umbraco.BusinessLogic;
using umbraco.cms.businesslogic;
using umbraco.cms.businesslogic.web;
using umbraco.DataLayer;
using umbraco.presentation.nodeFactory;
using Umbraco.Core;
using Umbraco.Core.Cache;
using Umbraco.Core.Configuration;
using Umbraco.Core.IO;
using Umbraco.Core.Logging;
using Umbraco.Core.Models;
using Umbraco.Core.Profiling;
using Umbraco.Web;
using Umbraco.Web.PublishedCache.XmlPublishedCache;
using Umbraco.Web.Scheduling;
using File = System.IO.File;
using Node = umbraco.NodeFactory.Node;
using Task = System.Threading.Tasks.Task;

namespace umbraco
{
    /// &lt;summary&gt;
    /// Represents the Xml storage for the Xml published cache.
    /// &lt;/summary&gt;
    public class content
    {
        private XmlCacheFilePersister _persisterTask;

        private volatile bool _released;

        #region Constructors

        private content()
        {
            if (SyncToXmlFile)
            {
                var logger = LoggerResolver.HasCurrent ? LoggerResolver.Current.Logger : new DebugDiagnosticsLogger();
                var profingLogger = new ProfilingLogger(
                    logger,
                    ProfilerResolver.HasCurrent ? ProfilerResolver.Current.Profiler : new LogProfiler(logger));

                // prepare the persister task
                // there&#39;s always be one task keeping a ref to the runner
                // so it&#39;s safe to just create it as a local var here
                var runner = new BackgroundTaskRunner&lt;XmlCacheFilePersister&gt;(&quot;XmlCacheFilePersister&quot;, new BackgroundTaskRunnerOptions
                {
                    LongRunning = true,
                    KeepAlive = true,
                    Hosted = false // main domain will take care of stopping the runner (see below)
                }, logger);

                // create (and add to runner)
                _persisterTask = new XmlCacheFilePersister(runner, this, profingLogger);

                var registered = ApplicationContext.Current.MainDom.Register(
                    null,
                    () =&gt;
                    {
                        // once released, the cache still works but does not write to file anymore,
                        // which is OK with database server messenger but will cause data loss with
                        // another messenger...

                        runner.Shutdown(false, true); // wait until flushed
                        _released = true;
                    });

                // failed to become the main domain, we will never use the file
                if (registered == false)
                    runner.Shutdown(false, true);

                _released = (registered == false);
            }

            // initialize content - populate the cache
            using (var safeXml = GetSafeXmlWriter(false))
            {
                bool registerXmlChange;

                // if we don&#39;t use the file then LoadXmlLocked will not even
                // read from the file and will go straight to database
                LoadXmlLocked(safeXml, out registerXmlChange);
                // if we use the file and registerXmlChange is true this will
                // write to file, else it will not
                safeXml.Commit(registerXmlChange);
            }
        }

        #endregion

        #region Singleton

        private static readonly Lazy&lt;content&gt; LazyInstance = new Lazy&lt;content&gt;(() =&gt; new content());

        public static content Instance
        {
            get
            {
                return LazyInstance.Value;
            }
        }

        #endregion

        #region Legacy &amp; Stuff

        // sync database access
        // (not refactoring that part at the moment)
        private static readonly object DbReadSyncLock = new object();

        private const string XmlContextContentItemKey = &quot;UmbracoXmlContextContent&quot;;
        private const string XmlContextClonedContentItemKey = &quot;UmbracoXmlContextContent.cloned&quot;;
        private static string _umbracoXmlDiskCacheFileName = string.Empty;
        private volatile XmlDocument _xmlContent;

        /// &lt;summary&gt;
        /// Gets the path of the umbraco XML disk cache file.
        /// &lt;/summary&gt;
        /// &lt;value&gt;The name of the umbraco XML disk cache file.&lt;/value&gt;
        public static string GetUmbracoXmlDiskFileName()
        {
            if (string.IsNullOrEmpty(_umbracoXmlDiskCacheFileName))
            {
                _umbracoXmlDiskCacheFileName = IOHelper.MapPath(SystemFiles.ContentCacheXml);
            }
            return _umbracoXmlDiskCacheFileName;
        }

        [Obsolete(&quot;Use the safer static GetUmbracoXmlDiskFileName() method instead to retrieve this value&quot;)]
        public string UmbracoXmlDiskCacheFileName
        {
            get { return GetUmbracoXmlDiskFileName(); }
            set { _umbracoXmlDiskCacheFileName = value; }
        }

        //NOTE: We CANNOT use this for a double check lock because it is a property, not a field and to do double
        // check locking in c# you MUST have a volatile field. Even thoug this wraps a volatile field it will still
        // not work as expected for a double check lock because properties are treated differently in the clr.
        public virtual bool isInitializing
        {
            get { return _xmlContent == null; }
        }

        /// &lt;summary&gt;
        /// Unused, please do not use
        /// &lt;/summary&gt;
        [Obsolete(&quot;Obsolete, For querying the database use the new UmbracoDatabase object ApplicationContext.Current.DatabaseContext.Database&quot;, false)]
        protected static ISqlHelper SqlHelper
        {
            get { return Application.SqlHelper; }
        }

        #endregion

        #region Public Methods

        [Obsolete(&quot;This is no longer used and will be removed in future versions, if you use this method it will not refresh &#39;async&#39; it will perform the refresh on the current thread which is how it should be doing it&quot;)]
        public virtual void RefreshContentFromDatabaseAsync()
        {
            RefreshContentFromDatabase();
        }

        /// &lt;summary&gt;
        /// Load content from database and replaces active content when done.
        /// &lt;/summary&gt;
        public virtual void RefreshContentFromDatabase()
        {
            var e = new RefreshContentEventArgs();
            FireBeforeRefreshContent(e);

            if (!e.Cancel)
            {
                using (var safeXml = GetSafeXmlWriter())
                {
                    safeXml.Xml = LoadContentFromDatabase();
                }
            }
        }

        /// &lt;summary&gt;
        /// Used by all overloaded publish methods to do the actual &quot;noderepresentation to xml&quot;
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;d&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;xmlContentCopy&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;updateSitemapProvider&quot;&gt;&lt;/param&gt;
        public static XmlDocument PublishNodeDo(Document d, XmlDocument xmlContentCopy, bool updateSitemapProvider)
        {
            // check if document *is* published, it could be unpublished by an event
            if (d.Published)
            {
                var parentId = d.Level == 1 ? -1 : d.ParentId;

                // fix sortOrder - see note in UpdateSortOrder
                var node = GetPreviewOrPublishedNode(d, xmlContentCopy, false);
                var attr = ((XmlElement)node).GetAttributeNode(&quot;sortOrder&quot;);
                attr.Value = d.sortOrder.ToString();
                xmlContentCopy = GetAddOrUpdateXmlNode(xmlContentCopy, d.Id, d.Level, parentId, node);

                // update sitemapprovider
                if (updateSitemapProvider &amp;&amp; SiteMap.Provider is UmbracoSiteMapProvider)
                {
                    try
                    {
                        var prov = (UmbracoSiteMapProvider)SiteMap.Provider;
                        var n = new Node(d.Id, true);
                        if (string.IsNullOrEmpty(n.Url) == false &amp;&amp; n.Url != &quot;/#&quot;)
                        {
                            prov.UpdateNode(n);
                        }
                        else
                        {
                            LogHelper.Debug&lt;content&gt;(string.Format(&quot;Can&#39;t update Sitemap Provider due to empty Url in node id: {0}&quot;, d.Id));
                        }
                    }
                    catch (Exception ee)
                    {
                        LogHelper.Error&lt;content&gt;(string.Format(&quot;Error adding node to Sitemap Provider in PublishNodeDo(): {0}&quot;, d.Id), ee);
                    }
                }
            }

            return xmlContentCopy;
        }

        private static XmlNode GetPreviewOrPublishedNode(Document d, XmlDocument xmlContentCopy, bool isPreview)
        {
            if (isPreview)
            {
                return d.ToPreviewXml(xmlContentCopy);
            }
            else
            {
                return d.ToXml(xmlContentCopy, false);
            }
        }

        /// &lt;summary&gt;
        /// Sorts the documents.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;parentId&quot;&gt;The parent node identifier.&lt;/param&gt;
        public void SortNodes(int parentId)
        {
            using (var safeXml = GetSafeXmlWriter(false))
            {
                var parentNode = parentId == -1
                    ? safeXml.Xml.DocumentElement
                    : safeXml.Xml.GetElementById(parentId.ToString(CultureInfo.InvariantCulture));

                if (parentNode == null) return;

                var sorted = XmlHelper.SortNodesIfNeeded(
                    parentNode,
                    ChildNodesXPath,
                    x =&gt; x.AttributeValue&lt;int&gt;(&quot;sortOrder&quot;));

                if (sorted == false) return;

                safeXml.Commit();
            }
        }

        /// &lt;summary&gt;
        /// Updates the document cache.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pageId&quot;&gt;The page id.&lt;/param&gt;
        public virtual void UpdateDocumentCache(int pageId)
        {
            var d = new Document(pageId);
            UpdateDocumentCache(d);
        }

        /// &lt;summary&gt;
        /// Updates the document cache.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;d&quot;&gt;The d.&lt;/param&gt;
        public virtual void UpdateDocumentCache(Document d)
        {
            var e = new DocumentCacheEventArgs();
            FireBeforeUpdateDocumentCache(d, e);

            if (!e.Cancel)
            {
                // lock the xml cache so no other thread can write to it at the same time
                // note that some threads could read from it while we hold the lock, though
                using (var safeXml = GetSafeXmlWriter())
                {
                    safeXml.Xml = PublishNodeDo(d, safeXml.Xml, true);
                }

                ClearContextCache();

                var cachedFieldKeyStart = string.Format(&quot;{0}{1}_&quot;, CacheKeys.ContentItemCacheKey, d.Id);
                ApplicationContext.Current.ApplicationCache.RuntimeCache.ClearCacheByKeySearch(cachedFieldKeyStart);

                FireAfterUpdateDocumentCache(d, e);
            }
        }

        internal virtual void UpdateSortOrder(int contentId)
        {
            var content = ApplicationContext.Current.Services.ContentService.GetById(contentId);
            if (content == null) return;
            UpdateSortOrder(content);
        }

        internal virtual void UpdateSortOrder(IContent c)
        {
            if (c == null) throw new ArgumentNullException(&quot;c&quot;);

            // the XML in database is updated only when content is published, and then
            // it contains the sortOrder value at the time the XML was generated. when
            // a document with unpublished changes is sorted, then it is simply saved
            // (see ContentService) and so the sortOrder has changed but the XML has
            // not been updated accordingly.

            // this updates the published cache to take care of the situation
            // without ContentService having to ... what exactly?

            // no need to do it if
            // - the content is published without unpublished changes (XML will be re-gen anyways)
            // - the content has no published version (not in XML)
            // - the sort order has not changed
            // note that
            // - if it is a new entity is has not published version
            // - if Published is dirty and false it&#39;s getting unpublished and has no published version
            //
            if (c.Published) return;
            if (c.HasPublishedVersion == false) return;
            if (c.WasPropertyDirty(&quot;SortOrder&quot;) == false) return;

            using (var safeXml = GetSafeXmlWriter(false))
            {
                //TODO: This can be null: safeXml.Xml!!!!


                var node = safeXml.Xml.GetElementById(c.Id.ToString(CultureInfo.InvariantCulture));
                if (node == null) return;
                var attr = node.GetAttributeNode(&quot;sortOrder&quot;);
                if (attr == null) return;
                var sortOrder = c.SortOrder.ToString(CultureInfo.InvariantCulture);
                if (attr.Value == sortOrder) return;

                // only if node was actually modified
                attr.Value = sortOrder;

                safeXml.Commit();
            }
        }

        /// &lt;summary&gt;
        /// Updates the document cache for multiple documents
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Documents&quot;&gt;The documents.&lt;/param&gt;
        [Obsolete(&quot;This is not used and will be removed from the codebase in future versions&quot;)]
        public virtual void UpdateDocumentCache(List&lt;Document&gt; Documents)
        {
            // We need to lock content cache here, because we cannot allow other threads
            // making changes at the same time, they need to be queued
            int parentid = Documents[0].Id;


            using (var safeXml = GetSafeXmlWriter())
            {
                foreach (Document d in Documents)
                {
                    safeXml.Xml = PublishNodeDo(d, safeXml.Xml, true);
                }
            }

            ClearContextCache();
        }

        [Obsolete(&quot;Method obsolete in version 4.1 and later, please use UpdateDocumentCache&quot;, true)]
        public virtual void UpdateDocumentCacheAsync(int documentId)
        {
            UpdateDocumentCache(documentId);
        }

        [Obsolete(&quot;Method obsolete in version 4.1 and later, please use ClearDocumentCache&quot;, true)]
        public virtual void ClearDocumentCacheAsync(int documentId)
        {
            ClearDocumentCache(documentId);
        }

        public virtual void ClearDocumentCache(int documentId)
        {
            ClearDocumentCache(documentId, true);
        }

        internal virtual void ClearDocumentCache(int documentId, bool removeDbXmlEntry)
        {
            // Get the document
            Document d;
            try
            {
                d = new Document(documentId);
            }
            catch
            {
                // if we need the document to remove it... this cannot be LB?!
                // shortcut everything here
                ClearDocumentXmlCache(documentId);
                return;
            }
            ClearDocumentCache(d, removeDbXmlEntry);
        }

        /// &lt;summary&gt;
        /// Clears the document cache and removes the document from the xml db cache.
        /// This means the node gets unpublished from the website.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;doc&quot;&gt;The document&lt;/param&gt;
        /// &lt;param name=&quot;removeDbXmlEntry&quot;&gt;&lt;/param&gt;
        internal void ClearDocumentCache(Document doc, bool removeDbXmlEntry)
        {
            var e = new DocumentCacheEventArgs();
            FireBeforeClearDocumentCache(doc, e);

            if (!e.Cancel)
            {
                XmlNode x;

                //Hack: this is here purely for backwards compat if someone for some reason is using the
                // ClearDocumentCache(int documentId) method and expecting it to remove the xml
                if (removeDbXmlEntry)
                {
                    // remove from xml db cache
                    doc.XmlRemoveFromDB();
                }

                // clear xml cache
                ClearDocumentXmlCache(doc.Id);

                ClearContextCache();

                //SD: changed to fire event BEFORE running the sitemap!! argh.
                FireAfterClearDocumentCache(doc, e);

                // update sitemapprovider
                if (SiteMap.Provider is UmbracoSiteMapProvider)
                {
                    var prov = (UmbracoSiteMapProvider)SiteMap.Provider;
                    prov.RemoveNode(doc.Id);
                }
            }
        }

        internal void ClearDocumentXmlCache(int id)
        {
            // We need to lock content cache here, because we cannot allow other threads
            // making changes at the same time, they need to be queued
            using (var safeXml = GetSafeXmlReader())
            {
                // Check if node present, before cloning
                var x = safeXml.Xml.GetElementById(id.ToString());
                if (x == null)
                    return;

                safeXml.UpgradeToWriter(false);

                // Find the document in the xml cache
                x = safeXml.Xml.GetElementById(id.ToString());
                if (x != null)
                {
                    // The document already exists in cache, so repopulate it
                    x.ParentNode.RemoveChild(x);
                    safeXml.Commit();
                }
            }
        }

        /// &lt;summary&gt;
        /// Unpublishes the  node.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;documentId&quot;&gt;The document id.&lt;/param&gt;
        [Obsolete(&quot;Please use: umbraco.content.ClearDocumentCache&quot;, true)]
        public virtual void UnPublishNode(int documentId)
        {
            ClearDocumentCache(documentId);
        }

        #endregion

        #region Protected &amp; Private methods

        /// &lt;summary&gt;
        /// Clear HTTPContext cache if any
        /// &lt;/summary&gt;
        private void ClearContextCache()
        {
            // If running in a context very important to reset context cache orelse new nodes are missing
            if (UmbracoContext.Current != null &amp;&amp; UmbracoContext.Current.HttpContext != null &amp;&amp; UmbracoContext.Current.HttpContext.Items.Contains(XmlContextContentItemKey))
                UmbracoContext.Current.HttpContext.Items.Remove(XmlContextContentItemKey);
        }

        /// &lt;summary&gt;
        /// Load content from database
        /// &lt;/summary&gt;
        private XmlDocument LoadContentFromDatabase()
        {
            try
            {
                LogHelper.Info&lt;content&gt;(&quot;Loading content from database...&quot;);

                lock (DbReadSyncLock)
                {
                    var xmlDoc = ApplicationContext.Current.Services.ContentService.BuildXmlCache();
                    LogHelper.Debug&lt;content&gt;(&quot;Done republishing Xml Index&quot;);
                    return xmlDoc;
                }
            }
            catch (Exception ee)
            {
                LogHelper.Error&lt;content&gt;(&quot;Error Republishing&quot;, ee);
            }

            // An error of some sort must have stopped us from successfully generating
            // the content tree, so lets return null signifying there is no content available
            return null;
        }

        [Obsolete(&quot;This method should not be used and does nothing, xml file persistence is done in a queue using a BackgroundTaskRunner&quot;)]
        public void PersistXmlToFile()
        {
        }

        internal DateTime GetCacheFileUpdateTime()
        {
            //TODO: Should there be a try/catch here in case the file is being written to while this is trying to be executed?

            if (File.Exists(GetUmbracoXmlDiskFileName()))
            {
                return new FileInfo(GetUmbracoXmlDiskFileName()).LastWriteTimeUtc;
            }

            return DateTime.MinValue;
        }

        #endregion

        #region Configuration

        // gathering configuration options here to document what they mean

        private readonly bool _xmlFileEnabled = true;

        // whether the disk cache is enabled
        private bool XmlFileEnabled
        {
            get { return _xmlFileEnabled &amp;&amp; UmbracoConfig.For.UmbracoSettings().Content.XmlCacheEnabled; }
        }

        // whether the disk cache is enabled and to update the disk cache when xml changes
        private bool SyncToXmlFile
        {
            get { return XmlFileEnabled &amp;&amp; UmbracoConfig.For.UmbracoSettings().Content.ContinouslyUpdateXmlDiskCache; }
        }

        // whether the disk cache is enabled and to reload from disk cache if it changes
        private bool SyncFromXmlFile
        {
            get { return XmlFileEnabled &amp;&amp; UmbracoConfig.For.UmbracoSettings().Content.XmlContentCheckForDiskChanges; }
        }

        // whether _xml is immutable or not (achieved by cloning before changing anything)
        private static bool XmlIsImmutable
        {
            get { return UmbracoConfig.For.UmbracoSettings().Content.CloneXmlContent; }
        }

        // whether to use the legacy schema
        private static bool UseLegacySchema
        {
            get { return UmbracoConfig.For.UmbracoSettings().Content.UseLegacyXmlSchema; }
        }

        #endregion

        #region Xml

        private readonly AsyncLock _xmlLock = new AsyncLock(); // protects _xml

        /// &lt;remarks&gt;
        /// Get content. First call to this property will initialize xmldoc
        /// subsequent calls will be blocked until initialization is done
        /// Further we cache (in context) xmlContent for each request to ensure that
        /// we always have the same XmlDoc throughout the whole request.
        /// &lt;/remarks&gt;
        public virtual XmlDocument XmlContent
        {
            get
            {
                if (UmbracoContext.Current == null || UmbracoContext.Current.HttpContext == null)
                    return XmlContentInternal;
                var content = UmbracoContext.Current.HttpContext.Items[XmlContextContentItemKey] as XmlDocument;
                if (content == null)
                {
                    content = XmlContentInternal;
                    UmbracoContext.Current.HttpContext.Items[XmlContextContentItemKey] = content;
                }
                return content;
            }
        }

        [Obsolete(&quot;Please use: content.Instance.XmlContent&quot;)]
        public static XmlDocument xmlContent
        {
            get { return Instance.XmlContent; }
        }

        // to be used by content.Instance
        protected internal virtual XmlDocument XmlContentInternal
        {
            get
            {
                ReloadXmlFromFileIfChanged();
                return _xmlContent;
            }
        }

        // assumes xml lock
        private void SetXmlLocked(XmlDocument xml, bool registerXmlChange)
        {
            // this is the ONLY place where we write to _xmlContent
            _xmlContent = xml;

            if (registerXmlChange == false || SyncToXmlFile == false)
                return;

            //_lastXmlChange = DateTime.UtcNow;
            _persisterTask = _persisterTask.Touch(); // _persisterTask != null because SyncToXmlFile == true
        }

        private static XmlDocument Clone(XmlDocument xmlDoc)
        {
            return xmlDoc == null ? null : (XmlDocument)xmlDoc.CloneNode(true);
        }

        private static XmlDocument EnsureSchema(string contentTypeAlias, XmlDocument xml)
        {
            string subset = null;

            // get current doctype
            var n = xml.FirstChild;
            while (n.NodeType != XmlNodeType.DocumentType &amp;&amp; n.NextSibling != null)
                n = n.NextSibling;
            if (n.NodeType == XmlNodeType.DocumentType)
                subset = ((XmlDocumentType)n).InternalSubset;

            // ensure it contains the content type
            if (subset != null &amp;&amp; subset.Contains(string.Format(&quot;&lt;!ATTLIST {0} id ID #REQUIRED&gt;&quot;, contentTypeAlias)))
                return xml;

            // alas, that does not work, replacing a doctype is ignored and GetElementById fails
            //
            //// remove current doctype, set new doctype
            //xml.RemoveChild(n);
            //subset = string.Format(&quot;&lt;!ELEMENT {1} ANY&gt;{0}&lt;!ATTLIST {1} id ID #REQUIRED&gt;{0}{2}&quot;, Environment.NewLine, contentTypeAlias, subset);
            //var doctype = xml.CreateDocumentType(&quot;root&quot;, null, null, subset);
            //xml.InsertAfter(doctype, xml.FirstChild);

            var xml2 = new XmlDocument();
            subset = string.Format(&quot;&lt;!ELEMENT {1} ANY&gt;{0}&lt;!ATTLIST {1} id ID #REQUIRED&gt;{0}{2}&quot;, Environment.NewLine, contentTypeAlias, subset);
            var doctype = xml2.CreateDocumentType(&quot;root&quot;, null, null, subset);
            xml2.AppendChild(doctype);
            xml2.AppendChild(xml2.ImportNode(xml.DocumentElement, true));
            return xml2;
        }

        // try to load from file, otherwise database
        // assumes xml lock (file is always locked)
        private void LoadXmlLocked(SafeXmlReaderWriter safeXml, out bool registerXmlChange)
        {
            LogHelper.Debug&lt;content&gt;(&quot;Loading Xml...&quot;);

            // try to get it from the file
            if (XmlFileEnabled &amp;&amp; (safeXml.Xml = LoadXmlFromFile()) != null)
            {
                registerXmlChange = false; // loaded from disk, do NOT write back to disk!
                return;
            }

            // get it from the database, and register
            safeXml.Xml = LoadContentFromDatabase();
            registerXmlChange = true;
        }

        // NOTE
        // - this is NOT a reader/writer lock and each lock is exclusive
        // - these locks are NOT reentrant / recursive

        // gets a locked safe read access to the main xml
        private SafeXmlReaderWriter GetSafeXmlReader()
        {
            var releaser = _xmlLock.Lock();
            return SafeXmlReaderWriter.GetReader(this, releaser);
        }

        // gets a locked safe write access to the main xml (cloned)
        private SafeXmlReaderWriter GetSafeXmlWriter(bool auto = true)
        {
            var releaser = _xmlLock.Lock();
            return SafeXmlReaderWriter.GetWriter(this, releaser, auto);
        }

        private class SafeXmlReaderWriter : IDisposable
        {
            private readonly content _instance;
            private IDisposable _releaser;
            private bool _isWriter;
            private bool _auto;
            private bool _committed;
            private XmlDocument _xml;

            private SafeXmlReaderWriter(content instance, IDisposable releaser, bool isWriter, bool auto)
            {
                _instance = instance;
                _releaser = releaser;
                _isWriter = isWriter;
                _auto = auto;

                // cloning for writer is not an option anymore (see XmlIsImmutable)
                _xml = _isWriter ? Clone(instance._xmlContent) : instance._xmlContent;
            }

            public static SafeXmlReaderWriter GetReader(content instance, IDisposable releaser)
            {
                return new SafeXmlReaderWriter(instance, releaser, false, false);
            }

            public static SafeXmlReaderWriter GetWriter(content instance, IDisposable releaser, bool auto)
            {
                return new SafeXmlReaderWriter(instance, releaser, true, auto);
            }

            public void UpgradeToWriter(bool auto)
            {
                if (_isWriter)
                    throw new InvalidOperationException(&quot;Already writing.&quot;);
                _isWriter = true;
                _auto = auto;
                _xml = Clone(_xml); // cloning for writer is not an option anymore (see XmlIsImmutable)
            }

            public XmlDocument Xml
            {
                get
                {
                    return _xml;
                }
                set
                {
                    if (_isWriter == false)
                        throw new InvalidOperationException(&quot;Not writing.&quot;);
                    _xml = value;
                }
            }

            // registerXmlChange indicates whether to do what should be done when Xml changes,
            // that is, to request that the file be written to disk - something we don&#39;t want
            // to do if we&#39;re committing Xml precisely after we&#39;ve read from disk!
            public void Commit(bool registerXmlChange = true)
            {
                if (_isWriter == false)
                    throw new InvalidOperationException(&quot;Not writing.&quot;);
                _instance.SetXmlLocked(Xml, registerXmlChange);
                _committed = true;
            }

            public void Dispose()
            {
                if (_releaser == null)
                    return;
                if (_isWriter &amp;&amp; _auto &amp;&amp; _committed == false)
                    Commit();
                _releaser.Dispose();
                _releaser = null;
            }

        }

        private static string ChildNodesXPath
        {
            get
            {
                return UmbracoConfig.For.UmbracoSettings().Content.UseLegacyXmlSchema
                    ? &quot;./node&quot;
                    : &quot;./* [@id]&quot;;
            }
        }

        private static string DataNodesXPath
        {
            get
            {
                return UmbracoConfig.For.UmbracoSettings().Content.UseLegacyXmlSchema
                    ? &quot;./data&quot;
                    : &quot;./* [not(@id)]&quot;;
            }
        }

        #endregion

        #region File

        private readonly string _xmlFileName = IOHelper.MapPath(SystemFiles.ContentCacheXml);
        private DateTime _lastFileRead; // last time the file was read
        private DateTime _nextFileCheck; // last time we checked whether the file was changed

        // not used - just try to read the file
        //private bool XmlFileExists
        //{
        //    get
        //    {
        //        // check that the file exists and has content (is not empty)
        //        var fileInfo = new FileInfo(_xmlFileName);
        //        return fileInfo.Exists &amp;&amp; fileInfo.Length &gt; 0;
        //    }
        //}

        private DateTime XmlFileLastWriteTime
        {
            get
            {
                var fileInfo = new FileInfo(_xmlFileName);
                return fileInfo.Exists ? fileInfo.LastWriteTimeUtc : DateTime.MinValue;
            }
        }

        // invoked by XmlCacheFilePersister ONLY and that one manages the MainDom, ie it
        // will NOT try to save once the current app domain is not the main domain anymore
        // (no need to test _released)
        internal void SaveXmlToFile()
        {
            LogHelper.Info&lt;content&gt;(&quot;Save Xml to file...&quot;);
            try
            {
                var xml = _xmlContent; // capture (atomic + volatile), immutable anyway
                if (xml == null) return;

                // delete existing file, if any
                DeleteXmlFile();

                // ensure cache directory exists
                var directoryName = Path.GetDirectoryName(_xmlFileName);
                if (directoryName == null)
                    throw new Exception(string.Format(&quot;Invalid XmlFileName \&quot;{0}\&quot;.&quot;, _xmlFileName));
                if (File.Exists(_xmlFileName) == false &amp;&amp; Directory.Exists(directoryName) == false)
                    Directory.CreateDirectory(directoryName);

                // save
                using (var fs = new FileStream(_xmlFileName, FileMode.Create, FileAccess.Write, FileShare.Read))
                {
                    SaveXmlToStream(xml, fs);
                }

                LogHelper.Info&lt;content&gt;(&quot;Saved Xml to file.&quot;);
            }
            catch (Exception e)
            {
                // if something goes wrong remove the file
                try
                {
                    DeleteXmlFile();
                }
                catch
                {
                    // don&#39;t make it worse: could be that we failed to write because we cannot
                    // access the file, in which case we won&#39;t be able to delete it either
                }
                LogHelper.Error&lt;content&gt;(&quot;Failed to save Xml to file.&quot;, e);
            }
        }

        private void SaveXmlToStream(XmlDocument xml, Stream writeStream)
        {
            // using that one method because we want to have proper indent
            // and in addition, writing async is never fully async because
            // althouth the writer is async, xml.WriteTo() will not async

            // that one almost works but... &quot;The elements are indented as long as the element
            // does not contain mixed content. Once the WriteString or WriteWhitespace method
            // is called to write out a mixed element content, the XmlWriter stops indenting.
            // The indenting resumes once the mixed content element is closed.&quot; - says MSDN
            // about XmlWriterSettings.Indent

            // so ImportContent must also make sure of ignoring whitespaces!

            if (writeStream.CanSeek)
            {
                writeStream.Position = 0;
            }

            using (var xmlWriter = XmlWriter.Create(writeStream, new XmlWriterSettings
            {
                Indent = true,
                Encoding = Encoding.UTF8,
                //OmitXmlDeclaration = true
            }))
            {
                //xmlWriter.WriteProcessingInstruction(&quot;xml&quot;, &quot;version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;&quot;);
                xml.WriteTo(xmlWriter); // already contains the xml declaration
            }
        }

        private XmlDocument LoadXmlFromFile()
        {
            // do NOT try to load if we are not the main domain anymore
            if (_released) return null;

            LogHelper.Info&lt;content&gt;(&quot;Load Xml from file...&quot;);

            try
            {
                var xml = new XmlDocument();
                using (var fs = new FileStream(_xmlFileName, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    xml.Load(fs);
                }
                _lastFileRead = DateTime.UtcNow;
                LogHelper.Info&lt;content&gt;(&quot;Loaded Xml from file.&quot;);
                return xml;
            }
            catch (FileNotFoundException)
            {
                LogHelper.Warn&lt;content&gt;(&quot;Failed to load Xml, file does not exist.&quot;);
                return null;
            }
            catch (Exception e)
            {
                LogHelper.Error&lt;content&gt;(&quot;Failed to load Xml from file.&quot;, e);
                try
                {
                    DeleteXmlFile();
                }
                catch
                {
                    // don&#39;t make it worse: could be that we failed to read because we cannot
                    // access the file, in which case we won&#39;t be able to delete it either
                }
                return null;
            }
        }

        private void DeleteXmlFile()
        {
            if (File.Exists(_xmlFileName) == false) return;
            File.SetAttributes(_xmlFileName, FileAttributes.Normal);
            File.Delete(_xmlFileName);
        }

        private void ReloadXmlFromFileIfChanged()
        {
            if (SyncFromXmlFile == false) return;

            var now = DateTime.UtcNow;
            if (now &lt; _nextFileCheck) return;

            // time to check
            _nextFileCheck = now.AddSeconds(1); // check every 1s
            if (XmlFileLastWriteTime &lt;= _lastFileRead) return;

            LogHelper.Debug&lt;content&gt;(&quot;Xml file change detected, reloading.&quot;);

            // time to read

            using (var safeXml = GetSafeXmlWriter(false))
            {
                bool registerXmlChange;
                LoadXmlLocked(safeXml, out registerXmlChange); // updates _lastFileRead
                safeXml.Commit(registerXmlChange);
            }
        }

        #endregion

        #region Manage change

        //TODO remove as soon as we can break backward compatibility
        [Obsolete(&quot;Use GetAddOrUpdateXmlNode which returns an updated Xml document.&quot;, false)]
        public static void AddOrUpdateXmlNode(XmlDocument xml, int id, int level, int parentId, XmlNode docNode)
        {
            GetAddOrUpdateXmlNode(xml, id, level, parentId, docNode);
        }

        // adds or updates a node (docNode) into a cache (xml)
        public static XmlDocument GetAddOrUpdateXmlNode(XmlDocument xml, int id, int level, int parentId, XmlNode docNode)
        {
            // sanity checks
            if (id != docNode.AttributeValue&lt;int&gt;(&quot;id&quot;))
                throw new ArgumentException(&quot;Values of id and docNode/@id are different.&quot;);
            if (parentId != docNode.AttributeValue&lt;int&gt;(&quot;parentID&quot;))
                throw new ArgumentException(&quot;Values of parentId and docNode/@parentID are different.&quot;);

            // find the document in the cache
            XmlNode currentNode = xml.GetElementById(id.ToInvariantString());

            // if the document is not there already then it&#39;s a new document
            // we must make sure that its document type exists in the schema
            if (currentNode == null &amp;&amp; UseLegacySchema == false)
            {
                var xml2 = EnsureSchema(docNode.Name, xml);
                if (ReferenceEquals(xml, xml2) == false)
                    docNode = xml2.ImportNode(docNode, true);
                xml = xml2;
            }

            // find the parent
            XmlNode parentNode = level == 1
                ? xml.DocumentElement
                : xml.GetElementById(parentId.ToInvariantString());

            // no parent = cannot do anything
            if (parentNode == null)
                return xml;

            // insert/move the node under the parent
            if (currentNode == null)
            {
                // document not there, new node, append
                currentNode = docNode;
                parentNode.AppendChild(currentNode);
            }
            else
            {
                // document found... we could just copy the currentNode children nodes over under
                // docNode, then remove currentNode and insert docNode... the code below tries to
                // be clever and faster, though only benchmarking could tell whether it&#39;s worth the
                // pain...

                // first copy current parent ID - so we can compare with target parent
                var moving = currentNode.AttributeValue&lt;int&gt;(&quot;parentID&quot;) != parentId;

                if (docNode.Name == currentNode.Name)
                {
                    // name has not changed, safe to just update the current node
                    // by transfering values eg copying the attributes, and importing the data elements
                    TransferValuesFromDocumentXmlToPublishedXml(docNode, currentNode);

                    // if moving, move the node to the new parent
                    // else it&#39;s already under the right parent
                    // (but maybe the sort order has been updated)
                    if (moving)
                        parentNode.AppendChild(currentNode); // remove then append to parentNode
                }
                else
                {
                    // name has changed, must use docNode (with new name)
                    // move children nodes from currentNode to docNode (already has properties)
                    var children = currentNode.SelectNodes(ChildNodesXPath);
                    if (children == null) throw new Exception(&quot;oops&quot;);
                    foreach (XmlNode child in children)
                        docNode.AppendChild(child); // remove then append to docNode

                    // and put docNode in the right place - if parent has not changed, then
                    // just replace, else remove currentNode and insert docNode under the right parent
                    // (but maybe not at the right position due to sort order)
                    if (moving)
                    {
                        if (currentNode.ParentNode == null) throw new Exception(&quot;oops&quot;);
                        currentNode.ParentNode.RemoveChild(currentNode);
                        parentNode.AppendChild(docNode);
                    }
                    else
                    {
                        // replacing might screw the sort order
                        parentNode.ReplaceChild(docNode, currentNode);
                    }

                    currentNode = docNode;
                }
            }

            // if the nodes are not ordered, must sort
            // (see U4-509 + has to work with ReplaceChild too)
            //XmlHelper.SortNodesIfNeeded(parentNode, childNodesXPath, x =&gt; x.AttributeValue&lt;int&gt;(&quot;sortOrder&quot;));

            // but...
            // if we assume that nodes are always correctly sorted
            // then we just need to ensure that currentNode is at the right position.
            // should be faster that moving all the nodes around.
            XmlHelper.SortNode(parentNode, ChildNodesXPath, currentNode, x =&gt; x.AttributeValue&lt;int&gt;(&quot;sortOrder&quot;));
            return xml;
        }

        private static void TransferValuesFromDocumentXmlToPublishedXml(XmlNode documentNode, XmlNode publishedNode)
        {
            // remove all attributes from the published node
            if (publishedNode.Attributes == null) throw new Exception(&quot;oops&quot;);
            publishedNode.Attributes.RemoveAll();

            // remove all data nodes from the published node
            //TODO: This could be faster, might as well just iterate all children and filter
            // instead of selecting matching children (i.e. iterating all) and then iterating the
            // filtered items to remove, this also allocates more memory to store the list of children.
            // Below we also then do another filtering of child nodes, if we just iterate all children we
            // can perform both functions more efficiently
            var dataNodes = publishedNode.SelectNodes(DataNodesXPath);
            if (dataNodes == null) throw new Exception(&quot;oops&quot;);
            foreach (XmlNode n in dataNodes)
                publishedNode.RemoveChild(n);

            // append all attributes from the document node to the published node
            if (documentNode.Attributes == null) throw new Exception(&quot;oops&quot;);
            foreach (XmlAttribute att in documentNode.Attributes)
                ((XmlElement)publishedNode).SetAttribute(att.Name, att.Value);

            // find the first child node, if any
            var childNodes = publishedNode.SelectNodes(ChildNodesXPath);
            if (childNodes == null) throw new Exception(&quot;oops&quot;);
            var firstChildNode = childNodes.Count == 0 ? null : childNodes[0];

            // append all data nodes from the document node to the published node
            dataNodes = documentNode.SelectNodes(DataNodesXPath);
            if (dataNodes == null) throw new Exception(&quot;oops&quot;);
            foreach (XmlNode n in dataNodes)
            {
                if (publishedNode.OwnerDocument == null) throw new Exception(&quot;oops&quot;);
                var imported = publishedNode.OwnerDocument.ImportNode(n, true);
                if (firstChildNode == null)
                    publishedNode.AppendChild(imported);
                else
                    publishedNode.InsertBefore(imported, firstChildNode);
            }
        }

        #endregion

        #region Events

        /// &lt;summary&gt;
        /// Occurs when [after loading the xml string from the database].
        /// &lt;/summary&gt;
        public delegate void ContentCacheDatabaseLoadXmlStringEventHandler(
            ref string xml, ContentCacheLoadNodeEventArgs e);

        /// &lt;summary&gt;
        /// Occurs when [after loading the xml string from the database and creating the xml node].
        /// &lt;/summary&gt;
        public delegate void ContentCacheLoadNodeEventHandler(XmlNode xmlNode, ContentCacheLoadNodeEventArgs e);

        public delegate void DocumentCacheEventHandler(Document sender, DocumentCacheEventArgs e);

        public delegate void RefreshContentEventHandler(Document sender, RefreshContentEventArgs e);

        /// &lt;summary&gt;
        /// Occurs when [before document cache update].
        /// &lt;/summary&gt;
        public static event DocumentCacheEventHandler BeforeUpdateDocumentCache;

        /// &lt;summary&gt;
        /// Fires the before document cache.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;The &lt;see cref=&quot;umbraco.cms.businesslogic.DocumentCacheEventArgs&quot;/&gt; instance containing the event data.&lt;/param&gt;
        protected virtual void FireBeforeUpdateDocumentCache(Document sender, DocumentCacheEventArgs e)
        {
            if (BeforeUpdateDocumentCache != null)
            {
                BeforeUpdateDocumentCache(sender, e);
            }
        }

        /// &lt;summary&gt;
        /// Occurs when [after document cache update].
        /// &lt;/summary&gt;
        public static event DocumentCacheEventHandler AfterUpdateDocumentCache;

        /// &lt;summary&gt;
        /// Fires after document cache updater.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;The &lt;see cref=&quot;umbraco.cms.businesslogic.DocumentCacheEventArgs&quot;/&gt; instance containing the event data.&lt;/param&gt;
        protected virtual void FireAfterUpdateDocumentCache(Document sender, DocumentCacheEventArgs e)
        {
            if (AfterUpdateDocumentCache != null)
            {
                AfterUpdateDocumentCache(sender, e);
            }
        }

        /// &lt;summary&gt;
        /// Occurs when [before document cache unpublish].
        /// &lt;/summary&gt;
        public static event DocumentCacheEventHandler BeforeClearDocumentCache;

        /// &lt;summary&gt;
        /// Fires the before document cache unpublish.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;The &lt;see cref=&quot;umbraco.cms.businesslogic.DocumentCacheEventArgs&quot;/&gt; instance containing the event data.&lt;/param&gt;
        protected virtual void FireBeforeClearDocumentCache(Document sender, DocumentCacheEventArgs e)
        {
            if (BeforeClearDocumentCache != null)
            {
                BeforeClearDocumentCache(sender, e);
            }
        }

        public static event DocumentCacheEventHandler AfterClearDocumentCache;

        /// &lt;summary&gt;
        /// Fires the after document cache unpublish.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;The &lt;see cref=&quot;umbraco.cms.businesslogic.DocumentCacheEventArgs&quot;/&gt; instance containing the event data.&lt;/param&gt;
        protected virtual void FireAfterClearDocumentCache(Document sender, DocumentCacheEventArgs e)
        {
            if (AfterClearDocumentCache != null)
            {
                AfterClearDocumentCache(sender, e);
            }
        }

        /// &lt;summary&gt;
        /// Occurs when [before refresh content].
        /// &lt;/summary&gt;
        public static event RefreshContentEventHandler BeforeRefreshContent;

        /// &lt;summary&gt;
        /// Fires the content of the before refresh.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;The &lt;see cref=&quot;umbraco.cms.businesslogic.RefreshContentEventArgs&quot;/&gt; instance containing the event data.&lt;/param&gt;
        protected virtual void FireBeforeRefreshContent(RefreshContentEventArgs e)
        {
            if (BeforeRefreshContent != null)
            {
                BeforeRefreshContent(null, e);
            }
        }

        /// &lt;summary&gt;
        /// Occurs when [after refresh content].
        /// &lt;/summary&gt;
        public static event RefreshContentEventHandler AfterRefreshContent;

        /// &lt;summary&gt;
        /// Fires the content of the after refresh.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;The sender.&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;The &lt;see cref=&quot;umbraco.cms.businesslogic.RefreshContentEventArgs&quot;/&gt; instance containing the event data.&lt;/param&gt;
        protected virtual void FireAfterRefreshContent(RefreshContentEventArgs e)
        {
            if (AfterRefreshContent != null)
            {
                AfterRefreshContent(null, e);
            }
        }

        [Obsolete(&quot;This is no used, do not use this for any reason&quot;)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static event ContentCacheDatabaseLoadXmlStringEventHandler AfterContentCacheDatabaseLoadXmlString;

        /// &lt;summary&gt;
        /// Occurs when [before when creating the document cache from database].
        /// &lt;/summary&gt;
        public static event ContentCacheLoadNodeEventHandler BeforeContentCacheLoadNode;

        /// &lt;summary&gt;
        /// Fires the before when creating the document cache from database
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;node&quot;&gt;The sender.&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;The &lt;see cref=&quot;umbraco.cms.businesslogic.ContentCacheLoadNodeEventArgs&quot;/&gt; instance containing the event data.&lt;/param&gt;
        internal static void FireBeforeContentCacheLoadNode(XmlNode node, ContentCacheLoadNodeEventArgs e)
        {
            if (BeforeContentCacheLoadNode != null)
            {
                BeforeContentCacheLoadNode(node, e);
            }
        }

        [Obsolete(&quot;This is no used, do not use this for any reason&quot;)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static event ContentCacheLoadNodeEventHandler AfterContentCacheLoadNodeFromDatabase;

        /// &lt;summary&gt;
        /// Occurs when [before a publish action updates the content cache].
        /// &lt;/summary&gt;
        public static event ContentCacheLoadNodeEventHandler BeforePublishNodeToContentCache;

        /// &lt;summary&gt;
        /// Fires the before a publish action updates the content cache
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;node&quot;&gt;The sender.&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;The &lt;see cref=&quot;umbraco.cms.businesslogic.ContentCacheLoadNodeEventArgs&quot;/&gt; instance containing the event data.&lt;/param&gt;
        public static void FireBeforePublishNodeToContentCache(XmlNode node, ContentCacheLoadNodeEventArgs e)
        {
            if (BeforePublishNodeToContentCache != null)
            {
                BeforePublishNodeToContentCache(node, e);
            }
        }

        #endregion
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[45,9,45,26,0],[46,9,46,10,0],[47,13,47,31,0],[48,13,48,14,0],[49,17,49,119,0],[50,17,52,112,0],[57,17,62,28,0],[65,17,65,89,0],[67,17,70,21,0],[70,21,70,22,0],[70,22,75,25,0],[75,25,75,54,0],[75,54,76,25,0],[76,25,76,42,0],[76,42,77,21,0],[77,21,77,22,0],[77,22,77,24,0],[67,17,77,24,0],[80,17,80,41,0],[81,21,81,50,0],[83,17,83,51,0],[84,13,84,14,0],[87,20,87,57,0],[88,13,88,14,0],[93,17,93,63,0],[96,17,96,51,0],[97,13,97,14,0],[98,9,98,10,0],[104,9,104,86,0],[104,86,104,99,0],[104,99,104,101,0],[104,9,104,101,0],[109,13,109,14,0],[110,17,110,43,0],[111,13,111,14,0],[120,9,120,70,0],[124,9,124,75,0],[132,9,132,10,0],[133,13,133,68,0],[134,13,134,14,0],[135,17,135,94,0],[136,13,136,14,0],[137,13,137,49,0],[138,9,138,10,0],[143,17,143,18,0],[143,19,143,54,0],[143,55,143,56,0],[144,17,144,18,0],[144,19,144,56,0],[144,57,144,58,0],[152,17,152,18,0],[152,19,152,46,0],[152,47,152,48,0],[161,17,161,18,0],[161,19,161,48,0],[161,49,161,50,0],[170,9,170,10,0],[171,13,171,42,0],[172,9,172,10,0],[178,9,178,10,0],[179,13,179,51,0],[180,13,180,41,0],[182,13,182,27,0],[183,13,183,14,0],[184,24,184,56,0],[185,17,185,18,0],[186,21,186,61,0],[187,17,187,18,0],[188,13,188,14,0],[189,9,189,10,0],[198,9,198,10,0],[200,13,200,29,0],[201,13,201,14,0],[202,17,202,63,0],[205,17,205,80,0],[206,17,206,77,0],[207,17,207,53,0],[208,17,208,103,0],[211,17,211,89,0],[212,17,212,18,0],[214,21,214,22,0],[215,25,215,77,0],[216,25,216,54,0],[217,25,217,83,0],[218,25,218,26,0],[219,29,219,48,0],[220,25,220,26,0],[222,25,222,26,0],[223,29,223,141,0],[224,25,224,26,0],[225,21,225,22,0],[226,21,226,41,0],[227,21,227,22,0],[228,25,228,140,0],[229,21,229,22,0],[230,17,230,18,0],[231,13,231,14,0],[233,13,233,35,0],[234,9,234,10,0],[237,9,237,10,0],[238,13,238,27,0],[239,13,239,14,0],[240,17,240,55,0],[243,13,243,14,0],[244,17,244,55,0],[246,9,246,10,0],[253,9,253,10,0],[254,20,254,57,0],[255,13,255,14,0],[256,17,258,99,0],[260,17,260,40,0],[260,41,260,48,0],[262,17,265,26,0],[265,26,265,60,0],[265,60,265,62,0],[262,17,265,62,0],[267,17,267,37,0],[267,38,267,45,0],[269,17,269,34,0],[270,13,270,14,0],[271,9,271,10,0],[278,9,278,10,0],[279,13,279,42,0],[280,13,280,36,0],[281,9,281,10,0],[288,9,288,10,0],[289,13,289,50,0],[290,13,290,49,0],[292,13,292,27,0],[293,13,293,14,0],[296,24,296,56,0],[297,17,297,18,0],[298,21,298,71,0],[299,17,299,18,0],[301,17,301,37,0],[303,17,303,105,0],[304,17,304,117,0],[306,17,306,52,0],[307,13,307,14,0],[308,9,308,10,0],[311,9,311,10,0],[312,13,312,97,0],[313,13,313,33,0],[313,34,313,41,0],[314,13,314,38,0],[315,9,315,10,0],[318,9,318,10,0],[319,13,319,27,0],[319,28,319,65,0],[338,13,338,29,0],[338,30,338,37,0],[339,13,339,48,0],[339,49,339,56,0],[340,13,340,58,0],[340,59,340,66,0],[342,20,342,57,0],[343,13,343,14,0],[347,17,347,100,0],[348,17,348,34,0],[348,35,348,42,0],[349,17,349,63,0],[350,17,350,34,0],[350,35,350,42,0],[351,17,351,84,0],[352,17,352,45,0],[352,46,352,53,0],[355,17,355,40,0],[357,17,357,34,0],[358,13,358,14,0],[359,9,359,10,0],[367,9,367,10,0],[370,13,370,44,0],[373,20,373,52,0],[374,13,374,14,0],[375,17,375,24,0],[375,26,375,36,0],[375,37,375,39,0],[375,40,375,49,0],[376,17,376,18,0],[377,21,377,71,0],[378,17,378,18,0],[379,13,379,14,0],[381,13,381,33,0],[382,9,382,10,0],[386,9,386,10,0],[387,13,387,45,0],[388,9,388,10,0],[392,9,392,10,0],[393,13,393,44,0],[394,9,394,10,0],[397,9,397,10,0],[398,13,398,50,0],[399,9,399,10,0],[402,9,402,10,0],[406,13,406,14,0],[407,17,407,46,0],[408,13,408,14,0],[409,13,409,18,0],[410,13,410,14,0],[413,17,413,51,0],[414,17,414,24,0],[416,13,416,53,0],[417,9,417,10,0],[426,9,426,10,0],[427,13,427,50,0],[428,13,428,50,0],[430,13,430,27,0],[431,13,431,14,0],[436,17,436,38,0],[437,17,437,18,0],[439,21,439,43,0],[440,17,440,18,0],[443,17,443,47,0],[445,17,445,37,0],[448,17,448,53,0],[451,17,451,64,0],[452,17,452,18,0],[453,21,453,73,0],[454,21,454,45,0],[455,17,455,18,0],[456,13,456,14,0],[457,9,457,10,0],[460,9,460,10,0],[463,20,463,52,0],[464,13,464,14,0],[466,17,466,67,0],[467,17,467,31,0],[468,21,468,28,0],[470,17,470,48,0],[473,17,473,63,0],[474,17,474,31,0],[475,17,475,18,0],[477,21,477,49,0],[478,21,478,38,0],[479,17,479,18,0],[480,13,480,14,0],[481,9,481,10,0],[489,9,489,10,0],[490,13,490,44,0],[491,9,491,10,0],[501,9,501,10,0],[503,13,503,173,0],[504,17,504,91,0],[505,9,505,10,0],[511,9,511,10,0],[513,13,513,14,0],[514,17,514,77,0],[516,17,516,38,0],[517,17,517,18,0],[518,21,518,101,0],[519,21,519,77,0],[520,21,520,35,0],[523,13,523,33,0],[524,13,524,14,0],[525,17,525,68,0],[526,13,526,14,0],[530,13,530,25,0],[531,9,531,10,0],[535,9,535,10,0],[536,9,536,10,0],[539,9,539,10,0],[542,13,542,58,0],[543,13,543,14,0],[544,17,544,83,0],[547,13,547,38,0],[548,9,548,10,0],[556,9,556,54,0],[561,17,561,18,0],[561,19,561,105,0],[561,106,561,107,0],[567,17,567,18,0],[567,19,567,118,0],[567,119,567,120,0],[573,17,573,18,0],[573,19,573,118,0],[573,119,573,120,0],[579,17,579,18,0],[579,19,579,86,0],[579,87,579,88,0],[585,17,585,18,0],[585,19,585,89,0],[585,90,585,91,0],[592,9,592,63,0],[603,13,603,14,0],[604,17,604,98,0],[605,21,605,47,0],[606,17,606,113,0],[607,17,607,37,0],[608,17,608,18,0],[609,21,609,50,0],[610,21,610,98,0],[611,17,611,18,0],[612,17,612,32,0],[613,13,613,14,0],[619,17,619,18,0],[619,19,619,46,0],[619,47,619,48,0],[626,13,626,14,0],[627,17,627,46,0],[628,17,628,36,0],[629,13,629,14,0],[634,9,634,10,0],[636,13,636,31,0],[638,13,638,70,0],[639,17,639,24,0],[642,13,642,53,0],[643,9,643,10,0],[646,9,646,10,0],[647,13,647,80,0],[648,9,648,10,0],[651,9,651,10,0],[652,13,652,34,0],[655,13,655,36,0],[656,13,656,84,0],[657,17,657,35,0],[658,13,658,56,0],[659,17,659,62,0],[662,13,662,118,0],[663,17,663,28,0],[673,13,673,42,0],[674,13,674,144,0],[675,13,675,79,0],[676,13,676,39,0],[677,13,677,74,0],[678,13,678,25,0],[679,9,679,10,0],[684,9,684,10,0],[685,13,685,56,0],[688,13,688,77,0],[689,13,689,14,0],[690,17,690,43,0],[691,17,691,24,0],[695,13,695,53,0],[696,13,696,38,0],[697,9,697,10,0],[705,9,705,10,0],[706,13,706,44,0],[707,13,707,66,0],[708,9,708,10,0],[712,9,712,10,0],[713,13,713,44,0],[714,13,714,72,0],[715,9,715,10,0],[726,13,726,106,0],[727,13,727,14,0],[728,17,728,38,0],[729,17,729,38,0],[730,17,730,38,0],[731,17,731,30,0],[734,17,734,87,0],[735,13,735,14,0],[738,13,738,14,0],[739,17,739,82,0],[740,13,740,14,0],[743,13,743,14,0],[744,17,744,80,0],[745,13,745,14,0],[748,13,748,14,0],[749,17,749,31,0],[750,21,750,77,0],[751,17,751,34,0],[752,17,752,30,0],[753,17,753,36,0],[754,13,754,14,0],[759,17,759,18,0],[760,21,760,33,0],[761,17,761,18,0],[763,17,763,18,0],[764,21,764,44,0],[765,25,765,77,0],[766,21,766,34,0],[767,17,767,18,0],[774,13,774,14,0],[775,17,775,40,0],[776,21,776,73,0],[777,17,777,64,0],[778,17,778,35,0],[779,13,779,14,0],[782,13,782,14,0],[783,17,783,39,0],[784,21,784,28,0],[785,17,785,63,0],[786,21,786,30,0],[787,17,787,37,0],[788,17,788,34,0],[789,13,789,14,0],[796,13,796,14,0],[797,17,799,35,0],[800,13,800,14,0],[806,13,806,14,0],[807,17,809,40,0],[810,13,810,14,0],[817,9,817,94,0],[835,13,835,14,0],[836,17,836,59,0],[837,17,837,88,0],[838,13,838,14,0],[845,9,845,10,0],[846,13,846,60,0],[848,13,848,14,0],[849,17,849,39,0],[850,17,850,33,0],[850,34,850,41,0],[853,17,853,33,0],[856,17,856,73,0],[857,17,857,43,0],[858,21,858,102,0],[859,17,859,100,0],[860,21,860,62,0],[863,24,863,112,0],[864,17,864,18,0],[865,21,865,46,0],[866,17,866,18,0],[868,17,868,63,0],[869,13,869,14,0],[870,13,870,32,0],[871,13,871,14,0],[874,17,874,18,0],[875,21,875,37,0],[876,17,876,18,0],[877,17,877,22,0],[878,17,878,18,0],[881,17,881,18,0],[882,17,882,76,0],[883,13,883,14,0],[884,9,884,10,0],[887,9,887,10,0],[900,13,900,37,0],[901,13,901,14,0],[902,17,902,42,0],[903,13,903,14,0],[905,20,910,15,0],[911,13,911,14,0],[913,17,913,40,0],[914,13,914,14,0],[915,9,915,10,0],[918,9,918,10,0],[920,13,920,27,0],[920,28,920,40,0],[922,13,922,62,0],[925,13,925,14,0],[926,17,926,45,0],[927,24,927,109,0],[928,17,928,18,0],[929,21,929,34,0],[930,17,930,18,0],[931,17,931,49,0],[932,17,932,66,0],[933,17,933,28,0],[935,13,935,42,0],[936,13,936,14,0],[937,17,937,85,0],[938,17,938,29,0],[940,13,940,32,0],[941,13,941,14,0],[942,17,942,78,0],[944,17,944,18,0],[945,21,945,37,0],[946,17,946,18,0],[947,17,947,22,0],[948,17,948,18,0],[951,17,951,18,0],[952,17,952,29,0],[954,9,954,10,0],[957,9,957,10,0],[958,13,958,52,0],[958,53,958,60,0],[959,13,959,69,0],[960,13,960,39,0],[961,9,961,10,0],[964,9,964,10,0],[965,13,965,42,0],[965,43,965,50,0],[967,13,967,39,0],[968,13,968,38,0],[968,39,968,46,0],[971,13,971,48,0],[972,13,972,55,0],[972,56,972,63,0],[974,13,974,78,0],[978,20,978,57,0],[979,13,979,14,0],[981,17,981,63,0],[982,17,982,51,0],[983,13,983,14,0],[984,9,984,10,0],[993,9,993,10,0],[994,13,994,70,0],[995,9,995,10,0],[999,9,999,10,0],[1001,13,1001,57,0],[1002,17,1002,92,0],[1003,13,1003,69,0],[1004,17,1004,104,0],[1007,13,1007,78,0],[1011,13,1011,65,0],[1012,13,1012,14,0],[1013,17,1013,60,0],[1014,17,1014,57,0],[1015,21,1015,62,0],[1016,17,1016,28,0],[1017,13,1017,14,0],[1020,13,1022,68,0],[1025,13,1025,36,0],[1026,17,1026,28,0],[1029,13,1029,37,0],[1030,13,1030,14,0],[1032,17,1032,39,0],[1033,17,1033,53,0],[1034,13,1034,14,0],[1036,13,1036,14,0],[1043,17,1043,86,0],[1045,17,1045,54,0],[1046,17,1046,18,0],[1049,21,1049,87,0],[1054,21,1054,32,0],[1055,25,1055,61,0],[1056,17,1056,18,0],[1058,17,1058,18,0],[1061,21,1061,77,0],[1062,21,1062,42,0],[1062,43,1062,71,0],[1063,21,1063,28,0],[1063,30,1063,43,0],[1063,44,1063,46,0],[1063,47,1063,55,0],[1064,25,1064,52,0],[1069,21,1069,32,0],[1070,21,1070,22,0],[1071,25,1071,60,0],[1071,61,1071,89,0],[1072,25,1072,73,0],[1073,25,1073,57,0],[1074,21,1074,22,0],[1076,21,1076,22,0],[1078,25,1078,71,0],[1079,21,1079,22,0],[1081,21,1081,43,0],[1082,17,1082,18,0],[1083,13,1083,14,0],[1093,13,1093,79,0],[1093,79,1093,113,0],[1093,113,1093,115,0],[1093,13,1093,115,0],[1094,13,1094,24,0],[1095,9,1095,10,0],[1098,9,1098,10,0],[1100,13,1100,50,0],[1100,51,1100,79,0],[1101,13,1101,50,0],[1109,13,1109,71,0],[1110,13,1110,35,0],[1110,36,1110,64,0],[1111,13,1111,20,0],[1111,22,1111,31,0],[1111,32,1111,34,0],[1111,35,1111,44,0],[1112,17,1112,46,0],[1115,13,1115,49,0],[1115,50,1115,78,0],[1116,13,1116,20,0],[1116,22,1116,38,0],[1116,39,1116,41,0],[1116,42,1116,65,0],[1117,17,1117,79,0],[1120,13,1120,73,0],[1121,13,1121,36,0],[1121,37,1121,65,0],[1122,13,1122,79,0],[1125,13,1125,66,0],[1126,13,1126,35,0],[1126,36,1126,64,0],[1127,13,1127,20,0],[1127,22,1127,31,0],[1127,32,1127,34,0],[1127,35,1127,44,0],[1128,13,1128,14,0],[1129,17,1129,57,0],[1129,58,1129,86,0],[1130,17,1130,80,0],[1131,17,1131,44,0],[1132,21,1132,57,0],[1134,21,1134,74,0],[1135,13,1135,14,0],[1136,9,1136,10,0],[1168,9,1168,10,0],[1169,13,1169,51,0],[1170,13,1170,14,0],[1171,17,1171,54,0],[1172,13,1172,14,0],[1173,9,1173,10,0],[1186,9,1186,10,0],[1187,13,1187,50,0],[1188,13,1188,14,0],[1189,17,1189,53,0],[1190,13,1190,14,0],[1191,9,1191,10,0],[1204,9,1204,10,0],[1205,13,1205,50,0],[1206,13,1206,14,0],[1207,17,1207,53,0],[1208,13,1208,14,0],[1209,9,1209,10,0],[1219,9,1219,10,0],[1220,13,1220,49,0],[1221,13,1221,14,0],[1222,17,1222,52,0],[1223,13,1223,14,0],[1224,9,1224,10,0],[1237,9,1237,10,0],[1238,13,1238,46,0],[1239,13,1239,14,0],[1240,17,1240,47,0],[1241,13,1241,14,0],[1242,9,1242,10,0],[1255,9,1255,10,0],[1256,13,1256,45,0],[1257,13,1257,14,0],[1258,17,1258,46,0],[1259,13,1259,14,0],[1260,9,1260,10,0],[1277,9,1277,10,0],[1278,13,1278,52,0],[1279,13,1279,14,0],[1280,17,1280,53,0],[1281,13,1281,14,0],[1282,9,1282,10,0],[1299,9,1299,10,0],[1300,13,1300,57,0],[1301,13,1301,14,0],[1302,17,1302,58,0],[1303,13,1303,14,0],[1304,9,1304,10,0]]);
    </script>
  </body>
</html>