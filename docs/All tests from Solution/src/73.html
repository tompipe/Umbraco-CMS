<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Tests\CoreXml\FrameworkXmlTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using NUnit.Framework;

namespace Umbraco.Tests.CoreXml
{
    [TestFixture]
    public class FrameworkXmlTests
    {
        const string Xml1 = @&quot;&lt;root&gt;
    &lt;items&gt;
        &lt;item1 /&gt;
        &lt;item2&gt;
            &lt;item21&gt;text21&lt;/item21&gt;
        &lt;/item2&gt;
        &lt;item3&gt;
            &lt;item31&gt;text31&lt;/item31&gt;
        &lt;/item3&gt;
        &lt;item4 /&gt;
        &lt;item5 /&gt;
        &lt;item6 /&gt;
    &lt;/items&gt;
&lt;/root&gt;&quot;;


        // Umbraco : the following test shows that when legacy imports the whole tree in a
        // &quot;contentAll&quot; xslt macro parameter, the entire collection of nodes is cloned ie is
        // duplicated.
        //
        // What is the impact on memory?
        // What happens for non-xslt macros?

        [Test]
        public void ImportNodeClonesImportedNode()
        {
            var doc1 = new XmlDocument();            
            doc1.LoadXml(Xml1);

            var node1 = doc1.SelectSingleNode(&quot;//item2&quot;);
            Assert.IsNotNull(node1);

            var doc2 = new XmlDocument();
            doc2.LoadXml(&quot;&lt;nodes /&gt;&quot;);
            var node2 = doc2.ImportNode(node1, true);
            var root2 = doc2.DocumentElement;
            Assert.IsNotNull(root2);
            root2.AppendChild(node2);

            var node3 = doc2.SelectSingleNode(&quot;//item2&quot;);

            Assert.AreNotSame(node1, node2); // has been cloned
            Assert.AreSame(node2, node3); // has been appended

            Assert.AreNotSame(node1.FirstChild, node2.FirstChild); // deep clone
        }


        // Umbraco: the CanRemove...NodeAndNavigate tests shows that if the underlying XmlDocument
        // is modified while navigating, then strange situations can be created. For xslt macros,
        // the result depends on what the xslt engine is doing at the moment = unpredictable.
        //
        // What happens for non-xslt macros?

        [Test]
        public void CanRemoveCurrentNodeAndNavigate()
        {
            var doc1 = new XmlDocument();
            doc1.LoadXml(Xml1);
            var nav1 = doc1.CreateNavigator();

            Assert.IsTrue(nav1.MoveToFirstChild());
            Assert.AreEqual(&quot;root&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToFirstChild());
            Assert.AreEqual(&quot;items&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToFirstChild());
            Assert.AreEqual(&quot;item1&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToNext());
            Assert.AreEqual(&quot;item2&quot;, nav1.Name);

            var node1 = doc1.SelectSingleNode(&quot;//item2&quot;);
            Assert.IsNotNull(node1);
            var parent1 = node1.ParentNode;
            Assert.IsNotNull(parent1);
            parent1.RemoveChild(node1);

            // navigator now navigates on an isolated fragment
            // that is rooted on the node that was removed

            Assert.AreEqual(&quot;item2&quot;, nav1.Name);
            Assert.IsFalse(nav1.MoveToPrevious());
            Assert.IsFalse(nav1.MoveToNext());
            Assert.IsFalse(nav1.MoveToParent());

            Assert.IsTrue(nav1.MoveToFirstChild());
            Assert.AreEqual(&quot;item21&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToParent());
            Assert.AreEqual(&quot;item2&quot;, nav1.Name);

            nav1.MoveToRoot();
            Assert.AreEqual(&quot;item2&quot;, nav1.Name);
        }

        [Test]
        public void CanRemovePathNodeAndNavigate()
        {
            var doc1 = new XmlDocument();
            doc1.LoadXml(Xml1);
            var nav1 = doc1.CreateNavigator();

            Assert.IsTrue(nav1.MoveToFirstChild());
            Assert.AreEqual(&quot;root&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToFirstChild());
            Assert.AreEqual(&quot;items&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToFirstChild());
            Assert.AreEqual(&quot;item1&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToNext());
            Assert.AreEqual(&quot;item2&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToFirstChild());
            Assert.AreEqual(&quot;item21&quot;, nav1.Name);

            var node1 = doc1.SelectSingleNode(&quot;//item2&quot;);
            Assert.IsNotNull(node1);
            var parent1 = node1.ParentNode;
            Assert.IsNotNull(parent1);
            parent1.RemoveChild(node1);

            // navigator now navigates on an isolated fragment
            // that is rooted on the node that was removed

            Assert.AreEqual(&quot;item21&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToParent());
            Assert.AreEqual(&quot;item2&quot;, nav1.Name);
            Assert.IsFalse(nav1.MoveToPrevious());
            Assert.IsFalse(nav1.MoveToNext());
            Assert.IsFalse(nav1.MoveToParent());

            nav1.MoveToRoot();
            Assert.AreEqual(&quot;item2&quot;, nav1.Name);
        }

        [Test]
        public void CanRemoveOutOfPathNodeAndNavigate()
        {
            var doc1 = new XmlDocument();
            doc1.LoadXml(Xml1);
            var nav1 = doc1.CreateNavigator();

            Assert.IsTrue(nav1.MoveToFirstChild());
            Assert.AreEqual(&quot;root&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToFirstChild());
            Assert.AreEqual(&quot;items&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToFirstChild());
            Assert.AreEqual(&quot;item1&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToNext());
            Assert.AreEqual(&quot;item2&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToNext());
            Assert.AreEqual(&quot;item3&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToNext());
            Assert.AreEqual(&quot;item4&quot;, nav1.Name);

            var node1 = doc1.SelectSingleNode(&quot;//item2&quot;);
            Assert.IsNotNull(node1);
            var parent1 = node1.ParentNode;
            Assert.IsNotNull(parent1);
            parent1.RemoveChild(node1);

            // navigator sees the change

            Assert.AreEqual(&quot;item4&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToPrevious());
            Assert.AreEqual(&quot;item3&quot;, nav1.Name);
            Assert.IsTrue(nav1.MoveToPrevious());
            Assert.AreEqual(&quot;item1&quot;, nav1.Name);
        }

        // Umbraco: the following test shows that if the underlying XmlDocument is modified while
        // iterating, then strange situations can be created. For xslt macros, the result depends
        // on what the xslt engine is doing at the moment = unpredictable.
        //
        // What happens for non-xslt macros?

        [Test]
        public void CanRemoveNodeAndIterate()
        {
            var doc1 = new XmlDocument();
            doc1.LoadXml(Xml1);
            var nav1 = doc1.CreateNavigator();

            var iter1 = nav1.Select(&quot;//items/*&quot;);
            var iter2 = nav1.Select(&quot;//items/*&quot;);

            Assert.AreEqual(6, iter1.Count);

            var node1 = doc1.SelectSingleNode(&quot;//item2&quot;);
            Assert.IsNotNull(node1);
            var parent1 = node1.ParentNode;
            Assert.IsNotNull(parent1);
            parent1.RemoveChild(node1);

            // iterator partially sees the change

            Assert.AreEqual(6, iter1.Count); // has been cached, not updated
            Assert.AreEqual(5, iter2.Count); // not calculated yet, correct value

            var count = 0;
            while (iter1.MoveNext())
                count++;

            Assert.AreEqual(5, count);
        }

        [Test]
        public void OldFrameworkXPathBugIsFixed()
        {
            // see http://bytes.com/topic/net/answers/177129-reusing-xpathexpression-multiple-iterations

            var doc = new XmlDocument();
            doc.LoadXml(&quot;&lt;root&gt;&lt;a&gt;&lt;a1/&gt;&lt;a2/&gt;&lt;/a&gt;&lt;b/&gt;&lt;/root&gt;&quot;);

            var nav = doc.CreateNavigator();
            var expr = nav.Compile(&quot;*&quot;);

            nav.MoveToFirstChild(); //root
            var iter1 = nav.Select(expr);
            iter1.MoveNext(); //root/a
            var iter2 = iter1.Current.Select(expr);
            iter2.MoveNext(); // /root/a/a1
            iter2.MoveNext(); // /root/a/a2

            // used to fail because iter1 and iter2 would conflict
            Assert.IsTrue(iter1.MoveNext()); //root/b
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[40,9,40,10,1],[41,13,41,42,1],[42,13,42,32,1],[44,13,44,58,1],[45,13,45,37,1],[47,13,47,42,1],[48,13,48,39,1],[49,13,49,54,1],[50,13,50,46,1],[51,13,51,37,1],[52,13,52,38,1],[54,13,54,58,1],[56,13,56,45,1],[57,13,57,42,1],[59,13,59,67,1],[60,9,60,10,1],[71,9,71,10,1],[72,13,72,42,1],[73,13,73,32,1],[74,13,74,47,1],[76,13,76,52,1],[77,13,77,48,1],[78,13,78,52,1],[79,13,79,49,1],[80,13,80,52,1],[81,13,81,49,1],[82,13,82,46,1],[83,13,83,49,1],[85,13,85,58,1],[86,13,86,37,1],[87,13,87,44,1],[88,13,88,39,1],[89,13,89,40,1],[94,13,94,49,1],[95,13,95,51,1],[96,13,96,47,1],[97,13,97,49,1],[99,13,99,52,1],[100,13,100,50,1],[101,13,101,48,1],[102,13,102,49,1],[104,13,104,31,1],[105,13,105,49,1],[106,9,106,10,1],[110,9,110,10,1],[111,13,111,42,1],[112,13,112,32,1],[113,13,113,47,1],[115,13,115,52,1],[116,13,116,48,1],[117,13,117,52,1],[118,13,118,49,1],[119,13,119,52,1],[120,13,120,49,1],[121,13,121,46,1],[122,13,122,49,1],[123,13,123,52,1],[124,13,124,50,1],[126,13,126,58,1],[127,13,127,37,1],[128,13,128,44,1],[129,13,129,39,1],[130,13,130,40,1],[135,13,135,50,1],[136,13,136,48,1],[137,13,137,49,1],[138,13,138,51,1],[139,13,139,47,1],[140,13,140,49,1],[142,13,142,31,1],[143,13,143,49,1],[144,9,144,10,1],[148,9,148,10,1],[149,13,149,42,1],[150,13,150,32,1],[151,13,151,47,1],[153,13,153,52,1],[154,13,154,48,1],[155,13,155,52,1],[156,13,156,49,1],[157,13,157,52,1],[158,13,158,49,1],[159,13,159,46,1],[160,13,160,49,1],[161,13,161,46,1],[162,13,162,49,1],[163,13,163,46,1],[164,13,164,49,1],[166,13,166,58,1],[167,13,167,37,1],[168,13,168,44,1],[169,13,169,39,1],[170,13,170,40,1],[174,13,174,49,1],[175,13,175,50,1],[176,13,176,49,1],[177,13,177,50,1],[178,13,178,49,1],[179,9,179,10,1],[189,9,189,10,1],[190,13,190,42,1],[191,13,191,32,1],[192,13,192,47,1],[194,13,194,50,1],[195,13,195,50,1],[197,13,197,45,1],[199,13,199,58,1],[200,13,200,37,1],[201,13,201,44,1],[202,13,202,39,1],[203,13,203,40,1],[207,13,207,45,1],[208,13,208,45,1],[210,13,210,27,1],[211,13,211,37,1],[212,17,212,25,1],[214,13,214,39,1],[215,9,215,10,1],[219,9,219,10,1],[222,13,222,41,1],[223,13,223,63,1],[225,13,225,45,1],[226,13,226,41,1],[228,13,228,36,1],[229,13,229,42,1],[230,13,230,30,1],[231,13,231,52,1],[232,13,232,30,1],[233,13,233,30,1],[236,13,236,45,1],[237,9,237,10,1]]);
    </script>
  </body>
</html>