<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Xml\XPath\MacroNavigator.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Xml;
using System.Xml.XPath;

namespace Umbraco.Core.Xml.XPath
{
    /// &lt;summary&gt;
    /// Provides a cursor model for navigating {macro /} as if it were XML.
    /// &lt;/summary&gt;
    class MacroNavigator : XPathNavigator
    {
        private readonly XmlNameTable _nameTable;
        private readonly MacroRoot _macro;
        private State _state;

        #region Constructor

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;MacroNavigator&quot;/&gt; class with macro parameters.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;The macro parameters.&lt;/param&gt;
        public MacroNavigator(IEnumerable&lt;MacroParameter&gt; parameters)
            : this(new MacroRoot(parameters), new NameTable(), new State())
        { }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;MacroNavigator&quot;/&gt; class with a macro node,
        /// a name table and a state.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;macro&quot;&gt;The macro node.&lt;/param&gt;
        /// &lt;param name=&quot;nameTable&quot;&gt;The name table.&lt;/param&gt;
        /// &lt;param name=&quot;state&quot;&gt;The state.&lt;/param&gt;
        /// &lt;remarks&gt;Privately used for cloning a navigator.&lt;/remarks&gt;
        private MacroNavigator(MacroRoot macro, XmlNameTable nameTable, State state)
        {
            _macro = macro;
            _nameTable = nameTable;
            _state = state;
        }

        #endregion

        #region Diagnostics

        // diagnostics code will not be compiled nor called into Release configuration.
        // in Debug configuration, uncomment lines in Debug() to write to console or to log.
        //
        // much of this code is duplicated in each navigator due to conditional compilation

#if DEBUG
        private const string Tabs = &quot;                    &quot;;
        private int _tabs;
        private readonly int _uid = GetUid();
        private static int _uidg;
        private readonly static object Uidl = new object();
        private static int GetUid()
        {
            lock (Uidl)
            {
                return _uidg++;
            }
        }
#endif

        [Conditional(&quot;DEBUG&quot;)]
        void DebugEnter(string name)
        {
#if DEBUG
            Debug(&quot;&quot;);
            DebugState(&quot;:&quot;);
            Debug(name);
            _tabs = Math.Min(Tabs.Length, _tabs + 2);
#endif
        }

        [Conditional(&quot;DEBUG&quot;)]
        void DebugCreate(MacroNavigator nav)
        {
#if DEBUG
            Debug(&quot;Create: [MacroNavigator::{0}]&quot;, nav._uid);
#endif
        }

        [Conditional(&quot;DEBUG&quot;)]
        private void DebugReturn()
        {
#if DEBUG
// ReSharper disable IntroduceOptionalParameters.Local
            DebugReturn(&quot;(void)&quot;);
// ReSharper restore IntroduceOptionalParameters.Local
#endif
        }

        [Conditional(&quot;DEBUG&quot;)]
        private void DebugReturn(bool value)
        {
#if DEBUG
            DebugReturn(value ? &quot;true&quot; : &quot;false&quot;);
#endif
        }

        [Conditional(&quot;DEBUG&quot;)]
        void DebugReturn(string format, params object[] args)
        {
#if DEBUG
            Debug(&quot;=&gt; &quot; + format, args);
            if (_tabs &gt; 0) _tabs -= 2;
#endif
        }

        [Conditional(&quot;DEBUG&quot;)]
        void DebugState(string s = &quot; =&gt;&quot;)
        {
#if DEBUG
            string position;

            switch (_state.Position)
            {
                case StatePosition.Macro:
                    position = &quot;At macro.&quot;;
                    break;
                case StatePosition.Parameter:
                    position = string.Format(&quot;At parameter &#39;{0}&#39;.&quot;,
                        _macro.Parameters[_state.ParameterIndex].Name);
                    break;
                case StatePosition.ParameterAttribute:
                    position = string.Format(&quot;At parameter attribute &#39;{0}/{1}&#39;.&quot;,
                        _macro.Parameters[_state.ParameterIndex].Name,
                        _macro.Parameters[_state.ParameterIndex].Attributes[_state.ParameterAttributeIndex].Key);
                    break;
                case StatePosition.ParameterNavigator:
                    position = string.Format(&quot;In parameter &#39;{0}{1}&#39; navigator.&quot;,
                        _macro.Parameters[_state.ParameterIndex].Name,
                        _macro.Parameters[_state.ParameterIndex].WrapNavigatorInNodes ? &quot;/nodes&quot; : &quot;&quot;);
                    break;
                case StatePosition.ParameterNodes:
                    position = string.Format(&quot;At parameter &#39;{0}/nodes&#39;.&quot;,
                        _macro.Parameters[_state.ParameterIndex].Name);
                    break;
                case StatePosition.ParameterText:
                    position = string.Format(&quot;In parameter &#39;{0}&#39; text.&quot;,
                        _macro.Parameters[_state.ParameterIndex].Name);
                    break;
                case StatePosition.Root:
                    position = &quot;At root.&quot;;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            Debug(&quot;State{0} {1}&quot;, s, position);
#endif
        }

#if DEBUG
        void Debug(string format, params object[] args)
        {
            // remove comments to write

            format = &quot;[&quot; + _uid.ToString(&quot;00000&quot;) + &quot;] &quot; + Tabs.Substring(0, _tabs) + format;
#pragma warning disable 168
            var msg = string.Format(format, args); // unused if not writing, hence #pragma
#pragma warning restore 168
            //LogHelper.Debug&lt;MacroNavigator&gt;(msg); // beware! this can quicky overflow log4net
            //Console.WriteLine(msg);
        }
#endif

        #endregion

        #region Macro

        private class MacroRoot
        {
            public MacroRoot(IEnumerable&lt;MacroParameter&gt; parameters)
            {
                Parameters = parameters == null ? new MacroParameter[] {} : parameters.ToArray();
            }

            public MacroParameter[] Parameters { get; private set; }
        }

        public class MacroParameter
        {
            // note: assuming we&#39;re not thinking about supporting
            // XPathIterator in parameters - enough nonsense!

            public MacroParameter(string name, string value)
            {
                Name = name;
                StringValue = value;
            }

            public MacroParameter(string name, XPathNavigator navigator,
                int maxNavigatorDepth = int.MaxValue,
                bool wrapNavigatorInNodes = false,
                IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; attributes = null)
            {
                Name = name;
                MaxNavigatorDepth = maxNavigatorDepth;
                WrapNavigatorInNodes = wrapNavigatorInNodes;
                if (attributes != null)
                {
                    var a = attributes.ToArray();
                    if (a.Length &gt; 0)
                        Attributes = a;
                }
                NavigatorValue = navigator; // should not be empty
            }

            public string Name { get; private set; }
            public string StringValue { get; private set; }
            public XPathNavigator NavigatorValue { get; private set; }
            public int MaxNavigatorDepth { get; private set; }
            public bool WrapNavigatorInNodes { get; private set; }
            public KeyValuePair&lt;string, string&gt;[] Attributes { get; private set; }
        }
        
        #endregion

        /// &lt;summary&gt;
        /// Creates a new XPathNavigator positioned at the same node as this XPathNavigator.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A new XPathNavigator positioned at the same node as this XPathNavigator.&lt;/returns&gt;
        public override XPathNavigator Clone()
        {
            DebugEnter(&quot;Clone&quot;);
            var nav = new MacroNavigator(_macro, _nameTable, _state.Clone());
            DebugCreate(nav);
            DebugReturn(&quot;[XPathNavigator]&quot;);
            return nav;
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether the current node is an empty element without an end element tag.
        /// &lt;/summary&gt;
        public override bool IsEmptyElement
        {
            get 
            {
                DebugEnter(&quot;IsEmptyElement&quot;);
                bool isEmpty;

                switch (_state.Position)
                {
                    case StatePosition.Macro:
                        isEmpty = _macro.Parameters.Length == 0;
                        break;
                    case StatePosition.Parameter:
                        var parameter = _macro.Parameters[_state.ParameterIndex];
                        var nav = parameter.NavigatorValue;
                        if (parameter.WrapNavigatorInNodes || nav != null)
                        {
                            isEmpty = false;
                        }
                        else
                        {
                            var s = _macro.Parameters[_state.ParameterIndex].StringValue;
                            isEmpty = s == null;
                        }
                        break;
                    case StatePosition.ParameterNavigator:
                        isEmpty = _state.ParameterNavigator.IsEmptyElement;
                        break;
                    case StatePosition.ParameterNodes:
                        isEmpty = _macro.Parameters[_state.ParameterIndex].NavigatorValue == null;
                        break;
                    case StatePosition.ParameterAttribute:
                    case StatePosition.ParameterText:
                    case StatePosition.Root:
                        throw new InvalidOperationException(&quot;Not an element.&quot;);
                    default:
                        throw new InvalidOperationException(&quot;Invalid position.&quot;);
                }

                DebugReturn(isEmpty);
                return isEmpty;
            }
        }

        /// &lt;summary&gt;
        /// Determines whether the current XPathNavigator is at the same position as the specified XPathNavigator.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;nav&quot;&gt;The XPathNavigator to compare to this XPathNavigator.&lt;/param&gt;
        /// &lt;returns&gt;true if the two XPathNavigator objects have the same position; otherwise, false.&lt;/returns&gt;
        public override bool IsSamePosition(XPathNavigator nav)
        {
            DebugEnter(&quot;IsSamePosition&quot;);
            bool isSame;

            switch (_state.Position)
            {
                case StatePosition.ParameterNavigator:
                case StatePosition.Macro:
                case StatePosition.Parameter:
                case StatePosition.ParameterAttribute:
                case StatePosition.ParameterNodes:
                case StatePosition.ParameterText:
                case StatePosition.Root:
                    var other = nav as MacroNavigator;
                    isSame = other != null &amp;&amp; other._macro == _macro &amp;&amp; _state.IsSamePosition(other._state);
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(isSame);
            return isSame;
        }

        /// &lt;summary&gt;
        /// Gets the qualified name of the current node.
        /// &lt;/summary&gt;
        public override string Name
        {
            get
            {
                DebugEnter(&quot;Name&quot;);
                string name;

                switch (_state.Position)
                {
                    case StatePosition.Macro:
                        name = &quot;macro&quot;;
                        break;
                    case StatePosition.Parameter:
                        name = _macro.Parameters[_state.ParameterIndex].Name;
                        break;
                    case StatePosition.ParameterAttribute:
                        name = _macro.Parameters[_state.ParameterIndex].Attributes[_state.ParameterAttributeIndex].Key;
                        break;
                    case StatePosition.ParameterNavigator:
                        name = _state.ParameterNavigator.Name;
                        break;
                    case StatePosition.ParameterNodes:
                        name = &quot;nodes&quot;;
                        break;
                    case StatePosition.ParameterText:
                    case StatePosition.Root:
                        name = string.Empty;
                        break;
                    default:
                        throw new InvalidOperationException(&quot;Invalid position.&quot;);
                }

                DebugReturn(&quot;\&quot;{0}\&quot;&quot;, name);
                return name;
            }
        }

        /// &lt;summary&gt;
        /// Gets the Name of the current node without any namespace prefix.
        /// &lt;/summary&gt;
        public override string LocalName
        {
            get
            {
                DebugEnter(&quot;LocalName&quot;);
                var name = Name;
                DebugReturn(&quot;\&quot;{0}\&quot;&quot;, name);
                return name;
            }
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the same position as the specified XPathNavigator.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;nav&quot;&gt;The XPathNavigator positioned on the node that you want to move to. &lt;/param&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the same position as the specified XPathNavigator;
        /// otherwise, false. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveTo(XPathNavigator nav)
        {
            DebugEnter(&quot;MoveTo&quot;);

            var other = nav as MacroNavigator;
            var succ = false;

            if (other != null &amp;&amp; other._macro == _macro)
            {
                _state = other._state.Clone();
                DebugState();
                succ = true;
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the first attribute of the current node.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the first attribute of the current node;
        /// otherwise, false. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToFirstAttribute()
        {
            DebugEnter(&quot;MoveToFirstAttribute&quot;);
            bool succ;

            switch (_state.Position)
            {
                case StatePosition.ParameterNavigator:
                    succ = _state.ParameterNavigator.MoveToFirstAttribute();
                    break;
                case StatePosition.Parameter:
                    if (_macro.Parameters[_state.ParameterIndex].Attributes != null)
                    {
                        _state.Position = StatePosition.ParameterAttribute;
                        _state.ParameterAttributeIndex = 0;
                        succ = true;
                        DebugState();
                    }
                    else succ = false;
                    break;
                case StatePosition.ParameterAttribute:
                case StatePosition.ParameterNodes:
                case StatePosition.Macro:
                case StatePosition.ParameterText:
                case StatePosition.Root:
                    succ = false;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the first child node of the current node.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the first child node of the current node;
        /// otherwise, false. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToFirstChild()
        {
            DebugEnter(&quot;MoveToFirstChild&quot;);
            bool succ;

            switch (_state.Position)
            {
                case StatePosition.Macro:
                    if (_macro.Parameters.Length == 0)
                    {
                        succ = false;
                    }
                    else
                    {
                        _state.ParameterIndex = 0;
                        _state.Position = StatePosition.Parameter;
                        succ = true;
                    }
                    break;
                case StatePosition.Parameter:
                    var parameter = _macro.Parameters[_state.ParameterIndex];
                    var nav = parameter.NavigatorValue;
                    if (parameter.WrapNavigatorInNodes)
                    {
                        _state.Position = StatePosition.ParameterNodes;
                        DebugState();
                        succ = true;
                    }
                    else if (nav != null)
                    {
                        nav = nav.Clone(); // never use the raw parameter&#39;s navigator
                        nav.MoveToFirstChild();
                        _state.ParameterNavigator = nav;
                        _state.ParameterNavigatorDepth = 0;
                        _state.Position = StatePosition.ParameterNavigator;
                        DebugState();
                        succ = true;
                    }
                    else
                    {
                        var s = _macro.Parameters[_state.ParameterIndex].StringValue;
                        if (s != null)
                        {
                            _state.Position = StatePosition.ParameterText;
                            DebugState();
                            succ = true;
                        }
                        else succ = false;
                    }
                    break;
                case StatePosition.ParameterNavigator:
                    if (_state.ParameterNavigatorDepth == _macro.Parameters[_state.ParameterIndex].MaxNavigatorDepth)
                    {
                        succ = false;
                    }
                    else
                    {
                        // move to first doc child =&gt; increment depth, else (property child) do nothing
                        succ = _state.ParameterNavigator.MoveToFirstChild();
                        if (succ &amp;&amp; IsDoc(_state.ParameterNavigator))
                        {
                            ++_state.ParameterNavigatorDepth;
                            DebugState();
                        }
                    }
                    break;
                case StatePosition.ParameterNodes:
                    if (_macro.Parameters[_state.ParameterIndex].NavigatorValue != null)
                    {
                        // never use the raw parameter&#39;s navigator
                        _state.ParameterNavigator = _macro.Parameters[_state.ParameterIndex].NavigatorValue.Clone();
                        _state.Position = StatePosition.ParameterNavigator;
                        succ = true;
                        DebugState();
                    }
                    else succ = false;
                    break;
                case StatePosition.ParameterAttribute:
                case StatePosition.ParameterText:
                    succ = false;
                    break;
                case StatePosition.Root:
                    _state.Position = StatePosition.Macro;
                    DebugState();
                    succ = true;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the first namespace node that matches the XPathNamespaceScope specified.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;namespaceScope&quot;&gt;An XPathNamespaceScope value describing the namespace scope. &lt;/param&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the first namespace node;
        /// otherwise, false. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope)
        {
            DebugEnter(&quot;MoveToFirstNamespace&quot;);
            DebugReturn(false);
            return false;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the next namespace node matching the XPathNamespaceScope specified.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;namespaceScope&quot;&gt;An XPathNamespaceScope value describing the namespace scope. &lt;/param&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the next namespace node;
        /// otherwise, false. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToNextNamespace(XPathNamespaceScope namespaceScope)
        {
            DebugEnter(&quot;MoveToNextNamespace&quot;);
            DebugReturn(false);
            return false;
        }

        /// &lt;summary&gt;
        /// Moves to the node that has an attribute of type ID whose value matches the specified String.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;id&quot;&gt;A String representing the ID value of the node to which you want to move.&lt;/param&gt;
        /// &lt;returns&gt;true if the XPathNavigator is successful moving; otherwise, false.
        /// If false, the position of the navigator is unchanged.&lt;/returns&gt;
        public override bool MoveToId(string id)
        {
            DebugEnter(&quot;MoveToId&quot;);
            // impossible to implement since parameters can contain duplicate fragments of the
            // main xml and therefore there can be duplicate unique node identifiers.
            DebugReturn(&quot;NotImplementedException&quot;);
            throw new NotImplementedException();
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the next sibling node of the current node.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;true if the XPathNavigator is successful moving to the next sibling node;
        /// otherwise, false if there are no more siblings or if the XPathNavigator is currently
        /// positioned on an attribute node. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToNext()
        {
            DebugEnter(&quot;MoveToNext&quot;);
            bool succ;

            switch (_state.Position)
            {
                case StatePosition.Parameter:
                    if (_state.ParameterIndex == _macro.Parameters.Length - 1)
                    {
                        succ = false;
                    }
                    else
                    {
                        ++_state.ParameterIndex;
                        DebugState();
                        succ = true;
                    }
                    break;
                case StatePosition.ParameterNavigator:
                    var wasDoc = IsDoc(_state.ParameterNavigator);
                    succ = _state.ParameterNavigator.MoveToNext();
                    if (succ &amp;&amp; !wasDoc &amp;&amp; IsDoc(_state.ParameterNavigator))
                    {
                        // move to first doc child =&gt; increment depth, else (another property child) do nothing
                        if (_state.ParameterNavigatorDepth == _macro.Parameters[_state.ParameterIndex].MaxNavigatorDepth)
                        {
                            _state.ParameterNavigator.MoveToPrevious();
                            succ = false;
                        }
                        else
                        {
                            ++_state.ParameterNavigatorDepth;
                            DebugState();
                        }
                    }
                    break;
                case StatePosition.ParameterNodes:
                case StatePosition.ParameterAttribute:
                case StatePosition.ParameterText:
                case StatePosition.Macro:
                case StatePosition.Root:
                    succ = false;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the previous sibling node of the current node.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the previous sibling node;
        /// otherwise, false if there is no previous sibling node or if the XPathNavigator is currently
        /// positioned on an attribute node. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToPrevious()
        {
            DebugEnter(&quot;MoveToPrevious&quot;);
            bool succ;

            switch (_state.Position)
            {
                case StatePosition.Parameter:
                    if (_state.ParameterIndex == -1)
                    {
                        succ = false;
                    }
                    else
                    {
                        --_state.ParameterIndex;
                        DebugState();
                        succ = true;
                    }
                    break;
                case StatePosition.ParameterNavigator:
                    var wasDoc = IsDoc(_state.ParameterNavigator);
                    succ = _state.ParameterNavigator.MoveToPrevious();
                    if (succ &amp;&amp; wasDoc &amp;&amp; !IsDoc(_state.ParameterNavigator))
                    {
                        // move from doc child back to property child =&gt; decrement depth
                        --_state.ParameterNavigatorDepth;
                        DebugState();
                    }
                    break;
                case StatePosition.ParameterAttribute:
                case StatePosition.ParameterNodes:
                case StatePosition.ParameterText:
                case StatePosition.Macro:
                case StatePosition.Root:
                    succ = false;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the next attribute.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the next attribute;
        /// false if there are no more attributes. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToNextAttribute()
        {
            DebugEnter(&quot;MoveToNextAttribute&quot;);
            bool succ;

            switch (_state.Position)
            {
                case StatePosition.ParameterNavigator:
                    succ = _state.ParameterNavigator.MoveToNextAttribute();
                    break;
                case StatePosition.ParameterAttribute:
                    if (_state.ParameterAttributeIndex == _macro.Parameters[_state.ParameterIndex].Attributes.Length - 1)
                        succ = false;
                    else
                    {
                        ++_state.ParameterAttributeIndex;
                        DebugState();
                        succ = true;
                    }
                    break;
                case StatePosition.Parameter:
                case StatePosition.ParameterNodes:
                case StatePosition.ParameterText:
                case StatePosition.Macro:
                case StatePosition.Root:
                    succ = false;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the parent node of the current node.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the parent node of the current node;
        /// otherwise, false. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToParent()
        {
            DebugEnter(&quot;MoveToParent&quot;);
            bool succ;

            switch (_state.Position)
            {
                case StatePosition.Macro:
                    _state.Position = StatePosition.Root;
                    DebugState();
                    succ = true;
                    break;
                case StatePosition.Parameter:
                    _state.Position = StatePosition.Macro;
                    DebugState();
                    succ = true;
                    break;
                case StatePosition.ParameterAttribute:
                case StatePosition.ParameterNodes:
                    _state.Position = StatePosition.Parameter;
                    DebugState();
                    succ = true;
                    break;
                case StatePosition.ParameterNavigator:
                    var wasDoc = IsDoc(_state.ParameterNavigator);
                    succ = _state.ParameterNavigator.MoveToParent();
                    if (succ)
                    {
                        // move from doc child =&gt; decrement depth
                        if (wasDoc &amp;&amp; --_state.ParameterNavigatorDepth == 0)
                        {
                            _state.Position = StatePosition.Parameter;
                            _state.ParameterNavigator = null;
                            DebugState();
                        }
                    }
                    break;
                case StatePosition.ParameterText:
                    _state.Position = StatePosition.Parameter;
                    DebugState();
                    succ = true;
                    break;
                case StatePosition.Root:
                    succ = false;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the root node that the current node belongs to.
        /// &lt;/summary&gt;
        public override void MoveToRoot()
        {
            DebugEnter(&quot;MoveToRoot&quot;);

            switch (_state.Position)
            {
                case StatePosition.ParameterNavigator:
                    _state.ParameterNavigator = null;
                    _state.ParameterNavigatorDepth = -1;
                    break;
                case StatePosition.Parameter:
                case StatePosition.ParameterText:
                    _state.ParameterIndex = -1;
                    break;
                case StatePosition.ParameterAttribute:
                case StatePosition.ParameterNodes:
                case StatePosition.Macro:
                case StatePosition.Root:
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            _state.Position = StatePosition.Root;
            DebugState();

            DebugReturn();
        }

        /// &lt;summary&gt;
        /// Gets the base URI for the current node.
        /// &lt;/summary&gt;
        public override string BaseURI
        {
            get { return string.Empty; }
        }

        /// &lt;summary&gt;
        /// Gets the XmlNameTable of the XPathNavigator.
        /// &lt;/summary&gt;
        public override XmlNameTable NameTable
        {
            get { return _nameTable; }
        }

        /// &lt;summary&gt;
        /// Gets the namespace URI of the current node.
        /// &lt;/summary&gt;
        public override string NamespaceURI
        {
            get { return string.Empty; }
        }

        /// &lt;summary&gt;
        /// Gets the XPathNodeType of the current node.
        /// &lt;/summary&gt;
        public override XPathNodeType NodeType
        {
            get
            {
                DebugEnter(&quot;NodeType&quot;);
                XPathNodeType type;

                switch (_state.Position)
                {
                    case StatePosition.Macro:
                    case StatePosition.Parameter:
                    case StatePosition.ParameterNodes:
                        type = XPathNodeType.Element;
                        break;
                    case StatePosition.ParameterNavigator:
                        type = _state.ParameterNavigator.NodeType;
                        break;
                    case StatePosition.ParameterAttribute:
                        type = XPathNodeType.Attribute;
                        break;
                    case StatePosition.ParameterText:
                        type = XPathNodeType.Text;
                        break;
                    case StatePosition.Root:
                        type = XPathNodeType.Root;
                        break;
                    default:
                        throw new InvalidOperationException(&quot;Invalid position.&quot;);
                }

                DebugReturn(&quot;\&#39;{0}\&#39;&quot;, type);
                return type;
            }
        }

        /// &lt;summary&gt;
        /// Gets the namespace prefix associated with the current node.
        /// &lt;/summary&gt;
        public override string Prefix
        {
            get { return string.Empty; }
        }

        /// &lt;summary&gt;
        /// Gets the string value of the item.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Does not fully behave as per the specs, as we report empty value on root and macro elements, and we start
        /// reporting values only on parameter elements. This is because, otherwise, we would might dump the whole database
        /// and it probably does not make sense at Umbraco level.&lt;/remarks&gt;
        public override string Value
        {
            get
            {
                DebugEnter(&quot;Value&quot;);
                string value;

                XPathNavigator nav;
                switch (_state.Position)
                {
                    case StatePosition.Parameter:
                        nav = _macro.Parameters[_state.ParameterIndex].NavigatorValue;
                        if (nav != null)
                        {
                            nav = nav.Clone(); // never use the raw parameter&#39;s navigator
                            nav.MoveToFirstChild();
                            value = nav.Value;
                        }
                        else
                        {
                            var s = _macro.Parameters[_state.ParameterIndex].StringValue;
                            value = s ?? string.Empty;
                        }
                        break;
                    case StatePosition.ParameterAttribute:
                        value = _macro.Parameters[_state.ParameterIndex].Attributes[_state.ParameterAttributeIndex].Value;
                        break;
                    case StatePosition.ParameterNavigator:
                        value = _state.ParameterNavigator.Value;
                        break;
                    case StatePosition.ParameterNodes:
                        nav = _macro.Parameters[_state.ParameterIndex].NavigatorValue;
                        if (nav == null)
                            value = string.Empty;
                        else
                        {
                            nav = nav.Clone(); // never use the raw parameter&#39;s navigator
                            nav.MoveToFirstChild();
                            value = nav.Value;
                        }
                        break;
                    case StatePosition.ParameterText:
                        value = _macro.Parameters[_state.ParameterIndex].StringValue;
                        break;
                    case StatePosition.Macro:
                    case StatePosition.Root:
                        value = string.Empty;
                        break;
                    default:
                        throw new InvalidOperationException(&quot;Invalid position.&quot;);
                }

                DebugReturn(&quot;\&quot;{0}\&quot;&quot;, value);
                return value;
            }
        }

        private static bool IsDoc(XPathNavigator nav)
        {
            if (nav.NodeType != XPathNodeType.Element)
                return false;

            var clone = nav.Clone();
            if (!clone.MoveToFirstAttribute())
                return false;
            do
            {
                if (clone.Name == &quot;isDoc&quot;)
                    return true;
            } while (clone.MoveToNextAttribute());

            return false;
        }

        #region State management

        // the possible state positions
        internal enum StatePosition
        {
            Root,
            Macro,
            Parameter,
            ParameterAttribute,
            ParameterText,
            ParameterNodes,
            ParameterNavigator
        };

        // gets the state
        // for unit tests only
        internal State InternalState { get { return _state; } }

        // represents the XPathNavigator state
        internal class State
        {
            public StatePosition Position { get; set; }

            // initialize a new state
            private State(StatePosition position)
            {
                Position = position;
                ParameterIndex = 0;
                ParameterNavigatorDepth = 0;
                ParameterAttributeIndex = 0;
            }

            // initialize a new state
            // used for creating the very first state
            public State()
                : this(StatePosition.Root)
            { }

            // initialize a clone state
            private State(State other)
            {
                Position = other.Position;

                ParameterIndex = other.ParameterIndex;

                if (Position == StatePosition.ParameterNavigator)
                {
                    ParameterNavigator = other.ParameterNavigator.Clone();
                    ParameterNavigatorDepth = other.ParameterNavigatorDepth;
                    ParameterAttributeIndex = other.ParameterAttributeIndex;
                }
            }

            public State Clone()
            {
                return new State(this);
            }

            // the index of the current element
            public int ParameterIndex { get; set; }

            // the current depth within the element navigator
            public int ParameterNavigatorDepth { get; set; }

            // the index of the current element&#39;s attribute
            public int ParameterAttributeIndex { get; set; }

            // gets or sets the element navigator
            public XPathNavigator ParameterNavigator { get; set; }

            // gets a value indicating whether this state is at the same position as another one.
            public bool IsSamePosition(State other)
            {
                return other.Position == Position 
                    &amp;&amp; (Position != StatePosition.ParameterNavigator || other.ParameterNavigator.IsSamePosition(ParameterNavigator))
                    &amp;&amp; other.ParameterIndex == ParameterIndex
                    &amp;&amp; other.ParameterAttributeIndex == ParameterAttributeIndex;
            }
        }

        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[26,15,26,76,1],[27,9,27,10,1],[27,11,27,12,1],[37,9,37,85,1],[38,9,38,10,1],[39,13,39,28,1],[40,13,40,36,1],[41,13,41,28,1],[42,9,42,10,1],[56,9,56,46,1],[58,9,58,60,1],[60,9,60,10,1],[61,13,61,24,1],[62,13,62,14,1],[63,17,63,32,1],[65,9,65,10,1],[70,9,70,10,1],[72,13,72,23,1],[73,13,73,29,1],[74,13,74,25,1],[75,13,75,54,1],[77,9,77,10,1],[81,9,81,10,1],[83,13,83,62,1],[85,9,85,10,1],[89,9,89,10,1],[92,13,92,35,1],[95,9,95,10,1],[99,9,99,10,1],[101,13,101,51,1],[103,9,103,10,1],[107,9,107,10,1],[109,13,109,41,1],[110,13,110,27,1],[110,28,110,39,1],[112,9,112,10,1],[116,9,116,10,1],[120,13,120,37,1],[123,21,123,44,1],[124,21,124,27,1],[126,21,127,72,1],[128,21,128,27,1],[130,21,132,114,0],[133,21,133,27,0],[135,21,137,104,1],[138,21,138,27,1],[140,21,141,72,0],[142,21,142,27,0],[144,21,145,72,0],[146,21,146,27,0],[148,21,148,43,1],[149,21,149,27,1],[151,21,151,78,0],[154,13,154,48,1],[156,9,156,10,1],[160,9,160,10,1],[163,13,163,94,1],[165,13,165,51,1],[169,9,169,10,1],[178,13,178,69,1],[179,13,179,14,1],[180,17,180,98,1],[181,13,181,14,1],[183,50,183,54,1],[183,55,183,67,1],[191,13,191,61,0],[192,13,192,14,0],[193,17,193,29,0],[194,17,194,37,0],[195,13,195,14,0],[197,13,200,77,1],[201,13,201,14,1],[202,17,202,29,1],[203,17,203,55,1],[204,17,204,61,1],[205,17,205,40,1],[206,17,206,18,0],[207,21,207,50,0],[208,21,208,38,0],[209,25,209,40,0],[210,17,210,18,0],[211,17,211,44,1],[212,13,212,14,1],[214,34,214,38,1],[214,39,214,51,1],[215,41,215,45,0],[215,46,215,58,0],[216,52,216,56,1],[216,57,216,69,1],[217,44,217,48,1],[217,49,217,61,1],[218,48,218,52,1],[218,53,218,65,1],[219,64,219,68,1],[219,69,219,81,0],[229,9,229,10,1],[230,13,230,33,1],[231,13,231,78,1],[232,13,232,30,1],[233,13,233,45,1],[234,13,234,24,1],[235,9,235,10,1],[243,13,243,14,0],[244,17,244,46,0],[247,17,247,41,0],[250,25,250,65,0],[251,25,251,31,0],[253,25,253,82,0],[254,25,254,60,0],[255,25,255,75,0],[256,25,256,26,0],[257,29,257,45,0],[258,25,258,26,0],[260,25,260,26,0],[261,29,261,90,0],[262,29,262,49,0],[263,25,263,26,0],[264,25,264,31,0],[266,25,266,76,0],[267,25,267,31,0],[269,25,269,99,0],[270,25,270,31,0],[274,25,274,80,0],[276,25,276,82,0],[279,17,279,38,0],[280,17,280,32,0],[281,13,281,14,0],[290,9,290,10,1],[291,13,291,42,1],[294,13,294,37,1],[303,21,303,55,1],[304,21,304,109,1],[305,21,305,27,1],[307,21,307,78,0],[310,13,310,33,1],[311,13,311,27,1],[312,9,312,10,1],[320,13,320,14,1],[321,17,321,36,1],[324,17,324,41,1],[327,25,327,40,1],[328,25,328,31,1],[330,25,330,78,1],[331,25,331,31,1],[333,25,333,120,0],[334,25,334,31,0],[336,25,336,63,1],[337,25,337,31,1],[339,25,339,40,0],[340,25,340,31,0],[343,25,343,45,0],[344,25,344,31,0],[346,25,346,82,0],[349,17,349,46,1],[350,17,350,29,1],[351,13,351,14,1],[360,13,360,14,1],[361,17,361,41,1],[362,17,362,33,1],[363,17,363,46,1],[364,17,364,29,1],[365,13,365,14,1],[375,9,375,10,1],[376,13,376,34,1],[378,13,378,47,1],[379,13,379,30,1],[381,13,381,57,1],[382,13,382,14,1],[383,17,383,47,1],[384,17,384,30,1],[385,17,385,29,1],[386,13,386,14,1],[388,13,388,31,1],[389,13,389,25,1],[390,9,390,10,1],[398,9,398,10,1],[399,13,399,48,1],[402,13,402,37,1],[405,21,405,77,1],[406,21,406,27,1],[408,21,408,85,1],[409,21,409,22,0],[410,25,410,76,0],[411,25,411,60,0],[412,25,412,37,0],[413,25,413,38,0],[414,21,414,22,0],[415,26,415,39,1],[416,21,416,27,1],[422,21,422,34,1],[423,21,423,27,1],[425,21,425,78,0],[428,13,428,31,1],[429,13,429,25,1],[430,9,430,10,1],[438,9,438,10,1],[439,13,439,44,1],[442,13,442,37,1],[445,21,445,55,1],[446,21,446,22,0],[447,25,447,38,0],[448,21,448,22,0],[450,21,450,22,1],[451,25,451,51,1],[452,25,452,67,1],[453,25,453,37,1],[454,21,454,22,1],[455,21,455,27,1],[457,21,457,78,1],[458,21,458,56,1],[459,21,459,56,1],[460,21,460,22,0],[461,25,461,72,0],[462,25,462,38,0],[463,25,463,37,0],[464,21,464,22,0],[465,26,465,42,1],[466,21,466,22,1],[467,25,467,43,1],[468,25,468,48,1],[469,25,469,57,1],[470,25,470,60,1],[471,25,471,76,1],[472,25,472,38,1],[473,25,473,37,1],[474,21,474,22,1],[476,21,476,22,0],[477,25,477,86,0],[478,25,478,39,0],[479,25,479,26,0],[480,29,480,75,0],[481,29,481,42,0],[482,29,482,41,0],[483,25,483,26,0],[484,30,484,43,0],[485,21,485,22,0],[486,21,486,27,1],[488,21,488,118,1],[489,21,489,22,0],[490,25,490,38,0],[491,21,491,22,0],[493,21,493,22,1],[495,25,495,77,1],[496,25,496,70,1],[497,25,497,26,1],[498,29,498,62,1],[499,29,499,42,1],[500,25,500,26,1],[501,21,501,22,1],[502,21,502,27,1],[504,21,504,89,0],[505,21,505,22,0],[507,25,507,117,0],[508,25,508,76,0],[509,25,509,37,0],[510,25,510,38,0],[511,21,511,22,0],[512,26,512,39,0],[513,21,513,27,0],[516,21,516,34,0],[517,21,517,27,0],[519,21,519,59,1],[520,21,520,34,1],[521,21,521,33,1],[522,21,522,27,1],[524,21,524,78,0],[527,13,527,31,1],[528,13,528,25,1],[529,9,529,10,1],[538,9,538,10,0],[539,13,539,48,0],[540,13,540,32,0],[541,13,541,26,0],[542,9,542,10,0],[551,9,551,10,0],[552,13,552,47,0],[553,13,553,32,0],[554,13,554,26,0],[555,9,555,10,0],[564,9,564,10,0],[565,13,565,36,0],[568,13,568,52,0],[569,13,569,49,0],[579,9,579,10,1],[580,13,580,38,1],[583,13,583,37,1],[586,21,586,79,1],[587,21,587,22,1],[588,25,588,38,1],[589,21,589,22,1],[591,21,591,22,0],[592,25,592,49,0],[593,25,593,38,0],[594,25,594,37,0],[595,21,595,22,0],[596,21,596,27,1],[598,21,598,67,1],[599,21,599,67,1],[600,21,600,77,1],[601,21,601,22,1],[603,25,603,122,1],[604,25,604,26,0],[605,29,605,72,0],[606,29,606,42,0],[607,25,607,26,0],[609,25,609,26,1],[610,29,610,62,1],[611,29,611,42,1],[612,25,612,26,1],[613,21,613,22,1],[614,21,614,27,1],[620,21,620,34,1],[621,21,621,27,1],[623,21,623,78,0],[626,13,626,31,1],[627,13,627,25,1],[628,9,628,10,1],[637,9,637,10,0],[638,13,638,42,0],[641,13,641,37,0],[644,21,644,53,0],[645,21,645,22,0],[646,25,646,38,0],[647,21,647,22,0],[649,21,649,22,0],[650,25,650,49,0],[651,25,651,38,0],[652,25,652,37,0],[653,21,653,22,0],[654,21,654,27,0],[656,21,656,67,0],[657,21,657,71,0],[658,21,658,77,0],[659,21,659,22,0],[661,25,661,58,0],[662,25,662,38,0],[663,21,663,22,0],[664,21,664,27,0],[670,21,670,34,0],[671,21,671,27,0],[673,21,673,78,0],[676,13,676,31,0],[677,13,677,25,0],[678,9,678,10,0],[686,9,686,10,1],[687,13,687,47,1],[690,13,690,37,1],[693,21,693,76,1],[694,21,694,27,1],[696,21,696,122,0],[697,25,697,38,0],[699,21,699,22,0],[700,25,700,58,0],[701,25,701,38,0],[702,25,702,37,0],[703,21,703,22,0],[704,21,704,27,0],[710,21,710,34,0],[711,21,711,27,0],[713,21,713,78,0],[716,13,716,31,1],[717,13,717,25,1],[718,9,718,10,1],[726,9,726,10,1],[727,13,727,40,1],[730,13,730,37,1],[733,21,733,58,1],[734,21,734,34,1],[735,21,735,33,1],[736,21,736,27,1],[738,21,738,59,1],[739,21,739,34,1],[740,21,740,33,1],[741,21,741,27,1],[744,21,744,63,0],[745,21,745,34,0],[746,21,746,33,0],[747,21,747,27,0],[749,21,749,67,1],[750,21,750,69,1],[751,21,751,30,1],[752,21,752,22,1],[754,25,754,77,1],[755,25,755,26,1],[756,29,756,71,1],[757,29,757,62,1],[758,29,758,42,1],[759,25,759,26,1],[760,21,760,22,1],[761,21,761,27,1],[763,21,763,63,0],[764,21,764,34,0],[765,21,765,33,0],[766,21,766,27,0],[768,21,768,34,1],[769,21,769,27,1],[771,21,771,78,0],[774,13,774,31,1],[775,13,775,25,1],[776,9,776,10,1],[782,9,782,10,1],[783,13,783,38,1],[785,13,785,37,1],[788,21,788,54,0],[789,21,789,57,0],[790,21,790,27,0],[793,21,793,48,0],[794,21,794,27,0],[799,21,799,27,1],[801,21,801,78,0],[804,13,804,50,1],[805,13,805,26,1],[807,13,807,27,1],[808,9,808,10,1],[815,17,815,18,0],[815,19,815,39,0],[815,40,815,41,0],[823,17,823,18,1],[823,19,823,37,1],[823,38,823,39,1],[831,17,831,18,1],[831,19,831,39,1],[831,40,831,41,1],[840,13,840,14,1],[841,17,841,40,1],[844,17,844,41,1],[849,25,849,54,1],[850,25,850,31,1],[852,25,852,67,1],[853,25,853,31,1],[855,25,855,56,0],[856,25,856,31,0],[858,25,858,51,0],[859,25,859,31,0],[861,25,861,51,1],[862,25,862,31,1],[864,25,864,82,0],[867,17,867,46,1],[868,17,868,29,1],[869,13,869,14,1],[877,17,877,18,0],[877,19,877,39,0],[877,40,877,41,0],[889,13,889,14,1],[890,17,890,37,1],[894,17,894,41,1],[897,25,897,87,0],[898,25,898,41,0],[899,25,899,26,0],[900,29,900,47,0],[901,29,901,52,0],[902,29,902,47,0],[903,25,903,26,0],[905,25,905,26,0],[906,29,906,90,0],[907,29,907,55,0],[908,25,908,26,0],[909,25,909,31,0],[911,25,911,123,0],[912,25,912,31,0],[914,25,914,65,1],[915,25,915,31,1],[917,25,917,87,0],[918,25,918,41,0],[919,29,919,50,0],[921,25,921,26,0],[922,29,922,47,0],[923,29,923,52,0],[924,29,924,47,0],[925,25,925,26,0],[926,25,926,31,0],[928,25,928,86,0],[929,25,929,31,0],[932,25,932,46,0],[933,25,933,31,0],[935,25,935,82,0],[938,17,938,47,1],[939,17,939,30,1],[940,13,940,14,1],[944,9,944,10,1],[945,13,945,55,1],[946,17,946,30,1],[948,13,948,37,1],[949,13,949,47,1],[950,17,950,30,1],[952,13,952,14,1],[953,17,953,43,1],[954,21,954,33,1],[955,13,955,14,1],[955,15,955,51,1],[957,13,957,26,0],[958,9,958,10,1],[976,44,976,45,0],[976,46,976,60,0],[976,61,976,62,0],[981,45,981,49,1],[981,50,981,54,1],[984,13,984,50,1],[985,13,985,14,1],[986,17,986,37,1],[987,17,987,36,1],[988,17,988,45,1],[989,17,989,45,1],[990,13,990,14,1],[995,19,995,43,1],[996,13,996,14,1],[996,15,996,16,1],[999,13,999,39,1],[1000,13,1000,14,1],[1001,17,1001,43,1],[1003,17,1003,55,1],[1005,17,1005,66,1],[1006,17,1006,18,1],[1007,21,1007,75,1],[1008,21,1008,77,1],[1009,21,1009,77,1],[1010,17,1010,18,1],[1011,13,1011,14,1],[1014,13,1014,14,1],[1015,17,1015,40,1],[1016,13,1016,14,1],[1019,41,1019,45,1],[1019,46,1019,50,1],[1022,50,1022,54,1],[1022,55,1022,59,1],[1025,50,1025,54,1],[1025,55,1025,59,1],[1028,56,1028,60,1],[1028,61,1028,65,1],[1032,13,1032,14,1],[1033,17,1036,81,1],[1037,13,1037,14,1]]);
    </script>
  </body>
</html>