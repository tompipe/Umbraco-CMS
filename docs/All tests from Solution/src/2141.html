<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Logging\LogHelper.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Linq;
using System.Threading;
using System.Web;
using log4net;

namespace Umbraco.Core.Logging
{
    ///&lt;summary&gt;
	/// Used for logging, ILogger should be used instead but this is available for static access to logging
	///&lt;/summary&gt;
	/// &lt;remarks&gt;
    /// this wraps ILogger 
	/// &lt;/remarks&gt;
	public static class LogHelper
	{
		#region Error
		/// &lt;summary&gt;
		/// Adds an error log
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
		/// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;exception&quot;&gt;&lt;/param&gt;
		public static void Error&lt;T&gt;(string message, Exception exception)
		{
		    if (LoggerResolver.HasCurrent == false || LoggerResolver.Current.HasValue == false) return;
		    LoggerResolver.Current.Logger.Error&lt;T&gt;(message, exception);
		}

		public static void Error(Type callingType, string message, Exception exception)
		{
            if (LoggerResolver.HasCurrent == false || LoggerResolver.Current.HasValue == false) return;
            LoggerResolver.Current.Logger.Error(callingType, message, exception);
		}

		#endregion

		#region Warn		

		public static void Warn(Type callingType, string message, params Func&lt;object&gt;[] formatItems)
		{
            if (LoggerResolver.HasCurrent == false || LoggerResolver.Current.HasValue == false) return;
            LoggerResolver.Current.Logger.Warn(callingType, message, formatItems);
		}

        [Obsolete(&quot;Warnings with http trace should not be used. This method will be removed in future versions&quot;)]
		public static void Warn(Type callingType, string message, bool showHttpTrace, params Func&lt;object&gt;[] formatItems)
		{
			Mandate.ParameterNotNull(callingType, &quot;callingType&quot;);
			Mandate.ParameterNotNullOrEmpty(message, &quot;message&quot;);

			if (showHttpTrace &amp;&amp; HttpContext.Current != null)
			{
				HttpContext.Current.Trace.Warn(callingType.Name, string.Format(message, formatItems.Select(x =&gt; x.Invoke()).ToArray()));
			}

            if (LoggerResolver.HasCurrent == false || LoggerResolver.Current.HasValue == false) return;
            LoggerResolver.Current.Logger.Warn(callingType, message, formatItems);

		}

		public static void WarnWithException(Type callingType, string message, Exception e, params Func&lt;object&gt;[] formatItems)
		{
			WarnWithException(callingType, message, false, e, formatItems);
		}

        [Obsolete(&quot;Warnings with http trace should not be used. This method will be removed in future versions&quot;)]
		public static void WarnWithException(Type callingType, string message, bool showHttpTrace, Exception e, params Func&lt;object&gt;[] formatItems)
		{
			Mandate.ParameterNotNull(e, &quot;e&quot;);
			Mandate.ParameterNotNull(callingType, &quot;callingType&quot;);
			Mandate.ParameterNotNullOrEmpty(message, &quot;message&quot;);

			if (showHttpTrace &amp;&amp; HttpContext.Current != null)
			{
				HttpContext.Current.Trace.Warn(
					callingType.Name,
					string.Format(message, formatItems.Select(x =&gt; x.Invoke()).ToArray()), 
					e);
			}

            if (LoggerResolver.HasCurrent == false || LoggerResolver.Current.HasValue == false) return;
            LoggerResolver.Current.Logger.WarnWithException(callingType, message, e, formatItems);
		} 

		/// &lt;summary&gt;
		/// Adds a warn log
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
		/// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;formatItems&quot;&gt;&lt;/param&gt;
		public static void Warn&lt;T&gt;(string message, params Func&lt;object&gt;[] formatItems)
		{
			Warn(typeof(T), message, formatItems);
		}

        [Obsolete(&quot;Warnings with http trace should not be used. This method will be removed in future versions&quot;)]
		public static void Warn&lt;T&gt;(string message, bool showHttpTrace, params Func&lt;object&gt;[] formatItems)
		{
			Warn(typeof(T), message, showHttpTrace, formatItems);
		}

		public static void WarnWithException&lt;T&gt;(string message, Exception e, params Func&lt;object&gt;[] formatItems)
		{
			WarnWithException(typeof(T), message, e, formatItems);
		}

        [Obsolete(&quot;Warnings with http trace should not be used. This method will be removed in future versions&quot;)]
		public static void WarnWithException&lt;T&gt;(string message, bool showHttpTrace, Exception e, params Func&lt;object&gt;[] formatItems)
		{
			WarnWithException(typeof(T), message, showHttpTrace, e, formatItems);
		} 

		#endregion

		#region Info
		/// &lt;summary&gt;
		/// Traces a message, only generating the message if tracing is actually enabled. Use this method to avoid calling any long-running methods such as &quot;ToDebugString&quot; if logging is disabled.
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
		/// &lt;param name=&quot;generateMessage&quot;&gt;The delegate to generate a message.&lt;/param&gt;
		/// &lt;remarks&gt;&lt;/remarks&gt;
		public static void Info&lt;T&gt;(Func&lt;string&gt; generateMessage)
		{
			Info(typeof(T), generateMessage);
		}

		/// &lt;summary&gt;
		/// Traces if tracing is enabled.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;callingType&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;generateMessage&quot;&gt;&lt;/param&gt;
		public static void Info(Type callingType, Func&lt;string&gt; generateMessage)
		{
            if (LoggerResolver.HasCurrent == false || LoggerResolver.Current.HasValue == false) return;
            LoggerResolver.Current.Logger.Info(callingType, generateMessage);
		}

		/// &lt;summary&gt;
		/// Traces if tracing is enabled.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;type&quot;&gt;The type for the logging namespace.&lt;/param&gt;
		/// &lt;param name=&quot;generateMessageFormat&quot;&gt;The message format.&lt;/param&gt;
		/// &lt;param name=&quot;formatItems&quot;&gt;The format items.&lt;/param&gt;
		public static void Info(Type type, string generateMessageFormat, params Func&lt;object&gt;[] formatItems)
		{
            if (LoggerResolver.HasCurrent == false || LoggerResolver.Current.HasValue == false) return;
            LoggerResolver.Current.Logger.Info(type, generateMessageFormat, formatItems);
		}

		/// &lt;summary&gt;
		/// Traces a message, only generating the message if tracing is actually enabled. Use this method to avoid calling any long-running methods such as &quot;ToDebugString&quot; if logging is disabled.
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
		/// &lt;param name=&quot;generateMessageFormat&quot;&gt;The generate message format.&lt;/param&gt;
		/// &lt;param name=&quot;formatItems&quot;&gt;The format items.&lt;/param&gt;
		/// &lt;remarks&gt;&lt;/remarks&gt;
		public static void Info&lt;T&gt;(string generateMessageFormat, params Func&lt;object&gt;[] formatItems)
		{
			Info(typeof(T), generateMessageFormat, formatItems);
		} 
		#endregion

		#region Debug
		/// &lt;summary&gt;
		/// Debugs a message, only generating the message if tracing is actually enabled. Use this method to avoid calling any long-running methods such as &quot;ToDebugString&quot; if logging is disabled.
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
		/// &lt;param name=&quot;generateMessage&quot;&gt;The delegate to generate a message.&lt;/param&gt;
		/// &lt;remarks&gt;&lt;/remarks&gt;
		public static void Debug&lt;T&gt;(Func&lt;string&gt; generateMessage)
		{
			Debug(typeof(T), generateMessage);
		}

		/// &lt;summary&gt;
		/// Debugs if tracing is enabled.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;callingType&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;generateMessage&quot;&gt;&lt;/param&gt;
		public static void Debug(Type callingType, Func&lt;string&gt; generateMessage)
		{
            if (LoggerResolver.HasCurrent == false || LoggerResolver.Current.HasValue == false) return;
            LoggerResolver.Current.Logger.Debug(callingType, generateMessage);
		}

		/// &lt;summary&gt;
		/// Debugs if tracing is enabled.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;type&quot;&gt;The type for the logging namespace.&lt;/param&gt;
		/// &lt;param name=&quot;generateMessageFormat&quot;&gt;The message format.&lt;/param&gt;
		/// &lt;param name=&quot;formatItems&quot;&gt;The format items.&lt;/param&gt;
		public static void Debug(Type type, string generateMessageFormat, params Func&lt;object&gt;[] formatItems)
		{
            if (LoggerResolver.HasCurrent == false || LoggerResolver.Current.HasValue == false) return;
            LoggerResolver.Current.Logger.Debug(type, generateMessageFormat, formatItems);
		}

		/// &lt;summary&gt;
		/// Debugs a message, only generating the message if debug is actually enabled. Use this method to avoid calling any long-running methods such as &quot;ToDebugString&quot; if logging is disabled.
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
		/// &lt;param name=&quot;generateMessageFormat&quot;&gt;The generate message format.&lt;/param&gt;
		/// &lt;param name=&quot;formatItems&quot;&gt;The format items.&lt;/param&gt;
		/// &lt;remarks&gt;&lt;/remarks&gt;
		public static void Debug&lt;T&gt;(string generateMessageFormat, params Func&lt;object&gt;[] formatItems)
		{
			Debug(typeof(T), generateMessageFormat, formatItems);
		}

		/// &lt;summary&gt;
		/// Debugs a message and also writes to the TraceContext specified, useful for when you would like the debug
		/// output also displayed in the Http trace output.
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
		/// &lt;param name=&quot;generateMessageFormat&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;showHttpTrace&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;formatItems&quot;&gt;&lt;/param&gt;
        [Obsolete(&quot;Warnings with http trace should not be used. This method will be removed in future versions&quot;)]
		public static void Debug&lt;T&gt;(string generateMessageFormat, bool showHttpTrace, params Func&lt;object&gt;[] formatItems)
		{
			if (showHttpTrace &amp;&amp; HttpContext.Current != null)
			{
				HttpContext.Current.Trace.Write(
					typeof(T).Name,
					string.Format(generateMessageFormat, formatItems.Select(x =&gt; x()).ToArray()));	
			}			
			Debug(typeof(T), generateMessageFormat, formatItems);
		}

		#endregion
		
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[25,3,25,4,1],[26,7,26,90,1],[26,91,26,98,1],[27,7,27,66,0],[28,3,28,4,1],[31,3,31,4,0],[32,13,32,96,0],[32,97,32,104,0],[33,13,33,82,0],[34,3,34,4,0],[41,3,41,4,1],[42,13,42,96,1],[42,97,42,104,1],[43,13,43,83,0],[44,3,44,4,1],[48,3,48,4,0],[49,4,49,57,0],[50,4,50,56,0],[52,4,52,53,0],[53,4,53,5,0],[54,5,54,101,0],[54,101,54,111,0],[54,111,54,125,0],[54,5,54,125,0],[55,4,55,5,0],[57,13,57,96,0],[57,97,57,104,0],[58,13,58,83,0],[60,3,60,4,0],[63,3,63,4,1],[64,4,64,67,1],[65,3,65,4,1],[69,3,69,4,1],[70,4,70,37,1],[71,4,71,57,1],[72,4,72,56,1],[74,4,74,53,1],[75,4,75,5,0],[76,5,78,53,0],[78,53,78,63,0],[78,63,79,9,0],[76,5,79,9,0],[80,4,80,5,0],[82,13,82,96,1],[82,97,82,104,1],[83,13,83,99,0],[84,3,84,4,1],[93,3,93,4,1],[94,4,94,42,1],[95,3,95,4,1],[99,3,99,4,0],[100,4,100,57,0],[101,3,101,4,0],[104,3,104,4,0],[105,4,105,58,0],[106,3,106,4,0],[110,3,110,4,0],[111,4,111,73,0],[112,3,112,4,0],[124,3,124,4,0],[125,4,125,37,0],[126,3,126,4,0],[134,3,134,4,0],[135,13,135,96,0],[135,97,135,104,0],[136,13,136,78,0],[137,3,137,4,0],[146,3,146,4,1],[147,13,147,96,1],[147,97,147,104,1],[148,13,148,90,0],[149,3,149,4,1],[159,3,159,4,1],[160,4,160,56,1],[161,3,161,4,1],[172,3,172,4,0],[173,4,173,38,0],[174,3,174,4,0],[182,3,182,4,0],[183,13,183,96,0],[183,97,183,104,0],[184,13,184,79,0],[185,3,185,4,0],[194,3,194,4,1],[195,13,195,96,1],[195,97,195,104,1],[196,13,196,91,1],[197,3,197,4,1],[207,3,207,4,1],[208,4,208,57,1],[209,3,209,4,1],[221,3,221,4,0],[222,4,222,53,0],[223,4,223,5,0],[224,5,226,67,0],[226,67,226,70,0],[226,70,226,84,0],[224,5,226,84,0],[227,4,227,5,0],[228,4,228,57,0],[229,3,229,4,0]]);
    </script>
  </body>
</html>