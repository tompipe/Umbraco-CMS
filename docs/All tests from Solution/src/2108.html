<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Models\PublishedContent\PublishedPropertyType.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Xml.Linq;
using System.Xml.XPath;
using Umbraco.Core.Dynamics;
using Umbraco.Core.PropertyEditors;

namespace Umbraco.Core.Models.PublishedContent
{
    /// &lt;summary&gt;
    /// Represents an &lt;see cref=&quot;IPublishedProperty&quot;/&gt; type.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;Instances of the &lt;see cref=&quot;PublishedPropertyType&quot;/&gt; class are immutable, ie
    /// if the property type changes, then a new class needs to be created.&lt;/remarks&gt;
    public class PublishedPropertyType
    {
        #region Constructors

        // clone
        private PublishedPropertyType(PublishedPropertyType orig)
        {
            ContentType = orig.ContentType;
            PropertyTypeAlias = orig.PropertyTypeAlias;
            DataTypeId = orig.DataTypeId;
            PropertyEditorAlias = orig.PropertyEditorAlias;
            _converter = orig._converter;
            _sourceCacheLevel = orig._sourceCacheLevel;
            _objectCacheLevel = orig._objectCacheLevel;
            _xpathCacheLevel = orig._xpathCacheLevel;
            _clrType = orig._clrType;

            // do NOT copy the reduced cache levels
            // as we should NOT clone a nested / detached type
        }

        /// &lt;summary&gt;
        /// Initialize a new instance of the &lt;see cref=&quot;PublishedPropertyType&quot;/&gt; class within a &lt;see cref=&quot;PublishedContentType&quot;/&gt;,
        /// with a &lt;see cref=&quot;PropertyType&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;contentType&quot;&gt;The published content type.&lt;/param&gt;
        /// &lt;param name=&quot;propertyType&quot;&gt;The property type.&lt;/param&gt;
        /// &lt;remarks&gt;The new published property type belongs to the published content type and corresponds to the property type.&lt;/remarks&gt;
        public PublishedPropertyType(PublishedContentType contentType, PropertyType propertyType)
        {
            // PropertyEditor [1:n] DataTypeDefinition [1:n] PropertyType

            ContentType = contentType;
            PropertyTypeAlias = propertyType.Alias;

            DataTypeId = propertyType.DataTypeDefinitionId;
            PropertyEditorAlias = propertyType.PropertyEditorAlias;

            InitializeConverters();
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;PublishedPropertyType&quot;/&gt; class with an existing &lt;see cref=&quot;PublishedPropertyType&quot;/&gt;
        /// and a new property type alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyTypeAlias&quot;&gt;The new property type alias.&lt;/param&gt;
        /// &lt;param name=&quot;propertyType&quot;&gt;The existing published property type.&lt;/param&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The new published property type does not belong to a published content type.&lt;/para&gt;
        /// &lt;para&gt;It is a copy of the initial published property type, with a different alias.&lt;/para&gt;
        /// &lt;/remarks&gt;
        internal PublishedPropertyType(string propertyTypeAlias, PublishedPropertyType propertyType)
            : this(propertyTypeAlias, propertyType.DataTypeId, propertyType.PropertyEditorAlias)
        { }


        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;PublishedPropertyType&quot;/&gt; class with a property type alias and a property editor alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyTypeAlias&quot;&gt;The property type alias.&lt;/param&gt;
        /// &lt;param name=&quot;propertyEditorAlias&quot;&gt;The property editor alias.&lt;/param&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The new published property type does not belong to a published content type.&lt;/para&gt;
        /// &lt;para&gt;It is based upon the property editor, but has no datatype definition. This will work as long
        /// as the datatype definition is not required to process (eg to convert) the property values. For
        /// example, this may not work if the related IPropertyValueConverter requires the datatype definition
        /// to make decisions, fetch prevalues, etc.&lt;/para&gt;
        /// &lt;para&gt;The value of &lt;paramref name=&quot;propertyEditorAlias&quot;/&gt; is assumed to be valid.&lt;/para&gt;
        /// &lt;/remarks&gt;
        internal PublishedPropertyType(string propertyTypeAlias, string propertyEditorAlias)
            : this(propertyTypeAlias, 0, propertyEditorAlias)
        { }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;PublishedPropertyType&quot;/&gt; class with a property type alias and a datatype definition.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyTypeAlias&quot;&gt;The property type alias.&lt;/param&gt;
        /// &lt;param name=&quot;dataTypeDefinition&quot;&gt;The datatype definition.&lt;/param&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The new published property type does not belong to a published content type.&lt;/para&gt;
        /// &lt;/remarks&gt;
        internal PublishedPropertyType(string propertyTypeAlias, IDataTypeDefinition dataTypeDefinition)
            : this(propertyTypeAlias, dataTypeDefinition.Id, dataTypeDefinition.PropertyEditorAlias)
        { }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;PublishedPropertyType&quot;/&gt; class with a property type alias,
        /// a datatype definition identifier, and a property editor alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyTypeAlias&quot;&gt;The property type alias.&lt;/param&gt;
        /// &lt;param name=&quot;dataTypeDefinitionId&quot;&gt;The datatype definition identifier.&lt;/param&gt;
        /// &lt;param name=&quot;propertyEditorAlias&quot;&gt;The property editor alias.&lt;/param&gt;
        /// &lt;param name=&quot;initConverters&quot;&gt;Generally used only for testing, in production this will always be true&lt;/param&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The new published property type does not belong to a published content type.&lt;/para&gt;
        /// &lt;para&gt;The values of &lt;paramref name=&quot;dataTypeDefinitionId&quot;/&gt; and &lt;paramref name=&quot;propertyEditorAlias&quot;/&gt; are
        /// assumed to be valid and consistent.&lt;/para&gt;
        /// &lt;/remarks&gt;
        internal PublishedPropertyType(string propertyTypeAlias, int dataTypeDefinitionId, string propertyEditorAlias, bool initConverters = true)
        {
            // ContentType 
            // - in unit tests, to be set by PublishedContentType when creating it
            // - in detached types, remains null

            PropertyTypeAlias = propertyTypeAlias;

            DataTypeId = dataTypeDefinitionId;
            PropertyEditorAlias = propertyEditorAlias;

            if (initConverters)
                InitializeConverters();
        }

        #endregion

        #region Property type

        /// &lt;summary&gt;
        /// Gets or sets the published content type containing the property type.
        /// &lt;/summary&gt;
        // internally set by PublishedContentType constructor
        public PublishedContentType ContentType { get; internal set; }

        /// &lt;summary&gt;
        /// Gets or sets the alias uniquely identifying the property type.
        /// &lt;/summary&gt;
        public string PropertyTypeAlias { get; private set; }

        /// &lt;summary&gt;
        /// Gets or sets the identifier uniquely identifying the data type supporting the property type.
        /// &lt;/summary&gt;
        public int DataTypeId { get; private set; }

        /// &lt;summary&gt;
        /// Gets or sets the alias uniquely identifying the property editor for the property type.
        /// &lt;/summary&gt;
        public string PropertyEditorAlias { get; private set; }

        #endregion

        #region Converters

        private IPropertyValueConverter _converter;

        private PropertyCacheLevel _sourceCacheLevel;
        private PropertyCacheLevel _objectCacheLevel;
        private PropertyCacheLevel _xpathCacheLevel;

        private Type _clrType = typeof (object);

        private void InitializeConverters()
        {
            //TODO: Look at optimizing this method, it gets run for every property type for the document being rendered at startup,
            // every precious second counts!

            var converters = PropertyValueConvertersResolver.Current.Converters.ToArray();            
            var defaultConvertersWithAttributes = PropertyValueConvertersResolver.Current.DefaultConverters;

            _converter = null;
            
            //get all converters for this property type
            // todo: remove Union() once we drop IPropertyEditorValueConverter support.
            var foundConverters = converters.Union(GetCompatConverters()).Where(x =&gt; x.IsConverter(this)).ToArray();
            if (foundConverters.Length == 1)
            {
                _converter = foundConverters[0];
            }
            else if (foundConverters.Length &gt; 1)
            {
                //more than one was found, we need to first figure out if one of these is an Umbraco default value type converter
                //get the non-default and see if we have one
                var nonDefault = foundConverters.Except(defaultConvertersWithAttributes.Select(x =&gt; x.Item1)).ToArray();
                if (nonDefault.Length == 1)
                {
                    //there&#39;s only 1 custom converter registered that so use it
                    _converter = nonDefault[0];
                }
                else if (nonDefault.Length &gt; 1)
                {
                    //this is not allowed, there cannot be more than 1 custom converter
                    throw new InvalidOperationException(
                        string.Format(&quot;Type &#39;{2}&#39; cannot be an IPropertyValueConverter&quot;
                                      + &quot; for property &#39;{1}&#39; of content type &#39;{0}&#39; because type &#39;{3}&#39; has already been detected as a converter&quot;
                                      + &quot; for that property, and only one converter can exist for a property.&quot;,
                                      ContentType.Alias, PropertyTypeAlias,
                                      nonDefault[1].GetType().FullName, nonDefault[0].GetType().FullName));
                }
                else 
                {
                    //we need to remove any converters that have been shadowed by another converter
                    var foundDefaultConvertersWithAttributes = defaultConvertersWithAttributes.Where(x =&gt; foundConverters.Contains(x.Item1));
                    var shadowedTypes = foundDefaultConvertersWithAttributes.SelectMany(x =&gt; x.Item2.DefaultConvertersToShadow);
                    var shadowedDefaultConverters = foundConverters.Where(x =&gt; shadowedTypes.Contains(x.GetType()));
                    var nonShadowedDefaultConverters = foundConverters.Except(shadowedDefaultConverters).ToArray();

                    if (nonShadowedDefaultConverters.Length == 1)
                    {
                        //assign to the single default converter
                        _converter = nonShadowedDefaultConverters[0];    
                    }
                    else if (nonShadowedDefaultConverters.Length &gt; 1)
                    {
                        //this is not allowed, there cannot be more than 1 custom converter
                        throw new InvalidOperationException(
                            string.Format(&quot;Type &#39;{2}&#39; cannot be an IPropertyValueConverter&quot;
                                          + &quot; for property &#39;{1}&#39; of content type &#39;{0}&#39; because type &#39;{3}&#39; has already been detected as a converter&quot;
                                          + &quot; for that property, and only one converter can exist for a property.&quot;,
                                          ContentType.Alias, PropertyTypeAlias,
                                          nonShadowedDefaultConverters[1].GetType().FullName, nonShadowedDefaultConverters[0].GetType().FullName));
                    }
                }
                
            }

            var converterMeta = _converter as IPropertyValueConverterMeta;

            // get the cache levels, quietely fixing the inconsistencies (no need to throw, really)
            if (converterMeta != null)
            {
                _sourceCacheLevel = converterMeta.GetPropertyCacheLevel(this, PropertyCacheValue.Source);
                _objectCacheLevel = converterMeta.GetPropertyCacheLevel(this, PropertyCacheValue.Object);
                _xpathCacheLevel = converterMeta.GetPropertyCacheLevel(this, PropertyCacheValue.XPath);
            }
            else
            {
                _sourceCacheLevel = GetCacheLevel(_converter, PropertyCacheValue.Source);
                _objectCacheLevel = GetCacheLevel(_converter, PropertyCacheValue.Object);
                _xpathCacheLevel = GetCacheLevel(_converter, PropertyCacheValue.XPath);
            }
            if (_objectCacheLevel &lt; _sourceCacheLevel) _objectCacheLevel = _sourceCacheLevel;
            if (_xpathCacheLevel &lt; _sourceCacheLevel) _xpathCacheLevel = _sourceCacheLevel;

            // get the CLR type of the converted value
            if (_converter != null)
            {
                if (converterMeta != null)
                {
                    _clrType = converterMeta.GetPropertyValueType(this);
                }
                else
                {
                    var attr = _converter.GetType().GetCustomAttribute&lt;PropertyValueTypeAttribute&gt;(false);
                    if (attr != null)
                        _clrType = attr.Type;
                }
            }
        }

        static PropertyCacheLevel GetCacheLevel(IPropertyValueConverter converter, PropertyCacheValue value)
        {
            if (converter == null)
                return PropertyCacheLevel.Request;

            var attr = converter.GetType().GetCustomAttributes&lt;PropertyValueCacheAttribute&gt;(false)
                .FirstOrDefault(x =&gt; x.Value == value || x.Value == PropertyCacheValue.All);

            return attr == null ? PropertyCacheLevel.Request : attr.Level;
        }
        
        // converts the raw value into the source value
        // uses converters, else falls back to dark (&amp; performance-wise expensive) magic
        // source: the property raw value
        // preview: whether we are previewing or not
        public object ConvertDataToSource(object source, bool preview)
        {
            // use the converter else use dark (&amp; performance-wise expensive) magic
            return _converter != null 
                ? _converter.ConvertDataToSource(this, source, preview) 
                : ConvertUsingDarkMagic(source);
        }

        // gets the source cache level
        public PropertyCacheLevel SourceCacheLevel { get { return _sourceCacheLevel; } }

        // converts the source value into the clr value
        // uses converters, else returns the source value
        // source: the property source value
        // preview: whether we are previewing or not
        public object ConvertSourceToObject(object source, bool preview)
        {
            // use the converter if any
            // else just return the source value
            return _converter != null
                ? _converter.ConvertSourceToObject(this, source, preview) 
                : source;
        }

        // gets the value cache level
        public PropertyCacheLevel ObjectCacheLevel { get { return _objectCacheLevel; } }

        // converts the source value into the xpath value
        // uses the converter else returns the source value as a string
        // if successful, returns either a string or an XPathNavigator
        // source: the property source value
        // preview: whether we are previewing or not
        public object ConvertSourceToXPath(object source, bool preview)
        {
            // use the converter if any
            if (_converter != null)
                return _converter.ConvertSourceToXPath(this, source, preview);

            // else just return the source value as a string or an XPathNavigator
            if (source == null) return null;
            var xElement = source as XElement;
            if (xElement != null)
                return xElement.CreateNavigator();
            return source.ToString().Trim();
        }

        // gets the xpath cache level
        public PropertyCacheLevel XPathCacheLevel { get { return _xpathCacheLevel; } }

        internal static object ConvertUsingDarkMagic(object source)
        {
            // convert to string
            var stringSource = source as string;
            if (stringSource == null) return source; // not a string =&gt; return the object
            stringSource = stringSource.Trim();
            if (stringSource.Length == 0) return null; // empty string =&gt; return null

            // try numbers and booleans
            // make sure we use the invariant culture ie a dot decimal point, comma is for csv
            // NOTE far from perfect: &quot;01a&quot; is returned as a string but &quot;012&quot; is returned as an integer...
            int i;
            if (int.TryParse(stringSource, NumberStyles.Integer, CultureInfo.InvariantCulture, out i))
                return i;
            float f;
            if (float.TryParse(stringSource, NumberStyles.Float, CultureInfo.InvariantCulture, out f))
                return f;
            bool b;
            if (bool.TryParse(stringSource, out b))
                return b;

            //TODO: We can change this just like we do for the JSON converter - but to maintain compatibility might mean this still has to remain here

            // try xml - that is expensive, performance-wise
            XElement elt;
            if (XmlHelper.TryCreateXElementFromPropertyValue(stringSource, out elt))
                return new DynamicXml(elt); // xml =&gt; return DynamicXml for compatiblity&#39;s sake

            return source;
        }

        // gets the property CLR type
        public Type ClrType { get { return _clrType; } }

        #endregion

        #region Compat

        // backward-compatibility: support IPropertyEditorValueConverter while we have to
        // todo: remove once we drop IPropertyEditorValueConverter support.

        IEnumerable&lt;IPropertyValueConverter&gt; GetCompatConverters()
        {
            var propertyEditorGuid = LegacyPropertyEditorIdToAliasConverter.GetLegacyIdFromAlias(PropertyEditorAlias, LegacyPropertyEditorIdToAliasConverter.NotFoundLegacyIdResponseBehavior.ReturnNull);
            return PropertyEditorValueConvertersResolver.HasCurrent &amp;&amp; propertyEditorGuid.HasValue
                ? PropertyEditorValueConvertersResolver.Current.Converters
                    .Where(x =&gt; x.IsConverterFor(propertyEditorGuid.Value, ContentType.Alias, PropertyTypeAlias))
                    .Select(x =&gt; new CompatConverter(x))
                : Enumerable.Empty&lt;IPropertyValueConverter&gt;();
        }

        private class CompatConverter : PropertyValueConverterBase
        {
            private readonly IPropertyEditorValueConverter _converter;

            public CompatConverter(IPropertyEditorValueConverter converter)
            {
                _converter = converter;
            }

            public override bool IsConverter(PublishedPropertyType propertyType)
            {
                return true;
            }

            public override object ConvertDataToSource(PublishedPropertyType propertyType, object source, bool preview)
            {
                // NOTE: ignore preview, because IPropertyEditorValueConverter does not support it
                return _converter.ConvertPropertyValue(source).Result;
            }
        }

        #endregion

        #region Detached

        private PropertyCacheLevel _sourceCacheLevelReduced = 0;
        private PropertyCacheLevel _objectCacheLevelReduced = 0;
        private PropertyCacheLevel _xpathCacheLevelReduced = 0;

        internal bool IsDetachedOrNested
        {
            // enough to test source
            get { return _sourceCacheLevelReduced != 0; }
        }

        /// &lt;summary&gt;
        /// Creates a detached clone of this published property type.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A detached clone of this published property type.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Only a published property type that has not already been detached or nested, can be detached.&lt;/para&gt;
        /// &lt;para&gt;Use detached published property type when creating detached properties outside of a published content.&lt;/para&gt;
        /// &lt;/remarks&gt;
        internal PublishedPropertyType Detached()
        {
            // verify
            if (IsDetachedOrNested)
                throw new Exception(&quot;PublishedPropertyType is already detached/nested.&quot;);

            var detached = new PublishedPropertyType(this);
            detached._sourceCacheLevel 
                = detached._objectCacheLevel 
                = detached._xpathCacheLevel 
                = PropertyCacheLevel.Content;
            // set to none to a) indicate it&#39;s detached / nested and b) make sure any nested
            // types switch all their cache to .Content
            detached._sourceCacheLevelReduced 
                = detached._objectCacheLevelReduced
                = detached._xpathCacheLevelReduced
                = PropertyCacheLevel.None;

            return detached;
        }

        /// &lt;summary&gt;
        /// Creates a nested clone of this published property type within a specified container published property type.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;containerType&quot;&gt;The container published property type.&lt;/param&gt;
        /// &lt;returns&gt;A nested clone of this published property type&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Only a published property type that has not already been detached or nested, can be nested.&lt;/para&gt;
        /// &lt;para&gt;Use nested published property type when creating detached properties within a published content.&lt;/para&gt;
        /// &lt;/remarks&gt;
        internal PublishedPropertyType Nested(PublishedPropertyType containerType)
        {
            // verify
            if (IsDetachedOrNested)
                throw new Exception(&quot;PublishedPropertyType is already detached/nested.&quot;);

            var nested = new PublishedPropertyType(this);

            // before we reduce, both xpath and object are &gt;= source, and
            // the way reduce works, the relative order of resulting xpath, object and source are preserved

            // Reduce() will set _xxxCacheLevelReduced thus indicating that the type is detached / nested

            Reduce(_sourceCacheLevel, _sourceCacheLevelReduced, ref nested._sourceCacheLevel, ref nested._sourceCacheLevelReduced);
            Reduce(_objectCacheLevel, _objectCacheLevelReduced, ref nested._objectCacheLevel, ref nested._objectCacheLevelReduced);
            Reduce(_xpathCacheLevel, _xpathCacheLevelReduced, ref nested._xpathCacheLevel, ref nested._xpathCacheLevelReduced);

            return nested;
        }

        private static void Reduce(
            PropertyCacheLevel containerCacheLevel, PropertyCacheLevel containerCacheLevelReduced,
            ref PropertyCacheLevel nestedCacheLevel, ref PropertyCacheLevel nestedCacheLevelReduced)
        {
            // initialize if required
            if (containerCacheLevelReduced == 0)
                containerCacheLevelReduced = containerCacheLevel;

            switch (containerCacheLevelReduced)
            {
                case PropertyCacheLevel.None:
                    // once .None, force .Content for everything
                    nestedCacheLevel = PropertyCacheLevel.Content;
                    nestedCacheLevelReduced = PropertyCacheLevel.None; // and propagate
                    break;

                case PropertyCacheLevel.Request:
                    // once .Request, force .Content for everything
                    nestedCacheLevel = PropertyCacheLevel.Content;
                    nestedCacheLevelReduced = PropertyCacheLevel.Request; // and propagate
                    break;

                case PropertyCacheLevel.Content:
                    // as long as .Content, accept anything
                    nestedCacheLevelReduced = nestedCacheLevel; // and it becomes the nested reduced
                    break;

                case PropertyCacheLevel.ContentCache:
                    // once .ContentCache, accept .Request and .Content but not .ContentCache
                    switch (nestedCacheLevel)
                    {
                        case PropertyCacheLevel.Request:
                        case PropertyCacheLevel.None:
                            // accept
                            nestedCacheLevelReduced = nestedCacheLevel; // and it becomes the nested reduced
                            break;
                        case PropertyCacheLevel.Content:
                            // accept
                            nestedCacheLevelReduced = PropertyCacheLevel.ContentCache; // and propagate
                            break;
                        case PropertyCacheLevel.ContentCache:
                            // force .Content
                            nestedCacheLevel = PropertyCacheLevel.Content;
                            nestedCacheLevelReduced = PropertyCacheLevel.ContentCache; // and propagate
                            break;
                        default:
                            throw new Exception(&quot;Unsupported PropertyCacheLevel value.&quot;);
                    }
                    break;

                default:
                    throw new Exception(&quot;Unsupported PropertyCacheLevel value.&quot;);
            }
        }

        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[22,9,22,66,1],[23,9,23,10,1],[24,13,24,44,1],[25,13,25,56,1],[26,13,26,42,1],[27,13,27,60,1],[28,13,28,42,1],[29,13,29,56,1],[30,13,30,56,1],[31,13,31,54,1],[32,13,32,38,1],[36,9,36,10,1],[45,9,45,98,0],[46,9,46,10,0],[49,13,49,39,0],[50,13,50,52,0],[52,13,52,60,0],[53,13,53,68,0],[55,13,55,36,0],[56,9,56,10,0],[69,15,69,97,0],[70,9,70,10,0],[70,11,70,12,0],[87,15,87,62,1],[88,9,88,10,1],[88,11,88,12,1],[99,15,99,101,0],[100,9,100,10,0],[100,11,100,12,0],[115,9,115,147,1],[116,9,116,10,1],[121,13,121,51,1],[123,13,123,47,1],[124,13,124,55,1],[126,13,126,32,1],[127,17,127,40,1],[128,9,128,10,1],[138,51,138,55,1],[138,56,138,69,1],[143,43,143,47,1],[143,48,143,60,1],[148,33,148,37,1],[148,38,148,50,1],[153,45,153,49,1],[153,50,153,62,1],[165,9,165,49,1],[165,9,165,49,1],[165,9,165,49,0],[168,9,168,10,1],[172,13,172,91,1],[173,13,173,109,1],[175,13,175,31,1],[179,13,179,86,1],[179,86,179,105,1],[179,105,179,117,1],[179,13,179,117,1],[180,13,180,45,1],[181,13,181,14,1],[182,17,182,49,1],[183,13,183,14,1],[184,18,184,49,1],[185,13,185,14,0],[188,17,188,101,0],[188,101,188,108,0],[188,108,188,121,0],[188,17,188,121,0],[189,17,189,44,0],[190,17,190,18,0],[192,21,192,48,0],[193,17,193,18,0],[194,22,194,48,0],[195,17,195,18,0],[197,21,202,108,0],[205,17,205,18,0],[207,21,207,107,0],[207,107,207,140,0],[207,140,207,142,0],[207,21,207,142,0],[208,21,208,94,0],[208,94,208,127,0],[208,127,208,129,0],[208,21,208,129,0],[209,21,209,80,0],[209,80,209,115,0],[209,115,209,117,0],[209,21,209,117,0],[210,21,210,116,0],[212,21,212,66,0],[213,21,213,22,0],[215,25,215,70,0],[216,21,216,22,0],[217,26,217,70,0],[218,21,218,22,0],[220,25,225,148,0],[227,17,227,18,0],[229,13,229,14,0],[231,13,231,75,1],[234,13,234,39,1],[235,13,235,14,0],[236,17,236,106,0],[237,17,237,106,0],[238,17,238,104,0],[239,13,239,14,0],[241,13,241,14,1],[242,17,242,90,1],[243,17,243,90,1],[244,17,244,88,1],[245,13,245,14,1],[246,13,246,55,1],[246,56,246,94,0],[247,13,247,54,1],[247,55,247,92,0],[250,13,250,36,1],[251,13,251,14,1],[252,17,252,43,1],[253,17,253,18,0],[254,21,254,73,0],[255,17,255,18,0],[257,17,257,18,1],[258,21,258,107,1],[259,21,259,38,1],[260,25,260,46,1],[261,17,261,18,1],[262,13,262,14,1],[263,9,263,10,1],[266,9,266,10,1],[267,13,267,35,1],[268,17,268,51,1],[270,13,271,38,1],[271,38,271,91,1],[271,91,271,93,1],[270,13,271,93,1],[273,13,273,75,1],[274,9,274,10,1],[281,9,281,10,1],[283,13,285,49,1],[286,9,286,10,1],[289,58,289,59,0],[289,60,289,85,0],[289,86,289,87,0],[296,9,296,10,1],[299,13,301,26,1],[302,9,302,10,1],[305,58,305,59,0],[305,60,305,85,0],[305,86,305,87,0],[313,9,313,10,0],[315,13,315,36,0],[316,17,316,79,0],[319,13,319,32,0],[319,33,319,45,0],[320,13,320,47,0],[321,13,321,34,0],[322,17,322,51,0],[323,13,323,45,0],[324,9,324,10,0],[327,57,327,58,0],[327,59,327,83,0],[327,84,327,85,0],[330,9,330,10,1],[332,13,332,49,1],[333,13,333,38,1],[333,39,333,53,0],[334,13,334,48,1],[335,13,335,42,1],[335,43,335,55,1],[341,13,341,103,1],[342,17,342,26,1],[344,13,344,103,1],[345,17,345,26,0],[347,13,347,52,1],[348,17,348,26,0],[354,13,354,85,1],[355,17,355,44,0],[357,13,357,27,1],[358,9,358,10,1],[361,35,361,36,0],[361,37,361,53,0],[361,54,361,55,0],[371,9,371,10,1],[372,13,372,203,1],[373,13,375,33,1],[375,33,375,113,0],[375,113,376,34,1],[376,34,376,56,0],[376,56,377,63,1],[373,13,377,63,1],[378,9,378,10,1],[384,13,384,76,0],[385,13,385,14,0],[386,17,386,40,0],[387,13,387,14,0],[390,13,390,14,0],[391,17,391,29,0],[392,13,392,14,0],[395,13,395,14,0],[397,17,397,71,0],[398,13,398,14,0],[405,9,405,65,1],[405,9,405,65,0],[405,9,405,65,1],[406,9,406,65,1],[406,9,406,65,0],[406,9,406,65,1],[407,9,407,64,0],[407,9,407,64,1],[407,9,407,64,1],[412,17,412,18,1],[412,19,412,56,1],[412,57,412,58,1],[424,9,424,10,1],[426,13,426,36,1],[427,17,427,90,0],[429,13,429,60,1],[430,13,433,46,1],[436,13,439,43,1],[441,13,441,29,1],[442,9,442,10,1],[454,9,454,10,0],[456,13,456,36,0],[457,17,457,90,0],[459,13,459,58,0],[466,13,466,132,0],[467,13,467,132,0],[468,13,468,128,0],[470,13,470,27,0],[471,9,471,10,0],[476,9,476,10,0],[478,13,478,49,0],[479,17,479,66,0],[481,13,481,48,0],[485,21,485,67,0],[486,21,486,71,0],[487,21,487,27,0],[491,21,491,67,0],[492,21,492,74,0],[493,21,493,27,0],[497,21,497,64,0],[498,21,498,27,0],[502,21,502,46,0],[507,29,507,72,0],[508,29,508,35,0],[511,29,511,87,0],[512,29,512,35,0],[515,29,515,75,0],[516,29,516,87,0],[517,29,517,35,0],[519,29,519,90,0],[521,21,521,27,0],[524,21,524,82,0],[526,9,526,10,0]]);
    </script>
  </body>
</html>