<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Logging\AsynchronousRollingFileAppender.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using log4net.Core;
using log4net.Util;
using System;
using System.ComponentModel;
using System.Runtime.Remoting.Messaging;
using System.Security.Principal;
using System.Threading;
using System.Threading.Tasks;
using log4net.Appender;

namespace Umbraco.Core.Logging
{
    /// &lt;summary&gt;
    /// Based on https://github.com/cjbhaines/Log4Net.Async
    /// which is based on code by Chris Haines http://cjbhaines.wordpress.com/2012/02/13/asynchronous-log4net-appenders/
    /// This is an old/deprecated logger and has been superceded by ParallelForwardingAppender which is included in Umbraco and 
    /// also by AsyncForwardingAppender in the Log4Net.Async library.
	/// &lt;/summary&gt;
	[Obsolete(&quot;This is superceded by the ParallelForwardingAppender, this will be removed in v8&quot;)]
    [EditorBrowsable(EditorBrowsableState.Never)]
	public class AsynchronousRollingFileAppender : RollingFileAppender
	{
		private RingBuffer&lt;LoggingEvent&gt; pendingAppends;
        private readonly ManualResetEvent manualResetEvent;
        private bool shuttingDown;
        private bool hasFinished;
        private bool forceStop;
        private bool logBufferOverflow;
        private int bufferOverflowCounter;
        private DateTime lastLoggedBufferOverflow;
        private int queueSizeLimit = 1000;
        public int QueueSizeLimit
        {
            get
            {
                return queueSizeLimit;
            }
            set
            {
                queueSizeLimit = value;
            }
        }

        public AsynchronousRollingFileAppender()
        {
            manualResetEvent = new ManualResetEvent(false);
        }

        public override void ActivateOptions()
        {
            base.ActivateOptions();
            pendingAppends = new RingBuffer&lt;LoggingEvent&gt;(QueueSizeLimit);
            pendingAppends.BufferOverflow += OnBufferOverflow;
            StartAppendTask();
        }

        protected override void Append(LoggingEvent[] loggingEvents)
        {
            Array.ForEach(loggingEvents, Append);
        }

        protected override void Append(LoggingEvent loggingEvent)
        {
            if (FilterEvent(loggingEvent))
            {
                pendingAppends.Enqueue(loggingEvent);
            }
        }

        protected override void OnClose()
        {
            shuttingDown = true;
            manualResetEvent.WaitOne(TimeSpan.FromSeconds(5));

            if (!hasFinished)
            {
                forceStop = true;
                base.Append(new LoggingEvent(new LoggingEventData
                {
                    Level = Level.Error,
                    Message = &quot;Unable to clear out the AsyncRollingFileAppender buffer in the allotted time, forcing a shutdown&quot;,
                    TimeStamp = DateTime.UtcNow,
                    Identity = &quot;&quot;,
                    ExceptionString = &quot;&quot;,
                    UserName = WindowsIdentity.GetCurrent() != null ? WindowsIdentity.GetCurrent().Name : &quot;&quot;,
                    Domain = AppDomain.CurrentDomain.FriendlyName,
                    ThreadName = Thread.CurrentThread.ManagedThreadId.ToString(),
                    LocationInfo = new LocationInfo(this.GetType().Name, &quot;OnClose&quot;, &quot;AsyncRollingFileAppender.cs&quot;, &quot;75&quot;),
                    LoggerName = this.GetType().FullName,
                    Properties = new PropertiesDictionary(),
                })
                 );
            }

            base.OnClose();
        }

        private void StartAppendTask()
        {
            if (!shuttingDown)
            {
                Task appendTask = new Task(AppendLoggingEvents, TaskCreationOptions.LongRunning);
                appendTask.LogErrors(LogAppenderError).ContinueWith(x =&gt; StartAppendTask()).LogErrors(LogAppenderError);
                appendTask.Start();
            }
        }

        private void LogAppenderError(string logMessage, Exception exception)
        {
            base.Append(new LoggingEvent(new LoggingEventData
            {
                Level = Level.Error,
                Message = &quot;Appender exception: &quot; + logMessage,
                TimeStamp = DateTime.UtcNow,
                Identity = &quot;&quot;,
                ExceptionString = exception.ToString(),
                UserName = WindowsIdentity.GetCurrent() != null ? WindowsIdentity.GetCurrent().Name : &quot;&quot;,
                Domain = AppDomain.CurrentDomain.FriendlyName,
                ThreadName = Thread.CurrentThread.ManagedThreadId.ToString(),
                LocationInfo = new LocationInfo(this.GetType().Name, &quot;LogAppenderError&quot;, &quot;AsyncRollingFileAppender.cs&quot;, &quot;152&quot;),
                LoggerName = this.GetType().FullName,
                Properties = new PropertiesDictionary(),
            }));
        }

        private void AppendLoggingEvents()
        {
            LoggingEvent loggingEventToAppend;
            while (!shuttingDown)
            {
                if (logBufferOverflow)
                {
                    LogBufferOverflowError();
                    logBufferOverflow = false;
                    bufferOverflowCounter = 0;
                    lastLoggedBufferOverflow = DateTime.UtcNow;
                }

                while (!pendingAppends.TryDequeue(out loggingEventToAppend))
                {
                    Thread.Sleep(10);
                    if (shuttingDown)
                    {
                        break;
                    }
                }
                if (loggingEventToAppend == null)
                {
                    continue;
                }

                try
                {
                    base.Append(loggingEventToAppend);
                }
                catch
                {
                }
            }

            while (pendingAppends.TryDequeue(out loggingEventToAppend) &amp;&amp; !forceStop)
            {
                try
                {
                    base.Append(loggingEventToAppend);
                }
                catch
                {
                }
            }
            hasFinished = true;
            manualResetEvent.Set();
        }

        private void LogBufferOverflowError()
        {
            base.Append(new LoggingEvent(new LoggingEventData
            {
                Level = Level.Error,
                Message = string.Format(&quot;Buffer overflow. {0} logging events have been lost in the last 30 seconds. [QueueSizeLimit: {1}]&quot;, bufferOverflowCounter, QueueSizeLimit),
                TimeStamp = DateTime.UtcNow,
                Identity = &quot;&quot;,
                ExceptionString = &quot;&quot;,
                UserName = WindowsIdentity.GetCurrent() != null ? WindowsIdentity.GetCurrent().Name : &quot;&quot;,
                Domain = AppDomain.CurrentDomain.FriendlyName,
                ThreadName = Thread.CurrentThread.ManagedThreadId.ToString(),
                LocationInfo = new LocationInfo(this.GetType().Name, &quot;LogBufferOverflowError&quot;, &quot;AsyncRollingFileAppender.cs&quot;, &quot;152&quot;),
                LoggerName = this.GetType().FullName,
                Properties = new PropertiesDictionary(),
            }));
        }

        private void OnBufferOverflow(object sender, EventArgs eventArgs)
        {
            bufferOverflowCounter++;
            if (logBufferOverflow == false)
            {
                if (lastLoggedBufferOverflow &lt; DateTime.UtcNow.AddSeconds(-30))
                {
                    logBufferOverflow = true;
                }
            }
        }
    }

}
    </pre>
    <script type="text/javascript">
      highlightRanges([[31,9,31,43,1],[35,13,35,14,1],[36,17,36,39,1],[37,13,37,14,1],[39,13,39,14,0],[40,17,40,40,0],[41,13,41,14,0],[44,9,44,49,1],[45,9,45,10,1],[46,13,46,60,1],[47,9,47,10,1],[50,9,50,10,1],[51,13,51,36,1],[52,13,52,75,1],[53,13,53,63,1],[54,13,54,31,1],[55,9,55,10,1],[58,9,58,10,0],[59,13,59,50,0],[60,9,60,10,0],[63,9,63,10,1],[64,13,64,43,1],[65,13,65,14,1],[66,17,66,54,1],[67,13,67,14,1],[68,9,68,10,1],[71,9,71,10,1],[72,13,72,33,1],[73,13,73,63,1],[75,13,75,30,1],[76,13,76,14,0],[77,17,77,34,0],[78,17,92,20,0],[93,13,93,14,0],[95,13,95,28,1],[96,9,96,10,1],[99,9,99,10,1],[100,13,100,31,1],[101,13,101,14,1],[102,17,102,98,1],[103,17,103,74,1],[103,74,103,91,1],[103,91,103,121,1],[103,17,103,121,1],[104,17,104,36,1],[105,13,105,14,1],[106,9,106,10,1],[109,9,109,10,0],[110,13,123,17,0],[124,9,124,10,0],[127,9,127,10,1],[129,13,129,34,1],[130,13,130,14,1],[131,17,131,39,1],[132,17,132,18,0],[133,21,133,46,0],[134,21,134,47,0],[135,21,135,47,0],[136,21,136,64,0],[137,17,137,18,0],[139,17,139,77,1],[140,17,140,18,1],[141,21,141,38,1],[142,21,142,38,1],[143,21,143,22,1],[144,25,144,31,1],[146,17,146,18,1],[147,17,147,50,1],[148,17,148,18,1],[149,21,149,30,1],[153,17,153,18,1],[154,21,154,55,1],[155,17,155,18,1],[156,17,156,22,0],[157,17,157,18,0],[158,17,158,18,0],[159,13,159,14,1],[161,13,161,86,1],[162,13,162,14,0],[164,17,164,18,0],[165,21,165,55,0],[166,17,166,18,0],[167,17,167,22,0],[168,17,168,18,0],[169,17,169,18,0],[170,13,170,14,0],[171,13,171,32,1],[172,13,172,36,1],[173,9,173,10,1],[176,9,176,10,0],[177,13,190,17,0],[191,9,191,10,0],[194,9,194,10,0],[195,13,195,37,0],[196,13,196,44,0],[197,13,197,14,0],[198,17,198,80,0],[199,17,199,18,0],[200,21,200,46,0],[201,17,201,18,0],[202,13,202,14,0],[203,9,203,10,0]]);
    </script>
  </body>
</html>