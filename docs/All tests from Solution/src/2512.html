<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\umbraco.businesslogic\BasePages\ClientTools.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Text;
using System.Web;
using umbraco.BasePages;
using System.Web.UI;
using Umbraco.Core.IO;
using umbraco.BusinessLogic;
using Umbraco.Core;

namespace umbraco.BasePages
{

	/// &lt;summary&gt;
	/// Renders the client side code necessary to interact with the Umbraco client side API.
	/// Each method returns an instance of this class so you can chain calls together.
	/// &lt;/summary&gt;
    [Obsolete(&quot;This class has been superceded by Umbraco.Web.UI.Pages.ClientTools but requires the use of Umbraco.Web.UI.Pages.BasePage&quot;)]
	public sealed class ClientTools
	{

		public ClientTools(Page page)
		{
			m_page = page;
		}

		/// &lt;summary&gt;
		/// Returns the string markup for the JavaScript that is rendered.
		/// If referencing JavaScript scripts in the backend, this class should be used
		/// in case future changes to the client code is change, this will remain intact.
		/// &lt;/summary&gt;
		public static class Scripts
		{
			internal const string ClientMgrScript = &quot;UmbClientMgr&quot;;
			public static string GetAppActions { get { return string.Format(&quot;{0}.appActions()&quot;, ClientMgrScript); } }
			public static string GetMainWindow { get { return string.Format(&quot;{0}.mainWindow()&quot;, ClientMgrScript); } }
			public static string GetMainTree { get { return string.Format(&quot;{0}.mainTree()&quot;, ClientMgrScript); } }
			public static string GetContentFrame() { return string.Format(&quot;{0}.contentFrame()&quot;, ClientMgrScript); }
			public static string ShiftApp(string appAlias)
			{
                return string.Format(ClientMgrScript + &quot;.historyManager().addHistory(&#39;{0}&#39;)&quot;, appAlias);
			}
			public static string OpenDashboard(string app)
			{
				return string.Format(GetAppActions + &quot;.openDashboard(&#39;{0}&#39;);&quot;, app);
			}
			public static string RefreshAdmin { get { return &quot;setTimeout(&#39;&quot; + GetMainWindow + &quot;.location.reload()&#39;, {0});&quot;; } }
			public static string ShowSpeechBubble { get { return GetMainWindow + &quot;.UmbSpeechBubble.ShowMessage(&#39;{0}&#39;,&#39;{1}&#39;, &#39;{2}&#39;);&quot;; } }
			public static string ChangeContentFrameUrl(string url) {
				return string.Format(ClientMgrScript + &quot;.contentFrame(&#39;{0}&#39;);&quot;, url);
			}
			public static string ReloadContentFrameUrlIfPathLoaded(string url) {
                return string.Format(ClientMgrScript + &quot;.reloadContentFrameUrlIfPathLoaded(&#39;{0}&#39;);&quot;, url);
			}
            public static string ReloadLocation { get { return string.Format(ClientMgrScript + &quot;.reloadLocation();&quot;); } }
            public static string ChildNodeCreated = GetMainTree + &quot;.childNodeCreated();&quot;;
			public static string SyncTree { get { return GetMainTree + &quot;.syncTree(&#39;{0}&#39;, {1});&quot;; } }
			public static string ClearTreeCache { get { return GetMainTree + &quot;.clearTreeCache();&quot;; } }
			public static string CopyNode { get { return GetMainTree + &quot;.copyNode(&#39;{0}&#39;, &#39;{1}&#39;);&quot;; } }
			public static string MoveNode { get { return GetMainTree + &quot;.moveNode(&#39;{0}&#39;, &#39;{1}&#39;);&quot;; } }
			public static string ReloadActionNode { get { return GetMainTree + &quot;.reloadActionNode({0}, {1}, null);&quot;; } }
			public static string SetActiveTreeType { get { return GetMainTree + &quot;.setActiveTreeType(&#39;{0}&#39;);&quot;; } }
            public static string RefreshTree { get { return GetMainTree + &quot;.refreshTree();&quot;; } }
            public static string RefreshTreeType { get { return GetMainTree + &quot;.refreshTree(&#39;{0}&#39;);&quot;; } }
            public static string CloseModalWindow()
            {
                return string.Format(&quot;{0}.closeModalWindow();&quot;, ClientMgrScript);
            }
            public static string CloseModalWindow(string rVal)
            {
                return string.Format(&quot;{0}.closeModalWindow(&#39;{1}&#39;);&quot;, ClientMgrScript, rVal);
            }
            public static string OpenModalWindow(string url, string name, int width, int height)
            {
                return OpenModalWindow(url, name, true, width, height, 0, 0, &quot;&quot;, &quot;&quot;);
            }
            public static string OpenModalWindow(string url, string name, bool showHeader, int width, int height, int top, int leftOffset, string closeTriggers, string onCloseCallback)
            {
                return string.Format(&quot;{0}.openModalWindow(&#39;{1}&#39;, &#39;{2}&#39;, {3}, {4}, {5}, {6}, {7}, &#39;{8}&#39;, &#39;{9}&#39;);&quot;,
                    new object[] { ClientMgrScript, url, name, showHeader.ToString().ToLower(), width, height, top, leftOffset, closeTriggers, onCloseCallback });
            }
		}

		private Page m_page;

		/// &lt;summary&gt;
		/// This removes all tree JSON data cached in the client browser.
		/// Useful when you want to ensure that the tree is reloaded from live data.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public ClientTools ClearClientTreeCache()
		{
			RegisterClientScript(Scripts.ClearTreeCache);
			return this;
		}

		/// &lt;summary&gt;
		/// Change applications
		/// &lt;/summary&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public ClientTools ShiftApp(string appAlias)
		{
			RegisterClientScript(Scripts.ShiftApp(appAlias));
			return this;
		}
		
		/// &lt;summary&gt;
		/// Refresh the entire administration console after a specified amount of time.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;seconds&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public ClientTools RefreshAdmin(int seconds)
		{
			RegisterClientScript(string.Format(Scripts.RefreshAdmin, seconds * 1000));
			return this;
		}

        /// &lt;summary&gt;
        /// Refreshes the entire current tree
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public ClientTools RefreshTree()
        {
            RegisterClientScript(Scripts.RefreshTree);
            return this;
        }

        public ClientTools RefreshTree(string treeType)
        {
            RegisterClientScript(string.Format(Scripts.RefreshTreeType, treeType));
            return this;
        }
		
		/// &lt;summary&gt;
		/// A reference to the umbraco UI component &quot;speechbubble&quot;. The speechbubble appears in the lower right corner of the screen, notifying users of events
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;i&quot;&gt;The speechbubble icon.&lt;/param&gt;
		/// &lt;param name=&quot;header&quot;&gt;The speechbubble header.&lt;/param&gt;
		/// &lt;param name=&quot;body&quot;&gt;The body text&lt;/param&gt;
		public ClientTools ShowSpeechBubble(BasePage.speechBubbleIcon i, string header, string body)
		{
			RegisterClientScript(string.Format(Scripts.ShowSpeechBubble, i.ToString(), header.Replace(&quot;&#39;&quot;, &quot;\\&#39;&quot;), body.Replace(&quot;&#39;&quot;, &quot;\\&#39;&quot;)));
			return this;
		}
		
		/// &lt;summary&gt;
		/// Changes the content in the content frame to the specified URL
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;url&quot;&gt;&lt;/param&gt;
		public ClientTools ChangeContentFrameUrl(string url)
		{
            //don&#39;t load if there is no url
			if (string.IsNullOrEmpty(url)) return this;

            url = EnsureUmbracoUrl(url);

            if (url.Trim().StartsWith(&quot;~&quot;))
                url = IOHelper.ResolveUrl(url);

            RegisterClientScript(Scripts.ChangeContentFrameUrl(url));
			
            return this;
		}

        /// &lt;summary&gt;
        /// Reloads the content in the content frame if the specified URL is currently loaded
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;url&quot;&gt;&lt;/param&gt;
        public ClientTools ReloadContentFrameUrlIfPathLoaded(string url)
        {
            if (string.IsNullOrEmpty(url)) return this;

            url = EnsureUmbracoUrl(url);

            RegisterClientScript(Scripts.ReloadContentFrameUrlIfPathLoaded(url));

            return this;
        }

        private string EnsureUmbracoUrl(string url)
        {
            if (url.StartsWith(&quot;/&quot;) &amp;&amp; !url.StartsWith(IOHelper.ResolveUrl(SystemDirectories.Umbraco)))
            {
                url = IOHelper.ResolveUrl(SystemDirectories.Umbraco).EnsureEndsWith(&#39;/&#39;) + url;
            }

            if (url.Trim().StartsWith(&quot;~&quot;))
                url = IOHelper.ResolveUrl(url);

            return url;
        }

		/// &lt;summary&gt;
		/// Shows the dashboard for the given application
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;app&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public ClientTools ShowDashboard(string app)
		{
            return ChangeContentFrameUrl(SystemDirectories.Umbraco + string.Format(&quot;/dashboard.aspx?app={0}&quot;, app));
		}
		
		/// &lt;summary&gt;
		/// Reloads the children of the current action node and selects the node that didn&#39;t exist there before.
		/// If the client side system cannot determine which node is new, then no node is selected.		
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// This is used by many create dialogs, however the sync method should be used based on the full path of the
		/// node but because the current Umbraco implementation of ITask only returns a url to load, there&#39;s no way
		/// to determine what the full path of the new child is.
		/// &lt;/remarks&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public ClientTools ChildNodeCreated()
		{
			//RegisterClientScript(Scripts.ChildNodeCreated);
			return this;
		}		

		/// &lt;summary&gt;
		/// Synchronizes the tree to the path specified.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;forceReload&quot;&gt;
		/// If set to true, will ensure that the node to be synced has it&#39;s data 
		/// reloaded from the server. Otherwise, if the node already exists, the tree will simply sync to the node
		/// that is already there.
		/// &lt;/param&gt;
		/// &lt;remarks&gt;
		/// This will work for any tree, however you would need to know the path of the node. Currently, media and content
		/// are the only trees that store a path, however, if you were working in the template tree for example, a path to a
		/// node could be &quot;init,1090&quot; and this method would still work.
		/// 
		/// Sync tree will works by syncing the active tree type. This can be specified explicitly by calling SetActiveTreeType. 
		/// This will allow developers to sync many trees in one application at one time if needed.
		/// &lt;/remarks&gt;
		/// &lt;example&gt;
		/// &lt;![CDATA[
		/// //if you had both the media and content trees in the same app, you could sync both at the same
		/// //time by doing:
		/// BasePage.Current.ClientTools
		///		.SetActiveTreeType(&quot;content&quot;)
		///			.SyncTree(&quot;-1,100,200&quot;)
		///		.SetActiveTreeType(&quot;media&quot;)
		///			.SyncTree(&quot;-1,323,355&quot;);
		/// ]]&gt;
		/// &lt;/example&gt;
		public ClientTools SyncTree(string path, bool forceReload)
		{
			RegisterClientScript(string.Format(Scripts.SyncTree, path, forceReload.ToString().ToLower()));
			return this;
		}

		public ClientTools CopyNode(string currNodeId, string newParentPath)
		{
			RegisterClientScript(string.Format(Scripts.CopyNode, currNodeId, newParentPath));
			return this;
		}

		public ClientTools MoveNode(string currNodeId, string newParentPath)
		{
			RegisterClientScript(string.Format(Scripts.MoveNode, currNodeId, newParentPath));
			return this;
		}

		/// &lt;summary&gt;
		/// Reloads only the last node that the user interacted with via the context menu. To reload a specify node, use SyncTree.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;reselect&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;reloadChildren&quot;&gt;&lt;/param&gt;
		/// &lt;remarks&gt;
		/// If for whatever reason the client side system cannot just refresh the one node, the system will use jsTree&#39;s built in 
		/// refresh tool, this however won&#39;t allow for reselect or reloadChildren. Most trees will work with the single node
		/// refresh but 3rd party tools may have poorly built tree data models.
		/// &lt;/remarks&gt;
		public ClientTools ReloadActionNode(bool reselect, bool reloadChildren)
		{
			RegisterClientScript(string.Format(Scripts.ReloadActionNode, (!reselect).ToString().ToLower(), (!reloadChildren).ToString().ToLower()));
			return this;
		}
		
		/// &lt;summary&gt;
		/// When the application searches for a node, it searches for nodes in specific tree types.
		/// If SyncTree is used, it will sync the tree nodes with the active tree type, therefore if
		/// a developer wants to sync a specific tree, they can call this method to set the type to sync.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// Each branch of a particular tree should theoretically be the same type, however, developers can
		/// override the type of each branch in their BaseTree&#39;s but this is not standard practice. If there
		/// are multiple types of branches in one tree, then only those branches that have the Active tree type
		/// will be searched for syncing.
		/// &lt;/remarks&gt;
		/// &lt;param name=&quot;treeType&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public ClientTools SetActiveTreeType(string treeType)
		{
			RegisterClientScript(string.Format(Scripts.SetActiveTreeType, treeType));
			return this;
		}

		/// &lt;summary&gt;
        /// Closes the Umbraco dialog window if it is open
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;returnVal&quot;&gt;specify a value to return to add to the onCloseCallback method if one was specified in the OpenModalWindow method&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public ClientTools CloseModalWindow(string returnVal)
		{
			RegisterClientScript(Scripts.CloseModalWindow(returnVal));
			return this;
		}
        /// &lt;summary&gt;
        /// Closes the umbraco dialog window if it is open
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public ClientTools CloseModalWindow()
        {
            return CloseModalWindow(&quot;&quot;);
        }


		/// &lt;summary&gt;
		/// Opens a modal window
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;url&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;height&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;width&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public ClientTools OpenModalWindow(string url, string name, bool showHeader, int width, int height, int top, int leftOffset, string closeTriggers, string onCloseCallback)
		{
			RegisterClientScript(Scripts.OpenModalWindow(url, name, showHeader, width, height, top, leftOffset, closeTriggers, onCloseCallback));
			return this;
		}

		private Page GetCurrentPage()
		{
			return HttpContext.Current.CurrentHandler as Page;
		}

        /// &lt;summary&gt;
        /// This will use the ScriptManager to register the script if one is available, otherwise will default to the ClientScript
        /// class of the page.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;script&quot;&gt;&lt;/param&gt;
        private void RegisterClientScript(string script)
		{
			//use the hash code of the script to generate the key, this way, the exact same script won&#39;t be
			//inserted more than once.
            if (ScriptManager.GetCurrent(m_page) != null)
            {
                ScriptManager.RegisterStartupScript(m_page, m_page.GetType(), script.GetHashCode().ToString(), script, true);
            }
            else
            {
                m_page.ClientScript.RegisterStartupScript(m_page.GetType(), script.GetHashCode().ToString(), script, true);
            }
		}




	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[22,3,22,32,0],[23,3,23,4,0],[24,4,24,18,0],[25,3,25,4,0],[35,45,35,46,0],[35,47,35,105,0],[35,106,35,107,0],[36,45,36,46,0],[36,47,36,105,0],[36,106,36,107,0],[37,43,37,44,0],[37,45,37,101,0],[37,102,37,103,0],[38,43,38,44,0],[38,45,38,105,0],[38,106,38,107,0],[40,4,40,5,0],[41,17,41,105,0],[42,4,42,5,0],[44,4,44,5,0],[45,5,45,73,0],[46,4,46,5,0],[47,44,47,45,0],[47,46,47,115,0],[47,116,47,117,0],[48,48,48,49,0],[48,50,48,125,0],[48,126,48,127,0],[49,59,49,60,0],[50,5,50,74,0],[51,4,51,5,0],[52,71,52,72,0],[53,17,53,107,0],[54,4,54,5,0],[55,55,55,56,0],[55,57,55,118,0],[55,119,55,120,0],[56,13,56,90,0],[57,40,57,41,0],[57,42,57,88,0],[57,89,57,90,0],[58,46,58,47,0],[58,48,58,90,0],[58,91,58,92,0],[59,40,59,41,0],[59,42,59,90,0],[59,91,59,92,0],[60,40,60,41,0],[60,42,60,90,0],[60,91,60,92,0],[61,48,61,49,0],[61,50,61,108,0],[61,109,61,110,0],[62,49,62,50,0],[62,51,62,101,0],[62,102,62,103,0],[63,52,63,53,0],[63,54,63,93,0],[63,94,63,95,0],[64,56,64,57,0],[64,58,64,102,0],[64,103,64,104,0],[66,13,66,14,0],[67,17,67,82,0],[68,13,68,14,0],[70,13,70,14,0],[71,17,71,93,0],[72,13,72,14,0],[74,13,74,14,0],[75,17,75,86,0],[76,13,76,14,0],[78,13,78,14,0],[79,17,80,163,0],[81,13,81,14,0],[92,3,92,4,0],[93,4,93,49,0],[94,4,94,16,0],[95,3,95,4,0],[102,3,102,4,0],[103,4,103,53,0],[104,4,104,16,0],[105,3,105,4,0],[113,3,113,4,0],[114,4,114,78,0],[115,4,115,16,0],[116,3,116,4,0],[123,9,123,10,0],[124,13,124,55,0],[125,13,125,25,0],[126,9,126,10,0],[129,9,129,10,0],[130,13,130,84,0],[131,13,131,25,0],[132,9,132,10,0],[141,3,141,4,0],[142,4,142,134,0],[143,4,143,16,0],[144,3,144,4,0],[151,3,151,4,0],[153,4,153,34,0],[153,35,153,47,0],[155,13,155,41,0],[157,13,157,44,0],[158,17,158,48,0],[160,13,160,70,0],[162,13,162,25,0],[163,3,163,4,0],[170,9,170,10,0],[171,13,171,43,0],[171,44,171,56,0],[173,13,173,41,0],[175,13,175,82,0],[177,13,177,25,0],[178,9,178,10,0],[181,9,181,10,0],[182,13,182,104,0],[183,13,183,14,0],[184,17,184,96,0],[185,13,185,14,0],[187,13,187,44,0],[188,17,188,48,0],[190,13,190,24,0],[191,9,191,10,0],[199,3,199,4,0],[200,13,200,117,0],[201,3,201,4,0],[214,3,214,4,0],[216,4,216,16,0],[217,3,217,4,0],[248,3,248,4,0],[249,4,249,98,0],[250,4,250,16,0],[251,3,251,4,0],[254,3,254,4,0],[255,4,255,85,0],[256,4,256,16,0],[257,3,257,4,0],[260,3,260,4,0],[261,4,261,85,0],[262,4,262,16,0],[263,3,263,4,0],[276,3,276,4,0],[277,4,277,140,0],[278,4,278,16,0],[279,3,279,4,0],[295,3,295,4,0],[296,4,296,77,0],[297,4,297,16,0],[298,3,298,4,0],[306,3,306,4,0],[307,4,307,62,0],[308,4,308,16,0],[309,3,309,4,0],[315,9,315,10,0],[316,13,316,41,0],[317,9,317,10,0],[329,3,329,4,0],[330,4,330,137,0],[331,4,331,16,0],[332,3,332,4,0],[335,3,335,4,0],[336,4,336,54,0],[337,3,337,4,0],[345,3,345,4,0],[348,13,348,58,0],[349,13,349,14,0],[350,17,350,126,0],[351,13,351,14,0],[353,13,353,14,0],[354,17,354,124,0],[355,13,355,14,0],[356,3,356,4,0]]);
    </script>
  </body>
</html>