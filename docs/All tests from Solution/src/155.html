<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Tests\Strings\LegacyShortStringHelperTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Collections.Generic;
using System.Linq;
using NUnit.Framework;
using Umbraco.Core.Strings;
using Umbraco.Tests.TestHelpers;

namespace Umbraco.Tests.Strings
{
    [TestFixture]
    public class LegacyShortStringHelperTests
    {
        private LegacyShortStringHelper _helper;

        [SetUp]
        public void Setup()
        {
            var config = SettingsForTests.GetDefault();
            SettingsForTests.ConfigureSettings(config);
            _helper = new LegacyShortStringHelper();
        }

        [TearDown]
        public void TearDown()
        {
        }


        #region Cases
        [TestCase(&quot;foo&quot;, &quot;foo&quot;)]
        [TestCase(&quot;    foo    &quot;, &quot;Foo&quot;)]
        [TestCase(&quot;Foo&quot;, &quot;Foo&quot;)]
        [TestCase(&quot;FoO&quot;, &quot;FoO&quot;)]
        [TestCase(&quot;FoO bar&quot;, &quot;FoOBar&quot;)]
        [TestCase(&quot;FoO bar NIL&quot;, &quot;FoOBarNIL&quot;)]
        [TestCase(&quot;FoO 33bar 22NIL&quot;, &quot;FoO33bar22NIL&quot;)]
        [TestCase(&quot;FoO 33bar 22NI&quot;, &quot;FoO33bar22NI&quot;)]
        [TestCase(&quot;0foo&quot;, &quot;foo&quot;)]
        [TestCase(&quot;2foo bar&quot;, &quot;fooBar&quot;)]
        [TestCase(&quot;9FOO&quot;, &quot;FOO&quot;)]
        [TestCase(&quot;foo-BAR&quot;, &quot;foo-BAR&quot;)]
        [TestCase(&quot;foo-BA-dang&quot;, &quot;foo-BA-dang&quot;)]
        [TestCase(&quot;foo_BAR&quot;, &quot;foo_BAR&quot;)]
        [TestCase(&quot;foo&#39;BAR&quot;, &quot;fooBAR&quot;)]
        [TestCase(&quot;saut&#233; dans l&#39;espace&quot;, &quot;sauteDansLespace&quot;, IgnoreReason = &quot;non-supported non-ascii chars&quot;)]
        [TestCase(&quot;foo\&quot;\&quot;bar&quot;, &quot;foobar&quot;)]
        [TestCase(&quot;-foo-&quot;, &quot;-foo-&quot;)]
        [TestCase(&quot;_foo_&quot;, &quot;_foo_&quot;)]
        [TestCase(&quot;sp&#233;cial&quot;, &quot;special&quot;, IgnoreReason = &quot;non-supported non-ascii chars&quot;)]
        [TestCase(&quot;br&#244; d&#235;k &quot;, &quot;broDek&quot;, IgnoreReason = &quot;non-supported non-ascii chars&quot;)]
        [TestCase(&quot;1235br&#244; d&#235;k &quot;, &quot;broDek&quot;, IgnoreReason = &quot;non-supported non-ascii chars&quot;)]
        [TestCase(&quot;汉#字*/漢?字&quot;, &quot;&quot;)]
        [TestCase(&quot;aa DB cd EFG X KLMN OP qrst&quot;, &quot;aaDBCdEFGXKLMNOPQrst&quot;)]
        [TestCase(&quot;AA db cd EFG X KLMN OP qrst&quot;, &quot;AADbCdEFGXKLMNOPQrst&quot;)]
        [TestCase(&quot;AAA db cd EFG X KLMN OP qrst&quot;, &quot;AAADbCdEFGXKLMNOPQrst&quot;)]
        [TestCase(&quot;4 ways selector&quot;, &quot;WaysSelector&quot;)]
        [TestCase(&quot;WhatIfWeDoItAgain&quot;, &quot;WhatIfWeDoItAgain&quot;)]
        [TestCase(&quot;whatIfWeDoItAgain&quot;, &quot;whatIfWeDoItAgain&quot;)]
        [TestCase(&quot;WhatIfWEDOITAgain&quot;, &quot;WhatIfWEDOITAgain&quot;)]
        [TestCase(&quot;WhatIfWe doItAgain&quot;, &quot;WhatIfWeDoItAgain&quot;)]
        #endregion
        public void CleanStringForSafeAlias(string input, string expected)
        {
            // NOTE legacy CleanStringForSafeAlias has issues w/some cases
            // -&gt; ignore test cases
            // also, some aliases are strange... how can &quot;-foo-&quot; be a valid alias?
            var output = _helper.CleanStringForSafeAlias(input);
            Assert.AreEqual(expected, output);
        }

        #region Cases
        [TestCase(&quot;Tab 1&quot;, &quot;tab1&quot;)]
        [TestCase(&quot;Home - Page&quot;, &quot;homePage&quot;)]
        [TestCase(&quot;Home.Page&quot;, &quot;homePage&quot;)]
        [TestCase(&quot;Shannon&#39;s Document Type&quot;, &quot;shannonsDocumentType&quot;)] // look, lowercase s and the end of shannons
        [TestCase(&quot;!BADDLY nam-ed Document Type&quot;, &quot;baddlyNamEdDocumentType&quot;)]
        [TestCase(&quot;i %Want!thisTo end up In Proper@case&quot;, &quot;iWantThisToEndUpInProperCase&quot;)]
        [TestCase(&quot;R&#228;ksm&#246;rg&#229;s %%$&#163;&#164;&#164;&#164;&#167; k&#233;K&#233;&quot;, &quot;raksmorgasKeKe&quot;, IgnoreReason = &quot;non-supported non-ascii chars&quot;)]
        [TestCase(&quot;TRii&quot;, &quot;tRii&quot;)]
        [TestCase(&quot;**TRii&quot;, &quot;tRii&quot;)]
        [TestCase(&quot;trII&quot;, &quot;trII&quot;)]
        [TestCase(&quot;**trII&quot;, &quot;trII&quot;)]
        [TestCase(&quot;trIIX&quot;, &quot;trIIX&quot;)]
        [TestCase(&quot;**trIIX&quot;, &quot;trIIX&quot;)]
        #endregion
        public void LegacyCleanStringForUmbracoAlias(string input, string expected)
        {
            // NOTE ToUmbracoAlias has issues w/non-ascii, and a few other things
            // -&gt; ignore test cases
            // also all those tests should, in theory, fail because removeSpaces is false by default
            var output = _helper.LegacyCleanStringForUmbracoAlias(input);
            Assert.AreEqual(expected, output);
        }

        #region Cases
        [TestCase(&quot;Home Page&quot;, &quot;home-page&quot;)]
        [TestCase(&quot;Shannon&#39;s Home Page!&quot;, &quot;shannons-home-page!&quot;)]
        [TestCase(&quot;#Someones&#39;s Twitter $h1z%n&quot;, &quot;someoness-twitter-$h1zn&quot;)]
        [TestCase(&quot;R&#228;ksm&#246;rg&#229;s&quot;, &quot;raeksmoergaas&quot;)]
        [TestCase(&quot;&#39;em guys-over there, are#goin&#39; a \&quot;little\&quot;bit crazy eh!! :)&quot;, &quot;em-guys-over-there,-aregoin-a-littlebit-crazy-eh!!-)&quot;)]
        [TestCase(&quot;汉#字*/漢?字&quot;, &quot;汉字star漢字&quot;)]
        [TestCase(&quot;R&#233;al&#246;sk fix bran#lo&#39;sk&quot;, &quot;realosk-fix-bran-lo-sk&quot;, IgnoreReason = &quot;cannot handle it&quot;)]
        #endregion
        public void LegacyFormatUrl(string input, string expected)
        {
            // NOTE CleanStringForUrlSegment has issues with a few cases
            // -&gt; ignore test cases
            // also some results are a bit strange...
            var output = _helper.LegacyFormatUrl(input);
            Assert.AreEqual(expected, output);

            // NOTE: not testing the overload with culture
            // in legacy, they are the same
        }

        #region Cases
        [TestCase(&quot;Home Page&quot;, &quot;home-page&quot;, true, true, false)]
        [TestCase(&quot;Shannon&#39;s Home Page!&quot;, &quot;shannons-home-page&quot;, true, true, false)]
        [TestCase(&quot;#Someones&#39;s Twitter $h1z%n&quot;, &quot;someoness-twitter-h1zn&quot;, true, true, false)]
        [TestCase(&quot;R&#228;ksm&#246;rg&#229;s&quot;, &quot;rksmrgs&quot;, true, true, false)]
        [TestCase(&quot;&#39;em guys-over there, are#goin&#39; a \&quot;little\&quot;bit crazy eh!! :)&quot;, &quot;em-guys-over-there-aregoin-a-littlebit-crazy-eh&quot;, true, true, false)]
        [TestCase(&quot;汉#字*/漢?字&quot;, &quot;&quot;, true, true, false)]
        [TestCase(&quot;汉#字*/漢?字&quot;, &quot;汉字漢字&quot;, true, false, false)]
        [TestCase(&quot;汉#字*/漢?字&quot;, &quot;%e6%b1%89%e5%ad%97%e6%bc%a2%e5%ad%97&quot;, true, false, true)]
        [TestCase(&quot;R&#233;al&#246;sk fix bran#lo&#39;sk&quot;, &quot;realosk-fix-bran-lo-sk&quot;, true, true, false, IgnoreReason = &quot;cannot handle it&quot;)]
        #endregion
        public void LegacyToUrlAlias(string input, string expected, bool replaceDoubleDashes, bool stripNonAscii, bool urlEncode)
        {
            var replacements = new Dictionary&lt;string, string&gt;
            {
                {&quot; &quot;, &quot;-&quot;},
                {&quot;\&quot;&quot;, &quot;&quot;},
                {&quot;&amp;quot;&quot;, &quot;&quot;},
                {&quot;@&quot;, &quot;&quot;},
                {&quot;%&quot;, &quot;&quot;},
                {&quot;.&quot;, &quot;&quot;},
                {&quot;;&quot;, &quot;&quot;},
                {&quot;/&quot;, &quot;&quot;},
                {&quot;:&quot;, &quot;&quot;},
                {&quot;#&quot;, &quot;&quot;},
                {&quot;+&quot;, &quot;&quot;},
                {&quot;*&quot;, &quot;&quot;},
                {&quot;&amp;amp;&quot;, &quot;&quot;},
                {&quot;?&quot;, &quot;&quot;}
            };

            // NOTE CleanStringForUrlSegment has issues with a few cases
            // -&gt; ignore test cases
            // also some results are a bit strange...
            var output = _helper.LegacyToUrlAlias(input, replacements, replaceDoubleDashes, stripNonAscii, urlEncode);
            Assert.AreEqual(expected, output);

            // NOTE: not testing the overload with culture
            // in legacy, they are the same
        }

        #region Cases
        [TestCase(&quot;Tab 1&quot;, &quot;tab1&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;Home - Page&quot;, &quot;homePage&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;Shannon&#39;s document type&quot;, &quot;shannon&#39;sDocumentType&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;This is the FIRSTTIME of TheDay.&quot;, &quot;ThisistheFIRSTTIMEofTheDay&quot;, CleanStringType.Unchanged)]
        [TestCase(&quot;S&#233;p&#224;y&#244; l&#252;x.&quot;, &quot;Sepayolux&quot;, CleanStringType.Unchanged, IgnoreReason = &quot;non-supported non-ascii chars&quot;)]
        [TestCase(&quot;This is the FIRSTTIME of TheDay.&quot;, &quot;ThisIsTheFIRSTTIMEOfTheDay&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;This is the FIRSTTIME of TheDay.&quot;, &quot;thisIsTheFIRSTTIMEOfTheDay&quot;, CleanStringType.CamelCase)]
        #endregion
        public void LegacyConvertStringCase(string input, string expected, CleanStringType caseType)
        {
            // NOTE LegacyConvertStringCase has issues with a few cases
            // -&gt; ignore test cases
            // also it removes symbols, etc... except the quote?
            var output = _helper.LegacyConvertStringCase(input, caseType);
            Assert.AreEqual(expected, output);
        }

        #region Cases
        [TestCase(&quot;ThisIsTheEndMyFriend&quot;, &quot;This Is The End My Friend&quot;)]
        [TestCase(&quot;ThisIsTHEEndMyFriend&quot;, &quot;This Is THE End My Friend&quot;)]
        [TestCase(&quot;THISIsTHEEndMyFriend&quot;, &quot;THIS Is THE End My Friend&quot;)]
        [TestCase(&quot;This33I33sThe33EndMyFriend&quot;, &quot;This33 I33s The33 End My Friend&quot;, IgnoreReason = &quot;fails&quot;)]
        [TestCase(&quot;ThisIsTHEEndMyFriendX&quot;, &quot;This Is THE End My Friend X&quot;)]
        [TestCase(&quot;ThisIsTHEEndMyFriendXYZ&quot;, &quot;This Is THE End My Friend XYZ&quot;)]
        [TestCase(&quot;ThisIsTHEEndMyFriendXYZt&quot;, &quot;This Is THE End My Friend XY Zt&quot;)]
        [TestCase(&quot;Une&#201;l&#233;vation&#192;Partir&quot;, &quot;Une &#201;l&#233;vation &#192; Partir&quot;, IgnoreReason = &quot;non-supported non-ascii chars&quot;)]
        #endregion
        public void SplitPascalCasing(string input, string expected)
        {
            // NOTE legacy SplitPascalCasing has issues w/some cases
            // -&gt; ignore test cases
            var output = _helper.SplitPascalCasing(input, &#39; &#39;);
            Assert.AreEqual(expected, output);
        }

        #region Cases
        [TestCase(&quot;foo&quot;, &quot;foo&quot;)]
        [TestCase(&quot;    foo    &quot;, &quot;foo&quot;)]
        [TestCase(&quot;Foo&quot;, &quot;foo&quot;)]
        [TestCase(&quot;FoO&quot;, &quot;foO&quot;)]
        [TestCase(&quot;FoO bar&quot;, &quot;foOBar&quot;)]
        [TestCase(&quot;FoO bar NIL&quot;, &quot;foOBarNil&quot;)]
        [TestCase(&quot;FoO 33bar 22NIL&quot;, &quot;foO33bar22Nil&quot;)]
        [TestCase(&quot;FoO 33bar 22NI&quot;, &quot;foO33bar22NI&quot;)]
        [TestCase(&quot;0foo&quot;, &quot;foo&quot;)]
        [TestCase(&quot;2foo bar&quot;, &quot;fooBar&quot;)]
        [TestCase(&quot;9FOO&quot;, &quot;foo&quot;)]
        [TestCase(&quot;foo-BAR&quot;, &quot;fooBar&quot;)]
        [TestCase(&quot;foo-BA-dang&quot;, &quot;fooBADang&quot;)]
        [TestCase(&quot;foo_BAR&quot;, &quot;fooBar&quot;)]
        [TestCase(&quot;foo&#39;BAR&quot;, &quot;fooBar&quot;)]
        [TestCase(&quot;saut&#233; dans l&#39;espace&quot;, &quot;sauteDansLEspace&quot;)]
        [TestCase(&quot;foo\&quot;\&quot;bar&quot;, &quot;fooBar&quot;)]
        [TestCase(&quot;-foo-&quot;, &quot;foo&quot;)]
        [TestCase(&quot;_foo_&quot;, &quot;foo&quot;)]
        [TestCase(&quot;sp&#233;cial&quot;, &quot;special&quot;)]
        [TestCase(&quot;br&#244; d&#235;k &quot;, &quot;broDek&quot;)]
        [TestCase(&quot;1235br&#244; d&#235;k &quot;, &quot;broDek&quot;)]
        [TestCase(&quot;汉#字*/漢?字&quot;, &quot;&quot;)]
        [TestCase(&quot;aa DB cd EFG X KLMN OP qrst&quot;, &quot;aaDBCdEfgXKlmnOPQrst&quot;)]
        [TestCase(&quot;AA db cd EFG X KLMN OP qrst&quot;, &quot;aaDbCdEfgXKlmnOPQrst&quot;)]
        [TestCase(&quot;AAA db cd EFG X KLMN OP qrst&quot;, &quot;aaaDbCdEfgXKlmnOPQrst&quot;)]
        #endregion
        public void CleanStringToAscii(string input, string expected)
        {
            var output = _helper.CleanString(input, CleanStringType.Ascii | CleanStringType.CamelCase);
            // legacy does nothing
            Assert.AreEqual(input, output);
        }

        #region Cases
        [TestCase(&quot;1235br&#244; d&#235;K tzARlan ban123!pOo&quot;, &quot;brodeKtzARlanban123pOo&quot;, CleanStringType.Unchanged)]
        [TestCase(&quot;    1235br&#244; d&#235;K tzARlan ban123!pOo    &quot;, &quot;brodeKtzARlanban123pOo&quot;, CleanStringType.Unchanged)]
        [TestCase(&quot;1235br&#244; d&#235;K tzARlan ban123!pOo&quot;, &quot;BroDeKTzARLanBan123POo&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;1235br&#244; d&#235;K tzARlan ban123!pOo&quot;, &quot;broDeKTzARLanBan123POo&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;1235br&#244; d&#235;K tzARlan ban123!pOo&quot;, &quot;BRODEKTZARLANBAN123POO&quot;, CleanStringType.UpperCase)]
        [TestCase(&quot;1235br&#244; d&#235;K tzARlan ban123!pOo&quot;, &quot;brodektzarlanban123poo&quot;, CleanStringType.LowerCase)]
        [TestCase(&quot;aa DB cd EFG X KLMN OP qrst&quot;, &quot;aaDBCdEfgXKlmnOPQrst&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;aaa DB cd EFG X KLMN OP qrst&quot;, &quot;aaaDBCdEfgXKlmnOPQrst&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;aa DB cd EFG X KLMN OP qrst&quot;, &quot;AaDBCdEfgXKlmnOPQrst&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;aaa DB cd EFG X KLMN OP qrst&quot;, &quot;AaaDBCdEfgXKlmnOPQrst&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;AA db cd EFG X KLMN OP qrst&quot;, &quot;aaDbCdEfgXKlmnOPQrst&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;AAA db cd EFG X KLMN OP qrst&quot;, &quot;aaaDbCdEfgXKlmnOPQrst&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;AA db cd EFG X KLMN OP qrst&quot;, &quot;AADbCdEfgXKlmnOPQrst&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;AAA db cd EFG X KLMN OP qrst&quot;, &quot;AaaDbCdEfgXKlmnOPQrst&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;We store some HTML in the DB for performance&quot;, &quot;WeStoreSomeHtmlInTheDBForPerformance&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;We store some HTML in the DB for performance&quot;, &quot;weStoreSomeHtmlInTheDBForPerformance&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;X is true&quot;, &quot;XIsTrue&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;X is true&quot;, &quot;xIsTrue&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;IO are slow&quot;, &quot;IOAreSlow&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;IO are slow&quot;, &quot;ioAreSlow&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;RAM is fast&quot;, &quot;RamIsFast&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;RAM is fast&quot;, &quot;ramIsFast&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;Tab 1&quot;, &quot;tab1&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;Home - Page&quot;, &quot;homePage&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;Shannon&#39;s Document Type&quot;, &quot;shannonsDocumentType&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;!BADDLY nam-ed Document Type&quot;, &quot;baddlyNamEdDocumentType&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;  !BADDLY nam-ed Document Type&quot;, &quot;BADDLYnamedDocumentType&quot;, CleanStringType.Unchanged)]
        [TestCase(&quot;!BADDLY nam-ed   Document Type&quot;, &quot;BaddlyNamEdDocumentType&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;i %Want!thisTo end up In Proper@case&quot;, &quot;IWantThisToEndUpInProperCase&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;R&#228;ksm&#246;rg&#229;s %%$&#163;&#164;&#164;&#164;&#167; k&#233;K&#233;&quot;, &quot;raksmorgasKeKe&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;R&#228;ksm&#246;rg&#229;s %%$&#163;&#164;&#164;&#164;&#167; k&#233;K&#233;&quot;, &quot;RaksmorgasKeKe&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;R&#228;ksm&#246;rg&#229;s %%$&#163;&#164;&#164;&#164;&#167; k&#233;K&#233;&quot;, &quot;RaksmorgaskeKe&quot;, CleanStringType.Unchanged)]
        [TestCase(&quot;TRii&quot;, &quot;TRii&quot;, CleanStringType.Unchanged)]
        [TestCase(&quot;**TRii&quot;, &quot;TRii&quot;, CleanStringType.Unchanged)]
        [TestCase(&quot;TRii&quot;, &quot;trIi&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;**TRii&quot;, &quot;trIi&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;TRii&quot;, &quot;TRIi&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;**TRii&quot;, &quot;TRIi&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;trII&quot;, &quot;trII&quot;, CleanStringType.Unchanged)]
        [TestCase(&quot;**trII&quot;, &quot;trII&quot;, CleanStringType.Unchanged)]
        [TestCase(&quot;trII&quot;, &quot;trII&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;**trII&quot;, &quot;trII&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;trII&quot;, &quot;TrII&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;**trII&quot;, &quot;TrII&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;trIIX&quot;, &quot;trIix&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;**trIIX&quot;, &quot;trIix&quot;, CleanStringType.CamelCase)]
        [TestCase(&quot;trIIX&quot;, &quot;TrIix&quot;, CleanStringType.PascalCase)]
        [TestCase(&quot;**trIIX&quot;, &quot;TrIix&quot;, CleanStringType.PascalCase)]
        #endregion
        public void CleanStringToAsciiWithCase(string input, string expected, CleanStringType caseType)
        {
            var output = _helper.CleanString(input, caseType | CleanStringType.Ascii);
            // legacy does nothing
            Assert.AreEqual(input, output);
        }

        #region Cases
        [TestCase(&quot;1235br&#244; d&#235;K tzARlan ban123!pOo&quot;, &quot;bro de K tz AR lan ban123 p Oo&quot;, &#39; &#39;, CleanStringType.Unchanged)]
        [TestCase(&quot;    1235br&#244; d&#235;K tzARlan ban123!pOo    &quot;, &quot;bro de K tz AR lan ban123 p Oo&quot;, &#39; &#39;, CleanStringType.Unchanged)]
        [TestCase(&quot;1235br&#244; d&#235;K tzARlan ban123!pOo&quot;, &quot;Bro De K Tz AR Lan Ban123 P Oo&quot;, &#39; &#39;, CleanStringType.PascalCase)]
        [TestCase(&quot;1235br&#244; d&#235;K     tzARlan ban123!pOo&quot;, &quot;Bro De K Tz AR Lan Ban123 P Oo&quot;, &#39; &#39;, CleanStringType.PascalCase)]
        [TestCase(&quot;1235br&#244; d&#235;K tzARlan ban123!pOo&quot;, &quot;bro De K Tz AR Lan Ban123 P Oo&quot;, &#39; &#39;, CleanStringType.CamelCase)]
        [TestCase(&quot;1235br&#244; d&#235;K tzARlan ban123!pOo&quot;, &quot;bro-De-K-Tz-AR-Lan-Ban123-P-Oo&quot;, &#39;-&#39;, CleanStringType.CamelCase)]
        [TestCase(&quot;1235br&#244; d&#235;K tzARlan ban123!pOo&quot;, &quot;BRO-DE-K-TZ-AR-LAN-BAN123-P-OO&quot;, &#39;-&#39;, CleanStringType.UpperCase)]
        [TestCase(&quot;1235br&#244; d&#235;K tzARlan ban123!pOo&quot;, &quot;bro-de-k-tz-ar-lan-ban123-p-oo&quot;, &#39;-&#39;, CleanStringType.LowerCase)]
        [TestCase(&quot;Tab 1&quot;, &quot;tab 1&quot;, &#39; &#39;, CleanStringType.CamelCase)]
        [TestCase(&quot;Home - Page&quot;, &quot;home Page&quot;, &#39; &#39;, CleanStringType.CamelCase)]
        [TestCase(&quot;Shannon&#39;s Document Type&quot;, &quot;shannons Document Type&quot;, &#39; &#39;, CleanStringType.CamelCase)]
        [TestCase(&quot;!BADDLY nam-ed Document Type&quot;, &quot;baddly Nam Ed Document Type&quot;, &#39; &#39;, CleanStringType.CamelCase)]
        [TestCase(&quot;  !BADDLY nam-ed Document Type&quot;, &quot;BADDLY nam ed Document Type&quot;, &#39; &#39;, CleanStringType.Unchanged)]
        [TestCase(&quot;!BADDLY nam-ed   Document Type&quot;, &quot;Baddly Nam Ed Document Type&quot;, &#39; &#39;, CleanStringType.PascalCase)]
        [TestCase(&quot;i %Want!thisTo end up In Proper@case&quot;, &quot;I Want This To End Up In Proper Case&quot;, &#39; &#39;, CleanStringType.PascalCase)]
        [TestCase(&quot;R&#228;ksm&#246;rg&#229;s %%$&#163;&#164;&#164;&#164;&#167; k&#233;K&#233;&quot;, &quot;raksmorgas Ke Ke&quot;, &#39; &#39;, CleanStringType.CamelCase)]
        [TestCase(&quot;R&#228;ksm&#246;rg&#229;s %%$&#163;&#164;&#164;&#164;&#167; k&#233;K&#233;&quot;, &quot;Raksmorgas Ke Ke&quot;, &#39; &#39;, CleanStringType.PascalCase)]
        [TestCase(&quot;R&#228;ksm&#246;rg&#229;s %%$&#163;&#164;&#164;&#164;&#167; k&#233;K&#233;&quot;, &quot;Raksmorgas ke Ke&quot;, &#39; &#39;, CleanStringType.Unchanged)]
        #endregion
        public void CleanStringToAsciiWithCaseAndSeparator(string input, string expected, char separator, CleanStringType caseType)
        {
            var output = _helper.CleanString(input, caseType | CleanStringType.Ascii, separator);
            // legacy does nothing
            Assert.AreEqual(input, output);
        }

        [Test] // can&#39;t do cases with an IDictionary
        public void ReplaceManyWithCharMap()
        {
            const string input = &quot;t&#233;l&#233;visi&#246;n tzv&#226;r &#223;up &amp;nbsp; pof&quot;;
            const string expected = &quot;television tzvar ssup   pof&quot;;
            IDictionary&lt;string, string&gt; replacements = new Dictionary&lt;string, string&gt;
                {
                    { &quot;&#233;&quot;, &quot;e&quot; },
                    { &quot;&#246;&quot;, &quot;o&quot; },
                    { &quot;&#226;&quot;, &quot;a&quot; },
                    { &quot;&#223;&quot;, &quot;ss&quot; },
                    { &quot;&amp;nbsp;&quot;, &quot; &quot; },
                };
            var output = _helper.ReplaceMany(input, replacements);
            Assert.AreEqual(expected, output);
        }

        #region Cases
        [TestCase(&quot;val$id!ate|this|str&#39;ing&quot;, &quot;$!&#39;&quot;, &#39;-&#39;, &quot;val-id-ate|this|str-ing&quot;)]
        [TestCase(&quot;val$id!ate|this|str&#39;ing&quot;, &quot;$!&#39;&quot;, &#39;*&#39;, &quot;val*id*ate|this|str*ing&quot;)]
        #endregion
        public void ReplaceManyByOneChar(string input, string toReplace, char replacement, string expected)
        {
            var output = _helper.ReplaceMany(input, toReplace.ToArray(), replacement);
            Assert.AreEqual(expected, output);
        }

        #region Cases
        [TestCase(&quot;foo.txt&quot;, &quot;foo.txt&quot;)]
        [TestCase(&quot;foo&quot;, &quot;foo&quot;, IgnoreReason = &quot;fails when no extension&quot;)]
        [TestCase(&quot;.txt&quot;, &quot;.txt&quot;)]
        [TestCase(&quot;nag*dog/poo:xit.txt&quot;, &quot;nag-dog-poo-xit.txt&quot;)]
        [TestCase(&quot;the dog is in the house.txt&quot;, &quot;the-dog-is-in-the-house.txt&quot;)]
        [TestCase(&quot;nil.nil.nil.txt&quot;, &quot;nilnilnil.txt&quot;)] // because of chars map
        [TestCase(&quot;taradabum&quot;, &quot;taradabum&quot;, IgnoreReason = &quot;fails when no extension&quot;)]
        [TestCase(&quot;tara$$da:b/u&lt;m&quot;, &quot;tara-da-b-u-m&quot;, IgnoreReason = &quot;fails when no extension&quot;)]
        [TestCase(&quot;Stra&#223;e Zv&#246;sk&#238;.yop&quot;, &quot;Strasse-Zvoesk&#238;.yop&quot;)] // because of chars map + does not lowercase
        [TestCase(&quot;yop.Stra&#223;e Zv&#246;sk&#238;&quot;, &quot;yop.Stra&#223;e-Zv&#246;sk&#238;&quot;)] // also note that neither &#238; nor &#223; are removed, not in the map
        [TestCase(&quot;yop.Stra&#223;e Zv&#246;s--k&#238;&quot;, &quot;yop.Stra&#223;e-Zv&#246;s-k&#238;&quot;)] // and finaly, not the same rule for ext eg &#246;...
        [TestCase(&quot;ma--ma---ma.ma-----ma&quot;, &quot;ma-ma-ma.ma-ma&quot;)]
        #endregion
        public void CleanStringForSafeFileName(string input, string expected)
        {
            var output = _helper.CleanStringForSafeFileName(input);
            Assert.AreEqual(expected, output);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[16,9,16,10,1],[17,13,17,56,1],[18,13,18,56,1],[19,13,19,53,1],[20,9,20,10,1],[24,9,24,10,1],[25,9,25,10,1],[62,9,62,10,1],[66,13,66,65,1],[67,13,67,47,1],[68,9,68,10,1],[86,9,86,10,1],[90,13,90,74,1],[91,13,91,47,1],[92,9,92,10,1],[104,9,104,10,1],[108,13,108,57,1],[109,13,109,47,1],[113,9,113,10,1],[127,9,127,10,1],[128,13,144,15,1],[149,13,149,119,1],[150,13,150,47,1],[154,9,154,10,1],[166,9,166,10,1],[170,13,170,75,1],[171,13,171,47,1],[172,9,172,10,1],[185,9,185,10,1],[188,13,188,64,1],[189,13,189,47,1],[190,9,190,10,1],[221,9,221,10,1],[222,13,222,104,1],[224,13,224,44,1],[225,9,225,10,1],[278,9,278,10,1],[279,13,279,87,1],[281,13,281,44,1],[282,9,282,10,1],[305,9,305,10,1],[306,13,306,98,1],[308,13,308,44,1],[309,9,309,10,1],[313,9,313,10,1],[316,13,323,19,1],[324,13,324,67,1],[325,13,325,47,1],[326,9,326,10,1],[333,9,333,10,1],[334,13,334,87,1],[335,13,335,47,1],[336,9,336,10,1],[353,9,353,10,1],[354,13,354,68,1],[355,13,355,47,1],[356,9,356,10,1]]);
    </script>
  </body>
</html>