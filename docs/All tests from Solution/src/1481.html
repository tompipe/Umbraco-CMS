<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Packaging\ConflictingPackageData.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using Umbraco.Core.Models;
using Umbraco.Core.Services;

namespace Umbraco.Core.Packaging
{
    internal class ConflictingPackageData : IConflictingPackageData
    {
        private readonly IMacroService _macroService;
        private readonly IFileService _fileService;

        public ConflictingPackageData(IMacroService macroService,
            IFileService fileService)
        {
            if (fileService != null) _fileService = fileService;
            else throw new ArgumentNullException(&quot;fileService&quot;);
            if (macroService != null) _macroService = macroService;
            else throw new ArgumentNullException(&quot;macroService&quot;);
        }
        
        public IEnumerable&lt;IFile&gt; FindConflictingStylesheets(XElement stylesheetNotes)
        {
            if (string.Equals(Constants.Packaging.StylesheetsNodeName, stylesheetNotes.Name.LocalName) == false)
            {
                throw new ArgumentException(&quot;the root element must be \&quot;&quot; + Constants.Packaging.StylesheetsNodeName + &quot;\&quot;&quot;, &quot;stylesheetNotes&quot;);
            }

            return stylesheetNotes.Elements(Constants.Packaging.StylesheetNodeName)
                .Select(n =&gt;
                {
                    XElement xElement = n.Element(Constants.Packaging.NameNodeName);
                    if (xElement == null)
                    {
                        throw new ArgumentException(&quot;Missing \&quot;&quot; + Constants.Packaging.NameNodeName + &quot;\&quot; element&quot;,
                            &quot;stylesheetNotes&quot;);
                    }

                    return _fileService.GetStylesheetByName(xElement.Value) as IFile;
                })
                .Where(v =&gt; v != null);
        }

        public IEnumerable&lt;ITemplate&gt; FindConflictingTemplates(XElement templateNotes)
        {
            if (string.Equals(Constants.Packaging.TemplatesNodeName, templateNotes.Name.LocalName) == false)
            {
                throw new ArgumentException(&quot;Node must be a \&quot;&quot; + Constants.Packaging.TemplatesNodeName + &quot;\&quot; node&quot;,
                    &quot;templateNotes&quot;);
            }

            return templateNotes.Elements(Constants.Packaging.TemplateNodeName)
                .Select(n =&gt;
                {
                    XElement xElement = n.Element(Constants.Packaging.AliasNodeNameCapital) ?? n.Element(Constants.Packaging.AliasNodeNameSmall);
                    if (xElement == null)
                    {
                        throw new ArgumentException(&quot;missing a \&quot;&quot; + Constants.Packaging.AliasNodeNameCapital + &quot;\&quot; element&quot;,
                            &quot;templateNotes&quot;);
                    }

                    return _fileService.GetTemplate(xElement.Value);
                })
                .Where(v =&gt; v != null);
        }

        public IEnumerable&lt;IMacro&gt; FindConflictingMacros(XElement macroNodes)
        {
            if (string.Equals(Constants.Packaging.MacrosNodeName, macroNodes.Name.LocalName) == false)
            {
                throw new ArgumentException(&quot;Node must be a \&quot;&quot; + Constants.Packaging.MacrosNodeName + &quot;\&quot; node&quot;,
                    &quot;macroNodes&quot;);
            }
            
            return macroNodes.Elements(Constants.Packaging.MacroNodeName)
                .Select(n =&gt;
                {
                    XElement xElement = n.Element(Constants.Packaging.AliasNodeNameSmall) ?? n.Element(Constants.Packaging.AliasNodeNameCapital);
                    if (xElement == null)
                    {
                        throw new ArgumentException(string.Format(&quot;missing a \&quot;{0}\&quot; element in {0} element&quot;, Constants.Packaging.AliasNodeNameSmall),
                            &quot;macroNodes&quot;);
                    }

                    return _macroService.GetByAlias(xElement.Value);
                })
                .Where(v =&gt; v != null);
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[15,9,16,38,1],[17,9,17,10,1],[18,13,18,37,1],[18,38,18,65,1],[19,18,19,65,0],[20,13,20,38,1],[20,39,20,68,1],[21,18,21,66,0],[22,9,22,10,1],[25,9,25,10,1],[26,13,26,113,1],[27,13,27,14,0],[28,17,28,144,0],[31,13,33,17,1],[33,17,33,18,0],[33,18,34,21,1],[34,21,34,85,0],[34,85,35,21,1],[35,21,35,42,0],[35,42,36,21,1],[36,21,36,22,0],[36,22,37,25,1],[37,25,38,48,0],[38,48,41,21,1],[41,21,41,86,0],[41,86,42,17,1],[42,17,42,18,0],[42,18,43,29,1],[43,29,43,38,0],[43,38,43,40,1],[31,13,43,40,1],[44,9,44,10,1],[47,9,47,10,1],[48,13,48,109,1],[49,13,49,14,0],[50,17,51,38,0],[54,13,56,17,1],[56,17,56,18,0],[56,18,57,21,1],[57,21,57,146,0],[57,146,58,21,1],[58,21,58,42,0],[58,42,59,21,1],[59,21,59,22,0],[59,22,60,25,1],[60,25,61,46,0],[61,46,64,21,1],[64,21,64,69,0],[64,69,65,17,1],[65,17,65,18,0],[65,18,66,29,1],[66,29,66,38,0],[66,38,66,40,1],[54,13,66,40,1],[67,9,67,10,1],[70,9,70,10,1],[71,13,71,103,1],[72,13,72,14,0],[73,17,74,35,0],[77,13,79,17,1],[79,17,79,18,0],[79,18,80,21,1],[80,21,80,146,0],[80,146,81,21,1],[81,21,81,42,0],[81,42,82,21,1],[82,21,82,22,0],[82,22,83,25,1],[83,25,84,43,0],[84,43,87,21,1],[87,21,87,69,0],[87,69,88,17,1],[88,17,88,18,0],[88,18,89,29,1],[89,29,89,38,0],[89,38,89,40,1],[77,13,89,40,1],[90,9,90,10,1]]);
    </script>
  </body>
</html>