<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\ConcurrentHashSet.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace Umbraco.Core
{
    /// &lt;summary&gt;
    /// A thread-safe representation of a &lt;see cref=&quot;HashSet{T}&quot;/&gt;. 
    /// Enumerating this collection is thread-safe and will only operate on a clone that is generated before returning the enumerator.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
    [Serializable]
    public class ConcurrentHashSet&lt;T&gt; : ICollection&lt;T&gt;
    {
        private readonly HashSet&lt;T&gt; _innerSet = new HashSet&lt;T&gt;();
        private readonly ReaderWriterLockSlim _instanceLocker = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);

        /// &lt;summary&gt;
        /// Returns an enumerator that iterates through the collection.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// A &lt;see cref=&quot;T:System.Collections.Generic.IEnumerator`1&quot;/&gt; that can be used to iterate through the collection.
        /// &lt;/returns&gt;
        /// &lt;filterpriority&gt;1&lt;/filterpriority&gt;
        public IEnumerator&lt;T&gt; GetEnumerator()
        {
            return GetThreadSafeClone().GetEnumerator();
        }

        /// &lt;summary&gt;
        /// Returns an enumerator that iterates through a collection.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot;/&gt; object that can be used to iterate through the collection.
        /// &lt;/returns&gt;
        /// &lt;filterpriority&gt;2&lt;/filterpriority&gt;
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// &lt;summary&gt;
        /// Removes the first occurrence of a specific object from the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// true if &lt;paramref name=&quot;item&quot;/&gt; was successfully removed from the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt;; otherwise, false. This method also returns false if &lt;paramref name=&quot;item&quot;/&gt; is not found in the original &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt;.
        /// &lt;/returns&gt;
        /// &lt;param name=&quot;item&quot;&gt;The object to remove from the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt;.&lt;/param&gt;&lt;exception cref=&quot;T:System.NotSupportedException&quot;&gt;The &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt; is read-only.&lt;/exception&gt;
        public bool Remove(T item)
        {
            using (new WriteLock(_instanceLocker))
            {
                return _innerSet.Remove(item);
            }
        }


        /// &lt;summary&gt;
        /// Gets the number of elements contained in the &lt;see cref=&quot;T:System.Collections.ICollection&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// The number of elements contained in the &lt;see cref=&quot;T:System.Collections.ICollection&quot;/&gt;.
        /// &lt;/returns&gt;
        /// &lt;filterpriority&gt;2&lt;/filterpriority&gt;
        public int Count
        {
            get { return GetThreadSafeClone().Count; }
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt; is read-only.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// true if the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt; is read-only; otherwise, false.
        /// &lt;/returns&gt;
        public bool IsReadOnly
        {
            get { return false; }
        }

        /// &lt;summary&gt;
        /// Adds an item to the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;item&quot;&gt;The object to add to the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt;.&lt;/param&gt;&lt;exception cref=&quot;T:System.NotSupportedException&quot;&gt;The &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt; is read-only.&lt;/exception&gt;
        public void Add(T item)
        {
            using (new WriteLock(_instanceLocker))
            {
                _innerSet.Add(item);
            }
        }
        
        /// &lt;summary&gt;
        /// Attempts to add an item to the collection
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool TryAdd(T item)
        {
            var clone = GetThreadSafeClone();
            if (clone.Contains(item)) return false;
            using (new WriteLock(_instanceLocker))
            {
                //double check
                if (_innerSet.Contains(item)) return false;
                _innerSet.Add(item);
                return true;
            }
        }

        /// &lt;summary&gt;
        /// Removes all items from the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;exception cref=&quot;T:System.NotSupportedException&quot;&gt;The &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt; is read-only. &lt;/exception&gt;
        public void Clear()
        {
            using (new WriteLock(_instanceLocker))
            {
                _innerSet.Clear();
            }
        }

        /// &lt;summary&gt;
        /// Determines whether the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt; contains a specific value.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// true if &lt;paramref name=&quot;item&quot;/&gt; is found in the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt;; otherwise, false.
        /// &lt;/returns&gt;
        /// &lt;param name=&quot;item&quot;&gt;The object to locate in the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt;.&lt;/param&gt;
        public bool Contains(T item)
        {
            return GetThreadSafeClone().Contains(item);
        }

        /// &lt;summary&gt;
        /// Copies the elements of the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot;/&gt; to an &lt;see cref=&quot;T:System.Array&quot;/&gt;, starting at a specified index.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;array&quot;&gt;The one-dimensional &lt;see cref=&quot;T:System.Array&quot;/&gt; that is the destination of the elements copied from the &lt;see cref=&quot;T:System.Collections.Concurrent.IProducerConsumerCollection`1&quot;/&gt;. The array must have zero-based indexing.&lt;/param&gt;&lt;param name=&quot;index&quot;&gt;The zero-based index in &lt;paramref name=&quot;array&quot;/&gt; at which copying begins.&lt;/param&gt;&lt;exception cref=&quot;T:System.ArgumentNullException&quot;&gt;&lt;paramref name=&quot;array&quot;/&gt; is a null reference (Nothing in Visual Basic).&lt;/exception&gt;&lt;exception cref=&quot;T:System.ArgumentOutOfRangeException&quot;&gt;&lt;paramref name=&quot;index&quot;/&gt; is less than zero.&lt;/exception&gt;&lt;exception cref=&quot;T:System.ArgumentException&quot;&gt;&lt;paramref name=&quot;index&quot;/&gt; is equal to or greater than the length of the &lt;paramref name=&quot;array&quot;/&gt; -or- The number of elements in the source &lt;see cref=&quot;T:System.Collections.Concurrent.ConcurrentQueue`1&quot;/&gt; is greater than the available space from &lt;paramref name=&quot;index&quot;/&gt; to the end of the destination &lt;paramref name=&quot;array&quot;/&gt;.&lt;/exception&gt;
        public void CopyTo(T[] array, int index)
        {
            var clone = GetThreadSafeClone();
            clone.CopyTo(array, index);
        }

        private HashSet&lt;T&gt; GetThreadSafeClone()
        {
            HashSet&lt;T&gt; clone = null;
            using (new WriteLock(_instanceLocker))
            {
                clone = new HashSet&lt;T&gt;(_innerSet, _innerSet.Comparer);
            }
            return clone;
        }

        /// &lt;summary&gt;
        /// Copies the elements of the &lt;see cref=&quot;T:System.Collections.ICollection&quot;/&gt; to an &lt;see cref=&quot;T:System.Array&quot;/&gt;, starting at a particular &lt;see cref=&quot;T:System.Array&quot;/&gt; index.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;array&quot;&gt;The one-dimensional &lt;see cref=&quot;T:System.Array&quot;/&gt; that is the destination of the elements copied from &lt;see cref=&quot;T:System.Collections.ICollection&quot;/&gt;. The &lt;see cref=&quot;T:System.Array&quot;/&gt; must have zero-based indexing. &lt;/param&gt;&lt;param name=&quot;index&quot;&gt;The zero-based index in &lt;paramref name=&quot;array&quot;/&gt; at which copying begins. &lt;/param&gt;&lt;exception cref=&quot;T:System.ArgumentNullException&quot;&gt;&lt;paramref name=&quot;array&quot;/&gt; is null. &lt;/exception&gt;&lt;exception cref=&quot;T:System.ArgumentOutOfRangeException&quot;&gt;&lt;paramref name=&quot;index&quot;/&gt; is less than zero. &lt;/exception&gt;&lt;exception cref=&quot;T:System.ArgumentException&quot;&gt;&lt;paramref name=&quot;array&quot;/&gt; is multidimensional.-or- The number of elements in the source &lt;see cref=&quot;T:System.Collections.ICollection&quot;/&gt; is greater than the available space from &lt;paramref name=&quot;index&quot;/&gt; to the end of the destination &lt;paramref name=&quot;array&quot;/&gt;. &lt;/exception&gt;&lt;exception cref=&quot;T:System.ArgumentException&quot;&gt;The type of the source &lt;see cref=&quot;T:System.Collections.ICollection&quot;/&gt; cannot be cast automatically to the type of the destination &lt;paramref name=&quot;array&quot;/&gt;. &lt;/exception&gt;&lt;filterpriority&gt;2&lt;/filterpriority&gt;
        public void CopyTo(Array array, int index)
        {
            var clone = GetThreadSafeClone();
            Array.Copy(clone.ToArray(), 0, array, index, clone.Count);
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[17,9,17,66,1],[18,9,18,123,1],[28,9,28,10,1],[29,13,29,57,1],[30,9,30,10,1],[40,9,40,10,0],[41,13,41,36,0],[42,9,42,10,0],[52,9,52,10,0],[53,13,53,51,0],[54,13,54,14,0],[55,17,55,47,0],[57,9,57,10,0],[69,17,69,18,0],[69,19,69,53,0],[69,54,69,55,0],[80,17,80,18,0],[80,19,80,32,0],[80,33,80,34,0],[88,9,88,10,0],[89,13,89,51,0],[90,13,90,14,0],[91,17,91,37,0],[92,13,92,14,0],[93,9,93,10,0],[101,9,101,10,0],[102,13,102,46,0],[103,13,103,38,0],[103,39,103,52,0],[104,13,104,51,0],[105,13,105,14,0],[107,17,107,46,0],[107,47,107,60,0],[108,17,108,37,0],[109,17,109,29,0],[111,9,111,10,0],[118,9,118,10,0],[119,13,119,51,0],[120,13,120,14,0],[121,17,121,35,0],[122,13,122,14,0],[123,9,123,10,0],[133,9,133,10,0],[134,13,134,56,0],[135,9,135,10,0],[142,9,142,10,0],[143,13,143,46,0],[144,13,144,40,0],[145,9,145,10,0],[148,9,148,10,1],[149,13,149,37,1],[150,13,150,51,1],[151,13,151,14,1],[152,17,152,71,1],[153,13,153,14,1],[154,13,154,26,1],[155,9,155,10,1],[162,9,162,10,0],[163,13,163,46,0],[164,13,164,71,0],[165,9,165,10,0]]);
    </script>
  </body>
</html>