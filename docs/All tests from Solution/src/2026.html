<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Models\PropertyType.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using Umbraco.Core.Models.EntityBase;
using Umbraco.Core.PropertyEditors;
using Umbraco.Core.Strings;

namespace Umbraco.Core.Models
{

    /// &lt;summary&gt;
    /// Defines the type of a &lt;see cref=&quot;Property&quot;/&gt; object
    /// &lt;/summary&gt;
    [Serializable]
    [DataContract(IsReference = true)]
    [DebuggerDisplay(&quot;Id: {Id}, Name: {Name}, Alias: {Alias}&quot;)]
    public class PropertyType : Entity, IEquatable&lt;PropertyType&gt;
    {
        private readonly bool _isExplicitDbType;
        private string _name;
        private string _alias;
        private string _description;
        private int _dataTypeDefinitionId;
        private Lazy&lt;int&gt; _propertyGroupId;
        private string _propertyEditorAlias;
        private DataTypeDatabaseType _dataTypeDatabaseType;
        private bool _mandatory;
        private string _helpText;
        private int _sortOrder;
        private string _validationRegExp;

        public PropertyType(IDataTypeDefinition dataTypeDefinition)
        {
            if (dataTypeDefinition == null) throw new ArgumentNullException(&quot;dataTypeDefinition&quot;);

            if(dataTypeDefinition.HasIdentity)
                _dataTypeDefinitionId = dataTypeDefinition.Id;

            _propertyEditorAlias = dataTypeDefinition.PropertyEditorAlias;
            _dataTypeDatabaseType = dataTypeDefinition.DatabaseType;
        }

        public PropertyType(IDataTypeDefinition dataTypeDefinition, string propertyTypeAlias)
            : this(dataTypeDefinition)
        {
            _alias = GetAlias(propertyTypeAlias);
        }

        public PropertyType(string propertyEditorAlias, DataTypeDatabaseType dataTypeDatabaseType)
            : this(propertyEditorAlias, dataTypeDatabaseType, false)
        {
        }

        public PropertyType(string propertyEditorAlias, DataTypeDatabaseType dataTypeDatabaseType, string propertyTypeAlias)
            : this(propertyEditorAlias, dataTypeDatabaseType, false, propertyTypeAlias)
        {
        }

        /// &lt;summary&gt;
        /// Used internally to assign an explicity database type for this property type regardless of what the underlying data type/property editor is.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyEditorAlias&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataTypeDatabaseType&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;isExplicitDbType&quot;&gt;&lt;/param&gt;
        internal PropertyType(string propertyEditorAlias, DataTypeDatabaseType dataTypeDatabaseType, bool isExplicitDbType)
        {
            _isExplicitDbType = isExplicitDbType;
            _propertyEditorAlias = propertyEditorAlias;
            _dataTypeDatabaseType = dataTypeDatabaseType;
        }

        /// &lt;summary&gt;
        /// Used internally to assign an explicity database type for this property type regardless of what the underlying data type/property editor is.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyEditorAlias&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataTypeDatabaseType&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;isExplicitDbType&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;propertyTypeAlias&quot;&gt;&lt;/param&gt;
        internal PropertyType(string propertyEditorAlias, DataTypeDatabaseType dataTypeDatabaseType, bool isExplicitDbType, string propertyTypeAlias)
        {
            _isExplicitDbType = isExplicitDbType;
            _propertyEditorAlias = propertyEditorAlias;
            _dataTypeDatabaseType = dataTypeDatabaseType;
            _alias = GetAlias(propertyTypeAlias);
        }

        private static readonly Lazy&lt;PropertySelectors&gt; Ps = new Lazy&lt;PropertySelectors&gt;();

        private class PropertySelectors
        {
            public readonly PropertyInfo NameSelector = ExpressionHelper.GetPropertyInfo&lt;PropertyType, string&gt;(x =&gt; x.Name);
            public readonly PropertyInfo AliasSelector = ExpressionHelper.GetPropertyInfo&lt;PropertyType, string&gt;(x =&gt; x.Alias);
            public readonly PropertyInfo DescriptionSelector = ExpressionHelper.GetPropertyInfo&lt;PropertyType, string&gt;(x =&gt; x.Description);
            public readonly PropertyInfo DataTypeDefinitionIdSelector = ExpressionHelper.GetPropertyInfo&lt;PropertyType, int&gt;(x =&gt; x.DataTypeDefinitionId);
            public readonly PropertyInfo PropertyEditorAliasSelector = ExpressionHelper.GetPropertyInfo&lt;PropertyType, string&gt;(x =&gt; x.PropertyEditorAlias);
            public readonly PropertyInfo DataTypeDatabaseTypeSelector = ExpressionHelper.GetPropertyInfo&lt;PropertyType, DataTypeDatabaseType&gt;(x =&gt; x.DataTypeDatabaseType);
            public readonly PropertyInfo MandatorySelector = ExpressionHelper.GetPropertyInfo&lt;PropertyType, bool&gt;(x =&gt; x.Mandatory);
            public readonly PropertyInfo HelpTextSelector = ExpressionHelper.GetPropertyInfo&lt;PropertyType, string&gt;(x =&gt; x.HelpText);
            public readonly PropertyInfo SortOrderSelector = ExpressionHelper.GetPropertyInfo&lt;PropertyType, int&gt;(x =&gt; x.SortOrder);
            public readonly PropertyInfo ValidationRegExpSelector = ExpressionHelper.GetPropertyInfo&lt;PropertyType, string&gt;(x =&gt; x.ValidationRegExp);
            public readonly PropertyInfo PropertyGroupIdSelector = ExpressionHelper.GetPropertyInfo&lt;PropertyType, Lazy&lt;int&gt;&gt;(x =&gt; x.PropertyGroupId);
        }

        /// &lt;summary&gt;
        /// Gets of Sets the Name of the PropertyType
        /// &lt;/summary&gt;
        [DataMember]
        public string Name
        {
            get { return _name; }
            set { SetPropertyValueAndDetectChanges(value, ref _name, Ps.Value.NameSelector); }
        }

        /// &lt;summary&gt;
        /// Gets of Sets the Alias of the PropertyType
        /// &lt;/summary&gt;
        [DataMember]
        public string Alias
        {
            get { return _alias; }
            set { SetPropertyValueAndDetectChanges(GetAlias(value), ref _alias, Ps.Value.AliasSelector); }
        }

        /// &lt;summary&gt;
        /// Gets of Sets the Description for the PropertyType
        /// &lt;/summary&gt;
        [DataMember]
        public string Description
        {
            get { return _description; }
            set { SetPropertyValueAndDetectChanges(value, ref _description, Ps.Value.DescriptionSelector); }
        }

        /// &lt;summary&gt;
        /// Gets of Sets the Id of the DataType (Definition), which the PropertyType is &quot;wrapping&quot;
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;This is actually the Id of the &lt;see cref=&quot;IDataTypeDefinition&quot;/&gt;&lt;/remarks&gt;
        [DataMember]
        public int DataTypeDefinitionId
        {
            get { return _dataTypeDefinitionId; }
            set { SetPropertyValueAndDetectChanges(value, ref _dataTypeDefinitionId, Ps.Value.DataTypeDefinitionIdSelector); }
        }

        [DataMember]
        public string PropertyEditorAlias
        {
            get { return _propertyEditorAlias; }
            set { SetPropertyValueAndDetectChanges(value, ref _propertyEditorAlias, Ps.Value.PropertyEditorAliasSelector); }
        }

        /// &lt;summary&gt;
        /// Gets of Sets the Id of the DataType control
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;This is the Id of the actual DataType control&lt;/remarks&gt;
        [Obsolete(&quot;Property editor&#39;s are defined by a string alias from version 7 onwards, use the PropertyEditorAlias property instead. This method will return a generated GUID for any property editor alias not explicitly mapped to a legacy ID&quot;)]
        public Guid DataTypeId
        {
            get
            {
                return LegacyPropertyEditorIdToAliasConverter.GetLegacyIdFromAlias(
                    _propertyEditorAlias, LegacyPropertyEditorIdToAliasConverter.NotFoundLegacyIdResponseBehavior.GenerateId).Value;
            }
            set
            {
                var alias = LegacyPropertyEditorIdToAliasConverter.GetAliasFromLegacyId(value, true);
                PropertyEditorAlias = alias;
            }
        }

        /// &lt;summary&gt;
        /// Gets or Sets the DatabaseType for which the DataType&#39;s value is saved as
        /// &lt;/summary&gt;
        [DataMember]
        internal DataTypeDatabaseType DataTypeDatabaseType
        {
            get { return _dataTypeDatabaseType; }
            set
            {
                //don&#39;t allow setting this if an explicit declaration has been made in the ctor
                if (_isExplicitDbType) return;

                SetPropertyValueAndDetectChanges(value, ref _dataTypeDatabaseType, Ps.Value.DataTypeDatabaseTypeSelector);                
            }
        }

        /// &lt;summary&gt;
        /// Gets or sets the identifier of the PropertyGroup this PropertyType belongs to.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;For generic properties, the value is &lt;c&gt;null&lt;/c&gt;.&lt;/remarks&gt;
        [DataMember]
        internal Lazy&lt;int&gt; PropertyGroupId
        {
            get { return _propertyGroupId; }
            set { SetPropertyValueAndDetectChanges(value, ref _propertyGroupId, Ps.Value.PropertyGroupIdSelector); }
        }

        /// &lt;summary&gt;
        /// Gets of Sets the Boolean indicating whether a value for this PropertyType is required
        /// &lt;/summary&gt;
        [DataMember]
        public bool Mandatory
        {
            get { return _mandatory; }
            set { SetPropertyValueAndDetectChanges(value, ref _mandatory, Ps.Value.MandatorySelector); }
        }

        /// &lt;summary&gt;
        /// Gets of Sets the Help text for the current PropertyType
        /// &lt;/summary&gt;
        [DataMember]
        [Obsolete(&quot;Not used anywhere, will be removed in future versions&quot;)]
        public string HelpText
        {
            get { return _helpText; }
            set { SetPropertyValueAndDetectChanges(value, ref _helpText, Ps.Value.HelpTextSelector); }
        }

        /// &lt;summary&gt;
        /// Gets of Sets the Sort order of the PropertyType, which is used for sorting within a group
        /// &lt;/summary&gt;
        [DataMember]
        public int SortOrder
        {
            get { return _sortOrder; }
            set { SetPropertyValueAndDetectChanges(value, ref _sortOrder, Ps.Value.SortOrderSelector); }
        }

        /// &lt;summary&gt;
        /// Gets or Sets the RegEx for validation of legacy DataTypes
        /// &lt;/summary&gt;
        [DataMember]
        public string ValidationRegExp
        {
            get { return _validationRegExp; }
            set { SetPropertyValueAndDetectChanges(value, ref _validationRegExp, Ps.Value.ValidationRegExpSelector); }
        }

        private string GetAlias(string value)
        {
            //NOTE: WE are doing this because we don&#39;t want to do a ToSafeAlias when the alias is the special case of
            // being prefixed with Constants.PropertyEditors.InternalGenericPropertiesPrefix
            // which is used internally

            return value.StartsWith(Constants.PropertyEditors.InternalGenericPropertiesPrefix)
                        ? value
                        : value.ToCleanString(CleanStringType.Alias | CleanStringType.UmbracoCase);
        }

        /// &lt;summary&gt;
        /// Create a new Property object from a &quot;raw&quot; database value.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Can be used for the &quot;old&quot; values where no serialization type exists&lt;/remarks&gt;
        /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;version&quot;&gt; &lt;/param&gt;
        /// &lt;param name=&quot;id&quot;&gt; &lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal Property CreatePropertyFromRawValue(object value, Guid version, int id)
        {
            return new Property(id, version, this, value);
        }

        /// &lt;summary&gt;
        /// Create a new Property object from a &quot;raw&quot; database value.
        /// In some cases the value will need to be deserialized.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;serializationType&quot;&gt; &lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal Property CreatePropertyFromRawValue(object value, string serializationType)
        {
            //The value from the db needs to be deserialized and then added to the property
            //if its not a simple type (Integer, Date, Nvarchar, Ntext)
            /*if (DataTypeDatabaseType == DataTypeDatabaseType.Object)
            {
                Type type = Type.GetType(serializationType);
                var stream = new MemoryStream(Encoding.UTF8.GetBytes(value.ToString()));
                var objValue = _service.FromStream(stream, type);
                return new Property(this, objValue);
            }*/

            return new Property(this, value);
        }

        /// &lt;summary&gt;
        /// Create a new Property object that conforms to the Type of the DataType
        /// and can be validated according to DataType validation / Mandatory-check.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public Property CreatePropertyFromValue(object value)
        {
            //Note that validation will occur when setting the value on the Property
            return new Property(this, value);
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether the value is of the expected type
        /// for the property, and can be assigned to the property &quot;as is&quot;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
        /// &lt;returns&gt;True if the value is of the expected type for the property,
        /// and can be assigned to the property &quot;as is&quot;. Otherwise, false, to indicate
        /// that some conversion is required.&lt;/returns&gt;
        public bool IsPropertyTypeValid(object value)
        {
            // null values are assumed to be ok
            if (value == null)
                return true;

            // check if the type of the value matches the type from the DataType/PropertyEditor
            var valueType = value.GetType();

            //TODO Add PropertyEditor Type validation when its relevant to introduce
            /*bool isEditorModel = value is IEditorModel;
            if (isEditorModel &amp;&amp; DataTypeControlId != Guid.Empty)
            {
                //Find PropertyEditor by Id
                var propertyEditor = PropertyEditorResolver.Current.GetById(DataTypeControlId);

                if (propertyEditor == null)
                    return false;//Throw exception instead?

                //Get the generic parameter of the PropertyEditor and check it against the type of the passed in (object) value
                Type argument = propertyEditor.GetType().BaseType.GetGenericArguments()[0];
                return argument == type;
            }*/

            if (PropertyEditorAlias.IsNullOrWhiteSpace() == false) // fixme - always true?
            {
                // simple validation using the DatabaseType from the DataTypeDefinition
                // and the Type of the passed in value
                switch (DataTypeDatabaseType)
                {
                    // fixme breaking!
                    case DataTypeDatabaseType.Integer:
                        return valueType == typeof(int);
                    case DataTypeDatabaseType.Decimal:
                        return valueType == typeof(decimal);
                    case DataTypeDatabaseType.Date:
                        return valueType == typeof(DateTime);
                    case DataTypeDatabaseType.Nvarchar:
                        return valueType == typeof(string);
                    case DataTypeDatabaseType.Ntext:
                        return valueType == typeof(string);
                }
            }

            // fixme - never reached + makes no sense?
            // fallback for simple value types when no Control Id or Database Type is set
            if (valueType.IsPrimitive || value is string)
                return true;

            return false;
        }

        /// &lt;summary&gt;
        /// Validates the Value from a Property according to the validation settings
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;True if valid, otherwise false&lt;/returns&gt;
        public bool IsPropertyValueValid(object value)
        {
            //If the Property is mandatory and value is null or empty, return false as the validation failed
            if (Mandatory &amp;&amp; (value == null || string.IsNullOrEmpty(value.ToString())))
                return false;

            //Check against Regular Expression for Legacy DataTypes - Validation exists and value is not null:
            if(string.IsNullOrEmpty(ValidationRegExp) == false &amp;&amp; (value != null &amp;&amp; string.IsNullOrEmpty(value.ToString()) == false))
            {
                try
                {
                    var regexPattern = new Regex(ValidationRegExp);
                    return regexPattern.IsMatch(value.ToString());
                }
                catch
                {
                         throw new Exception(string .Format(&quot;Invalid validation expression on property {0}&quot;,this.Alias));
                }

            }

            //TODO: We must ensure that the property value can actually be saved based on the specified database type

            //TODO Add PropertyEditor validation when its relevant to introduce
            /*if (value is IEditorModel &amp;&amp; DataTypeControlId != Guid.Empty)
            {
                //Find PropertyEditor by Id
                var propertyEditor = PropertyEditorResolver.Current.GetById(DataTypeControlId);

                //TODO Get the validation from the PropertyEditor if a validation attribute exists
                //Will probably need to reflect the PropertyEditor in order to apply the validation
            }*/

            return true;
        }

        public bool Equals(PropertyType other)
        {
            if (base.Equals(other)) return true;

            //Check whether the PropertyType&#39;s properties are equal.
            return Alias.InvariantEquals(other.Alias);
        }

        public override int GetHashCode()
        {
            //Get hash code for the Name field if it is not null.
            int baseHash = base.GetHashCode();

            //Get hash code for the Alias field.
            int hashAlias = Alias.ToLowerInvariant().GetHashCode();

            //Calculate the hash code for the product.
            return baseHash ^ hashAlias;
        }

        public override object DeepClone()
        {
            var clone = (PropertyType)base.DeepClone();
            //turn off change tracking
            clone.DisableChangeTracking();
            //need to manually assign the Lazy value as it will not be automatically mapped
            if (PropertyGroupId != null)
            {
                clone._propertyGroupId = new Lazy&lt;int&gt;(() =&gt; PropertyGroupId.Value);
            }
            //this shouldn&#39;t really be needed since we&#39;re not tracking
            clone.ResetDirtyProperties(false);
            //re-enable tracking
            clone.EnableChangeTracking();

            return clone;
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[35,9,35,68,1],[36,9,36,10,1],[37,13,37,44,1],[37,45,37,99,0],[39,13,39,47,1],[40,17,40,63,1],[42,13,42,75,1],[43,13,43,69,1],[44,9,44,10,1],[47,15,47,39,1],[48,9,48,10,1],[49,13,49,50,1],[50,9,50,10,1],[53,15,53,69,1],[54,9,54,10,1],[55,9,55,10,1],[58,15,58,88,1],[59,9,59,10,1],[60,9,60,10,1],[68,9,68,124,1],[69,9,69,10,1],[70,13,70,50,1],[71,13,71,56,1],[72,13,72,58,1],[73,9,73,10,1],[82,9,82,150,1],[83,9,83,10,1],[84,13,84,50,1],[85,13,85,56,1],[86,13,86,58,1],[87,13,87,50,1],[88,9,88,10,1],[90,9,90,92,1],[94,13,94,125,1],[95,13,95,127,1],[96,13,96,139,1],[97,13,97,154,1],[98,13,98,155,1],[99,13,99,171,1],[100,13,100,133,1],[101,13,101,133,1],[102,13,102,132,1],[103,13,103,149,1],[104,13,104,150,1],[113,17,113,18,1],[113,19,113,32,1],[113,33,113,34,1],[114,17,114,18,1],[114,19,114,93,1],[114,94,114,95,1],[123,17,123,18,1],[123,19,123,33,1],[123,34,123,35,1],[124,17,124,18,1],[124,19,124,105,1],[124,106,124,107,1],[133,17,133,18,1],[133,19,133,39,1],[133,40,133,41,1],[134,17,134,18,1],[134,19,134,107,1],[134,108,134,109,1],[144,17,144,18,1],[144,19,144,48,1],[144,49,144,50,1],[145,17,145,18,1],[145,19,145,125,1],[145,126,145,127,1],[151,17,151,18,1],[151,19,151,47,1],[151,48,151,49,1],[152,17,152,18,1],[152,19,152,123,1],[152,124,152,125,1],[163,13,163,14,1],[164,17,165,133,1],[166,13,166,14,1],[168,13,168,14,1],[169,17,169,102,1],[170,17,170,45,1],[171,13,171,14,1],[180,17,180,18,1],[180,19,180,48,1],[180,49,180,50,1],[182,13,182,14,1],[184,17,184,39,1],[184,40,184,47,1],[186,17,186,123,1],[187,13,187,14,1],[197,17,197,18,1],[197,19,197,43,1],[197,44,197,45,1],[198,17,198,18,1],[198,19,198,115,1],[198,116,198,117,1],[207,17,207,18,1],[207,19,207,37,1],[207,38,207,39,1],[208,17,208,18,1],[208,19,208,103,1],[208,104,208,105,1],[218,17,218,18,1],[218,19,218,36,1],[218,37,218,38,1],[219,17,219,18,0],[219,19,219,101,0],[219,102,219,103,0],[228,17,228,18,1],[228,19,228,37,1],[228,38,228,39,1],[229,17,229,18,1],[229,19,229,103,1],[229,104,229,105,1],[238,17,238,18,1],[238,19,238,44,1],[238,45,238,46,1],[239,17,239,18,1],[239,19,239,117,1],[239,118,239,119,1],[243,9,243,10,1],[248,13,250,100,1],[251,9,251,10,1],[262,9,262,10,1],[263,13,263,59,1],[264,9,264,10,1],[274,9,274,10,0],[285,13,285,46,0],[286,9,286,10,0],[295,9,295,10,1],[297,13,297,46,1],[298,9,298,10,1],[309,9,309,10,1],[311,13,311,31,1],[312,17,312,29,1],[315,13,315,45,1],[332,13,332,67,1],[333,13,333,14,1],[336,17,336,46,1],[340,25,340,57,1],[342,25,342,61,1],[344,25,344,62,1],[346,25,346,60,1],[348,25,348,60,1],[350,13,350,14,0],[354,13,354,58,0],[355,17,355,29,0],[357,13,357,26,0],[358,9,358,10,1],[366,9,366,10,1],[368,13,368,88,1],[369,17,369,30,1],[372,13,372,134,1],[373,13,373,14,0],[375,17,375,18,0],[376,21,376,68,0],[377,21,377,67,0],[379,17,379,22,0],[380,17,380,18,0],[381,26,381,122,0],[398,13,398,25,1],[399,9,399,10,1],[402,9,402,10,1],[403,13,403,36,1],[403,37,403,49,1],[406,13,406,55,1],[407,9,407,10,1],[410,9,410,10,1],[412,13,412,47,1],[415,13,415,68,1],[418,13,418,41,1],[419,9,419,10,1],[422,9,422,10,1],[423,13,423,56,1],[425,13,425,43,1],[427,13,427,41,1],[428,13,428,14,1],[429,17,429,62,1],[429,62,429,83,1],[429,83,429,85,1],[429,17,429,85,1],[430,13,430,14,1],[432,13,432,47,1],[434,13,434,42,1],[436,13,436,26,1],[437,9,437,10,1]]);
    </script>
  </body>
</html>