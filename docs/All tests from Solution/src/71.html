<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Tests\DynamicsAndReflection\ExtensionMethodFinderTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Web.Mvc;
using NUnit.Framework;
using Umbraco.Core;
using Umbraco.Core.Cache;
using Umbraco.Core.Dynamics;

namespace Umbraco.Tests.DynamicsAndReflection
{
    [TestFixture]
    public class ExtensionMethodFinderTests
    {
        #region Tests Elements

        public class TestClass { }
        public class TestClass&lt;T&gt; : TestClass { }
        public class TestClassOfInt : TestClass&lt;int&gt; { }
        public class TestClassOfString : TestClass&lt;string&gt; { }

        public void TestMethod1(int value) { }
        public void TestMethod2&lt;T&gt;(T value) { }
        public void TestMethod3&lt;T&gt;(T value1, T value2) { }
        public void TestMethod4&lt;T1, T2&gt;(T1 value1, T2 value2) { }
        public void TestMethod5&lt;T&gt;(List&lt;T&gt; value) { }
        public void TestMethod6(int value) { }
        public void TestMethod6(string value) { }
        public void TestMethod7&lt;T&gt;(IList&lt;T&gt; value) { }
        public void TestMethod8&lt;T&gt;(IDictionary&lt;T, T&gt; value) { }

        public interface ITestDict&lt;T&gt; : IDictionary&lt;T, T&gt; { }

        #endregion

        #region Utilities

        private static readonly IRuntimeCacheProvider NullCache = new NullCacheProvider();

        private static MethodInfo FindExtensionMethod(Type thisType, object[] args, string name, bool argsContainsThis)
        {
            return ExtensionMethodFinder.FindExtensionMethod(NullCache, thisType, args, name, argsContainsThis);
        }

        #endregion

        #region Tests Set #1

        [Test]
        public void Find_Non_Overloaded_Method()
        {
            var class1 = new TestClass();

            var method = FindExtensionMethod(typeof(TestClass), new object[] { 1 }, &quot;SimpleMethod&quot;, false);
            Assert.IsNotNull(method);
            method.Invoke(null, new object[] { class1, 1 });

            method = FindExtensionMethod(typeof(TestClass), new object[] { &quot;x&quot; }, &quot;SimpleMethod&quot;, false);
            Assert.IsNull(method);            
        }

        [Test]
        public void Find_SimpleOverloaded()
        {
            var class1 = new TestClass();

            var method = FindExtensionMethod(typeof(TestClass), new object[] { 1 }, &quot;SimpleOverloadMethod&quot;, false);
            Assert.IsNotNull(method);
            method.Invoke(null, new object[] { class1, 1 });

            method = FindExtensionMethod(typeof(TestClass), new object[] { &quot;x&quot; }, &quot;SimpleOverloadMethod&quot;, false);
            Assert.IsNotNull(method);
            method.Invoke(null, new object[] { class1, &quot;x&quot; });
        }

        [Test]
        public void Find_SimpleOverloaded_ArgsContainingThis()
        {
            var class1 = new TestClass();

            var method = FindExtensionMethod(typeof(TestClass), new object[] { class1, 1 }, &quot;SimpleOverloadMethod&quot;, true);
            Assert.IsNotNull(method);
            method.Invoke(null, new object[] { class1, 1 });

            method = FindExtensionMethod(typeof(TestClass), new object[] { class1, &quot;x&quot; }, &quot;SimpleOverloadMethod&quot;, true);
            Assert.IsNotNull(method);
            method.Invoke(null, new object[] { class1, &quot;x&quot; });
        }

        [Test]
        public void Find_NonOverloadedGenericEnumerable()
        {
            var class1 = Enumerable.Empty&lt;TestClass&gt;();

            var method = FindExtensionMethod(typeof(IEnumerable&lt;TestClass&gt;), new object[] { 1 }, &quot;SimpleEnumerableGenericMethod&quot;, false);
            Assert.IsNotNull(method);
            method.Invoke(null, new object[] { class1, 1 });

            method = FindExtensionMethod(typeof(IEnumerable&lt;TestClass&gt;), new object[] { &quot;x&quot; }, &quot;SimpleEnumerableGenericMethod&quot;, false);
            Assert.IsNull(method);       
        }

        [Test]
        public void Find_OverloadedGenericEnumerable()
        {
            var class1 = Enumerable.Empty&lt;TestClass&gt;();

            var method = FindExtensionMethod(typeof(IEnumerable&lt;TestClass&gt;), new object[] { 1 }, &quot;SimpleOverloadEnumerableGenericMethod&quot;, false);
            Assert.IsNotNull(method);
            method.Invoke(null, new object[] { class1, 1 });

            method = FindExtensionMethod(typeof(IEnumerable&lt;TestClass&gt;), new object[] { &quot;x&quot; }, &quot;SimpleOverloadEnumerableGenericMethod&quot;, false);
            Assert.IsNotNull(method);
            method.Invoke(null, new object[] { class1, &quot;x&quot; });
        }

        [Test]
        public void Find_InheritedType()
        {
            var genericTestClass = new TestClass&lt;TestClass&gt;();
            var nonGenericTestClass = new TestClass();

            // not really testing &quot;generics&quot; here, just inheritance

            var method = FindExtensionMethod(typeof(TestClass), new object[] { genericTestClass }, &quot;GenericParameterMethod&quot;, false);
            Assert.IsNotNull(method);

            method = FindExtensionMethod(typeof(TestClass), new object[] { nonGenericTestClass }, &quot;GenericParameterMethod&quot;, false);
            Assert.IsNotNull(method);
        }

        [Test]
        public void Find_TrueGeneric()
        {
            var c = new TestClass&lt;int&gt;();

            var method = FindExtensionMethod(c.GetType(), new object[] { }, &quot;GenericMethod&quot;, false);
            Assert.IsNotNull(method);
        }

        [Test]
        public void GetMethodVsGetMethods()
        {
            Assert.Throws&lt;AmbiguousMatchException&gt;(() =&gt;
            {
                var m = typeof (ExtensionMethodFinderTests).GetMethod(&quot;TestMethod6&quot;);
            });

            var ms = typeof (ExtensionMethodFinderTests).GetMethods().Where(x =&gt; x.Name == &quot;TestMethod6&quot;);
            Assert.AreEqual(2, ms.Count());
        }

        #endregion

        #region Tests Set #2 - Working with Generics

        // To expand on Jon&#39;s answer, the reason this doesn&#39;t work is because in regular,
        // non-dynamic code extension methods work by doing a full search of all the
        // classes known to the compiler for a static class that has an extension method
        // that match. The search goes in order based on the namespace nesting and available
        // &quot;using&quot; directives in each namespace.
        //
        // That means that in order to get a dynamic extension method invocation resolved
        // correctly, somehow the DLR has to know at runtime what all the namespace nestings
        // and &quot;using&quot; directives were in your source code. We do not have a mechanism handy
        // for encoding all that information into the call site. We considered inventing
        // such a mechanism, but decided that it was too high cost and produced too much
        // schedule risk to be worth it.
        //
        // Eric Lippert, http://stackoverflow.com/questions/5311465/extension-method-and-dynamic-object-in-c-sharp
        //
        // And so...
        // Obviously MatchType is broken and incomplete, it does not handle
        // - ref &amp; out parameters
        // - array types
        // - structs
        // - generics constraints
        // - generics variance
        // - ...

        [Test]
        public void Temp()
        {
            var t1 = typeof (IList&lt;int&gt;);
            var t2 = typeof (IList&lt;&gt;);
            Assert.IsTrue(t2.IsGenericTypeDefinition);
            Assert.AreEqual(t2, t1.GetGenericTypeDefinition());
            var m = typeof (ExtensionMethodFinderTests).GetMethod(&quot;TestMethod7&quot;);
            var parms = m.GetParameters();
            Assert.AreEqual(1, parms.Length);
            var parm = parms[0];
            var t3 = parm.ParameterType; // IList&lt;T&gt;
            Assert.AreEqual(t2, t3.GetGenericTypeDefinition());

            Assert.AreEqual(typeof (int), t1.GetGenericArguments()[0]);
            Assert.IsFalse(t1.GetGenericArguments()[0].IsGenericParameter);
            //Assert.AreEqual(???, t2.GetGenericArguments()[0]);
            Assert.IsTrue(t2.GetGenericArguments()[0].IsGenericParameter);
            Assert.AreEqual(&quot;T&quot;, t2.GetGenericArguments()[0].Name);
            Assert.IsTrue(t3.GetGenericArguments()[0].IsGenericParameter);
            Assert.AreEqual(&quot;T&quot;, t3.GetGenericArguments()[0].Name);
        }

        

        [Test]
        public void Find_Generic_Enumerable_Method()
        {
            MethodInfo method;
            var class1 = Enumerable.Empty&lt;TestClass&gt;();

            method = ExtensionMethodFinder.FindExtensionMethod(new NullCacheProvider(), typeof(IEnumerable&lt;TestClass&gt;), new object[] { }, &quot;GenericMethod&quot;, false);
            Assert.IsNotNull(method);
            method.Invoke(null, new object[] { class1 });

            var class2 = new TestClassCollection();

            method = ExtensionMethodFinder.FindExtensionMethod(new NullCacheProvider(), typeof(TestClassCollection), new object[] { }, &quot;GenericMethod&quot;, false);
            Assert.IsNotNull(method);
            method.Invoke(null, new object[] { class2 });
        }      

        [Ignore(&quot;This is just testing the below GetMethodForArguments method - Stephen was working on this but it&#39;s not used in the core&quot;)]
        [Test]
        public void TypesTests()
        {
            Assert.IsTrue(typeof(int[]).Inherits&lt;int[]&gt;());
            Assert.IsFalse(typeof(int[]).Inherits&lt;bool[]&gt;());

            var m1 = typeof(ExtensionMethodFinderTests).GetMethod(&quot;TestMethod1&quot;);

            var a1A = new object[] { 1 };
            var m1A = GetMethodForArguments(m1, a1A);
            Assert.IsNotNull(m1A);
            m1A.Invoke(this, a1A);

            var a1B = new object[] { &quot;foo&quot; };
            var m1B = GetMethodForArguments(m1, a1B);
            Assert.IsNull(m1B);

            var m2 = typeof(ExtensionMethodFinderTests).GetMethod(&quot;TestMethod2&quot;);

            var m2A = GetMethodForArguments(m2, a1A);
            Assert.IsNotNull(m2A);
            m2A.Invoke(this, a1A);

            var m2B = GetMethodForArguments(m2, a1B);
            Assert.IsNotNull(m2B);
            m2B.Invoke(this, a1B);

            var m3 = typeof(ExtensionMethodFinderTests).GetMethod(&quot;TestMethod3&quot;);

            var a3A = new object[] { 1, 2 };
            var m3A = GetMethodForArguments(m3, a3A);
            Assert.IsNotNull(m3A);
            m3A.Invoke(this, a3A);

            var a3B = new object[] { 1, &quot;foo&quot; };
            var m3B = GetMethodForArguments(m3, a3B);
            Assert.IsNull(m3B);

            var m4 = typeof(ExtensionMethodFinderTests).GetMethod(&quot;TestMethod4&quot;);

            var m4A = GetMethodForArguments(m4, a3A);
            Assert.IsNotNull(m4A);
            m4A.Invoke(this, a3A);

            var m4B = GetMethodForArguments(m4, a3B);
            Assert.IsNotNull(m4B);
            m4B.Invoke(this, a3B);

            var m5 = typeof(ExtensionMethodFinderTests).GetMethod(&quot;TestMethod5&quot;);

            // note - currently that fails because we can&#39;t match List&lt;T&gt; with List&lt;int32&gt;
            var a5 = new object[] { new List&lt;int&gt;() };
            var m5A = GetMethodForArguments(m5, a5);
            Assert.IsNotNull(m5A);

            // note - should we also handle &quot;ref&quot; and &quot;out&quot; parameters?
            // SD: NO, lets not make this more complicated than it already is
            // note - should we pay attention to array types?
            // SD: NO, lets not make this more complicated than it already is
        }

        // gets the method that can apply to the arguments
        // either the method itself, or a generic one
        // or null if it couldn&#39;t match
        //
        // this is a nightmare - if we want to do it right, then we have
        // to re-do the whole compiler type inference stuff by ourselves?!
        //
        static MethodInfo GetMethodForArguments(MethodInfo method, IList&lt;object&gt; arguments)
        {
            var parameters = method.GetParameters();
            var genericArguments = method.GetGenericArguments();

            if (parameters.Length != arguments.Count) return null;

            var genericArgumentTypes = new Type[genericArguments.Length];
            var i = 0;
            for (; i &lt; parameters.Length; i++)
            {
                var parameterType = parameters[i].ParameterType;
                var argumentType = arguments[i].GetType();

                Debug.Print(&quot;{0} / {1}&quot;, parameterType, argumentType);

                if (parameterType == argumentType) continue; // match
                if (parameterType.IsGenericParameter) // eg T
                {
                    var pos = parameterType.GenericParameterPosition;
                    if (genericArgumentTypes[pos] != null)
                    {
                        // note - is this OK? what about variance and such?
                        // it is NOT ok, if the first pass is SomethingElse then next is Something
                        // it will fail... the specs prob. indicate how it works, trying to find a common
                        // type...
                        if (genericArgumentTypes[pos].IsAssignableFrom(argumentType) == false)
                            break;
                    }
                    else
                    {
                        genericArgumentTypes[pos] = argumentType;
                    }
                }
                else if (parameterType.IsGenericType) // eg List&lt;T&gt;
                {
                    if (argumentType.IsGenericType == false) break;

                    var pg = parameterType.GetGenericArguments();
                    var ag = argumentType.GetGenericArguments();

                    // then what ?!
                    // should _variance_ be of some importance?
                    Debug.Print(&quot;generic {0}&quot;, argumentType.IsGenericType);
                }
                else
                {
                    if (parameterType.IsAssignableFrom(argumentType) == false)
                        break;
                }
            }
            if (i != parameters.Length) return null;
            return genericArguments.Length == 0
                ? method
                : method.MakeGenericMethod(genericArgumentTypes);
        }

        #endregion

        public class TestClassCollection : List&lt;TestClass&gt;
        {
            
        }

    }

    #region Tests Elements

        
    static class ExtensionMethodFinderTestsExtensions
    {
        public static void GenericMethod&lt;T&gt;(this IEnumerable&lt;T&gt; source)
        { }

        public static void SimpleMethod(this ExtensionMethodFinderTests.TestClass source, int value)
        { }

        public static void SimpleOverloadMethod(this ExtensionMethodFinderTests.TestClass source, int value)
        { }

        public static void SimpleOverloadMethod(this ExtensionMethodFinderTests.TestClass source, string value)
        { }

        public static void SimpleEnumerableGenericMethod(this IEnumerable&lt;ExtensionMethodFinderTests.TestClass&gt; source, int value)
        { }

        public static void SimpleOverloadEnumerableGenericMethod(this IEnumerable&lt;ExtensionMethodFinderTests.TestClass&gt; source, int value)
        { }

        public static void SimpleOverloadEnumerableGenericMethod(this IEnumerable&lt;ExtensionMethodFinderTests.TestClass&gt; source, string value)
        { }

        public static void GenericParameterMethod(this ExtensionMethodFinderTests.TestClass source, ExtensionMethodFinderTests.TestClass value)
        { }

        public static void GenericMethod&lt;T&gt;(this ExtensionMethodFinderTests.TestClass&lt;T&gt; source)
        { }
    }

    #endregion
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[25,44,25,45,0],[25,46,25,47,0],[26,45,26,46,0],[26,47,26,48,0],[27,56,27,57,0],[27,58,27,59,0],[28,63,28,64,0],[28,65,28,66,0],[29,51,29,52,0],[29,53,29,54,0],[30,44,30,45,0],[30,46,30,47,0],[31,47,31,48,0],[31,49,31,50,0],[32,52,32,53,0],[32,54,32,55,0],[33,61,33,62,0],[33,63,33,64,0],[41,9,41,91,1],[44,9,44,10,1],[45,13,45,113,1],[46,9,46,10,1],[54,9,54,10,1],[55,13,55,42,1],[57,13,57,108,1],[58,13,58,38,1],[59,13,59,61,1],[61,13,61,106,1],[62,13,62,35,1],[63,9,63,10,1],[67,9,67,10,1],[68,13,68,42,1],[70,13,70,116,1],[71,13,71,38,1],[72,13,72,61,1],[74,13,74,114,1],[75,13,75,38,1],[76,13,76,63,1],[77,9,77,10,1],[81,9,81,10,1],[82,13,82,42,1],[84,13,84,123,1],[85,13,85,38,1],[86,13,86,61,1],[88,13,88,121,1],[89,13,89,38,1],[90,13,90,63,1],[91,9,91,10,1],[95,9,95,10,1],[96,13,96,56,1],[98,13,98,138,1],[99,13,99,38,1],[100,13,100,61,1],[102,13,102,136,1],[103,13,103,35,1],[104,9,104,10,1],[108,9,108,10,1],[109,13,109,56,1],[111,13,111,146,1],[112,13,112,38,1],[113,13,113,61,1],[115,13,115,144,1],[116,13,116,38,1],[117,13,117,63,1],[118,9,118,10,1],[122,9,122,10,1],[123,13,123,63,1],[124,13,124,55,1],[128,13,128,133,1],[129,13,129,38,1],[131,13,131,132,1],[132,13,132,38,1],[133,9,133,10,1],[137,9,137,10,1],[138,13,138,42,1],[140,13,140,101,1],[141,13,141,38,1],[142,9,142,10,1],[146,9,146,10,1],[147,13,148,13,1],[148,13,148,14,1],[148,14,149,17,1],[149,17,149,86,1],[149,86,150,13,1],[150,13,150,14,0],[150,14,150,16,1],[147,13,150,16,1],[152,13,152,82,1],[152,82,152,105,1],[152,105,152,107,1],[152,13,152,107,1],[153,13,153,44,1],[154,9,154,10,1],[186,9,186,10,1],[187,13,187,42,1],[188,13,188,39,1],[189,13,189,55,1],[190,13,190,64,1],[191,13,191,82,1],[192,13,192,43,1],[193,13,193,46,1],[194,13,194,33,1],[195,13,195,41,1],[196,13,196,64,1],[198,13,198,72,1],[199,13,199,76,1],[201,13,201,75,1],[202,13,202,68,1],[203,13,203,75,1],[204,13,204,68,1],[205,9,205,10,1],[211,9,211,10,1],[213,13,213,56,1],[215,13,215,163,1],[216,13,216,38,1],[217,13,217,58,1],[219,13,219,52,1],[221,13,221,160,1],[222,13,222,38,1],[223,13,223,58,1],[224,9,224,10,1],[229,9,229,10,0],[230,13,230,60,0],[231,13,231,62,0],[233,13,233,82,0],[235,13,235,42,0],[236,13,236,54,0],[237,13,237,35,0],[238,13,238,35,0],[240,13,240,46,0],[241,13,241,54,0],[242,13,242,32,0],[244,13,244,82,0],[246,13,246,54,0],[247,13,247,35,0],[248,13,248,35,0],[250,13,250,54,0],[251,13,251,35,0],[252,13,252,35,0],[254,13,254,82,0],[256,13,256,45,0],[257,13,257,54,0],[258,13,258,35,0],[259,13,259,35,0],[261,13,261,49,0],[262,13,262,54,0],[263,13,263,32,0],[265,13,265,82,0],[267,13,267,54,0],[268,13,268,35,0],[269,13,269,35,0],[271,13,271,54,0],[272,13,272,35,0],[273,13,273,35,0],[275,13,275,82,0],[278,13,278,55,0],[279,13,279,53,0],[280,13,280,35,0],[286,9,286,10,0],[296,9,296,10,0],[297,13,297,53,0],[298,13,298,65,0],[300,13,300,54,0],[300,55,300,67,0],[302,13,302,74,0],[303,13,303,23,0],[304,20,304,41,0],[304,43,304,46,0],[305,13,305,14,0],[306,17,306,65,0],[307,17,307,59,0],[309,17,309,71,0],[311,17,311,51,0],[311,52,311,61,0],[312,17,312,54,0],[313,17,313,18,0],[314,21,314,70,0],[315,21,315,59,0],[316,21,316,22,0],[321,25,321,95,0],[322,29,322,35,0],[323,21,323,22,0],[325,21,325,22,0],[326,25,326,66,0],[327,21,327,22,0],[328,17,328,18,0],[329,22,329,54,0],[330,17,330,18,0],[331,21,331,61,0],[331,62,331,68,0],[333,21,333,66,0],[334,21,334,65,0],[338,21,338,76,0],[339,17,339,18,0],[341,17,341,18,0],[342,21,342,79,0],[343,25,343,31,0],[344,17,344,18,0],[345,13,345,14,0],[346,13,346,40,0],[346,41,346,53,0],[347,13,349,66,0],[350,9,350,10,0],[367,9,367,10,1],[367,11,367,12,1],[370,9,370,10,1],[370,11,370,12,1],[373,9,373,10,1],[373,11,373,12,1],[376,9,376,10,1],[376,11,376,12,1],[379,9,379,10,1],[379,11,379,12,1],[382,9,382,10,1],[382,11,382,12,1],[385,9,385,10,1],[385,11,385,12,1],[388,9,388,10,0],[388,11,388,12,0],[391,9,391,10,0],[391,11,391,12,0]]);
    </script>
  </body>
</html>