<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\umbraco.datalayer\SqlParser.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/************************************************************************************
 * 
 *  Umbraco Data Layer
 *  MIT Licensed work
 *  ï¿½2008 Ruben Verborgh
 * 
 ***********************************************************************************/

using System.Text;
using System;

namespace umbraco.DataLayer
{
    /// &lt;summary&gt;
    /// Object that performs parsing tasks on an SQL command.
    /// &lt;/summary&gt;
    public class SqlParser
    {
        /// &lt;summary&gt;Original tokens for query token replacement.&lt;/summary&gt;
        private char[] m_SrcTokens;
        /// &lt;summary&gt;Destination tokens for query token replacement.&lt;/summary&gt;
        private char[] m_DestTokens;

        #region Public Properties

        /// &lt;summary&gt;
        /// Gets the character strings are surrounded with.
        /// &lt;/summary&gt;
        /// &lt;value&gt;The string delimiter.&lt;/value&gt;
        public virtual char StringDelimiter
        {
            get { return &#39;\&#39;&#39;; }
        }

        /// &lt;summary&gt;
        /// Gets the param character parameters start with.
        /// &lt;/summary&gt;
        /// &lt;value&gt;The parameter starting token.&lt;/value&gt;
        public virtual char ParamToken
        {
            get { return &#39;@&#39;; }
        }

        #endregion

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;SqlParser&quot;/&gt; class.
        /// &lt;/summary&gt;
        public SqlParser()
            : this(null, null)
        { }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;SqlParser&quot;/&gt; class
        /// that performs the specified token translation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;srcTokens&quot;&gt;The original tokens.&lt;/param&gt;
        /// &lt;param name=&quot;destTokens&quot;&gt;The new tokens, each token corresponds with the item of
        /// &lt;c&gt;srcTokens&lt;/c&gt; at the same index.&lt;/param&gt;
        public SqlParser(char[] srcTokens, char[] destTokens)
        {
            if ((srcTokens == null &amp;&amp; destTokens != null)
                || (srcTokens != null &amp;&amp; destTokens == null)
                || (srcTokens != null &amp;&amp; destTokens != null &amp;&amp; srcTokens.Length != destTokens.Length))
                throw new ArgumentException(&quot;srcTokens and destTokens dimensions do not match&quot;);

            m_SrcTokens = srcTokens;
            m_DestTokens = destTokens;
        }

        #region Public Methods

        /// &lt;summary&gt;
        /// Parses the query, performing provider specific changes.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;query&quot;&gt;The query.&lt;/param&gt;
        /// &lt;returns&gt;The modified query.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// The default implementation returns the original query.
        /// Overriding classes can change this behavior.
        /// &lt;/remarks&gt;
        public virtual string Parse(string query)
        {
            return query;
        }

        /// &lt;summary&gt;
        /// Replaces parameters in a query by their values.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;commandText&quot;&gt;The command text.&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;The parameters.&lt;/param&gt;
        /// &lt;returns&gt;The query, with parameter placeholders replaced by their values.&lt;/returns&gt;
        public virtual string ApplyParameters(string commandText, IParameter[] parameters)
        {
            // no parameters, just return commandText
            if (parameters.Length == 0)
                return commandText;
            // build string that includes parameters
            StringBuilder result = new StringBuilder(commandText.Length);
            for (int i = 0; i &lt; commandText.Length; i++)
            {
                // Is this the start of a parameter name?
                if (commandText[i] == ParamToken)
                {
                    /* Read parameter name, from ParamToken till next space or end */
                    int paramNameStart = i;
                    // move i past end of parameter name
                    while (++i &lt; commandText.Length &amp;&amp; char.IsLetterOrDigit(commandText[i])) ;
                    // store parameter name in string
                    string paramName = commandText.Substring(paramNameStart, i - paramNameStart).ToLower();
                    /* Get the parameter value */
                    string paramValue = string.Empty;
                    // find a parameter with identical name
                    for (int p = 0; p &lt; parameters.Length &amp;&amp; paramValue.Length == 0; p++)
                        if (parameters[p].ParameterName.ToLower() == paramName)
                            paramValue = parameters[p].Value.ToString();
                    /* Append parameter value */
                    result.Append(&#39;\&#39;&#39;).Append(paramValue.Replace(&quot;&#39;&quot;, &quot;&#39;&#39;&quot;)).Append(&#39;\&#39;&#39;);
                    // check we&#39;re not at the end of the string
                    if (i &gt;= commandText.Length)
                        break;
                }
                // append the character
                result.Append(commandText[i]);
            }
            // append terminating semicolon
            result.Append(&#39;;&#39;);
            return result.ToString();
        }

        /// &lt;summary&gt;Replaces tokens before or after identifiers in a query string.&lt;/summary&gt;
        /// &lt;param name=&quot;query&quot;&gt;The original query.&lt;/param&gt;
        /// &lt;returns&gt;The query with replaced identifier tokens.&lt;/returns&gt;
        /// &lt;remarks&gt;Assumes a correct query.&lt;/remarks&gt;
        public virtual string ReplaceIdentifierTokens(string query)
        {
            if (m_SrcTokens == null || m_DestTokens == null || m_SrcTokens.Length == 0 || m_DestTokens.Length == 0)
                return query;

            // find first occurrence of an originalToken
            bool noMatch = true;
            int pos;
            for (pos = 0; pos &lt; query.Length &amp;&amp; noMatch; pos++)
                foreach (char srcToken in m_SrcTokens)
                    if (query[pos] == srcToken)
                        noMatch = false;

            // if no occurrence found before end of string, return original query
            if (noMatch)
                return query;

            // put pos back at the match of the source token
            pos--;

            // if there&#39;s a quote before the token, it could be inside of a string
            for (int i = 0; i &lt; pos; i++)
                if (query[i] == StringDelimiter)
                    // start at the beginning of the string
                    pos = i;
            // loop through all string characters
            char[] queryTokens = query.ToCharArray();
            do
            {
                char token = queryTokens[pos];
                // if begin of string, advance to end so we don&#39;t replace inside string literals
                if (token == StringDelimiter)
                    pos = FindStringEndPosition(query, pos);
                else
                {
                    // if we recognize a source token, replace it by a new one
                    for (int i = 0; i &lt; m_SrcTokens.Length; i++)
                        if (token == m_SrcTokens[i])
                        {
                            queryTokens[pos] = m_DestTokens[i];
                            break;
                        }
                }
            } while (++pos &lt; query.Length);
            // return new query
            return new string(queryTokens);
        }

        /// &lt;summary&gt;
        /// Uppercases the identifiers in the query, leaving strings untouched.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;query&quot;&gt;The query.&lt;/param&gt;
        /// &lt;returns&gt;The query with uppercased identifiers.&lt;/returns&gt;
        public virtual string UppercaseIdentifiers(string query)
        {
            if (string.IsNullOrEmpty(query))
                return string.Empty;

            StringBuilder replacedQuery = new StringBuilder(query.Length);

            // parse the query in SQL parts and string literal parts
            int partStartPos = 0;
            for (int currentPos = 0; currentPos &lt; query.Length; currentPos++)
            {
                // String start?
                if (query[currentPos] == StringDelimiter)
                {
                    // append part before string, uppercased
                    replacedQuery.Append(query.Substring(partStartPos, currentPos - partStartPos).ToUpper());

                    // append string, case unchanged
                    int endStringPos = FindStringEndPosition(query, currentPos);
                    replacedQuery.Append(query.Substring(currentPos, endStringPos - currentPos));

                    // advance string
                    currentPos = partStartPos = endStringPos;
                }
            }
            // append remainder of the query, uppercased
            replacedQuery.Append(query.Substring(partStartPos).ToUpper());

            return replacedQuery.ToString();
        }

        #endregion

        #region Protected Methods

        /// &lt;summary&gt;Searches the position in a query where a string is terminated.&lt;/summary&gt;
        /// &lt;param name=&quot;query&quot;&gt;The query to search.&lt;/param&gt;
        /// &lt;param name=&quot;startPos&quot;&gt;The position of the opening quote of the string.&lt;/param&gt;
        /// &lt;returns&gt;The position of termination quote of the string.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// Assumes a correct query, 0&amp;lt;startPos&amp;lt;query.Length-1 and query[startPos]==&#39;\&#39;&#39;.
        /// (because the function is optimized for speed)
        /// &lt;/remarks&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;If the query is incorrect,
        /// startPos not in ]0,query.Length-1[ or query[startPos]!=&#39;\&#39;&#39;. &lt;/exception&gt;
        protected virtual int FindStringEndPosition(string query, int startPos)
        {
            // move to first character of string
            startPos++;
            // keep searching, function will eventually return with correct query
            // or encounter an IndexOutOfRangeException if incorrect
            while (true)
            {
                // move to next quote
                while (query[startPos++] != StringDelimiter) ;
                // if the quote is at the end of the string, we&#39;re done
                if (startPos == query.Length)
                    return startPos - 1;
                // if the next character isn&#39;t a quote, we&#39;re done also (quotes are escaped by doubling)
                if (query[startPos++] != StringDelimiter)
                    return startPos - 2;
            }
        }

        #endregion
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[32,17,32,18,0],[32,19,32,31,0],[32,32,32,33,0],[41,17,41,18,0],[41,19,41,30,0],[41,31,41,32,0],[50,15,50,31,0],[51,9,51,10,0],[51,11,51,12,0],[60,9,60,62,0],[61,9,61,10,0],[62,13,64,103,0],[65,17,65,97,0],[67,13,67,37,0],[68,13,68,39,0],[69,9,69,10,0],[83,9,83,10,0],[84,13,84,26,0],[85,9,85,10,0],[94,9,94,10,0],[96,13,96,40,0],[97,17,97,36,0],[99,13,99,74,0],[100,18,100,27,0],[100,29,100,51,0],[100,53,100,56,0],[101,13,101,14,0],[103,17,103,50,0],[104,17,104,18,0],[106,21,106,44,0],[108,21,108,93,0],[108,94,108,95,0],[110,21,110,108,0],[112,21,112,54,0],[114,26,114,35,0],[114,37,114,84,0],[114,86,114,89,0],[115,25,115,80,0],[116,29,116,73,0],[118,21,118,92,0],[120,21,120,49,0],[121,25,121,31,0],[122,17,122,18,0],[124,17,124,47,0],[125,13,125,14,0],[127,13,127,32,0],[128,13,128,38,0],[129,9,129,10,0],[136,9,136,10,0],[137,13,137,116,0],[138,17,138,30,0],[141,13,141,33,0],[143,18,143,25,0],[143,27,143,56,0],[143,58,143,63,0],[144,17,144,24,0],[144,26,144,39,0],[144,40,144,42,0],[144,43,144,54,0],[145,21,145,48,0],[146,25,146,41,0],[149,13,149,25,0],[150,17,150,30,0],[153,13,153,19,0],[156,18,156,27,0],[156,29,156,36,0],[156,38,156,41,0],[157,17,157,49,0],[159,21,159,29,0],[161,13,161,54,0],[163,13,163,14,0],[164,17,164,47,0],[166,17,166,46,0],[167,21,167,61,0],[169,17,169,18,0],[171,26,171,35,0],[171,37,171,59,0],[171,61,171,64,0],[172,25,172,53,0],[173,25,173,26,0],[174,29,174,64,0],[175,29,175,35,0],[177,17,177,18,0],[178,13,178,14,0],[178,15,178,44,0],[180,13,180,44,0],[181,9,181,10,0],[189,9,189,10,0],[190,13,190,45,0],[191,17,191,37,0],[193,13,193,75,0],[196,13,196,34,0],[197,18,197,36,0],[197,38,197,63,0],[197,65,197,77,0],[198,13,198,14,0],[200,17,200,58,0],[201,17,201,18,0],[203,21,203,110,0],[206,21,206,81,0],[207,21,207,98,0],[210,21,210,62,0],[211,17,211,18,0],[212,13,212,14,0],[214,13,214,75,0],[216,13,216,45,0],[217,9,217,10,0],[234,9,234,10,0],[236,13,236,24,0],[239,13,239,25,0],[240,13,240,14,0],[242,17,242,61,0],[242,62,242,63,0],[244,17,244,46,0],[245,21,245,41,0],[247,17,247,58,0],[248,21,248,41,0],[249,13,249,14,0],[250,9,250,10,0]]);
    </script>
  </body>
</html>