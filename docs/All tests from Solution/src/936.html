<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Routing\RedirectTrackingEventHandler.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using Umbraco.Core;
using Umbraco.Core.Cache;
using Umbraco.Core.Configuration;
using Umbraco.Core.Events;
using Umbraco.Core.Models;
using Umbraco.Core.Models.PublishedContent;
using Umbraco.Core.Publishing;
using Umbraco.Core.Services;
using Umbraco.Core.Strings;
using Umbraco.Core.Sync;
using Umbraco.Web.Cache;
using Umbraco.Web.PublishedCache;

namespace Umbraco.Web.Routing
{
    /// &lt;summary&gt;
    /// Implements an Application Event Handler for managing redirect urls tracking.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// &lt;para&gt;when content is renamed or moved, we want to create a permanent 301 redirect from it&#39;s old url&lt;/para&gt;
    /// &lt;para&gt;not managing domains because we don&#39;t know how to do it - changing domains =&gt; must create a higher level strategy using rewriting rules probably&lt;/para&gt;
    /// &lt;para&gt;recycle bin = moving to and from does nothing: to = the node is gone, where would we redirect? from = same&lt;/para&gt;
    /// &lt;/remarks&gt;
    public class RedirectTrackingEventHandler : ApplicationEventHandler
    {
        private const string ContextKey1 = &quot;Umbraco.Web.Routing.RedirectTrackingEventHandler.1&quot;;
        private const string ContextKey2 = &quot;Umbraco.Web.Routing.RedirectTrackingEventHandler.2&quot;;
        private const string ContextKey3 = &quot;Umbraco.Web.Routing.RedirectTrackingEventHandler.3&quot;;

        /// &lt;inheritdoc /&gt;
        protected override void ApplicationStarting(UmbracoApplicationBase umbracoApplication, ApplicationContext applicationContext)
        {
            if (UmbracoConfig.For.UmbracoSettings().WebRouting.DisableRedirectUrlTracking)
            {
                ContentFinderResolver.Current.RemoveType&lt;ContentFinderByRedirectUrl&gt;();
            }
            else
            {
                // if any of these dlls are loaded we don&#39;t want to run our finder
                var dlls = new[]
                {
                    &quot;InfoCaster.Umbraco.UrlTracker&quot;,
                    &quot;SEOChecker&quot;,
                    &quot;Simple301&quot;,
                    &quot;Terabyte.Umbraco.Modules.PermanentRedirect&quot;,
                    &quot;CMUmbracoTools&quot;,
                    &quot;PWUrlRedirect&quot;
                };

                // assuming all assemblies have been loaded already
                // check if any of them matches one of the above dlls
                var found = AppDomain.CurrentDomain.GetAssemblies()
                    .Select(x =&gt; x.FullName.Split(&#39;,&#39;)[0])
                    .Any(x =&gt; dlls.Contains(x));
                if (found)
                    ContentFinderResolver.Current.RemoveType&lt;ContentFinderByRedirectUrl&gt;();
            }
        }

        /// &lt;inheritdoc /&gt;
        protected override void ApplicationStarted(UmbracoApplicationBase umbracoApplication, ApplicationContext applicationContext)
        {
            // don&#39;t let the event handlers kick in if Redirect Tracking is turned off in the config
            if (UmbracoConfig.For.UmbracoSettings().WebRouting.DisableRedirectUrlTracking) return;

            // events are weird
            // on &#39;published&#39; we &#39;could&#39; get the old or the new route depending on event handlers order
            // so it is not reliable. getting the old route in &#39;publishing&#39; to be sure and storing in http
            // context. then for the same reason, we have to process these old items only when the cache
            // is ready
            // when moving, the moved node is also published, which is causing all sorts of troubles with
            // descendants, so when moving, we lock events so that neither &#39;published&#39; nor &#39;publishing&#39;
            // are processed more than once
            //
            // this is all verrrry weird but it seems to work

            ContentService.Publishing += ContentService_Publishing;
            ContentService.Published += ContentService_Published;
            ContentService.Moving += ContentService_Moving;
            ContentService.Moved += ContentService_Moved;
            PageCacheRefresher.CacheUpdated += PageCacheRefresher_CacheUpdated;

            // kill all redirects once a content is deleted
            //ContentService.Deleted += ContentService_Deleted;
            // BUT, doing it here would prevent content deletion due to FK
            // so the rows are actually deleted by the ContentRepository (see GetDeleteClauses)

            // rolled back items have to be published, so publishing will take care of that
        }

        /// &lt;summary&gt;
        /// Tracks a documents URLs during publishing in the current request
        /// &lt;/summary&gt;
        private static Dictionary&lt;int, Tuple&lt;Guid, string&gt;&gt; OldRoutes
        {
            get
            {
                var oldRoutes = RequestCache.GetCacheItem&lt;Dictionary&lt;int, Tuple&lt;Guid, string&gt;&gt;&gt;(
                    ContextKey3,
                    () =&gt; new Dictionary&lt;int, Tuple&lt;Guid, string&gt;&gt;());
                return oldRoutes;
            }
        }

        private static bool LockedEvents
        {
            get
            {
                return Moving &amp;&amp; RequestCache.GetCacheItem(ContextKey2) != null;
            }
            set
            {
                if (Moving &amp;&amp; value)
                {
                    //this forces true into the cache
                    RequestCache.GetCacheItem(ContextKey2, () =&gt; true);
                }
                else
                {
                    RequestCache.ClearCacheItem(ContextKey2);
                }
            }
        }

        private static bool Moving
        {
            get { return RequestCache.GetCacheItem(ContextKey1) != null; }
            set
            {
                if (value)
                {
                    //this forces true into the cache
                    RequestCache.GetCacheItem(ContextKey1, () =&gt; true);
                }
                else
                {
                    RequestCache.ClearCacheItem(ContextKey1);
                    RequestCache.ClearCacheItem(ContextKey2);
                }
            }
        }

        /// &lt;summary&gt;
        /// Before the items are published, we need to get it&#39;s current URL before it changes
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt;
        private static void ContentService_Publishing(IPublishingStrategy sender, PublishEventArgs&lt;IContent&gt; args)
        {
            if (LockedEvents) return;

            var contentCache = GetPublishedCache();
            if (contentCache == null) return;

            // prepare entities
            var entities = PrepareEntities(args.PublishedEntities);

            foreach (var entity in entities)
            {
                // for each entity, we want to save the &#39;old route&#39; of any impacted entity.
                //
                // previously, we&#39;d save the routes of all descendants - super safe but has an
                // impact on perfs - assuming that the descendant routes will NOT change if the
                // entity&#39;s segment does not change (else... outside of the scope of the simple,
                // built -in, tracker) then we can compare the entity&#39;s old and new segments
                // and avoid processing the descendants

                var process = true;
                if (Moving == false) // always process descendants when moving
                {
                    // SD: in 7.5.0 we re-lookup the entity that is published, which gets its
                    // current state in the DB, which we use to get the &#39;old&#39; segment. In the
                    // future this will certainly cause some problems, to fix this we&#39;d need to
                    // change the IUrlSegmentProvider to support being able to determine if a
                    // segment is going to change for an entity. See notes in IUrlSegmentProvider.

                    var oldEntity = ApplicationContext.Current.Services.ContentService.GetById(entity.Id);
                    if (oldEntity == null) continue;
                    var oldSegment = oldEntity.GetUrlSegment();
                    var newSegment = entity.GetUrlSegment();
                    process = oldSegment != newSegment;
                }

                // skip if no segment change
                if (process == false) continue;

                // else save routes for all descendants
                var entityContent = contentCache.GetById(entity.Id);
                if (entityContent == null) continue;
                foreach (var x in entityContent.DescendantsOrSelf())
                {
                    var route = contentCache.GetRouteById(x.Id);
                    if (IsNotRoute(route)) continue;
                    var wk = UnwrapToKey(x);
                    if (wk == null) continue;

                    OldRoutes[x.Id] = Tuple.Create(wk.Key, route);
                }
            }

            LockedEvents = true; // we only want to see the &quot;first batch&quot;
        }

        private static IEnumerable&lt;IContent&gt; PrepareEntities(IEnumerable&lt;IContent&gt; eventEntities)
        {
            // prepare entities
            // - exclude entities without an identity (new entities)
            // - exclude duplicates (in case publishing a parent and its children)

            var entities = new List&lt;IContent&gt;();
            foreach (var e in eventEntities.Where(x =&gt; x.HasIdentity).OrderBy(x =&gt; x.Level))
            {
                var pathIds = e.Path.Split(&#39;,&#39;).Select(int.Parse);
                if (entities.Any(x =&gt; pathIds.Contains(x.Id))) continue;
                entities.Add(e);
            }
            return entities;
        }

        private static IPublishedContentWithKey UnwrapToKey(IPublishedContent content)
        {
            if (content == null) return null;
            var withKey = content as IPublishedContentWithKey;
            if (withKey != null) return withKey;

            var extended = content as PublishedContentExtended;
            while (extended != null)
                extended = (content = extended.Unwrap()) as PublishedContentExtended;

            withKey = content as IPublishedContentWithKey;
            return withKey;
        }

        /// &lt;summary&gt;
        /// Executed when the cache updates, which means we can know what the new URL is for a given document
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;cacheRefresherEventArgs&quot;&gt;&lt;/param&gt;
        private void PageCacheRefresher_CacheUpdated(PageCacheRefresher sender, CacheRefresherEventArgs cacheRefresherEventArgs)
        {
            // only on master / single, not on slaves!
            if (IsSlaveServer) return;

            // simply getting OldRoutes will register it in the request cache,
            // so whatever we do with it, try/finally it to ensure it&#39;s cleared

            try
            {
                foreach (var oldRoute in OldRoutes)
                {
                    // assuming we cannot have &#39;CacheUpdated&#39; for only part of the infos else we&#39;d need
                    // to set a flag in &#39;Published&#39; to indicate which entities have been refreshed ok
                    CreateRedirect(oldRoute.Key, oldRoute.Value.Item1, oldRoute.Value.Item2);
                }
            }
            finally
            {
                OldRoutes.Clear();
                RequestCache.ClearCacheItem(ContextKey3);
            }
        }

        private static void ContentService_Published(IPublishingStrategy sender, PublishEventArgs&lt;IContent&gt; e)
        {
            // look note in CacheUpdated
            // we might want to set a flag on the entities we are seeing here
        }

        private static void ContentService_Moving(IContentService sender, MoveEventArgs&lt;IContent&gt; e)
        {
            Moving = true;
        }

        private static void ContentService_Moved(IContentService sender, MoveEventArgs&lt;IContent&gt; e)
        {
            Moving = false;
            LockedEvents = false;
        }

        private static void CreateRedirect(int contentId, Guid contentKey, string oldRoute)
        {

            var contentCache = GetPublishedCache();
            if (contentCache == null) return;

            var newRoute = contentCache.GetRouteById(contentId);
            if (IsNotRoute(newRoute) || oldRoute == newRoute) return;
            var redirectUrlService = ApplicationContext.Current.Services.RedirectUrlService;
            redirectUrlService.Register(oldRoute, contentKey);
        }

        private static bool IsNotRoute(string route)
        {
            // null if content not found
            return route == null;
        }

        // gets a value indicating whether server is &#39;slave&#39;
        private static bool IsSlaveServer
        {
            get
            {
                var serverRole = ApplicationContext.Current.GetCurrentServerRole();
                return serverRole != ServerRole.Master &amp;&amp; serverRole != ServerRole.Single;
            }
        }

        /// &lt;summary&gt;
        /// Gets the current request cache to persist the values between handlers
        /// &lt;/summary&gt;
        private static ContextualPublishedContentCache GetPublishedCache()
        {
            return UmbracoContext.Current == null ? null : UmbracoContext.Current.ContentCache;
        }

        /// &lt;summary&gt;
        /// Gets the current request cache to persist the values between handlers
        /// &lt;/summary&gt;
        private static ICacheProvider RequestCache
        {
            get { return ApplicationContext.Current.ApplicationCache.RequestCache; }
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[35,9,35,10,0],[36,13,36,91,0],[37,13,37,14,0],[38,17,38,88,0],[39,13,39,14,0],[41,13,41,14,0],[43,17,51,19,0],[55,17,56,34,0],[56,34,56,58,0],[56,58,57,31,0],[57,31,57,47,0],[57,47,57,49,0],[55,17,57,49,0],[58,17,58,27,0],[59,21,59,92,0],[60,13,60,14,0],[61,9,61,10,0],[65,9,65,10,0],[67,13,67,91,0],[67,92,67,99,0],[80,13,80,68,0],[81,13,81,66,0],[82,13,82,60,0],[83,13,83,58,0],[84,13,84,80,0],[92,9,92,10,0],[100,13,100,14,0],[101,17,103,27,0],[103,27,103,69,0],[103,69,103,71,0],[101,17,103,71,0],[104,17,104,34,0],[105,13,105,14,0],[111,13,111,14,0],[112,17,112,81,0],[113,13,113,14,0],[115,13,115,14,0],[116,17,116,37,0],[117,17,117,18,0],[119,21,119,66,0],[119,66,119,70,0],[119,70,119,72,0],[119,21,119,72,0],[120,17,120,18,0],[122,17,122,18,0],[123,21,123,62,0],[124,17,124,18,0],[125,13,125,14,0],[130,17,130,18,0],[130,19,130,73,0],[130,74,130,75,0],[132,13,132,14,0],[133,17,133,27,0],[134,17,134,18,0],[136,21,136,66,0],[136,66,136,70,0],[136,70,136,72,0],[136,21,136,72,0],[137,17,137,18,0],[139,17,139,18,0],[140,21,140,62,0],[141,21,141,62,0],[142,17,142,18,0],[143,13,143,14,0],[152,9,152,10,0],[153,13,153,30,0],[153,31,153,38,0],[155,13,155,52,0],[156,13,156,38,0],[156,39,156,46,0],[159,13,159,68,0],[161,13,161,20,0],[161,22,161,32,0],[161,33,161,35,0],[161,36,161,44,0],[162,13,162,14,0],[171,17,171,36,0],[172,17,172,37,0],[173,17,173,18,0],[180,21,180,107,0],[181,21,181,43,0],[181,44,181,53,0],[182,21,182,64,0],[183,21,183,61,0],[184,21,184,56,0],[185,17,185,18,0],[188,17,188,38,0],[188,39,188,48,0],[191,17,191,69,0],[192,17,192,43,0],[192,44,192,53,0],[193,17,193,24,0],[193,26,193,31,0],[193,32,193,34,0],[193,35,193,68,0],[194,17,194,18,0],[195,21,195,65,0],[196,21,196,43,0],[196,44,196,53,0],[197,21,197,45,0],[198,21,198,36,0],[198,37,198,46,0],[200,21,200,67,0],[201,17,201,18,0],[202,13,202,14,0],[204,13,204,33,0],[205,9,205,10,0],[208,9,208,10,0],[213,13,213,49,0],[214,13,214,20,0],[214,22,214,27,0],[214,28,214,30,0],[214,31,214,56,0],[214,56,214,69,0],[214,69,214,84,0],[214,84,214,91,0],[214,91,214,92,0],[214,31,214,92,0],[215,13,215,14,0],[216,17,216,67,0],[217,17,217,39,0],[217,39,217,61,0],[217,61,217,63,0],[217,17,217,63,0],[217,64,217,73,0],[218,17,218,33,0],[219,13,219,14,0],[220,13,220,29,0],[221,9,221,10,0],[224,9,224,10,0],[225,13,225,33,0],[225,34,225,46,0],[226,13,226,63,0],[227,13,227,33,0],[227,34,227,49,0],[229,13,229,64,0],[230,13,230,37,0],[231,17,231,86,0],[233,13,233,59,0],[234,13,234,28,0],[235,9,235,10,0],[243,9,243,10,0],[245,13,245,31,0],[245,32,245,39,0],[251,13,251,14,0],[252,17,252,24,0],[252,26,252,38,0],[252,39,252,41,0],[252,42,252,51,0],[253,17,253,18,0],[256,21,256,94,0],[257,17,257,18,0],[258,13,258,14,0],[260,13,260,14,0],[261,17,261,35,0],[262,17,262,58,0],[263,13,263,14,0],[264,9,264,10,0],[267,9,267,10,0],[270,9,270,10,0],[273,9,273,10,0],[274,13,274,27,0],[275,9,275,10,0],[278,9,278,10,0],[279,13,279,28,0],[280,13,280,34,0],[281,9,281,10,0],[284,9,284,10,0],[286,13,286,52,0],[287,13,287,38,0],[287,39,287,46,0],[289,13,289,65,0],[290,13,290,62,0],[290,63,290,70,0],[291,13,291,93,0],[292,13,292,63,0],[293,9,293,10,0],[296,9,296,10,0],[298,13,298,34,0],[299,9,299,10,0],[305,13,305,14,0],[306,17,306,84,0],[307,17,307,91,0],[308,13,308,14,0],[315,9,315,10,0],[316,13,316,96,0],[317,9,317,10,0],[324,17,324,18,0],[324,19,324,83,0],[324,84,324,85,0]]);
    </script>
  </body>
</html>