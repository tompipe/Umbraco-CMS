<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Search\ExamineEvents.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Xml;
using System.Xml.Linq;
using Examine;
using Examine.LuceneEngine;
using Lucene.Net.Documents;
using Umbraco.Core;
using Umbraco.Core.Cache;
using Umbraco.Core.Logging;
using Umbraco.Core.Models;
using Umbraco.Core.Sync;
using Umbraco.Web.Cache;
using UmbracoExamine;
using Content = umbraco.cms.businesslogic.Content;
using Document = umbraco.cms.businesslogic.web.Document;

namespace Umbraco.Web.Search
{
	/// &lt;summary&gt;
	/// Used to wire up events for Examine
	/// &lt;/summary&gt;
	public sealed class ExamineEvents : ApplicationEventHandler
	{
		
		/// &lt;summary&gt;
		/// Once the application has started we should bind to all events and initialize the providers.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;httpApplication&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;applicationContext&quot;&gt;&lt;/param&gt;
		/// &lt;remarks&gt;
		/// We need to do this on the Started event as to guarantee that all resolvers are setup properly.
		/// &lt;/remarks&gt;		
		protected override void ApplicationStarted(UmbracoApplicationBase httpApplication, ApplicationContext applicationContext)
		{            
            LogHelper.Info&lt;ExamineEvents&gt;(&quot;Initializing Examine and binding to business logic events&quot;);

			var registeredProviders = ExamineManager.Instance.IndexProviderCollection
				.OfType&lt;BaseUmbracoIndexer&gt;().Count(x =&gt; x.EnableDefaultEventHandler);

			LogHelper.Info&lt;ExamineEvents&gt;(&quot;Adding examine event handlers for index providers: {0}&quot;, () =&gt; registeredProviders);

			//don&#39;t bind event handlers if we&#39;re not suppose to listen
			if (registeredProviders == 0)
				return;

            //Bind to distributed cache events - this ensures that this logic occurs on ALL servers that are taking part 
            // in a load balanced environment.
            CacheRefresherBase&lt;UnpublishedPageCacheRefresher&gt;.CacheUpdated += UnpublishedPageCacheRefresherCacheUpdated;
            CacheRefresherBase&lt;PageCacheRefresher&gt;.CacheUpdated += PublishedPageCacheRefresherCacheUpdated;
            CacheRefresherBase&lt;MediaCacheRefresher&gt;.CacheUpdated += MediaCacheRefresherCacheUpdated;
            CacheRefresherBase&lt;MemberCacheRefresher&gt;.CacheUpdated += MemberCacheRefresherCacheUpdated;
            CacheRefresherBase&lt;ContentTypeCacheRefresher&gt;.CacheUpdated += ContentTypeCacheRefresherCacheUpdated;
            
			var contentIndexer = ExamineManager.Instance.IndexProviderCollection[Constants.Examine.InternalIndexer] as UmbracoContentIndexer;
			if (contentIndexer != null)
			{
				contentIndexer.DocumentWriting += IndexerDocumentWriting;
			}
			var memberIndexer = ExamineManager.Instance.IndexProviderCollection[Constants.Examine.InternalMemberIndexer] as UmbracoMemberIndexer;
			if (memberIndexer != null)
			{
				memberIndexer.DocumentWriting += IndexerDocumentWriting;
			}
		}

        /// &lt;summary&gt;
        /// This is used to refresh content indexers IndexData based on the DataService whenever a content type is changed since
        /// properties may have been added/removed, then we need to re-index any required data if aliases have been changed
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
        /// &lt;remarks&gt;
        /// See: http://issues.umbraco.org/issue/U4-4798, http://issues.umbraco.org/issue/U4-7833
        /// &lt;/remarks&gt;
	    static void ContentTypeCacheRefresherCacheUpdated(ContentTypeCacheRefresher sender, CacheRefresherEventArgs e)
        {
            var indexersToUpdated = ExamineManager.Instance.IndexProviderCollection.OfType&lt;UmbracoContentIndexer&gt;();
            foreach (var provider in indexersToUpdated)
            {
                provider.RefreshIndexerDataFromDataService();
            }

            if (e.MessageType == MessageType.RefreshByJson)
            {
                var contentTypesChanged = new HashSet&lt;string&gt;();
                var mediaTypesChanged = new HashSet&lt;string&gt;();
                var memberTypesChanged = new HashSet&lt;string&gt;();

                var payloads = ContentTypeCacheRefresher.DeserializeFromJsonPayload(e.MessageObject.ToString());
                foreach (var payload in payloads)
                {
                    if (payload.IsNew == false
                        &amp;&amp; (payload.WasDeleted || payload.AliasChanged || payload.PropertyRemoved || payload.PropertyTypeAliasChanged))
                    {
                        //if we get here it means that some aliases have changed and the indexes for those particular doc types will need to be updated
                        if (payload.Type == typeof(IContentType).Name)
                        {
                            //if it is content
                            contentTypesChanged.Add(payload.Alias);
                        }
                        else if (payload.Type == typeof(IMediaType).Name)
                        {
                            //if it is media
                            mediaTypesChanged.Add(payload.Alias);
                        }
                        else if (payload.Type == typeof(IMemberType).Name)
                        {
                            //if it is members
                            memberTypesChanged.Add(payload.Alias);
                        }
                    }
                }

                //TODO: We need to update Examine to support re-indexing multiple items at once instead of one by one which will speed up 
                // the re-indexing process, we don&#39;t want to revert to rebuilding the whole thing!

                if (contentTypesChanged.Count &gt; 0)
                {
                    foreach (var alias in contentTypesChanged)
                    {
                        var ctType = ApplicationContext.Current.Services.ContentTypeService.GetContentType(alias);
                        if (ctType != null)
                        {
                            var contentItems = ApplicationContext.Current.Services.ContentService.GetContentOfContentType(ctType.Id);
                            foreach (var contentItem in contentItems)
                            {
                                ReIndexForContent(contentItem, contentItem.HasPublishedVersion &amp;&amp; contentItem.Trashed == false);
                            }
                        }                        
                    }                    
                }
                if (mediaTypesChanged.Count &gt; 0)
                {
                    foreach (var alias in mediaTypesChanged)
                    {
                        var ctType = ApplicationContext.Current.Services.ContentTypeService.GetMediaType(alias);
                        if (ctType != null)
                        {
                            var mediaItems = ApplicationContext.Current.Services.MediaService.GetMediaOfMediaType(ctType.Id);
                            foreach (var mediaItem in mediaItems)
                            {
                                ReIndexForMedia(mediaItem, mediaItem.Trashed == false);
                            }
                        }
                    }
                }
                if (memberTypesChanged.Count &gt; 0)
                {
                    foreach (var alias in memberTypesChanged)
                    {
                        var ctType = ApplicationContext.Current.Services.MemberTypeService.Get(alias);
                        if (ctType != null)
                        {
                            var memberItems = ApplicationContext.Current.Services.MemberService.GetMembersByMemberType(ctType.Id);
                            foreach (var memberItem in memberItems)
                            {
                                ReIndexForMember(memberItem);
                            }
                        }
                    }
                }
            }
            
        }

	    static void MemberCacheRefresherCacheUpdated(MemberCacheRefresher sender, CacheRefresherEventArgs e)
	    {
            switch (e.MessageType)
            {
                case MessageType.RefreshById:
                    var c1 = ApplicationContext.Current.Services.MemberService.GetById((int)e.MessageObject);
                    if (c1 != null)
                    {
                        ReIndexForMember(c1);
                    }
                    break;
                case MessageType.RemoveById:

                    // This is triggered when the item is permanently deleted

                    DeleteIndexForEntity((int)e.MessageObject, false);
                    break;
                case MessageType.RefreshByInstance:
                    var c3 = e.MessageObject as IMember;
                    if (c3 != null)
                    {
                        ReIndexForMember(c3);
                    }
                    break;
                case MessageType.RemoveByInstance:

                    // This is triggered when the item is permanently deleted

                    var c4 = e.MessageObject as IMember;
                    if (c4 != null)
                    {
                        DeleteIndexForEntity(c4.Id, false);
                    }
                    break;
                case MessageType.RefreshAll:
                case MessageType.RefreshByJson:
                default:
                    //We don&#39;t support these, these message types will not fire for unpublished content
                    break;
            }
	    }

	    /// &lt;summary&gt;
        /// Handles index management for all media events - basically handling saving/copying/trashing/deleting
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
	    static void MediaCacheRefresherCacheUpdated(MediaCacheRefresher sender, CacheRefresherEventArgs e)
        {
            switch (e.MessageType)
            {
                case MessageType.RefreshById:
                    var c1 = ApplicationContext.Current.Services.MediaService.GetById((int)e.MessageObject);
                    if (c1 != null)
                    {
                        ReIndexForMedia(c1, c1.Trashed == false);
                    }
                    break;
                case MessageType.RemoveById:
                    var c2 = ApplicationContext.Current.Services.MediaService.GetById((int)e.MessageObject);
                    if (c2 != null)
                    {
                        //This is triggered when the item has trashed.
                        // So we need to delete the index from all indexes not supporting unpublished content.

                        DeleteIndexForEntity(c2.Id, true);

                        //We then need to re-index this item for all indexes supporting unpublished content

                        ReIndexForMedia(c2, false);
                    }
                    break;
                case MessageType.RefreshByJson:

                    var jsonPayloads = MediaCacheRefresher.DeserializeFromJsonPayload((string)e.MessageObject);
                    if (jsonPayloads.Any())
                    {
                        foreach (var payload in jsonPayloads)
                        {
                            switch (payload.Operation)
                            {
                                case MediaCacheRefresher.OperationType.Saved:
                                    var media1 = ApplicationContext.Current.Services.MediaService.GetById(payload.Id);
                                    if (media1 != null)
                                    {
                                        ReIndexForMedia(media1, media1.Trashed == false);
                                    }                                    
                                    break;
                                case MediaCacheRefresher.OperationType.Trashed:
                                    
                                    //keep if trashed for indexes supporting unpublished
                                    //(delete the index from all indexes not supporting unpublished content)
                                    
                                    DeleteIndexForEntity(payload.Id, true);

                                    //We then need to re-index this item for all indexes supporting unpublished content
                                    var media2 = ApplicationContext.Current.Services.MediaService.GetById(payload.Id);
                                    if (media2 != null)
                                    {
                                        ReIndexForMedia(media2, false);
                                    }

                                    break;
                                case MediaCacheRefresher.OperationType.Deleted:

                                    //permanently remove from all indexes
                                    
                                    DeleteIndexForEntity(payload.Id, false);

                                    break;
                                default:
                                    throw new ArgumentOutOfRangeException();
                            }                            
                        }                        
                    }

                    break;
                case MessageType.RefreshByInstance:                    
                case MessageType.RemoveByInstance:                    
                case MessageType.RefreshAll:                
                default:
                    //We don&#39;t support these, these message types will not fire for media
                    break;
            }
        }

        /// &lt;summary&gt;
        /// Handles index management for all published content events - basically handling published/unpublished
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
        /// &lt;remarks&gt;
        /// This will execute on all servers taking part in load balancing
        /// &lt;/remarks&gt;
        static void PublishedPageCacheRefresherCacheUpdated(PageCacheRefresher sender, CacheRefresherEventArgs e)
        {
            switch (e.MessageType)
            {
                case MessageType.RefreshById:
                    var c1 = ApplicationContext.Current.Services.ContentService.GetById((int)e.MessageObject);
                    if (c1 != null)
                    {
                        ReIndexForContent(c1, true);
                    }
                    break;
                case MessageType.RemoveById:
                    
                    //This is triggered when the item has been unpublished or trashed (which also performs an unpublish).                    

                    var c2 = ApplicationContext.Current.Services.ContentService.GetById((int)e.MessageObject);
                    if (c2 != null)
                    {
                        // So we need to delete the index from all indexes not supporting unpublished content.

                        DeleteIndexForEntity(c2.Id, true);

                        // We then need to re-index this item for all indexes supporting unpublished content

                        ReIndexForContent(c2, false);
                    }
                    break;
                case MessageType.RefreshByInstance:
                    var c3 = e.MessageObject as IContent;
                    if (c3 != null)
                    {
                        ReIndexForContent(c3, true);
                    }
                    break;
                case MessageType.RemoveByInstance:

                    //This is triggered when the item has been unpublished or trashed (which also performs an unpublish).

                    var c4 = e.MessageObject as IContent;
                    if (c4 != null)
                    {
                        // So we need to delete the index from all indexes not supporting unpublished content.

                        DeleteIndexForEntity(c4.Id, true);

                        // We then need to re-index this item for all indexes supporting unpublished content

                        ReIndexForContent(c4, false);
                    }
                    break;
                case MessageType.RefreshAll:
                case MessageType.RefreshByJson:
                default:
                    //We don&#39;t support these for examine indexing
                    break;
            }
        }

        /// &lt;summary&gt;
        /// Handles index management for all unpublished content events - basically handling saving/copying/deleting
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
        /// &lt;remarks&gt;
        /// This will execute on all servers taking part in load balancing
        /// &lt;/remarks&gt;
	    static void UnpublishedPageCacheRefresherCacheUpdated(UnpublishedPageCacheRefresher sender, CacheRefresherEventArgs e)
        {
            switch (e.MessageType)
            {
                case MessageType.RefreshById:
                    var c1 = ApplicationContext.Current.Services.ContentService.GetById((int) e.MessageObject);
                    if (c1 != null)
                    {
                        ReIndexForContent(c1, false);
                    }
                    break;
                case MessageType.RemoveById:
                    
                    // This is triggered when the item is permanently deleted
                    
                    DeleteIndexForEntity((int)e.MessageObject, false);
                    break;
                case MessageType.RefreshByInstance:
                    var c3 = e.MessageObject as IContent;
                    if (c3 != null)
                    {
                        ReIndexForContent(c3, false);
                    }
                    break;
                case MessageType.RemoveByInstance:

                    // This is triggered when the item is permanently deleted

                    var c4 = e.MessageObject as IContent;
                    if (c4 != null)
                    {
                        DeleteIndexForEntity(c4.Id, false);
                    }
                    break;                
                case MessageType.RefreshByJson:

                    var jsonPayloads = UnpublishedPageCacheRefresher.DeserializeFromJsonPayload((string)e.MessageObject);
                    if (jsonPayloads.Any())
                    {
                        foreach (var payload in jsonPayloads)
                        {
                            switch (payload.Operation)
                            {
                                case UnpublishedPageCacheRefresher.OperationType.Deleted:                                   

                                    //permanently remove from all indexes
                                    
                                    DeleteIndexForEntity(payload.Id, false);

                                    break;
                                default:
                                    throw new ArgumentOutOfRangeException();
                            }                            
                        }                        
                    }

                    break;

                case MessageType.RefreshAll:                
                default:
                    //We don&#39;t support these, these message types will not fire for unpublished content
                    break;
            }
        }

		
        private static void ReIndexForMember(IMember member)
		{
		    ExamineManager.Instance.ReIndexNode(
		        member.ToXml(), IndexTypes.Member,
		        ExamineManager.Instance.IndexProviderCollection.OfType&lt;BaseUmbracoIndexer&gt;()
                    //ensure that only the providers are flagged to listen execute
		            .Where(x =&gt; x.EnableDefaultEventHandler));
		}

		/// &lt;summary&gt;
		/// Event handler to create a lower cased version of the node name, this is so we can support case-insensitive searching and still
		/// use the Whitespace Analyzer
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
		
		private static void IndexerDocumentWriting(object sender, DocumentWritingEventArgs e)
		{
			if (e.Fields.Keys.Contains(&quot;nodeName&quot;))
			{
                //TODO: This logic should really be put into the content indexer instead of hidden here!!

				//add the lower cased version
				e.Document.Add(new Field(&quot;__nodeName&quot;,
										e.Fields[&quot;nodeName&quot;].ToLower(),
										Field.Store.YES,
										Field.Index.ANALYZED,
										Field.TermVector.NO
										));
			}
		}
        
        private static void ReIndexForMedia(IMedia sender, bool isMediaPublished)
        {
            var xml = sender.ToXml();
            //add an icon attribute to get indexed
            xml.Add(new XAttribute(&quot;icon&quot;, sender.ContentType.Icon));

            ExamineManager.Instance.ReIndexNode(
                xml, IndexTypes.Media,
                ExamineManager.Instance.IndexProviderCollection.OfType&lt;BaseUmbracoIndexer&gt;()

                    //Index this item for all indexers if the media is not trashed, otherwise if the item is trashed
                    // then only index this for indexers supporting unpublished media

                    .Where(x =&gt; isMediaPublished || (x.SupportUnpublishedContent))
                    .Where(x =&gt; x.EnableDefaultEventHandler));
        }

	    /// &lt;summary&gt;
	    /// Remove items from any index that doesn&#39;t support unpublished content
	    /// &lt;/summary&gt;
        /// &lt;param name=&quot;entityId&quot;&gt;&lt;/param&gt;
	    /// &lt;param name=&quot;keepIfUnpublished&quot;&gt;
	    /// If true, indicates that we will only delete this item from indexes that don&#39;t support unpublished content.
	    /// If false it will delete this from all indexes regardless.
	    /// &lt;/param&gt;
	    private static void DeleteIndexForEntity(int entityId, bool keepIfUnpublished)
	    {
	        ExamineManager.Instance.DeleteFromIndex(
                entityId.ToString(CultureInfo.InvariantCulture),
	            ExamineManager.Instance.IndexProviderCollection.OfType&lt;BaseUmbracoIndexer&gt;()

                    //if keepIfUnpublished == true then only delete this item from indexes not supporting unpublished content,
                    // otherwise if keepIfUnpublished == false then remove from all indexes
                
                    .Where(x =&gt; keepIfUnpublished == false || x.SupportUnpublishedContent == false)
	                .Where(x =&gt; x.EnableDefaultEventHandler));
	    }

	    /// &lt;summary&gt;
	    /// Re-indexes a content item whether published or not but only indexes them for indexes supporting unpublished content
	    /// &lt;/summary&gt;
	    /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
	    /// &lt;param name=&quot;isContentPublished&quot;&gt;
	    /// Value indicating whether the item is published or not
	    /// &lt;/param&gt;
	    private static void ReIndexForContent(IContent sender, bool isContentPublished)
	    {
            var xml = sender.ToXml();
            //add an icon attribute to get indexed
            xml.Add(new XAttribute(&quot;icon&quot;, sender.ContentType.Icon));

            ExamineManager.Instance.ReIndexNode(
                xml, IndexTypes.Content,
	            ExamineManager.Instance.IndexProviderCollection.OfType&lt;BaseUmbracoIndexer&gt;()
                    
	                //Index this item for all indexers if the content is published, otherwise if the item is not published
	                // then only index this for indexers supporting unpublished content

	                .Where(x =&gt; isContentPublished || (x.SupportUnpublishedContent))
	                .Where(x =&gt; x.EnableDefaultEventHandler));
	    }

		/// &lt;summary&gt;
		/// Converts a content node to XDocument
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;cacheOnly&quot;&gt;true if data is going to be returned from cache&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;		
        [Obsolete(&quot;This method is no longer used and will be removed from the core in future versions, the cacheOnly parameter has no effect. Use the other ToXDocument overload instead&quot;)]
		public static XDocument ToXDocument(Content node, bool cacheOnly)
		{			
			return ToXDocument(node);
		}

		/// &lt;summary&gt;
		/// Converts a content node to Xml
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;		
		private static XDocument ToXDocument(Content node)
		{
            if (TypeHelper.IsTypeAssignableFrom&lt;Document&gt;(node))
            {
                return new XDocument(((Document) node).ContentEntity.ToXml());
            }

            if (TypeHelper.IsTypeAssignableFrom&lt;global::umbraco.cms.businesslogic.media.Media&gt;(node))
            {
                return new XDocument(((global::umbraco.cms.businesslogic.media.Media) node).MediaItem.ToXml());
            }

			var xDoc = new XmlDocument();
			var xNode = xDoc.CreateNode(XmlNodeType.Element, &quot;node&quot;, &quot;&quot;);
			node.XmlPopulate(xDoc, ref xNode, false);

			if (xNode.Attributes[&quot;nodeTypeAlias&quot;] == null)
			{
				//we&#39;ll add the nodeTypeAlias ourselves                                
				XmlAttribute d = xDoc.CreateAttribute(&quot;nodeTypeAlias&quot;);
				d.Value = node.ContentType.Alias;
				xNode.Attributes.Append(d);
			}

			return new XDocument(ExamineXmlExtensions.ToXElement(xNode));
		}

	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[37,3,37,4,0],[38,13,38,104,0],[40,4,41,46,0],[41,46,41,73,0],[41,73,41,75,0],[40,4,41,75,0],[43,4,43,98,0],[43,98,43,117,0],[43,117,43,119,0],[43,4,43,119,0],[46,4,46,33,0],[47,5,47,12,0],[51,13,51,121,0],[52,13,52,108,0],[53,13,53,101,0],[54,13,54,103,0],[55,13,55,113,0],[57,4,57,133,0],[58,4,58,31,0],[59,4,59,5,0],[60,5,60,62,0],[61,4,61,5,0],[62,4,62,137,0],[63,4,63,30,0],[64,4,64,5,0],[65,5,65,61,0],[66,4,66,5,0],[67,3,67,4,0],[79,9,79,10,0],[80,13,80,117,0],[81,13,81,20,0],[81,22,81,34,0],[81,35,81,37,0],[81,38,81,55,0],[82,13,82,14,0],[83,17,83,62,0],[84,13,84,14,0],[86,13,86,60,0],[87,13,87,14,0],[88,17,88,65,0],[89,17,89,63,0],[90,17,90,64,0],[92,17,92,113,0],[93,17,93,24,0],[93,26,93,37,0],[93,38,93,40,0],[93,41,93,49,0],[94,17,94,18,0],[95,21,96,136,0],[97,21,97,22,0],[99,25,99,71,0],[100,25,100,26,0],[102,29,102,68,0],[103,25,103,26,0],[104,30,104,74,0],[105,25,105,26,0],[107,29,107,66,0],[108,25,108,26,0],[109,30,109,75,0],[110,25,110,26,0],[112,29,112,67,0],[113,25,113,26,0],[114,21,114,22,0],[115,17,115,18,0],[120,17,120,51,0],[121,17,121,18,0],[122,21,122,28,0],[122,30,122,39,0],[122,40,122,42,0],[122,43,122,62,0],[123,21,123,22,0],[124,25,124,115,0],[125,25,125,44,0],[126,25,126,26,0],[127,29,127,134,0],[128,29,128,36,0],[128,38,128,53,0],[128,54,128,56,0],[128,57,128,69,0],[129,29,129,30,0],[130,33,130,129,0],[131,29,131,30,0],[132,25,132,26,0],[133,21,133,22,0],[134,17,134,18,0],[135,17,135,49,0],[136,17,136,18,0],[137,21,137,28,0],[137,30,137,39,0],[137,40,137,42,0],[137,43,137,60,0],[138,21,138,22,0],[139,25,139,113,0],[140,25,140,44,0],[141,25,141,26,0],[142,29,142,126,0],[143,29,143,36,0],[143,38,143,51,0],[143,52,143,54,0],[143,55,143,65,0],[144,29,144,30,0],[145,33,145,88,0],[146,29,146,30,0],[147,25,147,26,0],[148,21,148,22,0],[149,17,149,18,0],[150,17,150,50,0],[151,17,151,18,0],[152,21,152,28,0],[152,30,152,39,0],[152,40,152,42,0],[152,43,152,61,0],[153,21,153,22,0],[154,25,154,103,0],[155,25,155,44,0],[156,25,156,26,0],[157,29,157,131,0],[158,29,158,36,0],[158,38,158,52,0],[158,53,158,55,0],[158,56,158,67,0],[159,29,159,30,0],[160,33,160,62,0],[161,29,161,30,0],[162,25,162,26,0],[163,21,163,22,0],[164,17,164,18,0],[165,13,165,14,0],[167,9,167,10,0],[170,6,170,7,0],[171,13,171,35,0],[174,21,174,110,0],[175,21,175,36,0],[176,21,176,22,0],[177,25,177,46,0],[178,21,178,22,0],[179,21,179,27,0],[184,21,184,71,0],[185,21,185,27,0],[187,21,187,57,0],[188,21,188,36,0],[189,21,189,22,0],[190,25,190,46,0],[191,21,191,22,0],[192,21,192,27,0],[197,21,197,57,0],[198,21,198,36,0],[199,21,199,22,0],[200,25,200,60,0],[201,21,201,22,0],[202,21,202,27,0],[207,21,207,27,0],[209,6,209,7,0],[217,9,217,10,0],[218,13,218,35,0],[221,21,221,109,0],[222,21,222,36,0],[223,21,223,22,0],[224,25,224,66,0],[225,21,225,22,0],[226,21,226,27,0],[228,21,228,109,0],[229,21,229,36,0],[230,21,230,22,0],[234,25,234,59,0],[238,25,238,52,0],[239,21,239,22,0],[240,21,240,27,0],[243,21,243,112,0],[244,21,244,44,0],[245,21,245,22,0],[246,25,246,32,0],[246,34,246,45,0],[246,46,246,48,0],[246,49,246,61,0],[247,25,247,26,0],[248,29,248,55,0],[251,37,251,119,0],[252,37,252,56,0],[253,37,253,38,0],[254,41,254,90,0],[255,37,255,38,0],[256,37,256,43,0],[262,37,262,76,0],[265,37,265,119,0],[266,37,266,56,0],[267,37,267,38,0],[268,41,268,72,0],[269,37,269,38,0],[271,37,271,43,0],[276,37,276,77,0],[278,37,278,43,0],[280,37,280,77,0],[282,25,282,26,0],[283,21,283,22,0],[285,21,285,27,0],[291,21,291,27,0],[293,9,293,10,0],[304,9,304,10,0],[305,13,305,35,0],[308,21,308,111,0],[309,21,309,36,0],[310,21,310,22,0],[311,25,311,53,0],[312,21,312,22,0],[313,21,313,27,0],[318,21,318,111,0],[319,21,319,36,0],[320,21,320,22,0],[323,25,323,59,0],[327,25,327,54,0],[328,21,328,22,0],[329,21,329,27,0],[331,21,331,58,0],[332,21,332,36,0],[333,21,333,22,0],[334,25,334,53,0],[335,21,335,22,0],[336,21,336,27,0],[341,21,341,58,0],[342,21,342,36,0],[343,21,343,22,0],[346,25,346,59,0],[350,25,350,54,0],[351,21,351,22,0],[352,21,352,27,0],[357,21,357,27,0],[359,9,359,10,0],[370,9,370,10,0],[371,13,371,35,0],[374,21,374,112,0],[375,21,375,36,0],[376,21,376,22,0],[377,25,377,54,0],[378,21,378,22,0],[379,21,379,27,0],[384,21,384,71,0],[385,21,385,27,0],[387,21,387,58,0],[388,21,388,36,0],[389,21,389,22,0],[390,25,390,54,0],[391,21,391,22,0],[392,21,392,27,0],[397,21,397,58,0],[398,21,398,36,0],[399,21,399,22,0],[400,25,400,60,0],[401,21,401,22,0],[402,21,402,27,0],[405,21,405,122,0],[406,21,406,44,0],[407,21,407,22,0],[408,25,408,32,0],[408,34,408,45,0],[408,46,408,48,0],[408,49,408,61,0],[409,25,409,26,0],[410,29,410,55,0],[416,37,416,77,0],[418,37,418,43,0],[420,37,420,77,0],[422,25,422,26,0],[423,21,423,22,0],[425,21,425,27,0],[430,21,430,27,0],[432,9,432,10,0],[436,3,436,4,0],[437,7,441,27,0],[441,27,441,54,0],[441,54,441,57,0],[437,7,441,57,0],[442,3,442,4,0],[452,3,452,4,0],[453,4,453,43,0],[454,4,454,5,0],[458,5,463,14,0],[464,4,464,5,0],[465,3,465,4,0],[468,9,468,10,0],[469,13,469,38,0],[471,13,471,70,0],[473,13,480,33,0],[480,33,480,82,0],[480,82,481,33,0],[481,33,481,60,0],[481,60,481,63,0],[473,13,481,63,0],[482,9,482,10,0],[493,6,493,7,0],[494,10,501,33,0],[501,33,501,99,0],[501,99,502,30,0],[502,30,502,57,0],[502,57,502,60,0],[494,10,502,60,0],[503,6,503,7,0],[513,6,513,7,0],[514,13,514,38,0],[516,13,516,70,0],[518,13,525,30,0],[525,30,525,81,0],[525,81,526,30,0],[526,30,526,57,0],[526,57,526,60,0],[518,13,526,60,0],[527,6,527,7,0],[537,3,537,4,0],[538,4,538,29,0],[539,3,539,4,0],[547,3,547,4,0],[548,13,548,65,0],[549,13,549,14,0],[550,17,550,79,0],[553,13,553,102,0],[554,13,554,14,0],[555,17,555,112,0],[558,4,558,33,0],[559,4,559,65,0],[560,4,560,45,0],[562,4,562,50,0],[563,4,563,5,0],[565,5,565,60,0],[566,5,566,38,0],[567,5,567,32,0],[568,4,568,5,0],[570,4,570,65,0],[571,3,571,4,0]]);
    </script>
  </body>
</html>