<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Routing\SiteDomainHelper.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Text.RegularExpressions;
using Umbraco.Core;
 
namespace Umbraco.Web.Routing
{
 	/// &lt;summary&gt;
	/// Provides utilities to handle site domains.
 	/// &lt;/summary&gt;
	public class SiteDomainHelper : ISiteDomainHelper
 	{
        #region Configure
 
        private static readonly ReaderWriterLockSlim ConfigLock = new ReaderWriterLockSlim();
	    private static Dictionary&lt;string, string[]&gt; _sites;
        private static Dictionary&lt;string, List&lt;string&gt;&gt; _bindings;
        private static Dictionary&lt;string, Dictionary&lt;string, string[]&gt;&gt; _qualifiedSites;

        // these are for unit tests *only*
        internal static Dictionary&lt;string, string[]&gt; Sites { get { return _sites; } }
        internal static Dictionary&lt;string, List&lt;string&gt;&gt; Bindings { get { return _bindings;  } } 

        // these are for validation
	    //private const string DomainValidationSource = @&quot;^(\*|((?i:http[s]?://)?([-\w]+(\.[-\w]+)*)(:\d+)?(/[-\w]*)?))$&quot;;
        private const string DomainValidationSource = @&quot;^(((?i:http[s]?://)?([-\w]+(\.[-\w]+)*)(:\d+)?(/)?))$&quot;;
	    private static readonly Regex DomainValidation = new Regex(DomainValidationSource, RegexOptions.IgnoreCase | RegexOptions.Compiled);
 
         /// &lt;summary&gt;
        /// Returns a disposable object that represents safe write access to config.
         /// &lt;/summary&gt;
        /// &lt;remarks&gt;Should be used in a &lt;c&gt;using(SiteDomainHelper.ConfigWriteLock) { ... }&lt;/c&gt;  mode.&lt;/remarks&gt;
        protected static IDisposable ConfigWriteLock
	    {
            get { return new WriteLock(ConfigLock); }
	    }

        /// &lt;summary&gt;
        /// Returns a disposable object that represents safe read access to config.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Should be used in a &lt;c&gt;using(SiteDomainHelper.ConfigWriteLock) { ... }&lt;/c&gt;  mode.&lt;/remarks&gt;
        protected static IDisposable ConfigReadLock
        {
            get { return new ReadLock(ConfigLock); }
        }

        /// &lt;summary&gt;
        /// Clears the entire configuration.
        /// &lt;/summary&gt;
        public static void Clear()
        {
            using (ConfigWriteLock)
            {
                _sites = null;
                _bindings = null;
                _qualifiedSites = null;
            }
        }

        private static IEnumerable&lt;string&gt; ValidateDomains(IEnumerable&lt;string&gt; domains)
        {
            // must use authority format w/optional scheme and port, but no path
            // any domain should appear only once
            return domains.Select(domain =&gt;
                {
                    if (!DomainValidation.IsMatch(domain))
                        throw new ArgumentOutOfRangeException(&quot;domains&quot;, string.Format(&quot;Invalid domain: \&quot;{0}\&quot;&quot;, domain));
                    return domain;
                });
        }

        /// &lt;summary&gt;
        /// Adds a site.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;key&quot;&gt;A key uniquely identifying the site.&lt;/param&gt;
        /// &lt;param name=&quot;domains&quot;&gt;The site domains.&lt;/param&gt;
        /// &lt;remarks&gt;At the moment there is no public way to remove a site. Clear and reconfigure.&lt;/remarks&gt;
        public static void AddSite(string key, IEnumerable&lt;string&gt; domains)
        {
            using (ConfigWriteLock)
            {
                _sites = _sites ?? new Dictionary&lt;string, string[]&gt;();
                _sites[key] = ValidateDomains(domains).ToArray();
                _qualifiedSites = null;
            }
        }

        /// &lt;summary&gt;
        /// Adds a site.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;key&quot;&gt;A key uniquely identifying the site.&lt;/param&gt;
        /// &lt;param name=&quot;domains&quot;&gt;The site domains.&lt;/param&gt;
        /// &lt;remarks&gt;At the moment there is no public way to remove a site. Clear and reconfigure.&lt;/remarks&gt;
        public static void AddSite(string key, params string[] domains)
        {
            using (ConfigWriteLock)
            {
                _sites = _sites ?? new Dictionary&lt;string, string[]&gt;();
                _sites[key] = ValidateDomains(domains).ToArray();
                _qualifiedSites = null;
            }
        }

        /// &lt;summary&gt;
        /// Removes a site.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;key&quot;&gt;A key uniquely identifying the site.&lt;/param&gt;
        internal static void RemoveSite(string key)
        {
            using (ConfigWriteLock)
            {
                if (_sites != null &amp;&amp; _sites.ContainsKey(key))
                {
                    _sites.Remove(key);
                    if (_sites.Count == 0)
                        _sites = null;

                    if (_bindings != null &amp;&amp; _bindings.ContainsKey(key))
                    {
                        foreach (var b in _bindings[key])
                        {
                            _bindings[b].Remove(key);
                            if (_bindings[b].Count == 0)
                                _bindings.Remove(b);
                        }
                        _bindings.Remove(key);
                        if (_bindings.Count &gt; 0)
                            _bindings = null;
                    }

                    _qualifiedSites = null;
                }
            }
        }

        /// &lt;summary&gt;
        /// Binds some sites.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;keys&quot;&gt;The keys uniquely identifying the sites to bind.&lt;/param&gt;
         /// &lt;remarks&gt;
        /// &lt;para&gt;At the moment there is no public way to unbind sites. Clear and reconfigure.&lt;/para&gt;
        /// &lt;para&gt;If site1 is bound to site2 and site2 is bound to site3 then site1 is bound to site3.&lt;/para&gt;
         /// &lt;/remarks&gt;
        public static void BindSites(params string[] keys)
         {
            using (ConfigWriteLock)
            {
                foreach (var key in keys.Where(key =&gt; !_sites.ContainsKey(key)))
                    throw new ArgumentException(string.Format(&quot;Not an existing site key: {0}&quot;, key), &quot;keys&quot;);
 
                _bindings = _bindings ?? new Dictionary&lt;string, List&lt;string&gt;&gt;();
 
                var allkeys = _bindings
                    .Where(kvp =&gt; keys.Contains(kvp.Key))
                    .SelectMany(kvp =&gt; kvp.Value)
                    .Union(keys)
                    .ToArray();
                
                foreach (var key in allkeys)
                {
                    if (!_bindings.ContainsKey(key))
                        _bindings[key] = new List&lt;string&gt;();
                    var xkey = key;
                    var addKeys = allkeys.Where(k =&gt; k != xkey).Except(_bindings[key]);
                    _bindings[key].AddRange(addKeys);
                }
            }
        }

        #endregion

        #region Map domains

        /// &lt;summary&gt;
        /// Filters a list of &lt;c&gt;DomainAndUri&lt;/c&gt; to pick one that best matches the current request.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;current&quot;&gt;The Uri of the current request.&lt;/param&gt;
        /// &lt;param name=&quot;domainAndUris&quot;&gt;The list of &lt;c&gt;DomainAndUri&lt;/c&gt; to filter.&lt;/param&gt;
        /// &lt;returns&gt;The selected &lt;c&gt;DomainAndUri&lt;/c&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;If the filter is invoked then &lt;paramref name=&quot;domainAndUris&quot;/&gt; is _not_ empty and
        /// &lt;paramref name=&quot;current&quot;/&gt; is _not_ null, and &lt;paramref name=&quot;current&quot;/&gt; could not be
        /// matched with anything in &lt;paramref name=&quot;domainAndUris&quot;/&gt;.&lt;/para&gt;
        /// &lt;para&gt;The filter _must_ return something else an exception will be thrown.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public virtual DomainAndUri MapDomain(Uri current, DomainAndUri[] domainAndUris)
        {
            var currentAuthority = current.GetLeftPart(UriPartial.Authority);
            var qualifiedSites = GetQualifiedSites(current);

            return MapDomain(domainAndUris, qualifiedSites, currentAuthority);
        }

 	    /// &lt;summary&gt;
 	    /// Filters a list of &lt;c&gt;DomainAndUri&lt;/c&gt; to pick those that best matches the current request.
 	    /// &lt;/summary&gt;
 	    /// &lt;param name=&quot;current&quot;&gt;The Uri of the current request.&lt;/param&gt;
 	    /// &lt;param name=&quot;domainAndUris&quot;&gt;The list of &lt;c&gt;DomainAndUri&lt;/c&gt; to filter.&lt;/param&gt;
        /// &lt;param name=&quot;excludeDefault&quot;&gt;A value indicating whether to exclude the current/default domain.&lt;/param&gt;
 	    /// &lt;returns&gt;The selected &lt;c&gt;DomainAndUri&lt;/c&gt; items.&lt;/returns&gt;
 	    /// &lt;remarks&gt;The filter must return something, even empty, else an exception will be thrown.&lt;/remarks&gt;
 	    public virtual IEnumerable&lt;DomainAndUri&gt; MapDomains(Uri current, DomainAndUri[] domainAndUris, bool excludeDefault)
        {
            var currentAuthority = current.GetLeftPart(UriPartial.Authority);
            KeyValuePair&lt;string, string[]&gt;[] candidateSites = null;
 	        IEnumerable&lt;DomainAndUri&gt; ret = domainAndUris;

            using (ConfigReadLock) // so nothing changes between GetQualifiedSites and access to bindings
            {
                var qualifiedSites = GetQualifiedSitesInsideLock(current);

                if (excludeDefault)
                {
                    // exclude the current one (avoid producing the absolute equivalent of what GetUrl returns)
                    var hintWithSlash = current.EndPathWithSlash();
                    var hinted = domainAndUris.FirstOrDefault(d =&gt; d.Uri.EndPathWithSlash().IsBaseOf(hintWithSlash));
                    if (hinted != null)
                        ret = ret.Where(d =&gt; d != hinted);

                    // exclude the default one (avoid producing a possible duplicate of what GetUrl returns)
                    // only if the default one cannot be the current one ie if hinted is not null
                    if (hinted == null &amp;&amp; domainAndUris.Any())
                    {
                        // it is illegal to call MapDomain if domainAndUris is empty
                        // also, domainAndUris should NOT contain current, hence the test on hinted
                        var mainDomain = MapDomain(domainAndUris, qualifiedSites, currentAuthority); // what GetUrl would get
                        ret = ret.Where(d =&gt; d != mainDomain);
                    }
                }

                // we do our best, but can&#39;t do the impossible
                if (qualifiedSites == null)
                    return ret;

                // find a site that contains the current authority
                var currentSite = qualifiedSites.FirstOrDefault(site =&gt; site.Value.Contains(currentAuthority));

                // if current belongs to a site, pick every element from domainAndUris that also belong
                // to that site -- or to any site bound to that site

                if (!currentSite.Equals(default(KeyValuePair&lt;string, string[]&gt;)))
                {
                    candidateSites = new[] { currentSite };
                    if (_bindings != null &amp;&amp; _bindings.ContainsKey(currentSite.Key))
                    {
                        var boundSites = qualifiedSites.Where(site =&gt; _bindings[currentSite.Key].Contains(site.Key));
                        candidateSites = candidateSites.Union(boundSites).ToArray();

                        // .ToArray ensures it is evaluated before the configuration lock is exited
                    }
                }
            }
 
            // if we are able to filter, then filter, else return the whole lot
            return candidateSites == null ? ret : ret.Where(d =&gt;
                {
                    var authority = d.Uri.GetLeftPart(UriPartial.Authority);
                    return candidateSites.Any(site =&gt; site.Value.Contains(authority));
                });
         }
 
	    private static Dictionary&lt;string, string[]&gt; GetQualifiedSites(Uri current)
	    {
	        using (ConfigReadLock)
	        {
	            return GetQualifiedSitesInsideLock(current);
	        }
	    }
 
	    private static Dictionary&lt;string, string[]&gt; GetQualifiedSitesInsideLock(Uri current)
        {
            // we do our best, but can&#39;t do the impossible
            if (_sites == null)
                return null;
 
            // cached?
            if (_qualifiedSites != null &amp;&amp; _qualifiedSites.ContainsKey(current.Scheme))
                return _qualifiedSites[current.Scheme];
 
            _qualifiedSites = _qualifiedSites ?? new Dictionary&lt;string, Dictionary&lt;string, string[]&gt;&gt;();
 
            // convert sites into authority sites based upon current scheme
            // because some domains in the sites might not have a scheme -- and cache
            return _qualifiedSites[current.Scheme] = _sites
                .ToDictionary(
                    kvp =&gt; kvp.Key,
                    kvp =&gt; kvp.Value.Select(d =&gt; new Uri(UriUtility.StartWithScheme(d, current.Scheme)).GetLeftPart(UriPartial.Authority)).ToArray()
                );
 
            // .ToDictionary will evaluate and create the dictionary immediately
            // the new value is .ToArray so it will also be evaluated immediately
            // therefore it is safe to return and exit the configuration lock
        }

        private static DomainAndUri MapDomain(DomainAndUri[] domainAndUris, Dictionary&lt;string, string[]&gt; qualifiedSites, string currentAuthority)
        {
            if (domainAndUris == null)
                throw new ArgumentNullException(&quot;domainAndUris&quot;);
            if (!domainAndUris.Any())
                throw new ArgumentException(&quot;Cannot be empty.&quot;, &quot;domainAndUris&quot;);

            // we do our best, but can&#39;t do the impossible
            if (qualifiedSites == null)
                return domainAndUris.First();

            // find a site that contains the current authority
            var currentSite = qualifiedSites.FirstOrDefault(site =&gt; site.Value.Contains(currentAuthority));

            // if current belongs to a site - try to pick the first element 
            // from domainAndUris that also belongs to that site
            var ret = currentSite.Equals(default(KeyValuePair&lt;string, string[]&gt;))
                ? null
                : domainAndUris.FirstOrDefault(d =&gt; currentSite.Value.Contains(d.Uri.GetLeftPart(UriPartial.Authority)));

            // no match means that either current does not belong to a site, or the site it belongs to
            // does not contain any of domainAndUris. Yet we have to return something. here, it becomes
            // a bit arbitrary.

            // look through sites in order and pick the first domainAndUri that belongs to a site
            ret = ret ?? qualifiedSites
                .Where(site =&gt; site.Key != currentSite.Key)
                .Select(site =&gt; domainAndUris.FirstOrDefault(domainAndUri =&gt; site.Value.Contains(domainAndUri.Uri.GetLeftPart(UriPartial.Authority))))
                .FirstOrDefault(domainAndUri =&gt; domainAndUri != null);

            // random, really
            ret = ret ?? domainAndUris.First();

            return ret;
        }

        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[17,9,17,94,1],[23,66,23,67,1],[23,68,23,82,1],[23,83,23,84,1],[24,73,24,74,1],[24,75,24,92,1],[24,94,24,95,1],[29,6,29,138,1],[37,17,37,18,1],[37,19,37,52,1],[37,53,37,54,1],[46,17,46,18,1],[46,19,46,51,1],[46,52,46,53,1],[53,9,53,10,1],[54,13,54,36,1],[55,13,55,14,1],[56,17,56,31,1],[57,17,57,34,1],[58,17,58,40,1],[59,13,59,14,1],[60,9,60,10,1],[63,9,63,10,1],[66,13,67,17,1],[67,17,67,18,1],[67,18,68,21,1],[68,21,68,59,1],[68,59,69,25,1],[69,25,69,124,1],[69,124,70,21,1],[70,21,70,35,1],[70,35,71,17,1],[71,17,71,18,1],[71,18,71,20,1],[66,13,71,20,1],[72,9,72,10,1],[81,9,81,10,0],[82,13,82,36,0],[83,13,83,14,0],[84,17,84,71,0],[85,17,85,66,0],[86,17,86,40,0],[87,13,87,14,0],[88,9,88,10,0],[97,9,97,10,1],[98,13,98,36,1],[99,13,99,14,1],[100,17,100,71,1],[101,17,101,66,1],[102,17,102,40,1],[103,13,103,14,1],[104,9,104,10,1],[111,9,111,10,1],[112,13,112,36,1],[113,13,113,14,1],[114,17,114,63,1],[115,17,115,18,1],[116,21,116,40,1],[117,21,117,43,1],[118,25,118,39,0],[120,21,120,73,1],[121,21,121,22,0],[122,25,122,32,0],[122,34,122,39,0],[122,40,122,42,0],[122,43,122,57,0],[123,25,123,26,0],[124,29,124,54,0],[125,29,125,57,0],[126,33,126,53,0],[127,25,127,26,0],[128,25,128,47,0],[129,25,129,49,0],[130,29,130,46,0],[131,21,131,22,0],[133,21,133,44,1],[134,17,134,18,1],[135,13,135,14,1],[136,9,136,10,1],[147,10,147,11,1],[148,13,148,36,1],[149,13,149,14,1],[150,17,150,24,1],[150,26,150,33,0],[150,34,150,36,1],[150,37,150,55,1],[150,55,150,79,1],[150,79,150,80,1],[150,37,150,80,1],[151,21,151,110,0],[153,17,153,81,1],[155,17,156,35,1],[156,35,156,57,1],[156,57,157,40,1],[157,40,157,49,1],[157,49,159,32,1],[155,17,159,32,1],[161,17,161,24,1],[161,26,161,33,1],[161,34,161,36,1],[161,37,161,44,1],[162,17,162,18,1],[163,21,163,53,1],[164,25,164,61,1],[165,21,165,36,1],[166,21,166,54,1],[166,54,166,63,1],[166,63,166,88,1],[166,21,166,88,1],[167,21,167,54,1],[168,17,168,18,1],[169,13,169,14,1],[170,9,170,10,1],[189,9,189,10,1],[190,13,190,78,1],[191,13,191,61,1],[193,13,193,79,1],[194,9,194,10,1],[205,9,205,10,1],[206,13,206,78,1],[207,13,207,68,1],[208,11,208,57,1],[210,13,210,35,1],[211,13,211,14,1],[212,17,212,75,1],[214,17,214,36,1],[215,17,215,18,1],[217,21,217,68,1],[218,21,218,68,1],[218,68,218,116,1],[218,116,218,118,1],[218,21,218,118,1],[219,21,219,40,1],[220,25,220,46,1],[220,46,220,57,1],[220,57,220,59,1],[220,25,220,59,1],[224,21,224,63,1],[225,21,225,22,1],[228,25,228,101,1],[229,25,229,46,1],[229,46,229,61,1],[229,61,229,63,1],[229,25,229,63,1],[230,21,230,22,1],[231,17,231,18,1],[234,17,234,44,1],[235,21,235,32,1],[238,17,238,73,1],[238,73,238,110,1],[238,110,238,112,1],[238,17,238,112,1],[243,17,243,82,1],[244,17,244,18,1],[245,21,245,60,1],[246,21,246,85,1],[247,21,247,22,1],[248,25,248,71,1],[248,71,248,116,1],[248,116,248,118,1],[248,25,248,118,1],[249,25,249,85,1],[252,21,252,22,1],[253,17,253,18,1],[254,13,254,14,1],[257,13,258,17,1],[258,17,258,18,1],[258,18,259,21,1],[259,21,259,77,1],[259,77,260,21,1],[260,21,260,55,1],[260,55,260,85,1],[260,85,260,87,1],[260,21,260,87,1],[260,87,261,17,1],[261,17,261,18,1],[261,18,261,20,1],[257,13,261,20,1],[262,10,262,11,1],[265,6,265,7,1],[266,10,266,32,1],[267,10,267,11,1],[268,14,268,58,1],[270,6,270,7,1],[273,9,273,10,1],[275,13,275,32,1],[276,17,276,29,1],[279,13,279,88,1],[280,17,280,56,1],[282,13,282,105,1],[286,13,288,28,1],[288,28,288,35,1],[288,35,289,28,1],[289,28,289,50,1],[289,50,289,138,1],[289,138,289,149,1],[289,28,289,149,1],[289,149,290,19,1],[286,13,290,19,1],[295,9,295,10,1],[298,9,298,10,1],[299,13,299,39,1],[300,17,300,66,0],[301,13,301,38,1],[302,17,302,82,0],[305,13,305,40,1],[306,17,306,46,1],[309,13,309,69,1],[309,69,309,106,1],[309,106,309,108,1],[309,13,309,108,1],[313,13,315,53,1],[315,53,315,120,1],[315,120,315,122,1],[313,13,315,122,1],[322,13,323,32,1],[323,32,323,59,1],[323,59,324,33,1],[324,33,324,78,1],[324,78,324,149,1],[324,149,324,150,1],[324,33,324,150,1],[324,150,325,49,1],[325,49,325,69,1],[325,69,325,71,1],[322,13,325,71,1],[328,13,328,48,1],[330,13,330,24,1],[331,9,331,10,1]]);
    </script>
  </body>
</html>