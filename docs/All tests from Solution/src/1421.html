<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\TopologicalSorter.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;

namespace Umbraco.Core
{
    /// &lt;summary&gt;
    /// Topological Sort algorithm for sorting items based on dependencies.
    /// Use the static method TopologicalSorter.GetSortedItems for a convenient 
    /// way of sorting a list of items with dependencies between them.
    /// &lt;/summary&gt;
    public class TopologicalSorter
    {
        private readonly int[] _vertices; // list of vertices
        private readonly int[,] _matrix; // adjacency matrix
        private int _numVerts; // current number of vertices
        private readonly int[] _sortedArray;

        public TopologicalSorter(int size)
        {
            _vertices = new int[size];
            _matrix = new int[size, size];
            _numVerts = 0;
            for (int i = 0; i &lt; size; i++)
                for (int j = 0; j &lt; size; j++)
                    _matrix[i, j] = 0;
            _sortedArray = new int[size]; // sorted vert labels
        }

        #region Public Methods

        public int AddVertex(int vertex)
        {
            _vertices[_numVerts++] = vertex;
            return _numVerts - 1;
        }

        public void AddEdge(int start, int end)
        {
            _matrix[start, end] = 1;
        }

        public int[] Sort() // toplogical sort
        {
            while (_numVerts &gt; 0) // while vertices remain,
            {
                // get a vertex with no successors, or -1
                int currentVertex = NoSuccessors();
                if (currentVertex == -1) // must be a cycle                
                    throw new Exception(&quot;Graph has cycles&quot;);

                // insert vertex label in sorted array (start at end)
                _sortedArray[_numVerts - 1] = _vertices[currentVertex];

                DeleteVertex(currentVertex); // delete vertex
            }

            // vertices all gone; return sortedArray
            return _sortedArray;
        }

        #endregion

        #region Private Helper Methods

        // returns vert with no successors (or -1 if no such verts)
        private int NoSuccessors()
        {
            for (int row = 0; row &lt; _numVerts; row++)
            {
                bool isEdge = false; // edge from row to column in adjMat
                for (int col = 0; col &lt; _numVerts; col++)
                {
                    if (_matrix[row, col] &gt; 0) // if edge to another,
                    {
                        isEdge = true;
                        break; // this vertex has a successor try another
                    }
                }
                if (!isEdge) // if no edges, has no successors
                    return row;
            }
            return -1; // no
        }

        private void DeleteVertex(int delVert)
        {
            // if not last vertex, delete from vertexList
            if (delVert != _numVerts - 1)
            {
                for (int j = delVert; j &lt; _numVerts - 1; j++)
                    _vertices[j] = _vertices[j + 1];

                for (int row = delVert; row &lt; _numVerts - 1; row++)
                    MoveRowUp(row, _numVerts);

                for (int col = delVert; col &lt; _numVerts - 1; col++)
                    MoveColLeft(col, _numVerts - 1);
            }
            _numVerts--; // one less vertex
        }

        private void MoveRowUp(int row, int length)
        {
            for (int col = 0; col &lt; length; col++)
                _matrix[row, col] = _matrix[row + 1, col];
        }

        private void MoveColLeft(int col, int length)
        {
            for (int row = 0; row &lt; length; row++)
                _matrix[row, col] = _matrix[row, col + 1];
        }

        #endregion

        #region Static methods

        public static IEnumerable&lt;T&gt; GetSortedItems&lt;T&gt;(List&lt;DependencyField&lt;T&gt;&gt; fields) where T : class 
        {
            int[] sortOrder = GetTopologicalSortOrder(fields);
            var list = new List&lt;T&gt;();
            for (int i = 0; i &lt; sortOrder.Length; i++)
            {
                var field = fields[sortOrder[i]];
                list.Add(field.Item.Value);
            }
            list.Reverse();
            return list;
        }

        internal static int[] GetTopologicalSortOrder&lt;T&gt;(List&lt;DependencyField&lt;T&gt;&gt; fields) where T : class 
        {
            var g = new TopologicalSorter(fields.Count());
            var indexes = new Dictionary&lt;string, int&gt;();

            //add vertices
            for (int i = 0; i &lt; fields.Count(); i++)
            {
                indexes[fields[i].Alias.ToLowerInvariant()] = g.AddVertex(i);
            }

            //add edges
            for (int i = 0; i &lt; fields.Count; i++)
            {
                if (fields[i].DependsOn != null)
                {
                    for (int j = 0; j &lt; fields[i].DependsOn.Length; j++)
                    {
                        if (indexes.ContainsKey(fields[i].DependsOn[j].ToLowerInvariant()) == false)
                            throw new IndexOutOfRangeException(
                                string.Format(
                                    &quot;The alias &#39;{0}&#39; has an invalid dependency. The dependency &#39;{1}&#39; does not exist in the list of aliases&quot;,
                                    fields[i], fields[i].DependsOn[j]));

                        g.AddEdge(i, indexes[fields[i].DependsOn[j].ToLowerInvariant()]);
                    }
                }
            }

            int[] result = g.Sort();
            return result;
        }

        #endregion

        public class DependencyField&lt;T&gt; where T : class 
        {
            public DependencyField()
            {
            }

            public DependencyField(string @alias, string[] dependsOn, Lazy&lt;T&gt; item)
            {
                Alias = alias;
                DependsOn = dependsOn;
                Item = item;
            }

            public string Alias { get; set; }
            public string[] DependsOn { get; set; }
            public Lazy&lt;T&gt; Item { get; set; }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[19,9,19,43,1],[20,9,20,10,1],[21,13,21,39,1],[22,13,22,43,1],[23,13,23,27,1],[24,18,24,27,1],[24,29,24,37,1],[24,39,24,42,1],[25,22,25,31,1],[25,33,25,41,1],[25,43,25,46,1],[26,21,26,39,1],[27,13,27,42,1],[28,9,28,10,1],[33,9,33,10,1],[34,13,34,45,1],[35,13,35,34,1],[36,9,36,10,1],[39,9,39,10,1],[40,13,40,37,1],[41,9,41,10,1],[44,9,44,10,1],[45,13,45,34,1],[46,13,46,14,1],[48,17,48,52,1],[49,17,49,41,1],[50,21,50,61,0],[53,17,53,72,1],[55,17,55,45,1],[56,13,56,14,1],[59,13,59,33,1],[60,9,60,10,1],[68,9,68,10,1],[69,18,69,29,1],[69,31,69,46,1],[69,48,69,53,1],[70,13,70,14,1],[71,17,71,37,1],[72,22,72,33,1],[72,35,72,50,1],[72,52,72,57,1],[73,17,73,18,1],[74,21,74,47,1],[75,21,75,22,1],[76,25,76,39,1],[77,25,77,31,1],[79,17,79,18,1],[80,17,80,29,1],[81,21,81,32,1],[82,13,82,14,1],[83,13,83,23,0],[84,9,84,10,1],[87,9,87,10,1],[89,13,89,42,1],[90,13,90,14,1],[91,22,91,37,1],[91,39,91,56,1],[91,58,91,61,1],[92,21,92,53,1],[94,22,94,39,1],[94,41,94,60,1],[94,62,94,67,1],[95,21,95,47,1],[97,22,97,39,1],[97,41,97,60,1],[97,62,97,67,1],[98,21,98,53,1],[99,13,99,14,1],[100,13,100,25,1],[101,9,101,10,1],[104,9,104,10,1],[105,18,105,29,1],[105,31,105,43,1],[105,45,105,50,1],[106,17,106,59,1],[107,9,107,10,1],[110,9,110,10,1],[111,18,111,29,1],[111,31,111,43,1],[111,45,111,50,1],[112,17,112,59,1],[113,9,113,10,1],[120,9,120,10,1],[121,13,121,63,1],[122,13,122,38,1],[123,18,123,27,1],[123,29,123,49,1],[123,51,123,54,1],[124,13,124,14,1],[125,17,125,50,1],[126,17,126,44,1],[127,13,127,14,1],[128,13,128,28,1],[129,13,129,25,1],[130,9,130,10,1],[133,9,133,10,1],[134,13,134,59,1],[135,13,135,57,1],[138,18,138,27,1],[138,29,138,47,1],[138,49,138,52,1],[139,13,139,14,1],[140,17,140,78,1],[141,13,141,14,1],[144,18,144,27,1],[144,29,144,45,1],[144,47,144,50,1],[145,13,145,14,1],[146,17,146,49,1],[147,17,147,18,1],[148,26,148,35,1],[148,37,148,67,1],[148,69,148,72,1],[149,21,149,22,1],[150,25,150,101,1],[151,29,154,73,0],[156,25,156,90,1],[157,21,157,22,1],[158,17,158,18,1],[159,13,159,14,1],[161,13,161,37,1],[162,13,162,27,1],[163,9,163,10,1],[169,13,169,37,1],[170,13,170,14,1],[171,13,171,14,1],[173,13,173,84,0],[174,13,174,14,0],[175,17,175,31,0],[176,17,176,39,0],[177,17,177,29,0],[178,13,178,14,0],[180,35,180,39,1],[180,40,180,44,1],[181,41,181,45,1],[181,46,181,50,1],[182,35,182,39,1],[182,40,182,44,1]]);
    </script>
  </body>
</html>