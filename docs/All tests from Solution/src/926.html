<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Scheduling\BackgroundTaskRunner.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using System.Web.Hosting;
using Umbraco.Core.Events;
using Umbraco.Core.Logging;

namespace Umbraco.Web.Scheduling
{
    // exists for logging purposes
    internal class BackgroundTaskRunner
    { }

    /// &lt;summary&gt;
    /// Manages a queue of tasks of type &lt;typeparamref name=&quot;T&quot;/&gt; and runs them in the background.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;The type of the managed tasks.&lt;/typeparam&gt;
    /// &lt;remarks&gt;The task runner is web-aware and will ensure that it shuts down correctly when the AppDomain
    /// shuts down (ie is unloaded).&lt;/remarks&gt;
    internal class BackgroundTaskRunner&lt;T&gt; : BackgroundTaskRunner, IBackgroundTaskRunner&lt;T&gt;
        where T : class, IBackgroundTask
    {
        private readonly string _logPrefix;
        private readonly BackgroundTaskRunnerOptions _options;
        private readonly ILogger _logger;
        private readonly BlockingCollection&lt;T&gt; _tasks = new BlockingCollection&lt;T&gt;();
        private readonly object _locker = new object();

        // that event is used to stop the pump when it is alive and waiting
        // on a latched task - so it waits on the latch, the cancellation token,
        // and the completed event
        private readonly ManualResetEventSlim _completedEvent = new ManualResetEventSlim(false);

        // in various places we are testing these vars outside a lock, so make them volatile
        private volatile bool _isRunning; // is running
        private volatile bool _isCompleted; // does not accept tasks anymore, may still be running

        private Task _runningTask;
        private CancellationTokenSource _tokenSource;

        private bool _terminating; // ensures we raise that event only once
        private bool _terminated; // remember we&#39;ve terminated
        private TaskCompletionSource&lt;int&gt; _terminatedSource; // awaitable source

        internal event TypedEventHandler&lt;BackgroundTaskRunner&lt;T&gt;, TaskEventArgs&lt;T&gt;&gt; TaskError;
        internal event TypedEventHandler&lt;BackgroundTaskRunner&lt;T&gt;, TaskEventArgs&lt;T&gt;&gt; TaskStarting;
        internal event TypedEventHandler&lt;BackgroundTaskRunner&lt;T&gt;, TaskEventArgs&lt;T&gt;&gt; TaskCompleted;
        internal event TypedEventHandler&lt;BackgroundTaskRunner&lt;T&gt;, TaskEventArgs&lt;T&gt;&gt; TaskCancelled;
        
        // triggers when the runner stops (but could start again if a task is added to it)
        internal event TypedEventHandler&lt;BackgroundTaskRunner&lt;T&gt;, EventArgs&gt; Stopped;

        // triggers when the hosting environment requests that the runner terminates
        internal event TypedEventHandler&lt;BackgroundTaskRunner&lt;T&gt;, EventArgs&gt; Terminating;

        // triggers when the runner terminates (no task can be added, no task is running)
        internal event TypedEventHandler&lt;BackgroundTaskRunner&lt;T&gt;, EventArgs&gt; Terminated;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;BackgroundTaskRunner{T}&quot;/&gt; class.
        /// &lt;/summary&gt;
        public BackgroundTaskRunner(ILogger logger)
            : this(typeof (T).FullName, new BackgroundTaskRunnerOptions(), logger)
        { }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;BackgroundTaskRunner{T}&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The name of the runner.&lt;/param&gt;
        /// &lt;param name=&quot;logger&quot;&gt;&lt;/param&gt;
        public BackgroundTaskRunner(string name, ILogger logger)
            : this(name, new BackgroundTaskRunnerOptions(), logger)
        { }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;BackgroundTaskRunner{T}&quot;/&gt; class with a set of options.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;options&quot;&gt;The set of options.&lt;/param&gt;
        /// &lt;param name=&quot;logger&quot;&gt;&lt;/param&gt;
        public BackgroundTaskRunner(BackgroundTaskRunnerOptions options, ILogger logger)
            : this(typeof (T).FullName, options, logger)
        { }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;BackgroundTaskRunner{T}&quot;/&gt; class with a set of options.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The name of the runner.&lt;/param&gt;
        /// &lt;param name=&quot;options&quot;&gt;The set of options.&lt;/param&gt;
        /// &lt;param name=&quot;logger&quot;&gt;&lt;/param&gt;
        public BackgroundTaskRunner(string name, BackgroundTaskRunnerOptions options, ILogger logger)
        {
            if (options == null) throw new ArgumentNullException(&quot;options&quot;);
            if (logger == null) throw new ArgumentNullException(&quot;logger&quot;);
            _options = options;
            _logPrefix = &quot;[&quot; + name + &quot;] &quot;;
            _logger = logger;

            if (options.Hosted)
                HostingEnvironment.RegisterObject(this);

            if (options.AutoStart)
                StartUp();
        }

        /// &lt;summary&gt;
        /// Gets the number of tasks in the queue.
        /// &lt;/summary&gt;
        public int TaskCount
        {
            get { return _tasks.Count; }
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether a task is currently running.
        /// &lt;/summary&gt;
        public bool IsRunning
        {
            get { return _isRunning; }
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether the runner has completed and cannot accept tasks anymore.
        /// &lt;/summary&gt;
        public bool IsCompleted
        {
            get { return _isCompleted; }
        }

        /// &lt;summary&gt;
        /// Gets the running task as an immutable object.
        /// &lt;/summary&gt;
        /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;There is no running task.&lt;/exception&gt;
        /// &lt;remarks&gt;
        /// Unless the AutoStart option is true, there will be no running task until
        /// a background task is added to the queue. Unless the KeepAlive option is true, there
        /// will be no running task when the queue is empty.
        /// &lt;/remarks&gt;
        public ThreadingTaskImmutable CurrentThreadingTask
        {
            get
            {
                lock (_locker)
                {
                    if (_runningTask == null)
                        throw new InvalidOperationException(&quot;There is no current Threading.Task.&quot;);
                    return new ThreadingTaskImmutable(_runningTask);
                }
            }
        }

        /// &lt;summary&gt;
        /// Gets an awaitable used to await the runner running operation.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;An awaitable instance.&lt;/returns&gt;
        /// &lt;remarks&gt;Used to wait until the runner is no longer running (IsRunning == false),
        /// though the runner could be started again afterwards by adding tasks to it.&lt;/remarks&gt;
        public ThreadingTaskImmutable StoppedAwaitable
        {
            get
            {
                lock (_locker)
                {
                    var task = _runningTask ?? Task.FromResult(0);
                    return new ThreadingTaskImmutable(task);
                }
            }
        }

        /// &lt;summary&gt;
        /// Gets an awaitable used to await the runner.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;An awaitable instance.&lt;/returns&gt;
        /// &lt;remarks&gt;Used to wait until the runner is terminated.&lt;/remarks&gt;
        public ThreadingTaskImmutable TerminatedAwaitable
        {
            get
            {
                lock (_locker)
                {
                    if (_terminatedSource == null &amp;&amp; _terminated == false)
                        _terminatedSource = new TaskCompletionSource&lt;int&gt;();
                    var task = _terminatedSource == null ? Task.FromResult(0) : _terminatedSource.Task;
                    return new ThreadingTaskImmutable(task);
                }
            }
        }

        /// &lt;summary&gt;
        /// Adds a task to the queue.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task to add.&lt;/param&gt;
        /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;The task runner has completed.&lt;/exception&gt;
        public void Add(T task)
        {
            lock (_locker)
            {
                if (_isCompleted)
                    throw new InvalidOperationException(&quot;The task runner has completed.&quot;);

                // add task
                _logger.Debug&lt;BackgroundTaskRunner&gt;(_logPrefix + &quot;Task added {0}&quot;, task.GetType);
                _tasks.Add(task);

                // start
                StartUpLocked();
            }
        }

        /// &lt;summary&gt;
        /// Tries to add a task to the queue.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task to add.&lt;/param&gt;
        /// &lt;returns&gt;true if the task could be added to the queue; otherwise false.&lt;/returns&gt;
        /// &lt;remarks&gt;Returns false if the runner is completed.&lt;/remarks&gt;
        public bool TryAdd(T task)
        {
            lock (_locker)
            {
                if (_isCompleted)
                {
                    _logger.Debug&lt;BackgroundTaskRunner&gt;(_logPrefix + &quot;Task cannot be added {0}, the task runner is already shutdown&quot;, task.GetType);
                    return false;
                }

                // add task
                _logger.Debug&lt;BackgroundTaskRunner&gt;(_logPrefix + &quot;Task added {0}&quot;, task.GetType);
                _tasks.Add(task);

                // start
                StartUpLocked();

                return true;
            }
        }

        /// &lt;summary&gt;
        /// Starts the tasks runner, if not already running.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Is invoked each time a task is added, to ensure it is going to be processed.&lt;/remarks&gt;
        /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;The task runner has completed.&lt;/exception&gt;
        public void StartUp()
        {
            if (_isRunning) return;

            lock (_locker)
            {
                if (_isCompleted)
                    throw new InvalidOperationException(&quot;The task runner has completed.&quot;);

                StartUpLocked();
            }
        }

        /// &lt;summary&gt;
        /// Starts the tasks runner, if not already running.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Must be invoked within lock(_locker) and with _isCompleted being false.&lt;/remarks&gt;
        private void StartUpLocked()
        {
            // double check 
            if (_isRunning) return;
            _isRunning = true;

            // create a new token source since this is a new process
            _tokenSource = new CancellationTokenSource();
            _runningTask = PumpIBackgroundTasks(Task.Factory, _tokenSource.Token);
            _logger.Debug&lt;BackgroundTaskRunner&gt;(_logPrefix + &quot;Starting&quot;);
        }

        /// &lt;summary&gt;
        /// Shuts the taks runner down.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;force&quot;&gt;True for force the runner to stop.&lt;/param&gt;
        /// &lt;param name=&quot;wait&quot;&gt;True to wait until the runner has stopped.&lt;/param&gt;
        /// &lt;remarks&gt;If &lt;paramref name=&quot;force&quot;/&gt; is false, no more tasks can be queued but all queued tasks
        /// will run. If it is true, then only the current one (if any) will end and no other task will run.&lt;/remarks&gt;
        public void Shutdown(bool force, bool wait)
        {
            lock (_locker)
            {
                _isCompleted = true; // do not accept new tasks
                if (_isRunning == false) return; // done already
            }

            // try to be nice
            // assuming multiple threads can do these without problems
            _completedEvent.Set();
            _tasks.CompleteAdding();

            if (force)
            {
                // we must bring everything down, now
                Thread.Sleep(100); // give time to CompleteAdding()
                lock (_locker)
                {
                    // was CompleteAdding() enough?
                    if (_isRunning == false) return;
                }
                // try to cancel running async tasks (cannot do much about sync tasks)
                // break delayed tasks delay
                // truncate running queues
                _tokenSource.Cancel(false); // false is the default
            }

            // tasks in the queue will be executed...
            if (wait == false) return;

            if (_runningTask != null)
                _runningTask.Wait(); // wait for whatever is running to end...
        }

        /// &lt;summary&gt;
        /// Runs background tasks for as long as there are background tasks in the queue, with an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;factory&quot;&gt;The supporting &lt;see cref=&quot;TaskFactory&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;token&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;The asynchronous operation.&lt;/returns&gt;
        private Task PumpIBackgroundTasks(TaskFactory factory, CancellationToken token)
        {
            var taskSource = new TaskCompletionSource&lt;object&gt;(factory.CreationOptions);
            var enumerator = _options.KeepAlive ? _tasks.GetConsumingEnumerable(token).GetEnumerator() : null;

            // ReSharper disable once MethodSupportsCancellation // always run
            var taskSourceContinuing = taskSource.Task.ContinueWith(t =&gt;
            {
                // because the pump does not lock, there&#39;s a race condition,
                // the pump may stop and then we still have tasks to process,
                // and then we must restart the pump - lock to avoid race cond
                var onStopped = false;
                lock (_locker)
                {
                    if (token.IsCancellationRequested || _tasks.Count == 0)
                    {
                        _logger.Debug&lt;BackgroundTaskRunner&gt;(_logPrefix + &quot;Stopping&quot;);

                        if (_options.PreserveRunningTask == false)
                            _runningTask = null;

                        // stopped
                        _isRunning = false;
                        onStopped = true;
                    }
                }

                if (onStopped)
                {
                    OnEvent(Stopped, &quot;Stopped&quot;);
                    return;
                }

                // if _runningTask is taskSource.Task then we must keep continuing it,
                // not starting a new taskSource, else _runningTask would complete and
                // something may be waiting on it
                //PumpIBackgroundTasks(factory, token); // restart
                // ReSharper disable MethodSupportsCancellation // always run
                t.ContinueWithTask(_ =&gt; PumpIBackgroundTasks(factory, token)); // restart
                // ReSharper restore MethodSupportsCancellation
            });

            Action&lt;Task&gt; pump = null;
            pump = task =&gt;
            {
                // RunIBackgroundTaskAsync does NOT throw exceptions, just raises event
                // so if we have an exception here, really, wtf? - must read the exception
                // anyways so it does not bubble up and kill everything
                if (task != null &amp;&amp; task.IsFaulted)
                {
                    var exception = task.Exception;
                    _logger.Error&lt;BackgroundTaskRunner&gt;(_logPrefix + &quot;Task runner exception.&quot;, exception);
                }

                // is it ok to run?
                if (TaskSourceCanceled(taskSource, token)) return;

                // try to get a task
                // the blocking MoveNext will end if token is cancelled or collection is completed
                T bgTask;
                var hasBgTask = _options.KeepAlive
                    // ReSharper disable once PossibleNullReferenceException
                    ? (bgTask = enumerator.MoveNext() ? enumerator.Current : null) != null // blocking
                    : _tasks.TryTake(out bgTask); // non-blocking

                // no task, signal the runner we&#39;re done
                if (hasBgTask == false)
                {
                    TaskSourceCompleted(taskSource, token);
                    return;
                }

                // wait for latched task, supporting cancellation
                var dbgTask = bgTask as ILatchedBackgroundTask;
                if (dbgTask != null &amp;&amp; dbgTask.IsLatched)
                {
                    WaitHandle.WaitAny(new[] { dbgTask.Latch, token.WaitHandle, _completedEvent.WaitHandle });
                    if (TaskSourceCanceled(taskSource, token)) return;
                    // else run now, either because latch ok or runner is completed
                    // still latched &amp; not running on shutdown = stop here
                    if (dbgTask.IsLatched &amp;&amp; dbgTask.RunsOnShutdown == false)
                    {
                        dbgTask.Dispose(); // will not run
                        TaskSourceCompleted(taskSource, token);
                        return;
                    }
                }

                // run the task as first task, or a continuation
                task = task == null 
                    ? RunIBackgroundTaskAsync(bgTask, token)
                    // ReSharper disable once MethodSupportsCancellation // always run
                    : task.ContinueWithTask(_ =&gt; RunIBackgroundTaskAsync(bgTask, token));

                // and pump
                // ReSharper disable once MethodSupportsCancellation // always run
                task.ContinueWith(t =&gt; pump(t));
            };

            // start it all
            factory.StartNew(() =&gt; pump(null),
                token,
                _options.LongRunning ? TaskCreationOptions.LongRunning : TaskCreationOptions.None,
                TaskScheduler.Default);

            return taskSourceContinuing;
        }

        private static bool TaskSourceCanceled(TaskCompletionSource&lt;object&gt; taskSource, CancellationToken token)
        {
            if (token.IsCancellationRequested)
            {
                taskSource.SetCanceled();
                return true;
            }
            return false;
        }

        private static void TaskSourceCompleted(TaskCompletionSource&lt;object&gt; taskSource, CancellationToken token)
        {
            if (token.IsCancellationRequested)
                taskSource.SetCanceled();
            else
                taskSource.SetResult(null);
        }

        /// &lt;summary&gt;
        /// Runs a background task asynchronously.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;bgTask&quot;&gt;The background task.&lt;/param&gt;
        /// &lt;param name=&quot;token&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;The asynchronous operation.&lt;/returns&gt;
        internal async Task RunIBackgroundTaskAsync(T bgTask, CancellationToken token)
        {
            try
            {
                OnTaskStarting(new TaskEventArgs&lt;T&gt;(bgTask));

                try
                {
                    try
                    {
                        if (bgTask.IsAsync)
                            //configure await = false since we don&#39;t care about the context, we&#39;re on a background thread.
                            await bgTask.RunAsync(token).ConfigureAwait(false);
                        else
                            bgTask.Run();
                    }
                    finally // ensure we disposed - unless latched (again)
                    {
                        var lbgTask = bgTask as ILatchedBackgroundTask;
                        if (lbgTask == null || lbgTask.IsLatched == false)
                            bgTask.Dispose();
                    }
                }
                catch (Exception e)
                {
                    OnTaskError(new TaskEventArgs&lt;T&gt;(bgTask, e));
                    throw;
                }

                OnTaskCompleted(new TaskEventArgs&lt;T&gt;(bgTask));
            }
            catch (Exception ex)
            {
                _logger.Error&lt;BackgroundTaskRunner&gt;(_logPrefix + &quot;Task has failed&quot;, ex);
            }            
        }

        #region Events

        private void OnEvent(TypedEventHandler&lt;BackgroundTaskRunner&lt;T&gt;, EventArgs&gt; handler, string name)
        {
            if (handler == null) return;
            OnEvent(handler, name, EventArgs.Empty);
        }

        private void OnEvent&lt;TArgs&gt;(TypedEventHandler&lt;BackgroundTaskRunner&lt;T&gt;, TArgs&gt; handler, string name, TArgs e)
        {
            if (handler == null) return;

            try
            {
                handler(this, e);
            }
            catch (Exception ex)
            {
                _logger.Error&lt;BackgroundTaskRunner&gt;(_logPrefix + name + &quot; exception occurred&quot;, ex);
            }
        }

        protected virtual void OnTaskError(TaskEventArgs&lt;T&gt; e)
        {
            OnEvent(TaskError, &quot;TaskError&quot;, e);
        }

        protected virtual void OnTaskStarting(TaskEventArgs&lt;T&gt; e)
        {
            OnEvent(TaskStarting, &quot;TaskStarting&quot;, e);
        }

        protected virtual void OnTaskCompleted(TaskEventArgs&lt;T&gt; e)
        {
            OnEvent(TaskCompleted, &quot;TaskCompleted&quot;, e);
        }

        protected virtual void OnTaskCancelled(TaskEventArgs&lt;T&gt; e)
        {
            OnEvent(TaskCancelled, &quot;TaskCancelled&quot;, e);

            //dispose it
            e.Task.Dispose();
        }

        #endregion

        #region IDisposable

        private readonly object _disposalLocker = new object();
        public bool IsDisposed { get; private set; }

        ~BackgroundTaskRunner()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (IsDisposed || disposing == false)
                return;

            lock (_disposalLocker)
            {
                if (IsDisposed)
                    return;
                DisposeResources();
                IsDisposed = true;
            }
        }

        protected virtual void DisposeResources()
        {
            // just make sure we eventually go down
            Shutdown(true, false);
        }

        #endregion

        /// &lt;summary&gt;
        /// Requests a registered object to unregister.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;immediate&quot;&gt;true to indicate the registered object should unregister from the hosting
        /// environment before returning; otherwise, false.&lt;/param&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;&quot;When the application manager needs to stop a registered object, it will call the Stop method.&quot;&lt;/para&gt;
        /// &lt;para&gt;The application manager will call the Stop method to ask a registered object to unregister. During
        /// processing of the Stop method, the registered object must call the HostingEnvironment.UnregisterObject method.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public void Stop(bool immediate)
        {
            // the first time the hosting environment requests that the runner terminates,
            // raise the Terminating event - that could be used to prevent any process that
            // would expect the runner to be available from starting.
            var onTerminating = false;
            lock (_locker)
            {
                if (_terminating == false)
                {
                    _terminating = true;
                    _logger.Info&lt;BackgroundTaskRunner&gt;(_logPrefix + &quot;Terminating&quot; + (immediate ? &quot; (immediate)&quot; : &quot;&quot;));
                    onTerminating = true;
                }
            }

            if (onTerminating)
                OnEvent(Terminating, &quot;Terminating&quot;);

            if (immediate == false)
            {
                // The Stop method is first called with the immediate parameter set to false. The object can either complete
                // processing, call the UnregisterObject method, and then return or it can return immediately and complete
                // processing asynchronously before calling the UnregisterObject method.

                _logger.Info&lt;BackgroundTaskRunner&gt;(_logPrefix + &quot;Waiting for tasks to complete&quot;);
                Shutdown(false, false); // do not accept any more tasks, flush the queue, do not wait

                // raise the completed event only after the running task has completed
                // and there&#39;s no more task running

                lock (_locker)
                {
                    if (_runningTask != null)
                        _runningTask.ContinueWith(_ =&gt; Terminate(false));
                    else
                        Terminate(false);
                }
            }
            else
            {
                // If the registered object does not complete processing before the application manager&#39;s time-out
                // period expires, the Stop method is called again with the immediate parameter set to true. When the
                // immediate parameter is true, the registered object must call the UnregisterObject method before returning;
                // otherwise, its registration will be removed by the application manager.

                _logger.Info&lt;BackgroundTaskRunner&gt;(_logPrefix + &quot;Cancelling tasks&quot;);
                Shutdown(true, true); // cancel all tasks, wait for the current one to end
                Terminate(true);
            }
        }

        private void Terminate(bool immediate)
        {
            // signal the environment we have terminated
            // log
            // raise the Terminated event
            // complete the awaitable completion source, if any

            HostingEnvironment.UnregisterObject(this);
            _logger.Info&lt;BackgroundTaskRunner&gt;(_logPrefix + &quot;Tasks &quot; + (immediate ? &quot;cancelled&quot; : &quot;completed&quot;) + &quot;, terminated&quot;);
            OnEvent(Terminated, &quot;Terminated&quot;);

            TaskCompletionSource&lt;int&gt; terminatedSource;
            lock (_locker)
            {
                _terminated = true;
                terminatedSource = _terminatedSource;
            }
            if (terminatedSource != null)
                terminatedSource.SetResult(0);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[27,9,27,85,1],[28,9,28,56,1],[33,9,33,97,1],[64,15,64,83,0],[65,9,65,10,0],[65,11,65,12,0],[73,15,73,68,0],[74,9,74,10,0],[74,11,74,12,0],[82,15,82,57,1],[83,9,83,10,1],[83,11,83,12,1],[91,9,91,102,1],[92,9,92,10,1],[93,13,93,33,1],[93,34,93,77,0],[94,13,94,32,1],[94,33,94,75,0],[95,13,95,32,1],[96,13,96,44,1],[97,13,97,30,1],[99,13,99,32,1],[100,17,100,57,1],[102,13,102,35,1],[103,17,103,27,1],[104,9,104,10,1],[111,17,111,18,0],[111,19,111,39,0],[111,40,111,41,0],[119,17,119,18,1],[119,19,119,37,1],[119,38,119,39,1],[127,17,127,18,1],[127,19,127,39,1],[127,40,127,41,1],[142,13,142,14,1],[143,17,143,31,1],[144,17,144,18,1],[145,21,145,46,1],[146,25,146,100,0],[147,21,147,69,1],[149,13,149,14,1],[161,13,161,14,1],[162,17,162,31,1],[163,17,163,18,1],[164,21,164,67,1],[165,21,165,61,1],[167,13,167,14,1],[178,13,178,14,1],[179,17,179,31,1],[180,17,180,18,1],[181,21,181,75,1],[182,25,182,77,1],[183,21,183,104,1],[184,21,184,61,1],[186,13,186,14,1],[195,9,195,10,1],[196,13,196,27,1],[197,13,197,14,1],[198,17,198,34,1],[199,21,199,91,1],[202,17,202,98,1],[203,17,203,34,1],[206,17,206,33,1],[207,13,207,14,1],[208,9,208,10,1],[217,9,217,10,1],[218,13,218,27,1],[219,13,219,14,1],[220,17,220,34,1],[221,17,221,18,1],[222,21,222,149,1],[223,21,223,34,1],[227,17,227,98,1],[228,17,228,34,1],[231,17,231,33,1],[233,17,233,29,1],[235,9,235,10,1],[243,9,243,10,1],[244,13,244,28,1],[244,29,244,36,0],[246,13,246,27,1],[247,13,247,14,1],[248,17,248,34,1],[249,21,249,91,0],[251,17,251,33,1],[252,13,252,14,1],[253,9,253,10,1],[260,9,260,10,1],[262,13,262,28,1],[262,29,262,36,1],[263,13,263,31,1],[266,13,266,58,1],[267,13,267,83,1],[268,13,268,74,1],[269,9,269,10,1],[279,9,279,10,1],[280,13,280,27,1],[281,13,281,14,1],[282,17,282,37,1],[283,17,283,41,1],[283,42,283,49,1],[284,13,284,14,1],[288,13,288,35,1],[289,13,289,37,1],[291,13,291,23,1],[292,13,292,14,1],[294,17,294,35,1],[295,17,295,31,1],[296,17,296,18,1],[298,21,298,45,1],[298,46,298,53,1],[299,17,299,18,1],[303,17,303,44,1],[304,13,304,14,1],[307,13,307,31,1],[307,32,307,39,1],[309,13,309,38,1],[310,17,310,37,1],[311,9,311,10,1],[320,9,320,10,1],[321,13,321,88,1],[322,13,322,111,1],[325,13,326,13,1],[326,13,326,14,1],[326,14,330,17,1],[330,17,330,39,1],[330,39,331,17,1],[331,17,331,31,1],[331,31,332,17,1],[332,17,332,18,1],[332,18,333,21,1],[333,21,333,76,1],[333,76,334,21,1],[334,21,334,22,1],[334,22,335,25,1],[335,25,335,86,1],[335,86,337,25,1],[337,25,337,67,1],[337,67,338,29,1],[338,29,338,49,1],[338,49,341,25,1],[341,25,341,44,1],[341,44,342,25,1],[342,25,342,42,1],[342,42,343,21,1],[343,21,343,22,1],[343,22,344,17,1],[344,17,344,18,1],[344,18,346,17,1],[346,17,346,31,1],[346,31,347,17,1],[347,17,347,18,1],[347,18,348,21,1],[348,21,348,49,1],[348,49,349,21,1],[349,21,349,28,1],[349,28,357,17,1],[357,17,357,41,0],[357,41,357,77,0],[357,77,357,79,0],[357,17,357,79,0],[357,79,359,13,1],[359,13,359,14,1],[359,14,359,16,1],[325,13,359,16,1],[361,13,361,38,1],[362,13,363,13,1],[363,13,363,14,1],[363,14,367,17,1],[367,17,367,52,1],[367,52,368,17,1],[368,17,368,18,0],[368,18,369,21,1],[369,21,369,52,0],[369,52,370,21,1],[370,21,370,107,0],[370,107,371,17,1],[371,17,371,18,0],[371,18,374,17,1],[374,17,374,59,1],[374,59,374,60,1],[374,60,374,67,1],[374,67,379,17,1],[379,17,382,50,1],[382,50,385,17,1],[385,17,385,40,1],[385,40,386,17,1],[386,17,386,18,1],[386,18,387,21,1],[387,21,387,60,1],[387,60,388,21,1],[388,21,388,28,1],[388,28,392,17,1],[392,17,392,64,1],[392,64,393,17,1],[393,17,393,58,1],[393,58,394,17,1],[394,17,394,18,1],[394,18,395,21,1],[395,21,395,111,1],[395,111,396,21,1],[396,21,396,63,1],[396,63,396,64,1],[396,64,396,71,0],[396,71,399,21,1],[399,21,399,78,1],[399,78,400,21,1],[400,21,400,22,1],[400,22,401,25,1],[401,25,401,43,1],[401,43,402,25,1],[402,25,402,64,1],[402,64,403,25,1],[403,25,403,32,1],[403,32,405,17,1],[405,17,405,18,1],[405,18,408,17,1],[408,17,411,50,1],[411,50,411,88,1],[411,88,411,90,1],[408,17,411,90,1],[411,90,415,17,1],[415,17,415,40,1],[415,40,415,47,1],[415,47,415,49,1],[415,17,415,49,1],[415,49,416,13,1],[416,13,416,14,1],[416,14,416,15,1],[362,13,416,15,1],[419,13,419,36,1],[419,36,419,46,1],[419,46,422,40,1],[419,13,422,40,1],[424,13,424,41,1],[425,9,425,10,1],[428,9,428,10,1],[429,13,429,47,1],[430,13,430,14,1],[431,17,431,42,1],[432,17,432,29,1],[434,13,434,26,1],[435,9,435,10,1],[438,9,438,10,1],[439,13,439,47,1],[440,17,440,42,0],[442,17,442,44,1],[443,9,443,10,1],[452,9,452,10,1],[454,13,454,14,1],[455,17,455,62,1],[458,17,458,18,1],[460,21,460,22,1],[461,25,461,44,1],[463,29,463,80,1],[465,29,465,42,1],[466,21,466,22,1],[468,21,468,22,1],[469,25,469,72,1],[470,25,470,75,1],[471,29,471,46,1],[472,21,472,22,1],[473,17,473,18,1],[474,17,474,36,1],[475,17,475,18,1],[476,21,476,66,1],[477,21,477,27,1],[480,17,480,63,1],[481,13,481,14,1],[482,13,482,33,1],[483,13,483,14,1],[484,17,484,89,1],[485,13,485,14,1],[486,9,486,10,1],[491,9,491,10,1],[492,13,492,33,1],[492,34,492,41,1],[493,13,493,53,1],[494,9,494,10,1],[497,9,497,10,1],[498,13,498,33,1],[498,34,498,41,1],[501,13,501,14,1],[502,17,502,34,1],[503,13,503,14,1],[504,13,504,33,0],[505,13,505,14,0],[506,17,506,100,0],[507,13,507,14,0],[508,9,508,10,1],[511,9,511,10,1],[512,13,512,48,1],[513,9,513,10,1],[516,9,516,10,1],[517,13,517,54,1],[518,9,518,10,1],[521,9,521,10,1],[522,13,522,56,1],[523,9,523,10,1],[526,9,526,10,0],[527,13,527,56,0],[530,13,530,30,0],[531,9,531,10,0],[537,9,537,64,1],[538,34,538,38,1],[538,39,538,51,1],[541,9,541,10,0],[541,9,541,10,0],[542,13,542,28,0],[543,9,543,10,0],[543,9,543,10,0],[546,9,546,10,1],[547,13,547,27,1],[548,13,548,39,1],[549,9,549,10,1],[552,9,552,10,1],[553,13,553,50,1],[554,17,554,24,0],[556,13,556,35,1],[557,13,557,14,1],[558,17,558,32,1],[559,21,559,28,0],[560,17,560,36,1],[561,17,561,35,1],[562,13,562,14,1],[563,9,563,10,1],[566,9,566,10,1],[568,13,568,35,1],[569,9,569,10,1],[584,9,584,10,1],[588,13,588,39,1],[589,13,589,27,1],[590,13,590,14,1],[591,17,591,43,1],[592,17,592,18,1],[593,21,593,41,1],[594,21,594,120,1],[595,21,595,42,1],[596,17,596,18,1],[597,13,597,14,1],[599,13,599,31,1],[600,17,600,53,1],[602,13,602,36,1],[603,13,603,14,1],[608,17,608,98,1],[609,17,609,40,1],[614,17,614,31,1],[615,17,615,18,1],[616,21,616,46,1],[617,25,617,56,1],[617,56,617,72,1],[617,72,617,74,1],[617,25,617,74,1],[619,25,619,42,0],[620,17,620,18,1],[621,13,621,14,1],[623,13,623,14,1],[629,17,629,85,1],[630,17,630,38,1],[631,17,631,33,1],[632,13,632,14,1],[633,9,633,10,1],[636,9,636,10,1],[642,13,642,55,1],[643,13,643,130,1],[644,13,644,47,1],[647,13,647,27,1],[648,13,648,14,1],[649,17,649,36,1],[650,17,650,54,1],[651,13,651,14,1],[652,13,652,42,1],[653,17,653,47,1],[654,9,654,10,1]]);
    </script>
  </body>
</html>