<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Persistence\SqlSyntax\SqlSyntaxProviderBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Text;
using Umbraco.Core.Persistence.DatabaseAnnotations;
using Umbraco.Core.Persistence.DatabaseModelDefinitions;
using Umbraco.Core.Persistence.Querying;

namespace Umbraco.Core.Persistence.SqlSyntax
{
    /// &lt;summary&gt;
    /// Represents the Base Sql Syntax provider implementation.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// All Sql Syntax provider implementations should derive from this abstract class.
    /// &lt;/remarks&gt;
    /// &lt;typeparam name=&quot;TSyntax&quot;&gt;&lt;/typeparam&gt;
    public abstract class SqlSyntaxProviderBase&lt;TSyntax&gt; : ISqlSyntaxProvider
        where TSyntax : ISqlSyntaxProvider
    {
        protected SqlSyntaxProviderBase()
        {
            ClauseOrder = new List&lt;Func&lt;ColumnDefinition, string&gt;&gt;
                              {
                                  FormatString,
                                  FormatType,
                                  FormatNullable,
                                  FormatConstraint,
                                  FormatDefaultValue,
                                  FormatPrimaryKey,
                                  FormatIdentity
                              };

            //defaults for all providers
            StringLengthColumnDefinitionFormat = StringLengthUnicodeColumnDefinitionFormat;
            StringColumnDefinition = string.Format(StringLengthColumnDefinitionFormat, DefaultStringLength);
            DecimalColumnDefinition = string.Format(DecimalColumnDefinitionFormat, DefaultDecimalPrecision, DefaultDecimalScale);

            InitColumnTypeMap();
        }

        public string GetWildcardPlaceholder()
        {
            return &quot;%&quot;;
        }

        public string StringLengthNonUnicodeColumnDefinitionFormat = &quot;VARCHAR({0})&quot;;
        public string StringLengthUnicodeColumnDefinitionFormat = &quot;NVARCHAR({0})&quot;;
        public string DecimalColumnDefinitionFormat = &quot;DECIMAL({0},{1})&quot;;

        public string DefaultValueFormat = &quot;DEFAULT ({0})&quot;;
        public int DefaultStringLength = 255;
        public int DefaultDecimalPrecision = 20;
        public int DefaultDecimalScale = 9;

        //Set by Constructor
        public string StringColumnDefinition;
        public string StringLengthColumnDefinitionFormat;

        public string AutoIncrementDefinition = &quot;AUTOINCREMENT&quot;;
        public string IntColumnDefinition = &quot;INTEGER&quot;;
        public string LongColumnDefinition = &quot;BIGINT&quot;;
        public string GuidColumnDefinition = &quot;GUID&quot;;
        public string BoolColumnDefinition = &quot;BOOL&quot;;
        public string RealColumnDefinition = &quot;DOUBLE&quot;;
        public string DecimalColumnDefinition;
        public string BlobColumnDefinition = &quot;BLOB&quot;;
        public string DateTimeColumnDefinition = &quot;DATETIME&quot;;
        public string TimeColumnDefinition = &quot;DATETIME&quot;;

        protected IList&lt;Func&lt;ColumnDefinition, string&gt;&gt; ClauseOrder { get; set; }

        protected DbTypes&lt;TSyntax&gt; DbTypeMap = new DbTypes&lt;TSyntax&gt;();
        protected void InitColumnTypeMap()
        {
            DbTypeMap.Set&lt;string&gt;(DbType.String, StringColumnDefinition);
            DbTypeMap.Set&lt;char&gt;(DbType.StringFixedLength, StringColumnDefinition);
            DbTypeMap.Set&lt;char?&gt;(DbType.StringFixedLength, StringColumnDefinition);
            DbTypeMap.Set&lt;char[]&gt;(DbType.String, StringColumnDefinition);
            DbTypeMap.Set&lt;bool&gt;(DbType.Boolean, BoolColumnDefinition);
            DbTypeMap.Set&lt;bool?&gt;(DbType.Boolean, BoolColumnDefinition);
            DbTypeMap.Set&lt;Guid&gt;(DbType.Guid, GuidColumnDefinition);
            DbTypeMap.Set&lt;Guid?&gt;(DbType.Guid, GuidColumnDefinition);
            DbTypeMap.Set&lt;DateTime&gt;(DbType.DateTime, DateTimeColumnDefinition);
            DbTypeMap.Set&lt;DateTime?&gt;(DbType.DateTime, DateTimeColumnDefinition);
            DbTypeMap.Set&lt;TimeSpan&gt;(DbType.Time, TimeColumnDefinition);
            DbTypeMap.Set&lt;TimeSpan?&gt;(DbType.Time, TimeColumnDefinition);
            DbTypeMap.Set&lt;DateTimeOffset&gt;(DbType.Time, TimeColumnDefinition);
            DbTypeMap.Set&lt;DateTimeOffset?&gt;(DbType.Time, TimeColumnDefinition);

            DbTypeMap.Set&lt;byte&gt;(DbType.Byte, IntColumnDefinition);
            DbTypeMap.Set&lt;byte?&gt;(DbType.Byte, IntColumnDefinition);
            DbTypeMap.Set&lt;sbyte&gt;(DbType.SByte, IntColumnDefinition);
            DbTypeMap.Set&lt;sbyte?&gt;(DbType.SByte, IntColumnDefinition);
            DbTypeMap.Set&lt;short&gt;(DbType.Int16, IntColumnDefinition);
            DbTypeMap.Set&lt;short?&gt;(DbType.Int16, IntColumnDefinition);
            DbTypeMap.Set&lt;ushort&gt;(DbType.UInt16, IntColumnDefinition);
            DbTypeMap.Set&lt;ushort?&gt;(DbType.UInt16, IntColumnDefinition);
            DbTypeMap.Set&lt;int&gt;(DbType.Int32, IntColumnDefinition);
            DbTypeMap.Set&lt;int?&gt;(DbType.Int32, IntColumnDefinition);
            DbTypeMap.Set&lt;uint&gt;(DbType.UInt32, IntColumnDefinition);
            DbTypeMap.Set&lt;uint?&gt;(DbType.UInt32, IntColumnDefinition);

            DbTypeMap.Set&lt;long&gt;(DbType.Int64, LongColumnDefinition);
            DbTypeMap.Set&lt;long?&gt;(DbType.Int64, LongColumnDefinition);
            DbTypeMap.Set&lt;ulong&gt;(DbType.UInt64, LongColumnDefinition);
            DbTypeMap.Set&lt;ulong?&gt;(DbType.UInt64, LongColumnDefinition);

            DbTypeMap.Set&lt;float&gt;(DbType.Single, RealColumnDefinition);
            DbTypeMap.Set&lt;float?&gt;(DbType.Single, RealColumnDefinition);
            DbTypeMap.Set&lt;double&gt;(DbType.Double, RealColumnDefinition);
            DbTypeMap.Set&lt;double?&gt;(DbType.Double, RealColumnDefinition);

            DbTypeMap.Set&lt;decimal&gt;(DbType.Decimal, DecimalColumnDefinition);
            DbTypeMap.Set&lt;decimal?&gt;(DbType.Decimal, DecimalColumnDefinition);

            DbTypeMap.Set&lt;byte[]&gt;(DbType.Binary, BlobColumnDefinition);
        }

        public virtual string EscapeString(string val)
        {
            return PetaPocoExtensions.EscapeAtSymbols(val.Replace(&quot;&#39;&quot;, &quot;&#39;&#39;&quot;));
        }

        public virtual string GetStringColumnEqualComparison(string column, int paramIndex, TextColumnType columnType)
        {
            //use the &#39;upper&#39; method to always ensure strings are matched without case sensitivity no matter what the db setting.
            return string.Format(&quot;upper({0}) = upper(@{1})&quot;, column, paramIndex);
        }

        public virtual string GetStringColumnWildcardComparison(string column, int paramIndex, TextColumnType columnType)
        {
            //use the &#39;upper&#39; method to always ensure strings are matched without case sensitivity no matter what the db setting.
            return string.Format(&quot;upper({0}) LIKE upper(@{1})&quot;, column, paramIndex);
        }

        [Obsolete(&quot;Use the overload with the parameter index instead&quot;)]
        public virtual string GetStringColumnEqualComparison(string column, string value, TextColumnType columnType)
        {
            //use the &#39;upper&#39; method to always ensure strings are matched without case sensitivity no matter what the db setting.
            return string.Format(&quot;upper({0}) = &#39;{1}&#39;&quot;, column, value.ToUpper());
        }

        [Obsolete(&quot;Use the overload with the parameter index instead&quot;)]
        public virtual string GetStringColumnStartsWithComparison(string column, string value, TextColumnType columnType)
        {
            //use the &#39;upper&#39; method to always ensure strings are matched without case sensitivity no matter what the db setting.
            return string.Format(&quot;upper({0}) LIKE &#39;{1}%&#39;&quot;, column, value.ToUpper());
        }

        [Obsolete(&quot;Use the overload with the parameter index instead&quot;)]
        public virtual string GetStringColumnEndsWithComparison(string column, string value, TextColumnType columnType)
        {
            //use the &#39;upper&#39; method to always ensure strings are matched without case sensitivity no matter what the db setting.
            return string.Format(&quot;upper({0}) LIKE &#39;%{1}&#39;&quot;, column, value.ToUpper());
        }

        [Obsolete(&quot;Use the overload with the parameter index instead&quot;)]
        public virtual string GetStringColumnContainsComparison(string column, string value, TextColumnType columnType)
        {
            //use the &#39;upper&#39; method to always ensure strings are matched without case sensitivity no matter what the db setting.
            return string.Format(&quot;upper({0}) LIKE &#39;%{1}%&#39;&quot;, column, value.ToUpper());
        }

        [Obsolete(&quot;Use the overload with the parameter index instead&quot;)]
        public virtual string GetStringColumnWildcardComparison(string column, string value, TextColumnType columnType)
        {
            //use the &#39;upper&#39; method to always ensure strings are matched without case sensitivity no matter what the db setting.
            return string.Format(&quot;upper({0}) LIKE &#39;{1}&#39;&quot;, column, value.ToUpper());
        }

        public virtual string GetQuotedTableName(string tableName)
        {
            return string.Format(&quot;\&quot;{0}\&quot;&quot;, tableName);
        }

        public virtual string GetQuotedColumnName(string columnName)
        {
            return string.Format(&quot;\&quot;{0}\&quot;&quot;, columnName);
        }

        public virtual string GetQuotedName(string name)
        {
            return string.Format(&quot;\&quot;{0}\&quot;&quot;, name);
        }

        public virtual string GetQuotedValue(string value)
        {
            return string.Format(&quot;&#39;{0}&#39;&quot;, value);
        }

        public virtual string GetIndexType(IndexTypes indexTypes)
        {
            string indexType;

            if (indexTypes == IndexTypes.Clustered)
            {
                indexType = &quot;CLUSTERED&quot;;
            }
            else
            {
                indexType = indexTypes == IndexTypes.NonClustered
                    ? &quot;NONCLUSTERED&quot;
                    : &quot;UNIQUE NONCLUSTERED&quot;;
            }
            return indexType;
        }

        public virtual string GetSpecialDbType(SpecialDbTypes dbTypes)
        {
            if (dbTypes == SpecialDbTypes.NCHAR)
            {
                return &quot;NCHAR&quot;;
            }
            else if (dbTypes == SpecialDbTypes.NTEXT)
                return &quot;NTEXT&quot;;

            return &quot;NVARCHAR&quot;;
        }

        public virtual bool? SupportsCaseInsensitiveQueries(Database db)
        {
            return true;
        }

        public virtual IEnumerable&lt;string&gt; GetTablesInSchema(Database db)
        {
            return new List&lt;string&gt;();
        }

        public virtual IEnumerable&lt;ColumnInfo&gt; GetColumnsInSchema(Database db)
        {
            return new List&lt;ColumnInfo&gt;();
        }

        public virtual IEnumerable&lt;Tuple&lt;string, string&gt;&gt; GetConstraintsPerTable(Database db)
        {
            return new List&lt;Tuple&lt;string, string&gt;&gt;();
        }

        public virtual IEnumerable&lt;Tuple&lt;string, string, string&gt;&gt; GetConstraintsPerColumn(Database db)
        {
            return new List&lt;Tuple&lt;string, string, string&gt;&gt;();
        }

        public abstract IEnumerable&lt;Tuple&lt;string, string, string, bool&gt;&gt; GetDefinedIndexes(Database db);

        public virtual bool DoesTableExist(Database db, string tableName)
        {
            return false;
        }

        public virtual bool SupportsClustered()
        {
            return true;
        }

        public virtual bool SupportsIdentityInsert()
        {
            return true;
        }

        /// &lt;summary&gt;
        /// This is used ONLY if we need to format datetime without using SQL parameters (i.e. during migrations)
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;date&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;includeTime&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// MSSQL has a DateTime standard that is unambiguous and works on all servers:
        /// YYYYMMDD HH:mm:ss
        /// &lt;/remarks&gt;
        public virtual string FormatDateTime(DateTime date, bool includeTime = true)
        {
            // need CultureInfo.InvariantCulture because &quot;:&quot; here is the &quot;time separator&quot; and
            // may be converted to something else in different cultures (eg &quot;.&quot; in DK).
            return date.ToString(includeTime ? &quot;yyyyMMdd HH:mm:ss&quot; : &quot;yyyyMMdd&quot;, CultureInfo.InvariantCulture);
        }

        public virtual string Format(TableDefinition table)
        {
            var statement = string.Format(CreateTable, GetQuotedTableName(table.Name), Format(table.Columns));

            return statement;
        }

        public virtual List&lt;string&gt; Format(IEnumerable&lt;IndexDefinition&gt; indexes)
        {
            return indexes.Select(Format).ToList();
        }

        public virtual string Format(IndexDefinition index)
        {
            string name = string.IsNullOrEmpty(index.Name)
                                  ? string.Format(&quot;IX_{0}_{1}&quot;, index.TableName, index.ColumnName)
                                  : index.Name;

            string columns = index.Columns.Any()
                                 ? string.Join(&quot;,&quot;, index.Columns.Select(x =&gt; GetQuotedColumnName(x.Name)))
                                 : GetQuotedColumnName(index.ColumnName);

            return string.Format(CreateIndex, GetIndexType(index.IndexType), &quot; &quot;, GetQuotedName(name),
                                 GetQuotedTableName(index.TableName), columns);
        }

        public virtual List&lt;string&gt; Format(IEnumerable&lt;ForeignKeyDefinition&gt; foreignKeys)
        {
            return foreignKeys.Select(Format).ToList();
        }

        public virtual string Format(ForeignKeyDefinition foreignKey)
        {
            string constraintName = string.IsNullOrEmpty(foreignKey.Name)
                                        ? string.Format(&quot;FK_{0}_{1}_{2}&quot;, foreignKey.ForeignTable, foreignKey.PrimaryTable, foreignKey.PrimaryColumns.First())
                                        : foreignKey.Name;

            return string.Format(CreateForeignKeyConstraint,
                                 GetQuotedTableName(foreignKey.ForeignTable),
                                 GetQuotedName(constraintName),
                                 GetQuotedColumnName(foreignKey.ForeignColumns.First()),
                                 GetQuotedTableName(foreignKey.PrimaryTable),
                                 GetQuotedColumnName(foreignKey.PrimaryColumns.First()),
                                 FormatCascade(&quot;DELETE&quot;, foreignKey.OnDelete),
                                 FormatCascade(&quot;UPDATE&quot;, foreignKey.OnUpdate));
        }

        public virtual string Format(IEnumerable&lt;ColumnDefinition&gt; columns)
        {
            var sb = new StringBuilder();
            foreach (var column in columns)
            {
                sb.Append(Format(column) + &quot;,\n&quot;);
            }
            return sb.ToString().TrimEnd(&quot;,\n&quot;);
        }

        public virtual string Format(ColumnDefinition column)
        {
            var clauses = new List&lt;string&gt;();

            foreach (var action in ClauseOrder)
            {
                string clause = action(column);
                if (!string.IsNullOrEmpty(clause))
                    clauses.Add(clause);
            }

            return string.Join(&quot; &quot;, clauses.ToArray());
        }

        public virtual string FormatPrimaryKey(TableDefinition table)
        {
            var columnDefinition = table.Columns.FirstOrDefault(x =&gt; x.IsPrimaryKey);
            if (columnDefinition == null)
                return string.Empty;

            string constraintName = string.IsNullOrEmpty(columnDefinition.PrimaryKeyName)
                                        ? string.Format(&quot;PK_{0}&quot;, table.Name)
                                        : columnDefinition.PrimaryKeyName;

            string columns = string.IsNullOrEmpty(columnDefinition.PrimaryKeyColumns)
                                 ? GetQuotedColumnName(columnDefinition.Name)
                                 : string.Join(&quot;, &quot;, columnDefinition.PrimaryKeyColumns
                                                                     .Split(new[] { &#39;,&#39;, &#39; &#39; }, StringSplitOptions.RemoveEmptyEntries)
                                                                     .Select(GetQuotedColumnName));

            string primaryKeyPart = string.Concat(&quot;PRIMARY KEY&quot;, columnDefinition.IsIndexed ? &quot; CLUSTERED&quot; : &quot; NONCLUSTERED&quot;);

            return string.Format(CreateConstraint,
                                 GetQuotedTableName(table.Name),
                                 GetQuotedName(constraintName),
                                 primaryKeyPart,
                                 columns);
        }

        public virtual string FormatColumnRename(string tableName, string oldName, string newName)
        {
            return string.Format(RenameColumn,
                                 GetQuotedTableName(tableName),
                                 GetQuotedColumnName(oldName),
                                 GetQuotedColumnName(newName));
        }

        public virtual string FormatTableRename(string oldName, string newName)
        {
            return string.Format(RenameTable, GetQuotedTableName(oldName), GetQuotedTableName(newName));
        }

        protected virtual string FormatCascade(string onWhat, Rule rule)
        {
            string action = &quot;NO ACTION&quot;;
            switch (rule)
            {
                case Rule.None:
                    return &quot;&quot;;
                case Rule.Cascade:
                    action = &quot;CASCADE&quot;;
                    break;
                case Rule.SetNull:
                    action = &quot;SET NULL&quot;;
                    break;
                case Rule.SetDefault:
                    action = &quot;SET DEFAULT&quot;;
                    break;
            }

            return string.Format(&quot; ON {0} {1}&quot;, onWhat, action);
        }

        protected virtual string FormatString(ColumnDefinition column)
        {
            return GetQuotedColumnName(column.Name);
        }

        protected virtual string FormatType(ColumnDefinition column)
        {
            if (column.Type.HasValue == false &amp;&amp; string.IsNullOrEmpty(column.CustomType) == false)
                return column.CustomType;

            if (column.HasSpecialDbType)
            {
                if (column.Size != default(int))
                {
                    return string.Format(&quot;{0}({1})&quot;,
                                         GetSpecialDbType(column.DbType),
                                         column.Size);
                }

                return GetSpecialDbType(column.DbType);
            }

            Type type = column.Type.HasValue
                ? DbTypeMap.ColumnDbTypeMap.First(x =&gt; x.Value == column.Type.Value).Key
                : column.PropertyType;

            if (type == typeof(string))
            {
                var valueOrDefault = column.Size != default(int) ? column.Size : DefaultStringLength;
                return string.Format(StringLengthColumnDefinitionFormat, valueOrDefault);
            }

            if (type == typeof(decimal))
            {
                var precision = column.Size != default(int) ? column.Size : DefaultDecimalPrecision;
                var scale = column.Precision != default(int) ? column.Precision : DefaultDecimalScale;
                return string.Format(DecimalColumnDefinitionFormat, precision, scale);
            }

            string definition = DbTypeMap.ColumnTypeMap.First(x =&gt; x.Key == type).Value;
            string dbTypeDefinition = column.Size != default(int)
                                          ? string.Format(&quot;{0}({1})&quot;, definition, column.Size)
                                          : definition;
            //NOTE Percision is left out
            return dbTypeDefinition;
        }

        protected virtual string FormatNullable(ColumnDefinition column)
        {
            return column.IsNullable ? &quot;NULL&quot; : &quot;NOT NULL&quot;;
        }

        protected virtual string FormatConstraint(ColumnDefinition column)
        {
            if (string.IsNullOrEmpty(column.ConstraintName) &amp;&amp; column.DefaultValue == null)
                return string.Empty;

            return string.Format(&quot;CONSTRAINT {0}&quot;,
                                 string.IsNullOrEmpty(column.ConstraintName)
                                     ? GetQuotedName(string.Format(&quot;DF_{0}_{1}&quot;, column.TableName, column.Name))
                                     : column.ConstraintName);
        }

        protected virtual string FormatDefaultValue(ColumnDefinition column)
        {
            if (column.DefaultValue == null)
                return string.Empty;

            //hack - probably not needed with latest changes
            if (column.DefaultValue.ToString().ToLower().Equals(&quot;getdate()&quot;.ToLower()))
                column.DefaultValue = SystemMethods.CurrentDateTime;

            // see if this is for a system method
            if (column.DefaultValue is SystemMethods)
            {
                string method = FormatSystemMethods((SystemMethods)column.DefaultValue);
                if (string.IsNullOrEmpty(method))
                    return string.Empty;

                return string.Format(DefaultValueFormat, method);
            }

            return string.Format(DefaultValueFormat, GetQuotedValue(column.DefaultValue.ToString()));
        }

        protected virtual string FormatPrimaryKey(ColumnDefinition column)
        {
            return string.Empty;
        }

        protected abstract string FormatSystemMethods(SystemMethods systemMethod);

        protected abstract string FormatIdentity(ColumnDefinition column);

        public abstract Sql SelectTop(Sql sql, int top);

        public virtual string DeleteDefaultConstraint
        {
            get
            {
                throw new NotSupportedException(&quot;Default constraints are not supported&quot;);
            }
        }

        public virtual string CreateTable { get { return &quot;CREATE TABLE {0} ({1})&quot;; } }
        public virtual string DropTable { get { return &quot;DROP TABLE {0}&quot;; } }

        public virtual string AddColumn { get { return &quot;ALTER TABLE {0} ADD COLUMN {1}&quot;; } }
        public virtual string DropColumn { get { return &quot;ALTER TABLE {0} DROP COLUMN {1}&quot;; } }
        public virtual string AlterColumn { get { return &quot;ALTER TABLE {0} ALTER COLUMN {1}&quot;; } }
        public virtual string RenameColumn { get { return &quot;ALTER TABLE {0} RENAME COLUMN {1} TO {2}&quot;; } }

        public virtual string RenameTable { get { return &quot;RENAME TABLE {0} TO {1}&quot;; } }

        public virtual string CreateSchema { get { return &quot;CREATE SCHEMA {0}&quot;; } }
        public virtual string AlterSchema { get { return &quot;ALTER SCHEMA {0} TRANSFER {1}.{2}&quot;; } }
        public virtual string DropSchema { get { return &quot;DROP SCHEMA {0}&quot;; } }

        public virtual string CreateIndex { get { return &quot;CREATE {0}{1}INDEX {2} ON {3} ({4})&quot;; } }
        public virtual string DropIndex { get { return &quot;DROP INDEX {0}&quot;; } }

        public virtual string InsertData { get { return &quot;INSERT INTO {0} ({1}) VALUES ({2})&quot;; } }
        public virtual string UpdateData { get { return &quot;UPDATE {0} SET {1} WHERE {2}&quot;; } }
        public virtual string DeleteData { get { return &quot;DELETE FROM {0} WHERE {1}&quot;; } }
        public virtual string TruncateTable { get { return &quot;TRUNCATE TABLE {0}&quot;; } }

        public virtual string CreateConstraint { get { return &quot;ALTER TABLE {0} ADD CONSTRAINT {1} {2} ({3})&quot;; } }
        public virtual string DeleteConstraint { get { return &quot;ALTER TABLE {0} DROP CONSTRAINT {1}&quot;; } }
        public virtual string CreateForeignKeyConstraint { get { return &quot;ALTER TABLE {0} ADD CONSTRAINT {1} FOREIGN KEY ({2}) REFERENCES {3} ({4}){5}{6}&quot;; } }

        public virtual string ConvertIntegerToOrderableString { get { return &quot;REPLACE(STR({0}, 8), SPACE(1), &#39;0&#39;)&quot;; } }
        public virtual string ConvertDateToOrderableString { get { return &quot;CONVERT(nvarchar, {0}, 102)&quot;; } }
        public virtual string ConvertDecimalToOrderableString { get { return &quot;REPLACE(STR({0}, 20, 9), SPACE(1), &#39;0&#39;)&quot;; } }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[23,9,23,42,1],[24,9,24,10,1],[25,13,34,33,1],[37,13,37,92,1],[38,13,38,109,1],[39,13,39,130,1],[41,13,41,33,1],[42,9,42,10,1],[45,9,45,10,1],[46,13,46,24,1],[47,9,47,10,1],[49,9,49,85,1],[50,9,50,83,1],[51,9,51,74,1],[53,9,53,60,1],[54,9,54,46,1],[55,9,55,49,1],[56,9,56,44,1],[62,9,62,65,1],[63,9,63,55,1],[64,9,64,55,1],[65,9,65,53,1],[66,9,66,53,1],[67,9,67,55,1],[69,9,69,53,1],[70,9,70,61,1],[71,9,71,57,1],[73,71,73,75,1],[73,76,73,80,1],[75,9,75,71,1],[77,9,77,10,1],[78,13,78,74,1],[79,13,79,83,1],[80,13,80,84,1],[81,13,81,74,1],[82,13,82,71,1],[83,13,83,72,1],[84,13,84,68,1],[85,13,85,69,1],[86,13,86,80,1],[87,13,87,81,1],[88,13,88,72,1],[89,13,89,73,1],[90,13,90,78,1],[91,13,91,79,1],[93,13,93,67,1],[94,13,94,68,1],[95,13,95,69,1],[96,13,96,70,1],[97,13,97,69,1],[98,13,98,70,1],[99,13,99,71,1],[100,13,100,72,1],[101,13,101,67,1],[102,13,102,68,1],[103,13,103,69,1],[104,13,104,70,1],[106,13,106,69,1],[107,13,107,70,1],[108,13,108,71,1],[109,13,109,72,1],[111,13,111,71,1],[112,13,112,72,1],[113,13,113,72,1],[114,13,114,73,1],[116,13,116,77,1],[117,13,117,78,1],[119,13,119,72,1],[120,9,120,10,1],[123,9,123,10,0],[124,13,124,79,0],[125,9,125,10,0],[128,9,128,10,1],[130,13,130,82,1],[131,9,131,10,1],[134,9,134,10,1],[136,13,136,85,1],[137,9,137,10,1],[141,9,141,10,0],[143,13,143,81,0],[144,9,144,10,0],[148,9,148,10,0],[150,13,150,85,0],[151,9,151,10,0],[155,9,155,10,0],[157,13,157,85,0],[158,9,158,10,0],[162,9,162,10,0],[164,13,164,86,0],[165,9,165,10,0],[169,9,169,10,0],[171,13,171,84,0],[172,9,172,10,0],[175,9,175,10,0],[176,13,176,56,0],[177,9,177,10,0],[180,9,180,10,0],[181,13,181,57,0],[182,9,182,10,0],[185,9,185,10,0],[186,13,186,51,0],[187,9,187,10,0],[190,9,190,10,1],[191,13,191,50,1],[192,9,192,10,1],[195,9,195,10,1],[198,13,198,52,1],[199,13,199,14,1],[200,17,200,41,1],[201,13,201,14,1],[203,13,203,14,1],[204,17,206,45,1],[207,13,207,14,1],[208,13,208,30,1],[209,9,209,10,1],[212,9,212,10,1],[213,13,213,49,1],[214,13,214,14,1],[215,17,215,32,1],[217,18,217,54,1],[218,17,218,32,1],[220,13,220,31,0],[221,9,221,10,1],[224,9,224,10,0],[225,13,225,25,0],[226,9,226,10,0],[229,9,229,10,0],[230,13,230,39,0],[231,9,231,10,0],[234,9,234,10,0],[235,13,235,43,0],[236,9,236,10,0],[239,9,239,10,0],[240,13,240,54,0],[241,9,241,10,0],[244,9,244,10,0],[245,13,245,62,0],[246,9,246,10,0],[251,9,251,10,0],[252,13,252,26,0],[253,9,253,10,0],[256,9,256,10,0],[257,13,257,25,0],[258,9,258,10,0],[261,9,261,10,1],[262,13,262,25,1],[263,9,263,10,1],[276,9,276,10,0],[279,13,279,112,0],[280,9,280,10,0],[283,9,283,10,1],[284,13,284,111,1],[286,13,286,30,1],[287,9,287,10,1],[290,9,290,10,1],[291,13,291,52,1],[292,9,292,10,1],[295,9,295,10,1],[296,13,298,48,1],[300,13,301,79,1],[301,79,301,106,1],[301,106,302,74,1],[300,13,302,74,1],[304,13,305,80,1],[306,9,306,10,1],[309,9,309,10,1],[310,13,310,56,1],[311,9,311,10,1],[314,9,314,10,1],[315,13,317,59,1],[319,13,326,80,1],[327,9,327,10,1],[330,9,330,10,1],[331,13,331,42,1],[332,13,332,20,1],[332,22,332,32,1],[332,33,332,35,1],[332,36,332,43,1],[333,13,333,14,1],[334,17,334,51,1],[335,13,335,14,1],[336,13,336,49,1],[337,9,337,10,1],[340,9,340,10,1],[341,13,341,46,1],[343,13,343,20,1],[343,22,343,32,1],[343,33,343,35,1],[343,36,343,47,1],[344,13,344,14,1],[345,17,345,48,1],[346,17,346,51,1],[347,21,347,41,1],[348,13,348,14,1],[350,13,350,56,1],[351,9,351,10,1],[354,9,354,10,0],[355,13,355,70,0],[355,70,355,84,0],[355,84,355,86,0],[355,13,355,86,0],[356,13,356,42,0],[357,17,357,37,0],[359,13,361,75,0],[363,13,367,100,0],[369,13,369,127,0],[371,13,375,43,0],[376,9,376,10,0],[379,9,379,10,0],[380,13,383,64,0],[384,9,384,10,0],[387,9,387,10,0],[388,13,388,105,0],[389,9,389,10,0],[392,9,392,10,1],[393,13,393,41,1],[394,13,394,26,1],[397,21,397,31,1],[399,21,399,40,0],[400,21,400,27,0],[402,21,402,41,0],[403,21,403,27,0],[405,21,405,44,0],[406,21,406,27,0],[409,13,409,65,0],[410,9,410,10,1],[413,9,413,10,1],[414,13,414,53,1],[415,9,415,10,1],[418,9,418,10,1],[419,13,419,99,1],[420,17,420,42,0],[422,13,422,41,1],[423,13,423,14,1],[424,17,424,49,1],[425,17,425,18,1],[426,21,428,55,1],[431,17,431,56,1],[434,13,435,56,1],[435,56,435,84,1],[435,84,436,39,1],[434,13,436,39,1],[438,13,438,40,1],[439,13,439,14,1],[440,17,440,102,1],[441,17,441,90,1],[444,13,444,41,1],[445,13,445,14,0],[446,17,446,101,0],[447,17,447,103,0],[448,17,448,87,0],[451,13,451,68,1],[451,68,451,81,1],[451,81,451,89,1],[451,13,451,89,1],[452,13,454,56,1],[456,13,456,37,1],[457,9,457,10,1],[460,9,460,10,1],[461,13,461,60,1],[462,9,462,10,1],[465,9,465,10,1],[466,13,466,92,1],[467,17,467,37,1],[469,13,472,63,1],[473,9,473,10,1],[476,9,476,10,1],[477,13,477,45,1],[478,17,478,37,1],[481,13,481,88,1],[482,17,482,69,0],[485,13,485,54,1],[486,13,486,14,1],[487,17,487,89,1],[488,17,488,50,1],[489,21,489,41,0],[491,17,491,66,1],[494,13,494,102,1],[495,9,495,10,1],[498,9,498,10,1],[499,13,499,33,1],[500,9,500,10,1],[511,13,511,14,0],[512,17,512,90,0],[516,49,516,50,1],[516,51,516,83,1],[516,84,516,85,1],[517,47,517,48,1],[517,49,517,73,1],[517,74,517,75,1],[519,47,519,48,1],[519,49,519,89,1],[519,90,519,91,1],[520,48,520,49,1],[520,50,520,91,1],[520,92,520,93,1],[521,49,521,50,0],[521,51,521,93,0],[521,94,521,95,0],[522,50,522,51,0],[522,52,522,102,0],[522,103,522,104,0],[524,49,524,50,0],[524,51,524,84,0],[524,85,524,86,0],[526,50,526,51,0],[526,52,526,79,0],[526,80,526,81,0],[527,49,527,50,0],[527,51,527,94,0],[527,95,527,96,0],[528,48,528,49,0],[528,50,528,75,0],[528,76,528,77,0],[530,49,530,50,1],[530,51,530,96,1],[530,97,530,98,1],[531,47,531,48,0],[531,49,531,73,0],[531,74,531,75,0],[533,48,533,49,0],[533,50,533,94,0],[533,95,533,96,0],[534,48,534,49,0],[534,50,534,88,0],[534,89,534,90,0],[535,48,535,49,0],[535,50,535,85,0],[535,86,535,87,0],[536,51,536,52,0],[536,53,536,81,0],[536,82,536,83,0],[538,54,538,55,1],[538,56,538,110,1],[538,111,538,112,1],[539,54,539,55,1],[539,56,539,101,1],[539,102,539,103,1],[540,64,540,65,1],[540,66,540,155,1],[540,156,540,157,1],[542,69,542,70,1],[542,71,542,116,1],[542,117,542,118,1],[543,66,543,67,1],[543,68,543,105,1],[543,106,543,107,1],[544,69,544,70,1],[544,71,544,120,1],[544,121,544,122,1]]);
    </script>
  </body>
</html>