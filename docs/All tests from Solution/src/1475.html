<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\ObjectResolution\ResolverBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Threading;

namespace Umbraco.Core.ObjectResolution
{
    /// &lt;summary&gt;
    /// Base non-generic class for resolvers
    /// &lt;/summary&gt;
    public abstract class ResolverBase
    {
        protected ResolverBase(Action resetAction)
        {
            //add itself to the internal collection
            ResolverCollection.Add(this, resetAction);
        }

    }

	/// &lt;summary&gt;
	/// The base class for all resolvers.
	/// &lt;/summary&gt;
	/// &lt;typeparam name=&quot;TResolver&quot;&gt;The type of the concrete resolver class.&lt;/typeparam&gt;
	/// &lt;remarks&gt;Provides singleton management to all resolvers.&lt;/remarks&gt;
    public abstract class ResolverBase&lt;TResolver&gt; : ResolverBase
        where TResolver : ResolverBase
	{

        /// &lt;summary&gt;
        /// The underlying singleton object instance
        /// &lt;/summary&gt;
        static TResolver _resolver;

        /// &lt;summary&gt;
        /// The lock for the singleton.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// Though resharper says this is in error, it is actually correct. We want a different lock object for each generic type.
        /// See this for details: http://confluence.jetbrains.net/display/ReSharper/Static+field+in+generic+type
        /// &lt;/remarks&gt;
        static readonly ReaderWriterLockSlim ResolversLock = new ReaderWriterLockSlim();

        /// &lt;summary&gt;
        /// Constructor set the reset action for the underlying object
        /// &lt;/summary&gt;
	    protected ResolverBase()
	        : base(() =&gt; Reset())
	    {

	    }

	    /// &lt;summary&gt;
		/// Gets or sets the resolver singleton instance.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;The value can be set only once, and cannot be read before it has been set.&lt;/remarks&gt;
		/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;value is read before it has been set, or value is set again once it has already been set.&lt;/exception&gt;
		/// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;value is &lt;c&gt;null&lt;/c&gt;.&lt;/exception&gt;
		public static TResolver Current
		{
			get
			{
				using (new ReadLock(ResolversLock))
				{
					if (_resolver == null)
						throw new InvalidOperationException(string.Format(
							&quot;Current has not been initialized on {0}. You must initialize Current before trying to read it.&quot;,
							typeof(TResolver).FullName));
					return _resolver;
				}
			}

			set
			{
                using (Resolution.Configuration)
				using (new WriteLock(ResolversLock))
				{
					if (value == null)
						throw new ArgumentNullException(&quot;value&quot;);
					if (_resolver != null)
						throw new InvalidOperationException(string.Format(
							&quot;Current has already been initialized on {0}. It is not possible to re-initialize Current once it has been initialized.&quot;,
							typeof(TResolver).FullName));
					_resolver = value;
				}
			}
		}

        /// &lt;summary&gt;
        /// Gets a value indicating whether a the singleton instance has been set.
        /// &lt;/summary&gt;
        public static bool HasCurrent
        {
            get
            {
                using (new ReadLock(ResolversLock))
                {
                    return _resolver != null;
                }
            }
        }

		/// &lt;summary&gt;
		/// Resets the resolver singleton instance to null.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// To be used in unit tests. DO NOT USE THIS DURING PRODUCTION.
		/// &lt;/remarks&gt;
		/// &lt;param name=&quot;resetResolution&quot;&gt;
		/// By default this is true because we always need to reset resolution before we reset a resolver, however in some insanely rare cases like unit testing you might not want to do this.
		/// &lt;/param&gt;
		protected internal static void Reset(bool resetResolution = true)
		{

            //In order to reset a resolver, we always must reset the resolution
            if (resetResolution)
            {                
                Resolution.Reset();
            }

            //ensure its removed from the collection
            ResolverCollection.Remove(_resolver);

            using (Resolution.Configuration)
			using (new WriteLock(ResolversLock))
			{
				_resolver = null;
			}
            
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[11,9,11,51,1],[12,9,12,10,1],[14,13,14,55,1],[15,9,15,10,1],[40,9,40,89,1],[46,12,46,23,1],[46,23,46,30,1],[46,30,46,31,1],[46,12,46,31,1],[47,6,47,7,1],[49,6,49,7,1],[60,4,60,5,1],[61,5,61,40,1],[62,5,62,6,1],[63,6,63,28,1],[64,7,66,37,1],[67,6,67,23,1],[69,4,69,5,1],[72,4,72,5,1],[73,17,73,49,1],[74,5,74,41,1],[75,5,75,6,1],[76,6,76,24,1],[77,7,77,48,1],[78,6,78,28,1],[79,7,81,37,1],[82,6,82,24,1],[83,5,83,6,1],[84,4,84,5,1],[93,13,93,14,1],[94,17,94,52,1],[95,17,95,18,1],[96,21,96,46,1],[98,13,98,14,1],[111,3,111,4,1],[114,13,114,33,1],[115,13,115,14,1],[116,17,116,36,1],[117,13,117,14,1],[120,13,120,50,1],[122,13,122,45,1],[123,4,123,40,1],[124,4,124,5,1],[125,5,125,22,1],[126,4,126,5,1],[128,3,128,4,1]]);
    </script>
  </body>
</html>