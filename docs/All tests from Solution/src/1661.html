<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Persistence\FaultHandling\RetryPolicy.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Threading;
using Umbraco.Core.Logging;
using Umbraco.Core.Persistence.FaultHandling.Strategies;

namespace Umbraco.Core.Persistence.FaultHandling
{
    /// &lt;summary&gt;
    /// Provides the base implementation of the retry mechanism for unreliable actions and transient conditions.
    /// &lt;/summary&gt;
    public class RetryPolicy
    {
        /// &lt;summary&gt;
        /// Returns a default policy that does no retries, it just invokes action exactly once.
        /// &lt;/summary&gt;
        public static readonly RetryPolicy NoRetry = new RetryPolicy(new TransientErrorIgnoreStrategy(), 0);

        /// &lt;summary&gt;
        /// Returns a default policy that implements a fixed retry interval configured with the default &lt;see cref=&quot;FixedInterval&quot;/&gt; retry strategy.
        /// The default retry policy treats all caught exceptions as transient errors.
        /// &lt;/summary&gt;
        public static readonly RetryPolicy DefaultFixed = new RetryPolicy(new TransientErrorCatchAllStrategy(), new FixedInterval());

        /// &lt;summary&gt;
        /// Returns a default policy that implements a progressive retry interval configured with the default &lt;see cref=&quot;Incremental&quot;/&gt; retry strategy.
        /// The default retry policy treats all caught exceptions as transient errors.
        /// &lt;/summary&gt;
        public static readonly RetryPolicy DefaultProgressive = new RetryPolicy(new TransientErrorCatchAllStrategy(), new Incremental());

        /// &lt;summary&gt;
        /// Returns a default policy that implements a random exponential retry interval configured with the default &lt;see cref=&quot;FixedInterval&quot;/&gt; retry strategy.
        /// The default retry policy treats all caught exceptions as transient errors.
        /// &lt;/summary&gt;
        public static readonly RetryPolicy DefaultExponential = new RetryPolicy(new TransientErrorCatchAllStrategy(), new ExponentialBackoff());

        /// &lt;summary&gt;
        /// Initializes a new instance of the RetryPolicy class with the specified number of retry attempts and parameters defining the progressive delay between retries.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;errorDetectionStrategy&quot;&gt;The &lt;see cref=&quot;ITransientErrorDetectionStrategy&quot;/&gt; that is responsible for detecting transient conditions.&lt;/param&gt;
        /// &lt;param name=&quot;retryStrategy&quot;&gt;The retry strategy to use for this retry policy.&lt;/param&gt;
        public RetryPolicy(ITransientErrorDetectionStrategy errorDetectionStrategy, RetryStrategy retryStrategy)
        {
            //Guard.ArgumentNotNull(errorDetectionStrategy, &quot;errorDetectionStrategy&quot;);
            //Guard.ArgumentNotNull(retryStrategy, &quot;retryPolicy&quot;);

            this.ErrorDetectionStrategy = errorDetectionStrategy;

            if (errorDetectionStrategy == null)
            {
                throw new InvalidOperationException(&quot;The error detection strategy type must implement the ITransientErrorDetectionStrategy interface.&quot;);
            }

            this.RetryStrategy = retryStrategy;
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the RetryPolicy class with the specified number of retry attempts and default fixed time interval between retries.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;errorDetectionStrategy&quot;&gt;The &lt;see cref=&quot;ITransientErrorDetectionStrategy&quot;/&gt; that is responsible for detecting transient conditions.&lt;/param&gt;
        /// &lt;param name=&quot;retryCount&quot;&gt;The number of retry attempts.&lt;/param&gt;
        public RetryPolicy(ITransientErrorDetectionStrategy errorDetectionStrategy, int retryCount)
            : this(errorDetectionStrategy, new FixedInterval(retryCount))
        {
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the RetryPolicy class with the specified number of retry attempts and fixed time interval between retries.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;errorDetectionStrategy&quot;&gt;The &lt;see cref=&quot;ITransientErrorDetectionStrategy&quot;/&gt; that is responsible for detecting transient conditions.&lt;/param&gt;
        /// &lt;param name=&quot;retryCount&quot;&gt;The number of retry attempts.&lt;/param&gt;
        /// &lt;param name=&quot;retryInterval&quot;&gt;The interval between retries.&lt;/param&gt;
        public RetryPolicy(ITransientErrorDetectionStrategy errorDetectionStrategy, int retryCount, TimeSpan retryInterval)
            : this(errorDetectionStrategy, new FixedInterval(retryCount, retryInterval))
        {
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the RetryPolicy class with the specified number of retry attempts and back-off parameters for calculating the exponential delay between retries.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;errorDetectionStrategy&quot;&gt;The &lt;see cref=&quot;ITransientErrorDetectionStrategy&quot;/&gt; that is responsible for detecting transient conditions.&lt;/param&gt;
        /// &lt;param name=&quot;retryCount&quot;&gt;The number of retry attempts.&lt;/param&gt;
        /// &lt;param name=&quot;minBackoff&quot;&gt;The minimum back-off time.&lt;/param&gt;
        /// &lt;param name=&quot;maxBackoff&quot;&gt;The maximum back-off time.&lt;/param&gt;
        /// &lt;param name=&quot;deltaBackoff&quot;&gt;The time value that will be used for calculating a random delta in the exponential delay between retries.&lt;/param&gt;
        public RetryPolicy(ITransientErrorDetectionStrategy errorDetectionStrategy, int retryCount, TimeSpan minBackoff, TimeSpan maxBackoff, TimeSpan deltaBackoff)
            : this(errorDetectionStrategy, new ExponentialBackoff(retryCount, minBackoff, maxBackoff, deltaBackoff))
        {
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the RetryPolicy class with the specified number of retry attempts and parameters defining the progressive delay between retries.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;errorDetectionStrategy&quot;&gt;The &lt;see cref=&quot;ITransientErrorDetectionStrategy&quot;/&gt; that is responsible for detecting transient conditions.&lt;/param&gt;
        /// &lt;param name=&quot;retryCount&quot;&gt;The number of retry attempts.&lt;/param&gt;
        /// &lt;param name=&quot;initialInterval&quot;&gt;The initial interval that will apply for the first retry.&lt;/param&gt;
        /// &lt;param name=&quot;increment&quot;&gt;The incremental time value that will be used for calculating the progressive delay between retries.&lt;/param&gt;
        public RetryPolicy(ITransientErrorDetectionStrategy errorDetectionStrategy, int retryCount, TimeSpan initialInterval, TimeSpan increment)
            : this(errorDetectionStrategy, new Incremental(retryCount, initialInterval, increment))
        {
        }

        /// &lt;summary&gt;
        /// An instance of a callback delegate that will be invoked whenever a retry condition is encountered.
        /// &lt;/summary&gt;
        public event EventHandler&lt;RetryingEventArgs&gt; Retrying;

        /// &lt;summary&gt;
        /// Gets the retry strategy.
        /// &lt;/summary&gt;
        public RetryStrategy RetryStrategy { get; private set; }

        /// &lt;summary&gt;
        /// Gets the instance of the error detection strategy.
        /// &lt;/summary&gt;
        public ITransientErrorDetectionStrategy ErrorDetectionStrategy { get; private set; }

        /// &lt;summary&gt;
        /// Repetitively executes the specified action while it satisfies the current retry policy.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;action&quot;&gt;A delegate representing the executable action which doesn&#39;t return any results.&lt;/param&gt;
        public virtual void ExecuteAction(Action action)
        {
            //Guard.ArgumentNotNull(action, &quot;action&quot;);

            this.ExecuteAction(() =&gt; { action(); return default(object); });
        }

        /// &lt;summary&gt;
        /// Repetitively executes the specified action while it satisfies the current retry policy.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TResult&quot;&gt;The type of result expected from the executable action.&lt;/typeparam&gt;
        /// &lt;param name=&quot;func&quot;&gt;A delegate representing the executable action which returns the result of type R.&lt;/param&gt;
        /// &lt;returns&gt;The result from the action.&lt;/returns&gt;
        public virtual TResult ExecuteAction&lt;TResult&gt;(Func&lt;TResult&gt; func)
        {
            //Guard.ArgumentNotNull(func, &quot;func&quot;);

            int retryCount = 0;
            TimeSpan delay = TimeSpan.Zero;
            Exception lastError;

            var shouldRetry = this.RetryStrategy.GetShouldRetry();

            for (; ; )
            {
                lastError = null;

                try
                {
                    return func();
                }
                catch (RetryLimitExceededException limitExceededEx)
                {
                    // The user code can throw a RetryLimitExceededException to force the exit from the retry loop.
                    // The RetryLimitExceeded exception can have an inner exception attached to it. This is the exception
                    // which we will have to throw up the stack so that callers can handle it.
                    if (limitExceededEx.InnerException != null)
                    {
                        throw limitExceededEx.InnerException;
                    }
                    else
                    {
                        return default(TResult);
                    }
                }
                catch (Exception ex)
                {
                    lastError = ex;

                    if (!(this.ErrorDetectionStrategy.IsTransient(lastError) &amp;&amp; shouldRetry(retryCount++, lastError, out delay)))
                    {
                        throw;
                    }
                }

                // Perform an extra check in the delay interval. Should prevent from accidentally ending up with the value of -1 that will block a thread indefinitely. 
                // In addition, any other negative numbers will cause an ArgumentOutOfRangeException fault that will be thrown by Thread.Sleep.
                if (delay.TotalMilliseconds &lt; 0)
                {
                    delay = TimeSpan.Zero;
                }

                this.OnRetrying(retryCount, lastError, delay);

                if (retryCount &gt; 1 || !this.RetryStrategy.FastFirstRetry)
                {
                    Thread.Sleep(delay);
                }
            }
        }

        /// &lt;summary&gt;
        /// Notifies the subscribers whenever a retry condition is encountered.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;retryCount&quot;&gt;The current retry attempt count.&lt;/param&gt;
        /// &lt;param name=&quot;lastError&quot;&gt;The exception which caused the retry conditions to occur.&lt;/param&gt;
        /// &lt;param name=&quot;delay&quot;&gt;The delay indicating how long the current thread will be suspended for before the next iteration will be invoked.&lt;/param&gt;
        protected virtual void OnRetrying(int retryCount, Exception lastError, TimeSpan delay)
        {
            if (this.Retrying != null)
            {               
                this.Retrying(this, new RetryingEventArgs(retryCount, delay, lastError));
            }
        }

        #region Private classes
        /// &lt;summary&gt;
        /// Implements a strategy that ignores any transient errors.
        /// &lt;/summary&gt;
        private sealed class TransientErrorIgnoreStrategy : ITransientErrorDetectionStrategy
        {
            /// &lt;summary&gt;
            /// Always return false.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;ex&quot;&gt;The exception.&lt;/param&gt;
            /// &lt;returns&gt;Returns false.&lt;/returns&gt;
            public bool IsTransient(Exception ex)
            {
                return false;
            }
        }

        /// &lt;summary&gt;
        /// Implements a strategy that treats all exceptions as transient errors.
        /// &lt;/summary&gt;
        private sealed class TransientErrorCatchAllStrategy : ITransientErrorDetectionStrategy
        {
            /// &lt;summary&gt;
            /// Always return true.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;ex&quot;&gt;The exception.&lt;/param&gt;
            /// &lt;returns&gt;Returns true.&lt;/returns&gt;
            public bool IsTransient(Exception ex)
            {
                return true;
            }
        }
        #endregion
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[16,9,16,109,1],[22,9,22,134,1],[28,9,28,138,1],[34,9,34,145,1],[41,9,41,113,1],[42,9,42,10,1],[46,13,46,66,1],[48,13,48,48,1],[49,13,49,14,0],[50,17,50,153,0],[53,13,53,48,1],[54,9,54,10,1],[62,15,62,74,1],[63,9,63,10,1],[64,9,64,10,1],[73,15,73,89,0],[74,9,74,10,0],[75,9,75,10,0],[86,15,86,117,0],[87,9,87,10,0],[88,9,88,10,0],[98,15,98,100,0],[99,9,99,10,0],[100,9,100,10,0],[110,46,110,50,1],[110,51,110,63,1],[115,74,115,78,1],[115,79,115,91,1],[122,9,122,10,1],[125,13,125,38,1],[125,38,125,39,1],[125,39,125,40,1],[125,40,125,49,1],[125,49,125,50,1],[125,50,125,73,1],[125,73,125,74,1],[125,74,125,75,1],[125,75,125,77,1],[125,13,125,77,1],[126,9,126,10,1],[135,9,135,10,1],[138,13,138,32,1],[139,13,139,44,1],[142,13,142,67,1],[145,13,145,14,1],[146,17,146,34,1],[149,17,149,18,1],[150,21,150,35,1],[152,17,152,68,0],[153,17,153,18,0],[157,21,157,64,0],[158,21,158,22,0],[159,25,159,62,0],[162,21,162,22,0],[163,25,163,49,0],[166,17,166,37,1],[167,17,167,18,1],[168,21,168,36,1],[170,21,170,130,1],[171,21,171,22,1],[172,25,172,31,1],[174,17,174,18,0],[178,17,178,49,0],[179,17,179,18,0],[180,21,180,43,0],[181,17,181,18,0],[183,17,183,63,0],[185,17,185,74,0],[186,17,186,18,0],[187,21,187,41,0],[188,17,188,18,0],[189,13,189,14,0],[190,9,190,10,1],[199,9,199,10,0],[200,13,200,39,0],[201,13,201,14,0],[202,17,202,90,0],[203,13,203,14,0],[204,9,204,10,0],[218,13,218,14,0],[219,17,219,30,0],[220,13,220,14,0],[234,13,234,14,0],[235,17,235,29,0],[236,13,236,14,0]]);
    </script>
  </body>
</html>