<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Services\EntityXmlSerializer.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Web;
using System.Xml;
using System.Xml.Linq;
using Umbraco.Core.Configuration;
using Umbraco.Core.Models;
using Umbraco.Core.Persistence.Repositories;
using Umbraco.Core.PropertyEditors;
using Umbraco.Core.Strings;
using umbraco.interfaces;

namespace Umbraco.Core.Services
{
    //TODO: Move the rest of the logic for the PackageService.Export methods to here!

    /// &lt;summary&gt;
    /// A helper class to serialize entities to XML
    /// &lt;/summary&gt;
    internal class EntityXmlSerializer
    {
        /// &lt;summary&gt;
        /// Exports an &lt;see cref=&quot;IContent&quot;/&gt; item to xml as an &lt;see cref=&quot;XElement&quot;/&gt;
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;contentService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;userService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;content&quot;&gt;Content to export&lt;/param&gt;
        /// &lt;param name=&quot;deep&quot;&gt;Optional parameter indicating whether to include descendents&lt;/param&gt;
        /// &lt;returns&gt;&lt;see cref=&quot;XElement&quot;/&gt; containing the xml representation of the Content object&lt;/returns&gt;
        public XElement Serialize(IContentService contentService, IDataTypeService dataTypeService, IUserService userService, IContent content, bool deep = false)
        {
            //nodeName should match Casing.SafeAliasWithForcingCheck(content.ContentType.Alias);
            var nodeName = UmbracoConfig.For.UmbracoSettings().Content.UseLegacyXmlSchema ? &quot;node&quot; : content.ContentType.Alias.ToSafeAliasWithForcingCheck();

            var xml = Serialize(dataTypeService, content, nodeName);
            xml.Add(new XAttribute(&quot;nodeType&quot;, content.ContentType.Id));
            xml.Add(new XAttribute(&quot;creatorName&quot;, content.GetCreatorProfile(userService).Name));
            xml.Add(new XAttribute(&quot;writerName&quot;, content.GetWriterProfile(userService).Name));
            xml.Add(new XAttribute(&quot;writerID&quot;, content.WriterId));
            xml.Add(new XAttribute(&quot;template&quot;, content.Template == null ? &quot;0&quot; : content.Template.Id.ToString(CultureInfo.InvariantCulture)));
            xml.Add(new XAttribute(&quot;nodeTypeAlias&quot;, content.ContentType.Alias));

            if (deep)
            {
                var descendants = contentService.GetDescendants(content).ToArray();
                var currentChildren = descendants.Where(x =&gt; x.ParentId == content.Id);
                AddChildXml(contentService, dataTypeService, userService, descendants, currentChildren, xml);
            }

            return xml;
        }

        /// &lt;summary&gt;
        /// Exports an &lt;see cref=&quot;IMedia&quot;/&gt; item to xml as an &lt;see cref=&quot;XElement&quot;/&gt;
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;mediaService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;userService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;media&quot;&gt;Media to export&lt;/param&gt;
        /// &lt;param name=&quot;deep&quot;&gt;Optional parameter indicating whether to include descendents&lt;/param&gt;
        /// &lt;returns&gt;&lt;see cref=&quot;XElement&quot;/&gt; containing the xml representation of the Media object&lt;/returns&gt;
        public XElement Serialize(IMediaService mediaService, IDataTypeService dataTypeService, IUserService userService, IMedia media, bool deep = false)
        {
            //nodeName should match Casing.SafeAliasWithForcingCheck(content.ContentType.Alias);
            var nodeName = UmbracoConfig.For.UmbracoSettings().Content.UseLegacyXmlSchema ? &quot;node&quot; : media.ContentType.Alias.ToSafeAliasWithForcingCheck();

            var xml = Serialize(dataTypeService, media, nodeName);
            xml.Add(new XAttribute(&quot;nodeType&quot;, media.ContentType.Id));
            xml.Add(new XAttribute(&quot;writerName&quot;, media.GetCreatorProfile(userService).Name));
            xml.Add(new XAttribute(&quot;writerID&quot;, media.CreatorId));
            xml.Add(new XAttribute(&quot;version&quot;, media.Version));
            xml.Add(new XAttribute(&quot;template&quot;, 0));
            xml.Add(new XAttribute(&quot;nodeTypeAlias&quot;, media.ContentType.Alias));

            if (deep)
            {
                var descendants = mediaService.GetDescendants(media).ToArray();
                var currentChildren = descendants.Where(x =&gt; x.ParentId == media.Id);
                AddChildXml(mediaService, dataTypeService, userService, descendants, currentChildren, xml);
            }

            return xml;
        }

        /// &lt;summary&gt;
        /// Exports an &lt;see cref=&quot;IMember&quot;/&gt; item to xml as an &lt;see cref=&quot;XElement&quot;/&gt;
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;dataTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;member&quot;&gt;Member to export&lt;/param&gt;
        /// &lt;returns&gt;&lt;see cref=&quot;XElement&quot;/&gt; containing the xml representation of the Member object&lt;/returns&gt;
        public XElement Serialize(IDataTypeService dataTypeService, IMember member)
        {
            //nodeName should match Casing.SafeAliasWithForcingCheck(content.ContentType.Alias);
            var nodeName = UmbracoConfig.For.UmbracoSettings().Content.UseLegacyXmlSchema ? &quot;node&quot; : member.ContentType.Alias.ToSafeAliasWithForcingCheck();

            var xml = Serialize(dataTypeService, member, nodeName);
            xml.Add(new XAttribute(&quot;nodeType&quot;, member.ContentType.Id));
            xml.Add(new XAttribute(&quot;nodeTypeAlias&quot;, member.ContentType.Alias));

            xml.Add(new XAttribute(&quot;loginName&quot;, member.Username));
            xml.Add(new XAttribute(&quot;email&quot;, member.Email));
            
            xml.Add(new XAttribute(&quot;icon&quot;, member.ContentType.Icon));

            return xml;
        }

        public XElement Serialize(IDataTypeService dataTypeService, Property property)
        {
            var propertyType = property.PropertyType;
            var nodeName = UmbracoConfig.For.UmbracoSettings().Content.UseLegacyXmlSchema ? &quot;data&quot; : property.Alias.ToSafeAlias();

            var xElement = new XElement(nodeName);

            //Add the property alias to the legacy schema
            if (UmbracoConfig.For.UmbracoSettings().Content.UseLegacyXmlSchema)
            {
                var a = new XAttribute(&quot;alias&quot;, property.Alias.ToSafeAlias());
                xElement.Add(a);
            }

            //Get the property editor for thsi property and let it convert it to the xml structure
            var propertyEditor = PropertyEditorResolver.Current.GetByAlias(property.PropertyType.PropertyEditorAlias);
            if (propertyEditor != null)
            {
                var xmlValue = propertyEditor.ValueEditor.ConvertDbToXml(property, propertyType, dataTypeService);
                xElement.Add(xmlValue);
            }

            return xElement;
        }

        /// &lt;summary&gt;
        /// Exports an &lt;see cref=&quot;IDataTypeDefinition&quot;/&gt; item to xml as an &lt;see cref=&quot;XElement&quot;/&gt;
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;dataTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataTypeDefinition&quot;&gt;IDataTypeDefinition type to export&lt;/param&gt;
        /// &lt;returns&gt;&lt;see cref=&quot;XElement&quot;/&gt; containing the xml representation of the IDataTypeDefinition object&lt;/returns&gt;
        public XElement Serialize(IDataTypeService dataTypeService, IDataTypeDefinition dataTypeDefinition)
        {
            var prevalues = new XElement(&quot;PreValues&quot;);
            var prevalueList = dataTypeService.GetPreValuesCollectionByDataTypeId(dataTypeDefinition.Id)
                .FormatAsDictionary();

            var sort = 0;
            foreach (var pv in prevalueList)
            {
                var prevalue = new XElement(&quot;PreValue&quot;);
                prevalue.Add(new XAttribute(&quot;Id&quot;, pv.Value.Id));
                prevalue.Add(new XAttribute(&quot;Value&quot;, pv.Value.Value ?? &quot;&quot;));
                prevalue.Add(new XAttribute(&quot;Alias&quot;, pv.Key));
                prevalue.Add(new XAttribute(&quot;SortOrder&quot;, sort));
                prevalues.Add(prevalue);
                sort++;
            }

            var xml = new XElement(&quot;DataType&quot;, prevalues);
            xml.Add(new XAttribute(&quot;Name&quot;, dataTypeDefinition.Name));
            //The &#39;ID&#39; when exporting is actually the property editor alias (in pre v7 it was the IDataType GUID id)
            xml.Add(new XAttribute(&quot;Id&quot;, dataTypeDefinition.PropertyEditorAlias));
            xml.Add(new XAttribute(&quot;Definition&quot;, dataTypeDefinition.Key));
            xml.Add(new XAttribute(&quot;DatabaseType&quot;, dataTypeDefinition.DatabaseType.ToString()));

            var folderNames = string.Empty;
            if (dataTypeDefinition.Level != 1)
            {
                //get url encoded folder names
                var folders = dataTypeService.GetContainers(dataTypeDefinition)
                    .OrderBy(x =&gt; x.Level)
                    .Select(x =&gt; HttpUtility.UrlEncode(x.Name));

                folderNames = string.Join(&quot;/&quot;, folders.ToArray());
            }

            if (string.IsNullOrWhiteSpace(folderNames) == false)
                xml.Add(new XAttribute(&quot;Folders&quot;, folderNames));            

            return xml;
        }

        public XElement Serialize(IDictionaryItem dictionaryItem)
        {
            var xml = new XElement(&quot;DictionaryItem&quot;, new XAttribute(&quot;Key&quot;, dictionaryItem.ItemKey));
            foreach (var translation in dictionaryItem.Translations)
            {
                xml.Add(new XElement(&quot;Value&quot;,
                    new XAttribute(&quot;LanguageId&quot;, translation.Language.Id),
                    new XAttribute(&quot;LanguageCultureAlias&quot;, translation.Language.IsoCode),
                    new XCData(translation.Value)));
            }

            return xml;
        }

        public XElement Serialize(Stylesheet stylesheet)
        {
            var xml = new XElement(&quot;Stylesheet&quot;,
                new XElement(&quot;Name&quot;, stylesheet.Alias),
                new XElement(&quot;FileName&quot;, stylesheet.Path),
                new XElement(&quot;Content&quot;, new XCData(stylesheet.Content)));

            var props = new XElement(&quot;Properties&quot;);
            xml.Add(props);

            foreach (var prop in stylesheet.Properties)
            {
                props.Add(new XElement(&quot;Property&quot;,
                    new XElement(&quot;Name&quot;, prop.Name),
                    new XElement(&quot;Alias&quot;, prop.Alias),
                    new XElement(&quot;Value&quot;, prop.Value)));
            }

            return xml;
        }

        public XElement Serialize(ILanguage language)
        {
            var xml = new XElement(&quot;Language&quot;,
                new XAttribute(&quot;Id&quot;, language.Id),
                new XAttribute(&quot;CultureAlias&quot;, language.IsoCode),
                new XAttribute(&quot;FriendlyName&quot;, language.CultureName));

            return xml;
        }

        public XElement Serialize(ITemplate template)
        {
            var xml = new XElement(&quot;Template&quot;);
            xml.Add(new XElement(&quot;Name&quot;, template.Name));
            xml.Add(new XElement(&quot;Alias&quot;, template.Alias));
            xml.Add(new XElement(&quot;Design&quot;, new XCData(template.Content)));

            var concreteTemplate = template as Template;
            if (concreteTemplate != null &amp;&amp; concreteTemplate.MasterTemplateId != null)
            {
                if (concreteTemplate.MasterTemplateId.IsValueCreated &amp;&amp;
                    concreteTemplate.MasterTemplateId.Value != default(int))
                {
                    xml.Add(new XElement(&quot;Master&quot;, concreteTemplate.MasterTemplateId.ToString()));
                    xml.Add(new XElement(&quot;MasterAlias&quot;, concreteTemplate.MasterTemplateAlias));
                }
            }

            return xml;
        }

        public XElement Serialize(IDataTypeService dataTypeService, IMediaType mediaType)
        {
            var info = new XElement(&quot;Info&quot;,
                                    new XElement(&quot;Name&quot;, mediaType.Name),
                                    new XElement(&quot;Alias&quot;, mediaType.Alias),
                                    new XElement(&quot;Icon&quot;, mediaType.Icon),
                                    new XElement(&quot;Thumbnail&quot;, mediaType.Thumbnail),
                                    new XElement(&quot;Description&quot;, mediaType.Description),
                                    new XElement(&quot;AllowAtRoot&quot;, mediaType.AllowedAsRoot.ToString()));

            var masterContentType = mediaType.CompositionAliases().FirstOrDefault();
            if (masterContentType != null)
                info.Add(new XElement(&quot;Master&quot;, masterContentType));

            var structure = new XElement(&quot;Structure&quot;);
            foreach (var allowedType in mediaType.AllowedContentTypes)
            {
                structure.Add(new XElement(&quot;MediaType&quot;, allowedType.Alias));
            }

            var genericProperties = new XElement(&quot;GenericProperties&quot;); // actually, all of them
            foreach (var propertyType in mediaType.PropertyTypes)
            {
                var definition = dataTypeService.GetDataTypeDefinitionById(propertyType.DataTypeDefinitionId);

                var propertyGroup = propertyType.PropertyGroupId == null // true generic property
                    ? null
                    : mediaType.PropertyGroups.FirstOrDefault(x =&gt; x.Id == propertyType.PropertyGroupId.Value);

                var genericProperty = new XElement(&quot;GenericProperty&quot;,
                                                   new XElement(&quot;Name&quot;, propertyType.Name),
                                                   new XElement(&quot;Alias&quot;, propertyType.Alias),
                                                   new XElement(&quot;Type&quot;, propertyType.PropertyEditorAlias),
                                                   new XElement(&quot;Definition&quot;, definition.Key),
                                                   new XElement(&quot;Tab&quot;, propertyGroup == null ? &quot;&quot; : propertyGroup.Name),
                                                   new XElement(&quot;Mandatory&quot;, propertyType.Mandatory.ToString()),
                                                   new XElement(&quot;Validation&quot;, propertyType.ValidationRegExp),
                                                   new XElement(&quot;Description&quot;, new XCData(propertyType.Description)));
                genericProperties.Add(genericProperty);
            }

            var tabs = new XElement(&quot;Tabs&quot;);
            foreach (var propertyGroup in mediaType.PropertyGroups)
            {
                var tab = new XElement(&quot;Tab&quot;,
                                       new XElement(&quot;Id&quot;, propertyGroup.Id.ToString(CultureInfo.InvariantCulture)),
                                       new XElement(&quot;Caption&quot;, propertyGroup.Name),
                                       new XElement(&quot;SortOrder&quot;, propertyGroup.SortOrder));

                tabs.Add(tab);
            }

            var xml = new XElement(&quot;MediaType&quot;,
                                   info,
                                   structure,
                                   genericProperties,
                                   tabs);

            return xml;
        }

        public XElement Serialize(IMacro macro)
        {
            var xml = new XElement(&quot;macro&quot;);
            xml.Add(new XElement(&quot;name&quot;, macro.Name));
            xml.Add(new XElement(&quot;alias&quot;, macro.Alias));
            xml.Add(new XElement(&quot;scriptType&quot;, macro.ControlType));
            xml.Add(new XElement(&quot;scriptAssembly&quot;, macro.ControlAssembly));
            xml.Add(new XElement(&quot;scriptingFile&quot;, macro.ScriptPath));
            xml.Add(new XElement(&quot;xslt&quot;, macro.XsltPath));
            xml.Add(new XElement(&quot;useInEditor&quot;, macro.UseInEditor.ToString()));
            xml.Add(new XElement(&quot;dontRender&quot;, macro.DontRender.ToString()));
            xml.Add(new XElement(&quot;refreshRate&quot;, macro.CacheDuration.ToString(CultureInfo.InvariantCulture)));
            xml.Add(new XElement(&quot;cacheByMember&quot;, macro.CacheByMember.ToString()));
            xml.Add(new XElement(&quot;cacheByPage&quot;, macro.CacheByPage.ToString()));

            var properties = new XElement(&quot;properties&quot;);
            foreach (var property in macro.Properties)
            {
                properties.Add(new XElement(&quot;property&quot;,
                    new XAttribute(&quot;name&quot;, property.Name),
                    new XAttribute(&quot;alias&quot;, property.Alias),
                    new XAttribute(&quot;sortOrder&quot;, property.SortOrder),
                    new XAttribute(&quot;propertyType&quot;, property.EditorAlias)));
            }
            xml.Add(properties);

            return xml;
        }

        /// &lt;summary&gt;
        /// Exports an &lt;see cref=&quot;IContentType&quot;/&gt; item to xml as an &lt;see cref=&quot;XElement&quot;/&gt;
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;dataTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;contentTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;contentType&quot;&gt;Content type to export&lt;/param&gt;
        /// &lt;returns&gt;&lt;see cref=&quot;XElement&quot;/&gt; containing the xml representation of the IContentType object&lt;/returns&gt;
        public XElement Serialize(IDataTypeService dataTypeService, IContentTypeService contentTypeService, IContentType contentType)
        {
            var info = new XElement(&quot;Info&quot;,
                                    new XElement(&quot;Name&quot;, contentType.Name),
                                    new XElement(&quot;Alias&quot;, contentType.Alias),
                                    new XElement(&quot;Icon&quot;, contentType.Icon),
                                    new XElement(&quot;Thumbnail&quot;, contentType.Thumbnail),
                                    new XElement(&quot;Description&quot;, contentType.Description),
                                    new XElement(&quot;AllowAtRoot&quot;, contentType.AllowedAsRoot.ToString()),
                                    new XElement(&quot;IsListView&quot;, contentType.IsContainer.ToString()));

            var masterContentType = contentType.ContentTypeComposition.FirstOrDefault(x =&gt; x.Id == contentType.ParentId);
            if(masterContentType != null)
                info.Add(new XElement(&quot;Master&quot;, masterContentType.Alias));

            var compositionsElement = new XElement(&quot;Compositions&quot;);
            var compositions = contentType.ContentTypeComposition;
            foreach (var composition in compositions)
            {
                compositionsElement.Add(new XElement(&quot;Composition&quot;, composition.Alias));
            }
            info.Add(compositionsElement);

            var allowedTemplates = new XElement(&quot;AllowedTemplates&quot;);
            foreach (var template in contentType.AllowedTemplates)
            {
                allowedTemplates.Add(new XElement(&quot;Template&quot;, template.Alias));
            }
            info.Add(allowedTemplates);

            if (contentType.DefaultTemplate != null &amp;&amp; contentType.DefaultTemplate.Id != 0)
                info.Add(new XElement(&quot;DefaultTemplate&quot;, contentType.DefaultTemplate.Alias));
            else
                info.Add(new XElement(&quot;DefaultTemplate&quot;, &quot;&quot;));

            var structure = new XElement(&quot;Structure&quot;);
            foreach (var allowedType in contentType.AllowedContentTypes)
            {
                structure.Add(new XElement(&quot;DocumentType&quot;, allowedType.Alias));
            }

            var genericProperties = new XElement(&quot;GenericProperties&quot;); // actually, all of them
            foreach (var propertyType in contentType.PropertyTypes)
            {
                var definition = dataTypeService.GetDataTypeDefinitionById(propertyType.DataTypeDefinitionId);

                var propertyGroup = propertyType.PropertyGroupId == null // true generic property
                    ? null
                    : contentType.PropertyGroups.FirstOrDefault(x =&gt; x.Id == propertyType.PropertyGroupId.Value);

                var genericProperty = new XElement(&quot;GenericProperty&quot;,
                                                   new XElement(&quot;Name&quot;, propertyType.Name),
                                                   new XElement(&quot;Alias&quot;, propertyType.Alias),
                                                   new XElement(&quot;Type&quot;, propertyType.PropertyEditorAlias),
                                                   new XElement(&quot;Definition&quot;, definition.Key),
                                                   new XElement(&quot;Tab&quot;, propertyGroup == null ? &quot;&quot; : propertyGroup.Name),
                                                   new XElement(&quot;SortOrder&quot;, propertyType.SortOrder),
                                                   new XElement(&quot;Mandatory&quot;, propertyType.Mandatory.ToString()),
                                                   propertyType.ValidationRegExp != null ? new XElement(&quot;Validation&quot;, propertyType.ValidationRegExp) : null,
                                                   propertyType.Description != null ? new XElement(&quot;Description&quot;, new XCData(propertyType.Description)) : null);
                
                genericProperties.Add(genericProperty);
            }

            var tabs = new XElement(&quot;Tabs&quot;);
            foreach (var propertyGroup in contentType.PropertyGroups)
            {
                var tab = new XElement(&quot;Tab&quot;,
                                       new XElement(&quot;Id&quot;, propertyGroup.Id.ToString(CultureInfo.InvariantCulture)),
                                       new XElement(&quot;Caption&quot;, propertyGroup.Name),
                                       new XElement(&quot;SortOrder&quot;, propertyGroup.SortOrder));
                tabs.Add(tab);
            }

            var xml = new XElement(&quot;DocumentType&quot;,
                info,
                structure,
                genericProperties,
                tabs);

            var folderNames = string.Empty;
            //don&#39;t add folders if this is a child doc type
            if (contentType.Level != 1 &amp;&amp; masterContentType == null)
            {
                //get url encoded folder names
                var folders = contentTypeService.GetContentTypeContainers(contentType)
                    .OrderBy(x =&gt; x.Level)
                    .Select(x =&gt; HttpUtility.UrlEncode(x.Name));

                folderNames = string.Join(&quot;/&quot;, folders.ToArray());
            }

            if (string.IsNullOrWhiteSpace(folderNames) == false)
                xml.Add(new XAttribute(&quot;Folders&quot;, folderNames));

            return xml;
        }

        /// &lt;summary&gt;
        /// Used by Media Export to recursively add children
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;mediaService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;userService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;originalDescendants&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;currentChildren&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;currentXml&quot;&gt;&lt;/param&gt;
        private void AddChildXml(IMediaService mediaService, IDataTypeService dataTypeService, IUserService userService, IMedia[] originalDescendants, IEnumerable&lt;IMedia&gt; currentChildren, XElement currentXml)
        {
            foreach (var child in currentChildren)
            {
                //add the child&#39;s xml
                var childXml = Serialize(mediaService, dataTypeService, userService, child);
                currentXml.Add(childXml);
                //copy local (out of closure)
                var c = child;
                //get this item&#39;s children                
                var children = originalDescendants.Where(x =&gt; x.ParentId == c.Id);
                //recurse and add it&#39;s children to the child xml element
                AddChildXml(mediaService, dataTypeService, userService, originalDescendants, children, childXml);
            }
        }

        /// &lt;summary&gt;
        /// Part of the export of IContent and IMedia and IMember which is shared
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;dataTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;contentBase&quot;&gt;Base Content or Media to export&lt;/param&gt;
        /// &lt;param name=&quot;nodeName&quot;&gt;Name of the node&lt;/param&gt;
        /// &lt;returns&gt;&lt;see cref=&quot;XElement&quot;/&gt;&lt;/returns&gt;
        private XElement Serialize(IDataTypeService dataTypeService, IContentBase contentBase, string nodeName)
        {
            //NOTE: that one will take care of umbracoUrlName
            var url = contentBase.GetUrlSegment();

            var xml = new XElement(nodeName,
                new XAttribute(&quot;id&quot;, contentBase.Id),
                new XAttribute(&quot;key&quot;, contentBase.Key),
                new XAttribute(&quot;parentID&quot;, contentBase.Level &gt; 1 ? contentBase.ParentId : -1),
                new XAttribute(&quot;level&quot;, contentBase.Level),
                new XAttribute(&quot;creatorID&quot;, contentBase.CreatorId),
                new XAttribute(&quot;sortOrder&quot;, contentBase.SortOrder),
                new XAttribute(&quot;createDate&quot;, contentBase.CreateDate.ToString(&quot;s&quot;)),
                new XAttribute(&quot;updateDate&quot;, contentBase.UpdateDate.ToString(&quot;s&quot;)),
                new XAttribute(&quot;nodeName&quot;, contentBase.Name),
                new XAttribute(&quot;urlName&quot;, url),
                new XAttribute(&quot;path&quot;, contentBase.Path),
                new XAttribute(&quot;isDoc&quot;, &quot;&quot;));

            foreach (var property in contentBase.Properties.Where(p =&gt; p != null &amp;&amp; p.Value != null &amp;&amp; p.Value.ToString().IsNullOrWhiteSpace() == false))
            {
                xml.Add(Serialize(dataTypeService, property));
            }

            return xml;
        }

        /// &lt;summary&gt;
        /// Used by Content Export to recursively add children
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;contentService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;userService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;originalDescendants&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;currentChildren&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;currentXml&quot;&gt;&lt;/param&gt;
        private void AddChildXml(IContentService contentService, IDataTypeService dataTypeService, IUserService userService, IContent[] originalDescendants, IEnumerable&lt;IContent&gt; currentChildren, XElement currentXml)
        {
            foreach (var child in currentChildren)
            {
                //add the child&#39;s xml
                var childXml = Serialize(contentService, dataTypeService, userService, child);
                currentXml.Add(childXml);
                //copy local (out of closure)
                var c = child;
                //get this item&#39;s children                
                var children = originalDescendants.Where(x =&gt; x.ParentId == c.Id);
                //recurse and add it&#39;s children to the child xml element
                AddChildXml(contentService, dataTypeService, userService, originalDescendants, children, childXml);
            }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[34,9,34,10,1],[36,13,36,158,1],[38,13,38,69,1],[39,13,39,73,1],[40,13,40,97,1],[41,13,41,95,1],[42,13,42,67,1],[43,13,43,142,1],[44,13,44,81,1],[46,13,46,22,1],[47,13,47,14,0],[48,17,48,84,0],[49,17,49,62,0],[49,62,49,86,0],[49,86,49,88,0],[49,17,49,88,0],[50,17,50,110,0],[51,13,51,14,0],[53,13,53,24,1],[54,9,54,10,1],[66,9,66,10,1],[68,13,68,156,1],[70,13,70,67,1],[71,13,71,71,1],[72,13,72,94,1],[73,13,73,66,1],[74,13,74,63,1],[75,13,75,52,1],[76,13,76,79,1],[78,13,78,22,1],[79,13,79,14,1],[80,17,80,80,1],[81,17,81,62,1],[81,62,81,84,1],[81,84,81,86,1],[81,17,81,86,1],[82,17,82,108,1],[83,13,83,14,1],[85,13,85,24,1],[86,9,86,10,1],[95,9,95,10,1],[97,13,97,157,1],[99,13,99,68,1],[100,13,100,72,1],[101,13,101,80,1],[103,13,103,67,1],[104,13,104,60,1],[106,13,106,70,1],[108,13,108,24,1],[109,9,109,10,1],[112,9,112,10,1],[113,13,113,54,1],[114,13,114,131,1],[116,13,116,51,1],[119,13,119,80,1],[120,13,120,14,0],[121,17,121,79,0],[122,17,122,33,0],[123,13,123,14,0],[126,13,126,119,1],[127,13,127,40,1],[128,13,128,14,1],[129,17,129,115,1],[130,17,130,40,1],[131,13,131,14,1],[133,13,133,29,1],[134,9,134,10,1],[143,9,143,10,0],[144,13,144,55,0],[145,13,146,39,0],[148,13,148,26,0],[149,13,149,20,0],[149,22,149,28,0],[149,29,149,31,0],[149,32,149,44,0],[150,13,150,14,0],[151,17,151,57,0],[152,17,152,65,0],[153,17,153,77,0],[154,17,154,63,0],[155,17,155,65,0],[156,17,156,41,0],[157,17,157,24,0],[158,13,158,14,0],[160,13,160,59,0],[161,13,161,70,0],[163,13,163,83,0],[164,13,164,75,0],[165,13,165,97,0],[167,13,167,44,0],[168,13,168,47,0],[169,13,169,14,0],[171,17,172,35,0],[172,35,172,42,0],[172,42,173,34,0],[173,34,173,63,0],[173,63,173,65,0],[171,17,173,65,0],[175,17,175,67,0],[176,13,176,14,0],[178,13,178,65,0],[179,17,179,65,0],[181,13,181,24,0],[182,9,182,10,0],[185,9,185,10,1],[186,13,186,101,1],[187,13,187,20,1],[187,22,187,37,1],[187,38,187,40,1],[187,41,187,68,1],[188,13,188,14,1],[189,17,192,53,1],[193,13,193,14,1],[195,13,195,24,1],[196,9,196,10,1],[199,9,199,10,0],[200,13,203,74,0],[205,13,205,52,0],[206,13,206,28,0],[208,13,208,20,0],[208,22,208,30,0],[208,31,208,33,0],[208,34,208,55,0],[209,13,209,14,0],[210,17,213,57,0],[214,13,214,14,0],[216,13,216,24,0],[217,9,217,10,0],[220,9,220,10,1],[221,13,224,71,1],[226,13,226,24,1],[227,9,227,10,1],[230,9,230,10,0],[231,13,231,48,0],[232,13,232,58,0],[233,13,233,60,0],[234,13,234,75,0],[236,13,236,57,0],[237,13,237,87,0],[238,13,238,14,0],[239,17,240,77,0],[241,17,241,18,0],[242,21,242,99,0],[243,21,243,96,0],[244,17,244,18,0],[245,13,245,14,0],[247,13,247,24,0],[248,9,248,10,0],[251,9,251,10,0],[252,13,258,102,0],[260,13,260,85,0],[261,13,261,43,0],[262,17,262,69,0],[264,13,264,55,0],[265,13,265,20,0],[265,22,265,37,0],[265,38,265,40,0],[265,41,265,70,0],[266,13,266,14,0],[267,17,267,77,0],[268,13,268,14,0],[270,13,270,71,0],[271,13,271,20,0],[271,22,271,38,0],[271,39,271,41,0],[271,42,271,65,0],[272,13,272,14,0],[273,17,273,111,0],[275,17,277,68,0],[277,68,277,110,0],[277,110,277,112,0],[275,17,277,112,0],[279,17,287,119,0],[288,17,288,56,0],[289,13,289,14,0],[291,13,291,45,0],[292,13,292,20,0],[292,22,292,39,0],[292,40,292,42,0],[292,43,292,67,0],[293,13,293,14,0],[294,17,297,92,0],[299,17,299,31,0],[300,13,300,14,0],[302,13,306,42,0],[308,13,308,24,0],[309,9,309,10,0],[312,9,312,10,1],[313,13,313,45,1],[314,13,314,55,1],[315,13,315,57,1],[316,13,316,68,1],[317,13,317,76,1],[318,13,318,70,1],[319,13,319,59,1],[320,13,320,80,1],[321,13,321,78,1],[322,13,322,110,1],[323,13,323,84,1],[324,13,324,80,1],[326,13,326,57,1],[327,13,327,20,1],[327,22,327,34,0],[327,35,327,37,1],[327,38,327,54,1],[328,13,328,14,0],[329,17,333,76,0],[334,13,334,14,0],[335,13,335,33,1],[337,13,337,24,1],[338,9,338,10,1],[348,9,348,10,1],[349,13,356,101,1],[358,13,358,92,1],[358,92,358,120,0],[358,120,358,122,1],[358,13,358,122,1],[359,13,359,42,1],[360,17,360,75,0],[362,13,362,68,1],[363,13,363,67,1],[364,13,364,20,1],[364,22,364,37,0],[364,38,364,40,1],[364,41,364,53,1],[365,13,365,14,0],[366,17,366,89,0],[367,13,367,14,0],[368,13,368,43,1],[370,13,370,69,1],[371,13,371,20,1],[371,22,371,34,0],[371,35,371,37,1],[371,38,371,66,1],[372,13,372,14,0],[373,17,373,80,0],[374,13,374,14,0],[375,13,375,40,1],[377,13,377,92,1],[378,17,378,94,0],[380,17,380,63,1],[382,13,382,55,1],[383,13,383,20,1],[383,22,383,37,1],[383,38,383,40,1],[383,41,383,72,1],[384,13,384,14,1],[385,17,385,80,1],[386,13,386,14,1],[388,13,388,71,1],[389,13,389,20,1],[389,22,389,38,1],[389,39,389,41,1],[389,42,389,67,1],[390,13,390,14,1],[391,17,391,111,1],[393,17,395,70,1],[395,70,395,112,0],[395,112,395,114,1],[393,17,395,114,1],[397,17,406,161,1],[408,17,408,56,1],[409,13,409,14,1],[411,13,411,45,1],[412,13,412,20,1],[412,22,412,39,0],[412,40,412,42,1],[412,43,412,69,1],[413,13,413,14,0],[414,17,417,92,0],[418,17,418,31,0],[419,13,419,14,0],[421,13,425,23,1],[427,13,427,44,1],[429,13,429,69,1],[430,13,430,14,0],[432,17,433,35,0],[433,35,433,42,0],[433,42,434,34,0],[434,34,434,63,0],[434,63,434,65,0],[432,17,434,65,0],[436,17,436,67,0],[437,13,437,14,0],[439,13,439,65,1],[440,17,440,65,0],[442,13,442,24,1],[443,9,443,10,1],[455,9,455,10,1],[456,13,456,20,1],[456,22,456,31,1],[456,32,456,34,1],[456,35,456,50,1],[457,13,457,14,1],[459,17,459,93,1],[460,17,460,42,1],[462,17,462,31,1],[464,17,464,63,1],[464,63,464,81,1],[464,81,464,83,1],[464,17,464,83,1],[466,17,466,114,1],[467,13,467,14,1],[468,9,468,10,1],[478,9,478,10,1],[480,13,480,51,1],[482,13,494,46,1],[496,13,496,20,1],[496,22,496,34,1],[496,35,496,37,1],[496,38,496,72,1],[496,72,496,152,1],[496,152,496,153,1],[496,38,496,153,1],[497,13,497,14,1],[498,17,498,63,1],[499,13,499,14,1],[501,13,501,24,1],[502,9,502,10,1],[514,9,514,10,0],[515,13,515,20,0],[515,22,515,31,0],[515,32,515,34,0],[515,35,515,50,0],[516,13,516,14,0],[518,17,518,95,0],[519,17,519,42,0],[521,17,521,31,0],[523,17,523,63,0],[523,63,523,81,0],[523,81,523,83,0],[523,17,523,83,0],[525,17,525,116,0],[526,13,526,14,0],[527,9,527,10,0]]);
    </script>
  </body>
</html>