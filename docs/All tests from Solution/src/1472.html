<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\ObjectResolution\LegacyTransientObjectsResolver.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading;
using Umbraco.Core.Logging;

namespace Umbraco.Core.ObjectResolution
{
	/// &lt;summary&gt;
	/// The base class for old legacy factories such as the DataTypeFactory or CacheResolverFactory.
	/// &lt;/summary&gt;
	/// &lt;typeparam name=&quot;TResolver&quot;&gt;The type of the concrete resolver class.&lt;/typeparam&gt;
	/// &lt;typeparam name=&quot;TResolved&quot;&gt;The type of the resolved objects.&lt;/typeparam&gt;
	/// &lt;remarks&gt;
	/// This class contains basic functionality to mimic the functionality in these old factories since they all return 
	/// transient objects (though this should be changed) and the method GetById needs to lookup a type to an ID and since 
	/// these old classes don&#39;t contain metadata, the objects need to be instantiated first to get their metadata, we then store this
	/// for use in the GetById method.
	/// &lt;/remarks&gt;
	internal abstract class LegacyTransientObjectsResolver&lt;TResolver, TResolved&gt; : LazyManyObjectsResolverBase&lt;TResolver, TResolved&gt;
		where TResolved : class
        where TResolver : ResolverBase
	{
		private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();
		private ConcurrentDictionary&lt;Guid, Type&gt; _id2Type;

		#region Constructors

	    /// &lt;summary&gt;
	    /// Initializes a new instance of the &lt;see cref=&quot;LegacyTransientObjectsResolver{TResolver, TResolved}&quot;/&gt; class with an initial list of object types.
	    /// &lt;/summary&gt;
	    /// &lt;param name=&quot;serviceProvider&quot;&gt;&lt;/param&gt;
	    /// &lt;param name=&quot;logger&quot;&gt;&lt;/param&gt;
	    /// &lt;param name=&quot;value&quot;&gt;A function returning the list of object types.&lt;/param&gt;
	    /// &lt;remarks&gt;
	    /// We are creating Transient instances (new instances each time) because this is how the legacy code worked and
	    /// I don&#39;t want to muck anything up by changing them to application based instances. 
	    /// TODO: However, it would make much more sense to do this and would speed up the application plus this would make the GetById method much easier.
	    /// &lt;/remarks&gt;
	    protected LegacyTransientObjectsResolver(IServiceProvider serviceProvider, ILogger logger, Func&lt;IEnumerable&lt;Type&gt;&gt; value)
            : base(serviceProvider, logger, value, ObjectLifetimeScope.Transient) //  new objects every time
		{ }
		#endregion

		/// &lt;summary&gt;
		/// Returns the unique identifier of the type of a specified object.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;value&quot;&gt;The object.&lt;/param&gt;
		/// &lt;returns&gt;The unique identifier of the type of &lt;paramref name=&quot;value&quot;/&gt;.&lt;/returns&gt;
		protected abstract Guid GetUniqueIdentifier(TResolved value); 

		/// &lt;summary&gt;
		/// Returns a new instance for the type identified by its unique type identifier.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;id&quot;&gt;The type identifier.&lt;/param&gt;
		/// &lt;returns&gt;The value of the type uniquely identified by &lt;paramref name=&quot;id&quot;/&gt;.&lt;/returns&gt;
		public TResolved GetById(Guid id)
		{
			EnsureIsInitialized();
			return _id2Type.ContainsKey(id) == false
			       	? null
                    : ServiceProvider.GetService(_id2Type[id]) as TResolved;
		}

		/// &lt;summary&gt;
		/// Populates the identifiers-to-types dictionnary.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// &lt;para&gt;This allow us to instantiate a type by ID since these legacy types doesn&#39;t contain any metadata.&lt;/para&gt;
		/// &lt;para&gt;We instanciate all types once to get their unique identifier, then build the dictionary so that
		/// when GetById is called, we can instanciate a single object.&lt;/para&gt;
		/// &lt;/remarks&gt;
		protected void EnsureIsInitialized()
		{
			using (var l = new UpgradeableReadLock(_lock))
			{
				if (_id2Type == null)
				{
					l.UpgradeToWriteLock();

					_id2Type = new ConcurrentDictionary&lt;Guid, Type&gt;();
					foreach (var value in Values)
					{
						_id2Type.TryAdd(GetUniqueIdentifier(value), value.GetType());
					}
				}
			}
		}

	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[24,3,24,76,1],[41,15,41,82,1],[42,3,42,4,1],[42,5,42,6,1],[58,3,58,4,1],[59,4,59,26,1],[60,4,62,77,1],[63,3,63,4,1],[74,3,74,4,1],[75,11,75,49,1],[76,4,76,5,1],[77,5,77,26,1],[78,5,78,6,1],[79,6,79,29,1],[81,6,81,56,1],[82,6,82,13,1],[82,15,82,24,1],[82,25,82,27,1],[82,28,82,34,1],[83,6,83,7,1],[84,7,84,68,1],[85,6,85,7,1],[86,5,86,6,1],[87,4,87,5,1],[88,3,88,4,1]]);
    </script>
  </body>
</html>