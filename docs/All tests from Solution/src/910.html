<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Security\Providers\UmbracoMembershipProvider.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Specialized;
using System.Configuration.Provider;
using System.Linq;
using System.Text;
using System.Web.Configuration;
using System.Web.Security;
using Umbraco.Core;
using Umbraco.Core.Configuration;
using Umbraco.Core.Logging;
using Umbraco.Core.Models.Membership;
using Umbraco.Core.Persistence.Querying;
using Umbraco.Core.Security;
using Umbraco.Core.Services;

namespace Umbraco.Web.Security.Providers
{
    

    /// &lt;summary&gt;
    /// Abstract Membership Provider that users any implementation of IMembershipMemberService{TEntity} service
    /// &lt;/summary&gt;
    public abstract class UmbracoMembershipProvider&lt;T, TEntity&gt; : UmbracoMembershipProviderBase
        where T : IMembershipMemberService&lt;TEntity&gt;
        where TEntity : class, IMembershipUser
    {

        protected IMembershipMemberService&lt;TEntity&gt; MemberService { get; private set; }
        
        protected UmbracoMembershipProvider(IMembershipMemberService&lt;TEntity&gt; memberService)
        {
            MemberService = memberService;
        }

        public abstract string ProviderName { get; }

        protected abstract MembershipUser ConvertToMembershipUser(TEntity entity);

        private bool _allowManuallyChangingPassword = true;

        /// &lt;summary&gt;
        /// For backwards compatibility, this provider supports this option by default it is true
        /// &lt;/summary&gt;
        public override bool AllowManuallyChangingPassword
        {
            get { return _allowManuallyChangingPassword; }
        }

        /// &lt;summary&gt;
        /// Initializes the provider.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The friendly name of the provider.&lt;/param&gt;
        /// &lt;param name=&quot;config&quot;&gt;A collection of the name/value pairs representing the provider-specific attributes specified in the configuration for this provider.&lt;/param&gt;
        /// &lt;exception cref=&quot;T:System.ArgumentNullException&quot;&gt;The name of the provider is null.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.InvalidOperationException&quot;&gt;An attempt is made to call 
        /// &lt;see cref=&quot;M:System.Configuration.Provider.ProviderBase.Initialize(System.String,System.Collections.Specialized.NameValueCollection)&quot;&gt;&lt;/see&gt; on a provider after the provider 
        /// has already been initialized.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.ArgumentException&quot;&gt;The name of the provider has a length of zero.&lt;/exception&gt;       
        public override void Initialize(string name, NameValueCollection config)
        {
            if (config == null) {throw new ArgumentNullException(&quot;config&quot;);}

            if (string.IsNullOrEmpty(name)) name = ProviderName;

            // Initialize base provider class
            base.Initialize(name, config);

            _allowManuallyChangingPassword = config.GetValue(&quot;allowManuallyChangingPassword&quot;, true);
        }

        /// &lt;summary&gt;
        /// Processes a request to update the password for a membership user.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The user to update the password for.&lt;/param&gt;
        /// &lt;param name=&quot;oldPassword&quot;&gt;This property is ignore for this provider&lt;/param&gt;
        /// &lt;param name=&quot;newPassword&quot;&gt;The new password for the specified user.&lt;/param&gt;
        /// &lt;returns&gt;
        /// true if the password was updated successfully; otherwise, false.
        /// &lt;/returns&gt;
        protected override bool PerformChangePassword(string username, string oldPassword, string newPassword)
        {
            //NOTE: due to backwards compatibilty reasons (and UX reasons), this provider doesn&#39;t care about the old password and 
            // allows simply setting the password manually so we don&#39;t really care about the old password.
            // This is allowed based on the overridden AllowManuallyChangingPassword option.

            // in order to support updating passwords from the umbraco core, we can&#39;t validate the old password
            var m = MemberService.GetByUsername(username);
            if (m == null) return false;
            
            string salt;
            var encodedPassword = EncryptOrHashNewPassword(newPassword, out salt);

            m.RawPasswordValue = FormatPasswordForStorage(encodedPassword, salt);
            m.LastPasswordChangeDate = DateTime.Now;

            MemberService.Save(m);

            return true;
        }

        /// &lt;summary&gt;
        /// Processes a request to update the password question and answer for a membership user.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The user to change the password question and answer for.&lt;/param&gt;
        /// &lt;param name=&quot;password&quot;&gt;The password for the specified user.&lt;/param&gt;
        /// &lt;param name=&quot;newPasswordQuestion&quot;&gt;The new password question for the specified user.&lt;/param&gt;
        /// &lt;param name=&quot;newPasswordAnswer&quot;&gt;The new password answer for the specified user.&lt;/param&gt;
        /// &lt;returns&gt;
        /// true if the password question and answer are updated successfully; otherwise, false.
        /// &lt;/returns&gt;
        protected override bool PerformChangePasswordQuestionAndAnswer(string username, string password, string newPasswordQuestion, string newPasswordAnswer)
        {
            var member = MemberService.GetByUsername(username);
            if (member == null)
            {
                return false;
            }

            member.PasswordQuestion = newPasswordQuestion;
            member.RawPasswordAnswerValue = EncryptString(newPasswordAnswer);

            MemberService.Save(member);

            return true;
        }

        /// &lt;summary&gt;
        /// Adds a new membership user to the data source with the specified member type
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;memberTypeAlias&quot;&gt;A specific member type to create the member for&lt;/param&gt;
        /// &lt;param name=&quot;username&quot;&gt;The user name for the new user.&lt;/param&gt;
        /// &lt;param name=&quot;password&quot;&gt;The password for the new user.&lt;/param&gt;
        /// &lt;param name=&quot;email&quot;&gt;The e-mail address for the new user.&lt;/param&gt;
        /// &lt;param name=&quot;passwordQuestion&quot;&gt;The password question for the new user.&lt;/param&gt;
        /// &lt;param name=&quot;passwordAnswer&quot;&gt;The password answer for the new user&lt;/param&gt;
        /// &lt;param name=&quot;isApproved&quot;&gt;Whether or not the new user is approved to be validated.&lt;/param&gt;
        /// &lt;param name=&quot;providerUserKey&quot;&gt;The unique identifier from the membership data source for the user.&lt;/param&gt;
        /// &lt;param name=&quot;status&quot;&gt;A &lt;see cref=&quot;T:System.Web.Security.MembershipCreateStatus&quot;&gt;&lt;/see&gt; enumeration value indicating whether the user was created successfully.&lt;/param&gt;
        /// &lt;returns&gt;
        /// A &lt;see cref=&quot;T:System.Web.Security.MembershipUser&quot;&gt;&lt;/see&gt; object populated with the information for the newly created user.
        /// &lt;/returns&gt;
        protected override MembershipUser PerformCreateUser(string memberTypeAlias, string username, string password, string email, string passwordQuestion, 
                                                            string passwordAnswer, bool isApproved, object providerUserKey, out MembershipCreateStatus status)
        {
            // See if the user already exists
            if (MemberService.Exists(username))
            {
                status = MembershipCreateStatus.DuplicateUserName;
                LogHelper.Warn&lt;UmbracoMembershipProvider&lt;T, TEntity&gt;&gt;(&quot;Cannot create member as username already exists: &quot; + username);
                return null;
            }

            // See if the email is unique
            if (MemberService.GetByEmail(email) != null &amp;&amp; RequiresUniqueEmail)
            {
                status = MembershipCreateStatus.DuplicateEmail;
                LogHelper.Warn&lt;UmbracoMembershipProvider&lt;T, TEntity&gt;&gt;(
                    &quot;Cannot create member as a member with the same email address exists: &quot; + email);
                return null;
            }

            string salt;
            var encodedPassword = EncryptOrHashNewPassword(password, out salt);

            var member = MemberService.CreateWithIdentity(
                username,
                email, 
                FormatPasswordForStorage(encodedPassword, salt), 
                memberTypeAlias);
            
            member.PasswordQuestion = passwordQuestion;
            member.RawPasswordAnswerValue = EncryptString(passwordAnswer);
            member.IsApproved = isApproved;
            member.LastLoginDate = DateTime.Now;
            member.LastPasswordChangeDate = DateTime.Now;

            MemberService.Save(member);

            status = MembershipCreateStatus.Success;
            return ConvertToMembershipUser(member);
        }

        /// &lt;summary&gt;
        /// Removes a user from the membership data source.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The name of the user to delete.&lt;/param&gt;
        /// &lt;param name=&quot;deleteAllRelatedData&quot;&gt;
        /// TODO: This setting currently has no effect
        /// &lt;/param&gt;
        /// &lt;returns&gt;
        /// true if the user was successfully deleted; otherwise, false.
        /// &lt;/returns&gt;
        public override bool DeleteUser(string username, bool deleteAllRelatedData)
        {
            var member = MemberService.GetByUsername(username);
            if (member == null) return false;

            MemberService.Delete(member);
            return true;
        }

        /// &lt;summary&gt;
        /// Gets a collection of membership users where the e-mail address contains the specified e-mail address to match.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;emailToMatch&quot;&gt;The e-mail address to search for.&lt;/param&gt;
        /// &lt;param name=&quot;pageIndex&quot;&gt;The index of the page of results to return. pageIndex is zero-based.&lt;/param&gt;
        /// &lt;param name=&quot;pageSize&quot;&gt;The size of the page of results to return.&lt;/param&gt;
        /// &lt;param name=&quot;totalRecords&quot;&gt;The total number of matched users.&lt;/param&gt;
        /// &lt;returns&gt;
        /// A &lt;see cref=&quot;T:System.Web.Security.MembershipUserCollection&quot;&gt;&lt;/see&gt; collection that contains a page of pageSize&lt;see cref=&quot;T:System.Web.Security.MembershipUser&quot;&gt;&lt;/see&gt; objects beginning at the page specified by pageIndex.
        /// &lt;/returns&gt;
        public override MembershipUserCollection FindUsersByEmail(string emailToMatch, int pageIndex, int pageSize, out int totalRecords)
        {
            var byEmail = MemberService.FindByEmail(emailToMatch, pageIndex, pageSize, out totalRecords, StringPropertyMatchType.Wildcard).ToArray();
            
            var collection = new MembershipUserCollection();
            foreach (var m in byEmail)
            {
                collection.Add(ConvertToMembershipUser(m));
            }
            return collection;
        }

        /// &lt;summary&gt;
        /// Gets a collection of membership users where the user name contains the specified user name to match.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;usernameToMatch&quot;&gt;The user name to search for.&lt;/param&gt;
        /// &lt;param name=&quot;pageIndex&quot;&gt;The index of the page of results to return. pageIndex is zero-based.&lt;/param&gt;
        /// &lt;param name=&quot;pageSize&quot;&gt;The size of the page of results to return.&lt;/param&gt;
        /// &lt;param name=&quot;totalRecords&quot;&gt;The total number of matched users.&lt;/param&gt;
        /// &lt;returns&gt;
        /// A &lt;see cref=&quot;T:System.Web.Security.MembershipUserCollection&quot;&gt;&lt;/see&gt; collection that contains a page of pageSize&lt;see cref=&quot;T:System.Web.Security.MembershipUser&quot;&gt;&lt;/see&gt; objects beginning at the page specified by pageIndex.
        /// &lt;/returns&gt;
        public override MembershipUserCollection FindUsersByName(string usernameToMatch, int pageIndex, int pageSize, out int totalRecords)
        {
            var byEmail = MemberService.FindByUsername(usernameToMatch, pageIndex, pageSize, out totalRecords, StringPropertyMatchType.Wildcard).ToArray();

            var collection = new MembershipUserCollection();
            foreach (var m in byEmail)
            {
                collection.Add(ConvertToMembershipUser(m));
            }
            return collection;
        }

        /// &lt;summary&gt;
        /// Gets a collection of all the users in the data source in pages of data.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pageIndex&quot;&gt;The index of the page of results to return. pageIndex is zero-based.&lt;/param&gt;
        /// &lt;param name=&quot;pageSize&quot;&gt;The size of the page of results to return.&lt;/param&gt;
        /// &lt;param name=&quot;totalRecords&quot;&gt;The total number of matched users.&lt;/param&gt;
        /// &lt;returns&gt;
        /// A &lt;see cref=&quot;T:System.Web.Security.MembershipUserCollection&quot;&gt;&lt;/see&gt; collection that contains a page of pageSize&lt;see cref=&quot;T:System.Web.Security.MembershipUser&quot;&gt;&lt;/see&gt; objects beginning at the page specified by pageIndex.
        /// &lt;/returns&gt;
        public override MembershipUserCollection GetAllUsers(int pageIndex, int pageSize, out int totalRecords)
        {
            var membersList = new MembershipUserCollection();

            var pagedMembers = MemberService.GetAll(pageIndex, pageSize, out totalRecords);
            
            foreach (var m in pagedMembers)
            {
                membersList.Add(ConvertToMembershipUser(m));
            }
            return membersList;
        }

        /// &lt;summary&gt;
        /// Gets the number of users currently accessing the application.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// The number of users currently accessing the application.       
        /// &lt;/returns&gt;
        /// &lt;remarks&gt;
        /// The way this is done is the same way that it is done in the MS SqlMembershipProvider - We query for any members
        /// that have their last active date within the Membership.UserIsOnlineTimeWindow (which is in minutes). It isn&#39;t exact science
        /// but that is how MS have made theirs so we&#39;ll follow that principal.
        /// &lt;/remarks&gt;
        public override int GetNumberOfUsersOnline()
        {
            return MemberService.GetCount(MemberCountType.Online);
        }

        /// &lt;summary&gt;
        /// Gets the password for the specified user name from the data source.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The user to retrieve the password for.&lt;/param&gt;
        /// &lt;param name=&quot;answer&quot;&gt;The password answer for the user.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The password for the specified user name.
        /// &lt;/returns&gt;
        protected override string PerformGetPassword(string username, string answer)
        {            
            var m = MemberService.GetByUsername(username);
            if (m == null)
            {
                throw new ProviderException(&quot;The supplied user is not found&quot;);
            }

            var encAnswer = EncryptString(answer);

            if (RequiresQuestionAndAnswer &amp;&amp; m.RawPasswordAnswerValue != encAnswer)
            {
                throw new ProviderException(&quot;Incorrect password answer&quot;);
            }

            var decodedPassword = DecryptPassword(m.RawPasswordValue);

            return decodedPassword;
        }

        internal string EncryptString(string str)
        {
            if (str.IsNullOrWhiteSpace())
            {
                return &quot;&quot;;
            }
            var bytes = Encoding.Unicode.GetBytes(str);
            var password = new byte[bytes.Length];
            Buffer.BlockCopy(bytes, 0, password, 0, bytes.Length);
            var encBytes = EncryptPassword(password, MembershipPasswordCompatibilityMode.Framework40);
            return Convert.ToBase64String(encBytes);
        }

        /// &lt;summary&gt;
        /// Gets information from the data source for a user. Provides an option to update the last-activity date/time stamp for the user.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The name of the user to get information for.&lt;/param&gt;
        /// &lt;param name=&quot;userIsOnline&quot;&gt;true to update the last-activity date/time stamp for the user; false to return user information without updating the last-activity date/time stamp for the user.&lt;/param&gt;
        /// &lt;returns&gt;
        /// A &lt;see cref=&quot;T:System.Web.Security.MembershipUser&quot;&gt;&lt;/see&gt; object populated with the specified user&#39;s information from the data source.
        /// &lt;/returns&gt;
        public override MembershipUser GetUser(string username, bool userIsOnline)
        {
            var member = MemberService.GetByUsername(username);
            if (member == null)
            {
                return null;
            }

            if (userIsOnline)
            {
                member.LastLoginDate = DateTime.Now;
                member.UpdateDate = DateTime.Now;
                //don&#39;t raise events for this! It just sets the member dates, if we do raise events this will
                // cause all distributed cache to execute - which will clear out some caches we don&#39;t want.
                // http://issues.umbraco.org/issue/U4-3451

                // when upgrating from 7.2 to 7.3 trying to save will throw
                if (UmbracoVersion.Current &gt;= new Version(7, 3, 0, 0))
                    MemberService.Save(member, false);
            }

            return ConvertToMembershipUser(member);
        }

        /// &lt;summary&gt;
        /// Gets information from the data source for a user based on the unique identifier for the membership user. Provides an option to update the last-activity date/time stamp for the user.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;providerUserKey&quot;&gt;The unique identifier for the membership user to get information for.&lt;/param&gt;
        /// &lt;param name=&quot;userIsOnline&quot;&gt;true to update the last-activity date/time stamp for the user; false to return user information without updating the last-activity date/time stamp for the user.&lt;/param&gt;
        /// &lt;returns&gt;
        /// A &lt;see cref=&quot;T:System.Web.Security.MembershipUser&quot;&gt;&lt;/see&gt; object populated with the specified user&#39;s information from the data source.
        /// &lt;/returns&gt;
        public override MembershipUser GetUser(object providerUserKey, bool userIsOnline)
        {
            var member = MemberService.GetByProviderKey(providerUserKey);
            if (member == null)
            {
                return null;
            }

            if (userIsOnline)
            {
                member.LastLoginDate = DateTime.Now;
                member.UpdateDate = DateTime.Now;
                //don&#39;t raise events for this! It just sets the member dates, if we do raise events this will
                // cause all distributed cache to execute - which will clear out some caches we don&#39;t want.
                // http://issues.umbraco.org/issue/U4-3451
                MemberService.Save(member, false);
            }

            return ConvertToMembershipUser(member);
        }

        /// &lt;summary&gt;
        /// Gets the user name associated with the specified e-mail address.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;email&quot;&gt;The e-mail address to search for.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The user name associated with the specified e-mail address. If no match is found, return null.
        /// &lt;/returns&gt;
        public override string GetUserNameByEmail(string email)
        {
            var member = MemberService.GetByEmail(email);

            return member == null ? null : member.Username;
        }

        /// &lt;summary&gt;
        /// Resets a user&#39;s password to a new, automatically generated password.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The user to reset the password for.&lt;/param&gt;
        /// &lt;param name=&quot;answer&quot;&gt;The password answer for the specified user (not used with Umbraco).&lt;/param&gt;
        /// &lt;param name=&quot;generatedPassword&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;The new password for the specified user.&lt;/returns&gt;
        protected override string PerformResetPassword(string username, string answer, string generatedPassword)
        {
            //TODO: This should be here - but how do we update failure count in this provider??
            //if (answer == null &amp;&amp; RequiresQuestionAndAnswer)
            //{
            //    UpdateFailureCount(username, &quot;passwordAnswer&quot;);

            //    throw new ProviderException(&quot;Password answer required for password reset.&quot;);
            //}
            
            var m = MemberService.GetByUsername(username);
            if (m == null)
            {
                throw new ProviderException(&quot;The supplied user is not found&quot;);
            }

            if (m.IsLockedOut)
            {
                throw new ProviderException(&quot;The member is locked out.&quot;);
            }

            var encAnswer = EncryptString(answer);

            if (RequiresQuestionAndAnswer &amp;&amp; m.RawPasswordAnswerValue != encAnswer)
            {
                throw new ProviderException(&quot;Incorrect password answer&quot;);
            }

            string salt;
            var encodedPassword = EncryptOrHashNewPassword(generatedPassword, out salt);
            m.RawPasswordValue = FormatPasswordForStorage(encodedPassword, salt);
            m.LastPasswordChangeDate = DateTime.Now;
            MemberService.Save(m);
            
            return generatedPassword;
        }

        /// &lt;summary&gt;
        /// Clears a lock so that the membership user can be validated.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The membership user to clear the lock status for.&lt;/param&gt;
        /// &lt;returns&gt;
        /// true if the membership user was successfully unlocked; otherwise, false.
        /// &lt;/returns&gt;
        public override bool UnlockUser(string username)
        {
            var member = MemberService.GetByUsername(username);

            if (member == null)
            {
                throw new ProviderException(string.Format(&quot;No member with the username &#39;{0}&#39; found&quot;, username));
            }                

            // Non need to update
            if (member.IsLockedOut == false) return true;

            member.IsLockedOut = false;
            member.FailedPasswordAttempts = 0;

            MemberService.Save(member);

            return true;
        }

        /// &lt;summary&gt;
        /// Updates e-mail  approved status, lock status and comment on a user.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;A &lt;see cref=&quot;T:System.Web.Security.MembershipUser&quot;&gt;&lt;/see&gt; object that represents the user to update and the updated information for the user.&lt;/param&gt;      
        public override void UpdateUser(MembershipUser user)
        {
            var m = MemberService.GetByUsername(user.UserName);

            if (m == null)
            {
                throw new ProviderException(string.Format(&quot;No member with the username &#39;{0}&#39; found&quot;, user.UserName));
            }

            if (RequiresUniqueEmail &amp;&amp; user.Email.Trim().IsNullOrWhiteSpace() == false)
            {
                int totalRecs;
                var byEmail = MemberService.FindByEmail(user.Email.Trim(), 0, int.MaxValue, out totalRecs, StringPropertyMatchType.Exact);
                if (byEmail.Count(x =&gt; x.Id != m.Id) &gt; 0)
                {
                    throw new ProviderException(string.Format(&quot;A member with the email &#39;{0}&#39; already exists&quot;, user.Email));
                }
            }
            m.Email = user.Email;
            
            m.IsApproved = user.IsApproved;
            m.IsLockedOut = user.IsLockedOut;
            if (user.IsLockedOut)
            {
                m.LastLockoutDate = DateTime.Now;
            }
            m.Comments = user.Comment;

            MemberService.Save(m);
        }

        /// &lt;summary&gt;
        /// Verifies that the specified user name and password exist in the data source.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The name of the user to validate.&lt;/param&gt;
        /// &lt;param name=&quot;password&quot;&gt;The password for the specified user.&lt;/param&gt;
        /// &lt;returns&gt;
        /// true if the specified username and password are valid; otherwise, false.
        /// &lt;/returns&gt;
        public override bool ValidateUser(string username, string password)
        {
            var member = MemberService.GetByUsername(username);

            if (member == null)
            {
                LogHelper.Info&lt;UmbracoMembershipProviderBase&gt;(
                    string.Format(
                        &quot;Login attempt failed for username {0} from IP address {1}, the user does not exist&quot;,
                        username,
                        GetCurrentRequestIpAddress()));

                return false;
            }

            if (member.IsApproved == false)
            {
                LogHelper.Info&lt;UmbracoMembershipProviderBase&gt;(
                    string.Format(
                        &quot;Login attempt failed for username {0} from IP address {1}, the user is not approved&quot;,
                        username,
                        GetCurrentRequestIpAddress()));

                return false;
            }
            if (member.IsLockedOut)
            {
                LogHelper.Info&lt;UmbracoMembershipProviderBase&gt;(
                    string.Format(
                        &quot;Login attempt failed for username {0} from IP address {1}, the user is locked&quot;,
                        username,
                        GetCurrentRequestIpAddress()));

                return false;
            }

            var authenticated = CheckPassword(password, member.RawPasswordValue);

            if (authenticated == false)
            {
                // TODO: Increment login attempts - lock if too many.

                var count = member.FailedPasswordAttempts;
                count++;
                member.FailedPasswordAttempts = count;

                if (count &gt;= MaxInvalidPasswordAttempts)
                {
                    member.IsLockedOut = true;
                    member.LastLockoutDate = DateTime.Now;

                    LogHelper.Info&lt;UmbracoMembershipProviderBase&gt;(
                        string.Format(
                            &quot;Login attempt failed for username {0} from IP address {1}, the user is now locked out, max invalid password attempts exceeded&quot;,
                            username,
                            GetCurrentRequestIpAddress()));
                }
                else
                {
                    LogHelper.Info&lt;UmbracoMembershipProviderBase&gt;(
                        string.Format(
                            &quot;Login attempt failed for username {0} from IP address {1}&quot;,
                            username,
                            GetCurrentRequestIpAddress()));
                }
            }
            else
            {
                member.FailedPasswordAttempts = 0;
                member.LastLoginDate = DateTime.Now;

                LogHelper.Info&lt;UmbracoMembershipProviderBase&gt;(
                        string.Format(
                            &quot;Login attempt succeeded for username {0} from IP address {1}&quot;,
                            username,
                            GetCurrentRequestIpAddress()));
            }

            //don&#39;t raise events for this! It just sets the member dates, if we do raise events this will
            // cause all distributed cache to execute - which will clear out some caches we don&#39;t want.
            // http://issues.umbraco.org/issue/U4-3451
            //TODO: In v8 we aren&#39;t going to have an overload to disable events, so we&#39;ll need to make a different method
            // for this type of thing (i.e. UpdateLastLogin or similar).

            // when upgrating from 7.2 to 7.3 trying to save will throw
            if (UmbracoVersion.Current &gt;= new Version(7, 3, 0, 0))
                MemberService.Save(member, false);

            return authenticated;
        }



        

    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[28,69,28,73,1],[28,74,28,86,1],[30,9,30,93,1],[31,9,31,10,1],[32,13,32,43,1],[33,9,33,10,1],[39,9,39,60,1],[46,17,46,18,0],[46,19,46,57,0],[46,58,46,59,0],[60,9,60,10,1],[61,13,61,32,1],[61,33,61,34,0],[61,34,61,76,0],[63,13,63,44,1],[63,45,63,65,0],[66,13,66,43,1],[68,13,68,101,1],[69,9,69,10,1],[81,9,81,10,0],[87,13,87,59,0],[88,13,88,27,0],[88,28,88,41,0],[91,13,91,83,0],[93,13,93,82,0],[94,13,94,53,0],[96,13,96,35,0],[98,13,98,25,0],[99,9,99,10,0],[112,9,112,10,0],[113,13,113,64,0],[114,13,114,32,0],[115,13,115,14,0],[116,17,116,30,0],[119,13,119,59,0],[120,13,120,78,0],[122,13,122,40,0],[124,13,124,25,0],[125,9,125,10,0],[144,9,144,10,1],[146,13,146,48,1],[147,13,147,14,1],[148,17,148,67,1],[149,17,149,135,1],[150,17,150,29,1],[154,13,154,80,1],[155,13,155,14,1],[156,17,156,64,1],[157,17,158,102,1],[159,17,159,29,1],[163,13,163,80,1],[165,13,169,34,1],[171,13,171,56,1],[172,13,172,75,1],[173,13,173,44,1],[174,13,174,49,1],[175,13,175,58,1],[177,13,177,40,1],[179,13,179,53,1],[180,13,180,52,1],[181,9,181,10,1],[194,9,194,10,0],[195,13,195,64,0],[196,13,196,32,0],[196,33,196,46,0],[198,13,198,42,0],[199,13,199,25,0],[200,9,200,10,0],[213,9,213,10,0],[214,13,214,150,0],[216,13,216,61,0],[217,13,217,20,0],[217,22,217,27,0],[217,28,217,30,0],[217,31,217,38,0],[218,13,218,14,0],[219,17,219,60,0],[220,13,220,14,0],[221,13,221,31,0],[222,9,222,10,0],[235,9,235,10,0],[236,13,236,156,0],[238,13,238,61,0],[239,13,239,20,0],[239,22,239,27,0],[239,28,239,30,0],[239,31,239,38,0],[240,13,240,14,0],[241,17,241,60,0],[242,13,242,14,0],[243,13,243,31,0],[244,9,244,10,0],[256,9,256,10,0],[257,13,257,62,0],[259,13,259,92,0],[261,13,261,20,0],[261,22,261,27,0],[261,28,261,30,0],[261,31,261,43,0],[262,13,262,14,0],[263,17,263,61,0],[264,13,264,14,0],[265,13,265,32,0],[266,9,266,10,0],[280,9,280,10,0],[281,13,281,67,0],[282,9,282,10,0],[293,9,293,10,0],[294,13,294,59,0],[295,13,295,27,0],[296,13,296,14,0],[297,17,297,79,0],[300,13,300,51,0],[302,13,302,84,0],[303,13,303,14,0],[304,17,304,74,0],[307,13,307,71,0],[309,13,309,36,0],[310,9,310,10,0],[313,9,313,10,1],[314,13,314,42,1],[315,13,315,14,0],[316,17,316,27,0],[318,13,318,56,1],[319,13,319,51,1],[320,13,320,67,1],[321,13,321,103,1],[322,13,322,53,1],[323,9,323,10,1],[334,9,334,10,0],[335,13,335,64,0],[336,13,336,32,0],[337,13,337,14,0],[338,17,338,29,0],[341,13,341,30,0],[342,13,342,14,0],[343,17,343,53,0],[344,17,344,50,0],[350,17,350,71,0],[351,21,351,55,0],[352,13,352,14,0],[354,13,354,52,0],[355,9,355,10,0],[366,9,366,10,0],[367,13,367,74,0],[368,13,368,32,0],[369,13,369,14,0],[370,17,370,29,0],[373,13,373,30,0],[374,13,374,14,0],[375,17,375,53,0],[376,17,376,50,0],[380,17,380,51,0],[381,13,381,14,0],[383,13,383,52,0],[384,9,384,10,0],[394,9,394,10,0],[395,13,395,58,0],[397,13,397,60,0],[398,9,398,10,0],[408,9,408,10,0],[417,13,417,59,0],[418,13,418,27,0],[419,13,419,14,0],[420,17,420,79,0],[423,13,423,31,0],[424,13,424,14,0],[425,17,425,74,0],[428,13,428,51,0],[430,13,430,84,0],[431,13,431,14,0],[432,17,432,74,0],[436,13,436,89,0],[437,13,437,82,0],[438,13,438,53,0],[439,13,439,35,0],[441,13,441,38,0],[442,9,442,10,0],[452,9,452,10,0],[453,13,453,64,0],[455,13,455,32,0],[456,13,456,14,0],[457,17,457,113,0],[461,13,461,45,0],[461,46,461,58,0],[463,13,463,40,0],[464,13,464,47,0],[466,13,466,40,0],[468,13,468,25,0],[469,9,469,10,0],[476,9,476,10,0],[477,13,477,64,0],[479,13,479,27,0],[480,13,480,14,0],[481,17,481,118,0],[484,13,484,88,0],[485,13,485,14,0],[487,17,487,139,0],[488,17,488,40,0],[488,40,488,52,0],[488,52,488,58,0],[488,17,488,58,0],[489,17,489,18,0],[490,21,490,124,0],[492,13,492,14,0],[493,13,493,34,0],[495,13,495,44,0],[496,13,496,46,0],[497,13,497,34,0],[498,13,498,14,0],[499,17,499,50,0],[500,13,500,14,0],[501,13,501,39,0],[503,13,503,35,0],[504,9,504,10,0],[515,9,515,10,0],[516,13,516,64,0],[518,13,518,32,0],[519,13,519,14,0],[520,17,524,56,0],[526,17,526,30,0],[529,13,529,44,0],[530,13,530,14,0],[531,17,535,56,0],[537,17,537,30,0],[539,13,539,36,0],[540,13,540,14,0],[541,17,545,56,0],[547,17,547,30,0],[550,13,550,82,0],[552,13,552,40,0],[553,13,553,14,0],[556,17,556,59,0],[557,17,557,25,0],[558,17,558,55,0],[560,17,560,57,0],[561,17,561,18,0],[562,21,562,47,0],[563,21,563,59,0],[565,21,569,60,0],[570,17,570,18,0],[572,17,572,18,0],[573,21,577,60,0],[578,17,578,18,0],[579,13,579,14,0],[581,13,581,14,0],[582,17,582,51,0],[583,17,583,53,0],[585,17,589,60,0],[590,13,590,14,0],[599,13,599,67,0],[600,17,600,51,0],[602,13,602,34,0],[603,9,603,10,0]]);
    </script>
  </body>
</html>