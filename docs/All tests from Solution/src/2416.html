<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\umbraco.cms\businesslogic\Packager\PackageInstance\CreatedPackage.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using System.Web;
using Newtonsoft.Json;
using Umbraco.Core;
using Umbraco.Core.Logging;
using umbraco.cms.businesslogic.web;
using umbraco.cms.businesslogic.macro;
using Umbraco.Core.IO;
using Umbraco.Core.Models;
using Umbraco.Core.Services;
using File = System.IO.File;
using Template = umbraco.cms.businesslogic.template.Template;


namespace umbraco.cms.businesslogic.packager
{
    public class CreatedPackage
    {

        public static CreatedPackage GetById(int id)
        {
            var pack = new CreatedPackage();
            pack.Data = data.Package(id, IOHelper.MapPath(Settings.CreatedPackagesSettings));
            return pack;
        }

        public static CreatedPackage MakeNew(string name)
        {
            var pack = new CreatedPackage
            {
                Data = data.MakeNew(name, IOHelper.MapPath(Settings.CreatedPackagesSettings))
            };

            var e = new NewEventArgs();
            pack.OnNew(e);

            return pack;
        }

        public void Save()
        {
            var e = new SaveEventArgs();
            FireBeforeSave(e);

            if (!e.Cancel)
            {
                data.Save(this.Data, IOHelper.MapPath(Settings.CreatedPackagesSettings));
                FireAfterSave(e);
            }
        }

        public void Delete()
        {
            var e = new DeleteEventArgs();
            FireBeforeDelete(e);

            if (!e.Cancel)
            {
                data.Delete(this.Data.Id, IOHelper.MapPath(Settings.CreatedPackagesSettings));
                FireAfterDelete(e);
            }
        }

        public PackageInstance Data { get; set; }

        public static List&lt;CreatedPackage&gt; GetAllCreatedPackages()
        {
            var val = new List&lt;CreatedPackage&gt;();

            foreach (var pack in data.GetAllPackages(IOHelper.MapPath(Settings.CreatedPackagesSettings)))
            {
                var crPack = new CreatedPackage();
                crPack.Data = pack;
                val.Add(crPack);
            }

            return val;
        }

        private static XmlDocument _packageManifest;
        private static void CreatePackageManifest()
        {
            _packageManifest = new XmlDocument();
            var xmldecl = _packageManifest.CreateXmlDeclaration(&quot;1.0&quot;, &quot;UTF-8&quot;, &quot;no&quot;);

            _packageManifest.AppendChild(xmldecl);

            //root node
            XmlNode umbPackage = _packageManifest.CreateElement(&quot;umbPackage&quot;);
            _packageManifest.AppendChild(umbPackage);
            //Files node
            umbPackage.AppendChild(_packageManifest.CreateElement(&quot;files&quot;));
        }

        private static void AppendElement(XmlNode node)
        {
            var root = _packageManifest.SelectSingleNode(&quot;/umbPackage&quot;);
            root.AppendChild(node);
        }


        public void Publish()
        {

            var package = this;
            var pack = package.Data;

            var e = new PublishEventArgs();
            package.FireBeforePublish(e);

            if (e.Cancel == false)
            {
                var outInt = 0;

                //Path checking...
                var localPath = IOHelper.MapPath(SystemDirectories.Media + &quot;/&quot; + pack.Folder);

                if (Directory.Exists(localPath) == false)
                    Directory.CreateDirectory(localPath);

                //Init package file...
                CreatePackageManifest();
                //Info section..
                AppendElement(utill.PackageInfo(pack, _packageManifest));

                //Documents and tags...
                var contentNodeId = 0;
                if (string.IsNullOrEmpty(pack.ContentNodeId) == false &amp;&amp; int.TryParse(pack.ContentNodeId, out contentNodeId))
                {
                    if (contentNodeId &gt; 0)
                    {
                        //Create the Documents/DocumentSet node
                        XmlNode documents = _packageManifest.CreateElement(&quot;Documents&quot;);
                        XmlNode documentSet = _packageManifest.CreateElement(&quot;DocumentSet&quot;);
                        XmlAttribute importMode = _packageManifest.CreateAttribute(&quot;importMode&quot;, &quot;&quot;);
                        importMode.Value = &quot;root&quot;;
                        documentSet.Attributes.Append(importMode);
                        documents.AppendChild(documentSet);

                        //load content from umbraco.
                        var umbDocument = new Document(contentNodeId);
                        
                        documentSet.AppendChild(umbDocument.ToXml(_packageManifest, pack.ContentLoadChildNodes));

                        AppendElement(documents);

                        ////Create the TagProperties node - this is used to store a definition for all
                        //// document properties that are tags, this ensures that we can re-import tags properly
                        //XmlNode tagProps = _packageManifest.CreateElement(&quot;TagProperties&quot;);

                        ////before we try to populate this, we&#39;ll do a quick lookup to see if any of the documents
                        //// being exported contain published tags. 
                        //var allExportedIds = documents.SelectNodes(&quot;//@id&quot;).Cast&lt;XmlNode&gt;()
                        //    .Select(x =&gt; x.Value.TryConvertTo&lt;int&gt;())
                        //    .Where(x =&gt; x.Success)
                        //    .Select(x =&gt; x.Result)
                        //    .ToArray();
                        //var allContentTags = new List&lt;ITag&gt;();
                        //foreach (var exportedId in allExportedIds)
                        //{                            
                        //    allContentTags.AddRange(
                        //        ApplicationContext.Current.Services.TagService.GetTagsForEntity(exportedId));
                        //}

                        ////This is pretty round-about but it works. Essentially we need to get the properties that are tagged
                        //// but to do that we need to lookup by a tag (string)
                        //var allTaggedEntities = new List&lt;TaggedEntity&gt;();
                        //foreach (var group in allContentTags.Select(x =&gt; x.Group).Distinct())
                        //{
                        //    allTaggedEntities.AddRange(
                        //        ApplicationContext.Current.Services.TagService.GetTaggedContentByTagGroup(group));
                        //}

                        ////Now, we have all property Ids/Aliases and their referenced document Ids and tags
                        //var allExportedTaggedEntities = allTaggedEntities.Where(x =&gt; allExportedIds.Contains(x.EntityId))
                        //    .DistinctBy(x =&gt; x.EntityId)
                        //    .OrderBy(x =&gt; x.EntityId);

                        //foreach (var taggedEntity in allExportedTaggedEntities)
                        //{
                        //    foreach (var taggedProperty in taggedEntity.TaggedProperties.Where(x =&gt; x.Tags.Any()))
                        //    {
                        //        XmlNode tagProp = _packageManifest.CreateElement(&quot;TagProperty&quot;);
                        //        var docId = _packageManifest.CreateAttribute(&quot;docId&quot;, &quot;&quot;);
                        //        docId.Value = taggedEntity.EntityId.ToString(CultureInfo.InvariantCulture);
                        //        tagProp.Attributes.Append(docId);

                        //        var propertyAlias = _packageManifest.CreateAttribute(&quot;propertyAlias&quot;, &quot;&quot;);
                        //        propertyAlias.Value = taggedProperty.PropertyTypeAlias;
                        //        tagProp.Attributes.Append(propertyAlias);
                                
                        //        var group = _packageManifest.CreateAttribute(&quot;group&quot;, &quot;&quot;);
                        //        group.Value = taggedProperty.Tags.First().Group;
                        //        tagProp.Attributes.Append(group);

                        //        tagProp.AppendChild(_packageManifest.CreateCDataSection(
                        //            JsonConvert.SerializeObject(taggedProperty.Tags.Select(x =&gt; x.Text).ToArray())));

                        //        tagProps.AppendChild(tagProp);
                        //    }
                        //}

                        //AppendElement(tagProps);

                    }
                }

                //Document types..
                var dtl = new List&lt;DocumentType&gt;();
                var docTypes = _packageManifest.CreateElement(&quot;DocumentTypes&quot;);
                foreach (var dtId in pack.Documenttypes)
                {
                    if (int.TryParse(dtId, out outInt))
                    {
                        DocumentType docT = new DocumentType(outInt);

                        AddDocumentType(docT, ref dtl);

                    }
                }
                
                foreach (DocumentType d in dtl)
                {                   
                    docTypes.AppendChild(d.ToXml(_packageManifest));
                }

                AppendElement(docTypes);

                //Templates
                var templates = _packageManifest.CreateElement(&quot;Templates&quot;);
                foreach (var templateId in pack.Templates)
                {
                    if (int.TryParse(templateId, out outInt))
                    {
                        var t = new Template(outInt);
                        templates.AppendChild(t.ToXml(_packageManifest));
                    }
                }
                AppendElement(templates);

                //Stylesheets
                var stylesheets = _packageManifest.CreateElement(&quot;Stylesheets&quot;);
                foreach (var stylesheetName in pack.Stylesheets)
                {
                    if (stylesheetName.IsNullOrWhiteSpace()) continue;
                    var stylesheetXmlNode = utill.Stylesheet(stylesheetName, true, _packageManifest);
                    if (stylesheetXmlNode != null)
                    {
                        stylesheets.AppendChild(stylesheetXmlNode);
                    }
                }
                AppendElement(stylesheets);

                //Macros
                var macros = _packageManifest.CreateElement(&quot;Macros&quot;);
                foreach (var macroId in pack.Macros)
                {
                    if (int.TryParse(macroId, out outInt))
                    {
                        macros.AppendChild(utill.Macro(int.Parse(macroId), true, localPath, _packageManifest));
                    }
                }
                AppendElement(macros);

                //Dictionary Items
                var dictionaryItems = _packageManifest.CreateElement(&quot;DictionaryItems&quot;);
                foreach (var dictionaryId in pack.DictionaryItems)
                {
                    if (int.TryParse(dictionaryId, out outInt))
                    {
                        var di = new Dictionary.DictionaryItem(outInt);
                        dictionaryItems.AppendChild(di.ToXml(_packageManifest));
                    }
                }
                AppendElement(dictionaryItems);

                //Languages
                var languages = _packageManifest.CreateElement(&quot;Languages&quot;);
                foreach (var langId in pack.Languages)
                {
                    if (int.TryParse(langId, out outInt))
                    {
                        var lang = new language.Language(outInt);

                        languages.AppendChild(lang.ToXml(_packageManifest));
                    }
                }
                AppendElement(languages);

                //Datatypes
                var dataTypes = _packageManifest.CreateElement(&quot;DataTypes&quot;);
                foreach (var dtId in pack.DataTypes)
                {
                    if (int.TryParse(dtId, out outInt))
                    {
                        datatype.DataTypeDefinition dtd = new datatype.DataTypeDefinition(outInt);
                        dataTypes.AppendChild(dtd.ToXml(_packageManifest));
                    }
                }
                AppendElement(dataTypes);

                //Files
                foreach (var fileName in pack.Files)
                {
                    utill.AppendFileToManifest(fileName, localPath, _packageManifest);
                }

                //Load control on install...
                if (string.IsNullOrEmpty(pack.LoadControl) == false)
                {
                    XmlNode control = _packageManifest.CreateElement(&quot;control&quot;);
                    control.InnerText = pack.LoadControl;
                    utill.AppendFileToManifest(pack.LoadControl, localPath, _packageManifest);
                    AppendElement(control);
                }

                //Actions
                if (string.IsNullOrEmpty(pack.Actions) == false)
                {
                    try
                    {
                        var xdActions = new XmlDocument();
                        xdActions.LoadXml(&quot;&lt;Actions&gt;&quot; + pack.Actions + &quot;&lt;/Actions&gt;&quot;);
                        var actions = xdActions.DocumentElement.SelectSingleNode(&quot;.&quot;);


                        if (actions != null)
                        {
                            actions = _packageManifest.ImportNode(actions, true).Clone();
                            AppendElement(actions);
                        }
                    }
                    catch { }
                }

                var manifestFileName = localPath + &quot;/package.xml&quot;;

                if (File.Exists(manifestFileName))
                    File.Delete(manifestFileName);

                _packageManifest.Save(manifestFileName);
                _packageManifest = null;


                //string packPath = Settings.PackagerRoot.Replace(System.IO.Path.DirectorySeparatorChar.ToString(), &quot;/&quot;) + &quot;/&quot; + pack.Name.Replace(&#39; &#39;, &#39;_&#39;) + &quot;_&quot; + pack.Version.Replace(&#39; &#39;, &#39;_&#39;) + &quot;.&quot; + Settings.PackageFileExtension;

                // check if there&#39;s a packages directory below media
                var packagesDirectory = SystemDirectories.Media + &quot;/created-packages&quot;;
                if (Directory.Exists(IOHelper.MapPath(packagesDirectory)) == false)
                {
                    Directory.CreateDirectory(IOHelper.MapPath(packagesDirectory));
                }


                var packPath = packagesDirectory + &quot;/&quot; + (pack.Name + &quot;_&quot; + pack.Version).Replace(&#39; &#39;, &#39;_&#39;) + &quot;.&quot; + Settings.PackageFileExtension;
                utill.ZipPackage(localPath, IOHelper.MapPath(packPath));

                pack.PackagePath = packPath;

                if (pack.PackageGuid.Trim() == &quot;&quot;)
                    pack.PackageGuid = Guid.NewGuid().ToString();

                package.Save();

                //Clean up..
                File.Delete(localPath + &quot;/package.xml&quot;);
                Directory.Delete(localPath, true);

                package.FireAfterPublish(e);
            }

        }
        
        private void AddDocumentType(DocumentType dt, ref List&lt;DocumentType&gt; dtl)
        {
            if (dt.MasterContentType != 0 &amp;&amp; dt.Parent.nodeObjectType == Constants.ObjectTypes.DocumentTypeGuid)
            {
                //first add masters
                var mDocT = new DocumentType(dt.MasterContentType);
                AddDocumentType(mDocT, ref dtl);
            }

            if (dtl.Contains(dt) == false)
            {
                dtl.Add(dt);
            }
        }

        //EVENTS
        public delegate void SaveEventHandler(CreatedPackage sender, SaveEventArgs e);
        public delegate void NewEventHandler(CreatedPackage sender, NewEventArgs e);
        public delegate void PublishEventHandler(CreatedPackage sender, PublishEventArgs e);
        public delegate void DeleteEventHandler(CreatedPackage sender, DeleteEventArgs e);

        /// &lt;summary&gt;
        /// Occurs when a macro is saved.
        /// &lt;/summary&gt;
        public static event SaveEventHandler BeforeSave;
        protected virtual void FireBeforeSave(SaveEventArgs e)
        {
            if (BeforeSave != null)
                BeforeSave(this, e);
        }

        public static event SaveEventHandler AfterSave;
        protected virtual void FireAfterSave(SaveEventArgs e)
        {
            if (AfterSave != null)
                AfterSave(this, e);
        }

        public static event NewEventHandler New;
        protected virtual void OnNew(NewEventArgs e)
        {
            if (New != null)
                New(this, e);
        }

        public static event DeleteEventHandler BeforeDelete;
        protected virtual void FireBeforeDelete(DeleteEventArgs e)
        {
            if (BeforeDelete != null)
                BeforeDelete(this, e);
        }

        public static event DeleteEventHandler AfterDelete;
        protected virtual void FireAfterDelete(DeleteEventArgs e)
        {
            if (AfterDelete != null)
                AfterDelete(this, e);
        }

        public static event PublishEventHandler BeforePublish;
        protected virtual void FireBeforePublish(PublishEventArgs e)
        {
            if (BeforePublish != null)
                BeforePublish(this, e);
        }

        public static event PublishEventHandler AfterPublish;
        protected virtual void FireAfterPublish(PublishEventArgs e)
        {
            if (AfterPublish != null)
                AfterPublish(this, e);
        }


    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[27,9,27,10,0],[28,13,28,45,0],[29,13,29,94,0],[30,13,30,25,0],[31,9,31,10,0],[34,9,34,10,0],[35,13,38,15,0],[40,13,40,40,0],[41,13,41,27,0],[43,13,43,25,0],[44,9,44,10,0],[47,9,47,10,0],[48,13,48,41,0],[49,13,49,31,0],[51,13,51,27,0],[52,13,52,14,0],[53,17,53,90,0],[54,17,54,34,0],[55,13,55,14,0],[56,9,56,10,0],[59,9,59,10,0],[60,13,60,43,0],[61,13,61,33,0],[63,13,63,27,0],[64,13,64,14,0],[65,17,65,95,0],[66,17,66,36,0],[67,13,67,14,0],[68,9,68,10,0],[70,39,70,43,0],[70,44,70,48,0],[73,9,73,10,0],[74,13,74,50,0],[76,13,76,20,0],[76,22,76,30,0],[76,31,76,33,0],[76,34,76,105,0],[77,13,77,14,0],[78,17,78,51,0],[79,17,79,36,0],[80,17,80,33,0],[81,13,81,14,0],[83,13,83,24,0],[84,9,84,10,0],[88,9,88,10,0],[89,13,89,50,0],[90,13,90,87,0],[92,13,92,51,0],[95,13,95,79,0],[96,13,96,54,0],[98,13,98,77,0],[99,9,99,10,0],[102,9,102,10,0],[103,13,103,73,0],[104,13,104,36,0],[105,9,105,10,0],[109,9,109,10,0],[111,13,111,32,0],[112,13,112,37,0],[114,13,114,44,0],[115,13,115,42,0],[117,13,117,35,0],[118,13,118,14,0],[119,17,119,32,0],[122,17,122,95,0],[124,17,124,58,0],[125,21,125,58,0],[128,17,128,41,0],[130,17,130,74,0],[133,17,133,39,0],[134,17,134,126,0],[135,17,135,18,0],[136,21,136,43,0],[137,21,137,22,0],[139,25,139,89,0],[140,25,140,93,0],[141,25,141,102,0],[142,25,142,51,0],[143,25,143,67,0],[144,25,144,60,0],[147,25,147,71,0],[149,25,149,114,0],[151,25,151,50,0],[211,21,211,22,0],[212,17,212,18,0],[215,17,215,52,0],[216,17,216,80,0],[217,17,217,24,0],[217,26,217,34,0],[217,35,217,37,0],[217,38,217,56,0],[218,17,218,18,0],[219,21,219,56,0],[220,21,220,22,0],[221,25,221,70,0],[223,25,223,56,0],[225,21,225,22,0],[226,17,226,18,0],[228,17,228,24,0],[228,26,228,40,0],[228,41,228,43,0],[228,44,228,47,0],[229,17,229,18,0],[230,21,230,69,0],[231,17,231,18,0],[233,17,233,41,0],[236,17,236,77,0],[237,17,237,24,0],[237,26,237,40,0],[237,41,237,43,0],[237,44,237,58,0],[238,17,238,18,0],[239,21,239,62,0],[240,21,240,22,0],[241,25,241,54,0],[242,25,242,74,0],[243,21,243,22,0],[244,17,244,18,0],[245,17,245,42,0],[248,17,248,81,0],[249,17,249,24,0],[249,26,249,44,0],[249,45,249,47,0],[249,48,249,64,0],[250,17,250,18,0],[251,21,251,61,0],[251,62,251,71,0],[252,21,252,102,0],[253,21,253,51,0],[254,21,254,22,0],[255,25,255,68,0],[256,21,256,22,0],[257,17,257,18,0],[258,17,258,44,0],[261,17,261,71,0],[262,17,262,24,0],[262,26,262,37,0],[262,38,262,40,0],[262,41,262,52,0],[263,17,263,18,0],[264,21,264,59,0],[265,21,265,22,0],[266,25,266,112,0],[267,21,267,22,0],[268,17,268,18,0],[269,17,269,39,0],[272,17,272,89,0],[273,17,273,24,0],[273,26,273,42,0],[273,43,273,45,0],[273,46,273,66,0],[274,17,274,18,0],[275,21,275,64,0],[276,21,276,22,0],[277,25,277,72,0],[278,25,278,81,0],[279,21,279,22,0],[280,17,280,18,0],[281,17,281,48,0],[284,17,284,77,0],[285,17,285,24,0],[285,26,285,36,0],[285,37,285,39,0],[285,40,285,54,0],[286,17,286,18,0],[287,21,287,58,0],[288,21,288,22,0],[289,25,289,66,0],[291,25,291,77,0],[292,21,292,22,0],[293,17,293,18,0],[294,17,294,42,0],[297,17,297,77,0],[298,17,298,24,0],[298,26,298,34,0],[298,35,298,37,0],[298,38,298,52,0],[299,17,299,18,0],[300,21,300,56,0],[301,21,301,22,0],[302,25,302,99,0],[303,25,303,76,0],[304,21,304,22,0],[305,17,305,18,0],[306,17,306,42,0],[309,17,309,24,0],[309,26,309,38,0],[309,39,309,41,0],[309,42,309,52,0],[310,17,310,18,0],[311,21,311,87,0],[312,17,312,18,0],[315,17,315,69,0],[316,17,316,18,0],[317,21,317,81,0],[318,21,318,58,0],[319,21,319,95,0],[320,21,320,44,0],[321,17,321,18,0],[324,17,324,65,0],[325,17,325,18,0],[327,21,327,22,0],[328,25,328,59,0],[329,25,329,86,0],[330,25,330,87,0],[333,25,333,45,0],[334,25,334,26,0],[335,29,335,90,0],[336,29,336,52,0],[337,25,337,26,0],[338,21,338,22,0],[339,21,339,26,0],[339,27,339,28,0],[339,29,339,30,0],[340,17,340,18,0],[342,17,342,67,0],[344,17,344,51,0],[345,21,345,51,0],[347,17,347,57,0],[348,17,348,41,0],[354,17,354,87,0],[355,17,355,84,0],[356,17,356,18,0],[357,21,357,84,0],[358,17,358,18,0],[361,17,361,147,0],[362,17,362,73,0],[364,17,364,45,0],[366,17,366,51,0],[367,21,367,66,0],[369,17,369,32,0],[372,17,372,57,0],[373,17,373,51,0],[375,17,375,45,0],[376,13,376,14,0],[378,9,378,10,0],[381,9,381,10,0],[382,13,382,113,0],[383,13,383,14,0],[385,17,385,68,0],[386,17,386,49,0],[387,13,387,14,0],[389,13,389,43,0],[390,13,390,14,0],[391,17,391,29,0],[392,13,392,14,0],[393,9,393,10,0],[406,9,406,10,0],[407,13,407,36,0],[408,17,408,37,0],[409,9,409,10,0],[413,9,413,10,0],[414,13,414,35,0],[415,17,415,36,0],[416,9,416,10,0],[420,9,420,10,0],[421,13,421,29,0],[422,17,422,30,0],[423,9,423,10,0],[427,9,427,10,0],[428,13,428,38,0],[429,17,429,39,0],[430,9,430,10,0],[434,9,434,10,0],[435,13,435,37,0],[436,17,436,38,0],[437,9,437,10,0],[441,9,441,10,0],[442,13,442,39,0],[443,17,443,40,0],[444,9,444,10,0],[448,9,448,10,0],[449,13,449,38,0],[450,17,450,39,0],[451,9,451,10,0]]);
    </script>
  </body>
</html>