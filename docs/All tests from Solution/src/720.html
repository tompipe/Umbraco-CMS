<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\PublishedContentExtensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Web;
using Examine.LuceneEngine.SearchCriteria;
using Umbraco.Core.Models;
using Umbraco.Core.Models.PublishedContent;
using Umbraco.Core.Services;
using Umbraco.Web.Models;
using Umbraco.Core;
using Umbraco.Web.Routing;
using ContentType = umbraco.cms.businesslogic.ContentType;

namespace Umbraco.Web
{
    /// &lt;summary&gt;
    /// Provides extension methods for &lt;c&gt;IPublishedContent&lt;/c&gt;.
    /// &lt;/summary&gt;
	public static class PublishedContentExtensions
    {
        #region Key

        public static Guid GetKey(this IPublishedContent content)
        {
            var contentWithKey = content as IPublishedContentWithKey;
            return contentWithKey == null ? Guid.Empty : contentWithKey.Key;
        }

        #endregion

        #region Urls

        /// &lt;summary&gt;
		/// Gets the url for the content.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
		/// &lt;returns&gt;The url for the content.&lt;/returns&gt;
		[Obsolete(&quot;NiceUrl() is obsolete, use the Url() method instead&quot;)]
		public static string NiceUrl(this IPublishedContent content)
		{
			return content.Url();
		}

		/// &lt;summary&gt;
		/// Gets the url for the content.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
		/// &lt;returns&gt;The url for the content.&lt;/returns&gt;
		/// &lt;remarks&gt;Better use the &lt;c&gt;Url&lt;/c&gt; property but that method is here to complement &lt;c&gt;UrlAbsolute()&lt;/c&gt;.&lt;/remarks&gt;
		public static string Url(this IPublishedContent content)
		{
		    return content.Url;
		}

		/// &lt;summary&gt;
		/// Gets the absolute url for the content.
		/// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
		/// &lt;returns&gt;The absolute url for the content.&lt;/returns&gt;
		[Obsolete(&quot;NiceUrlWithDomain() is obsolete, use the UrlAbsolute() method instead.&quot;)]
		public static string NiceUrlWithDomain(this IPublishedContent content)
		{
            return content.UrlAbsolute();
		}

		/// &lt;summary&gt;
		/// Gets the absolute url for the content.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
		/// &lt;returns&gt;The absolute url for the content.&lt;/returns&gt;
        //[Obsolete(&quot;UrlWithDomain() is obsolete, use the UrlAbsolute() method instead.&quot;)]
        public static string UrlWithDomain(this IPublishedContent content)
		{
		    return content.UrlAbsolute();
		}

        /// &lt;summary&gt;
        /// Gets the absolute url for the content.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;The absolute url for the content.&lt;/returns&gt;
        public static string UrlAbsolute(this IPublishedContent content)
        {
            // adapted from PublishedContentBase.Url
            switch (content.ItemType)
            {
                case PublishedItemType.Content:
                    if (UmbracoContext.Current == null)
                        throw new InvalidOperationException(&quot;Cannot resolve a Url for a content item when UmbracoContext.Current is null.&quot;);
                    if (UmbracoContext.Current.UrlProvider == null)
                        throw new InvalidOperationException(&quot;Cannot resolve a Url for a content item when UmbracoContext.Current.UrlProvider is null.&quot;);
                    return UmbracoContext.Current.UrlProvider.GetUrl(content.Id, true);
                case PublishedItemType.Media:
                    throw new NotSupportedException(&quot;AbsoluteUrl is not supported for media types.&quot;);
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        #endregion

        #region Template

        /// &lt;summary&gt;
		/// Returns the current template Alias
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;content&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static string GetTemplateAlias(this IPublishedContent content)
        {
            var template = ApplicationContext.Current.Services.FileService.GetTemplate(content.TemplateId);
			return template == null ? string.Empty : template.Alias;
		}

        #endregion

        #region IsComposedOf

        /// &lt;summary&gt;
        /// Gets a value indicating whether the content is of a content type composed of the given alias
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The content type alias.&lt;/param&gt;
        /// &lt;returns&gt;A value indicating whether the content is of a content type composed of a content type identified by the alias.&lt;/returns&gt;
        public static bool IsComposedOf(this IPublishedContent content, string alias)
        {
            return content.ContentType.CompositionAliases.Contains(alias);
        }

        #endregion

        #region HasProperty

        /// &lt;summary&gt;
        /// Gets a value indicating whether the content has a property identified by its alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;returns&gt;A value indicating whether the content has the property identified by the alias.&lt;/returns&gt;
        /// &lt;remarks&gt;The content may have a property, and that property may not have a value.&lt;/remarks&gt;
        public static bool HasProperty(this IPublishedContent content, string alias)
        {
            return content.ContentType.GetPropertyType(alias) != null;
        }

        #endregion

        #region HasValue

        /// &lt;summary&gt;
        /// Gets a value indicating whether the content has a value for a property identified by its alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;returns&gt;A value indicating whether the content has a value for the property identified by the alias.&lt;/returns&gt;
        /// &lt;remarks&gt;Returns true if &lt;c&gt;GetProperty(alias)&lt;/c&gt; is not &lt;c&gt;null&lt;/c&gt; and &lt;c&gt;GetProperty(alias).HasValue&lt;/c&gt; is &lt;c&gt;true&lt;/c&gt;.&lt;/remarks&gt;
        public static bool HasValue(this IPublishedContent content, string alias)
        {
            return content.HasValue(alias, false);
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether the content has a value for a property identified by its alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;param name=&quot;recurse&quot;&gt;A value indicating whether to navigate the tree upwards until a property with a value is found.&lt;/param&gt;
        /// &lt;returns&gt;A value indicating whether the content has a value for the property identified by the alias.&lt;/returns&gt;
        /// &lt;remarks&gt;Returns true if &lt;c&gt;GetProperty(alias, recurse)&lt;/c&gt; is not &lt;c&gt;null&lt;/c&gt; and &lt;c&gt;GetProperty(alias, recurse).HasValue&lt;/c&gt; is &lt;c&gt;true&lt;/c&gt;.&lt;/remarks&gt;
        public static bool HasValue(this IPublishedContent content, string alias, bool recurse)
        {
            var prop = content.GetProperty(alias, recurse);
            return prop != null &amp;&amp; prop.HasValue;
        }

        /// &lt;summary&gt;
        /// Returns one of two strings depending on whether the content has a value for a property identified by its alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;param name=&quot;valueIfTrue&quot;&gt;The value to return if the content has a value for the property.&lt;/param&gt;
        /// &lt;param name=&quot;valueIfFalse&quot;&gt;The value to return if the content has no value for the property.&lt;/param&gt;
        /// &lt;returns&gt;Either &lt;paramref name=&quot;valueIfTrue&quot;/&gt; or &lt;paramref name=&quot;valueIfFalse&quot;/&gt; depending on whether the content
        /// has a value for the property identified by the alias.&lt;/returns&gt;
        public static IHtmlString HasValue(this IPublishedContent content, string alias,
            string valueIfTrue, string valueIfFalse = null)
        {
            return content.HasValue(alias, false)
                ? new HtmlString(valueIfTrue)
                : new HtmlString(valueIfFalse ?? string.Empty);
        }

        /// &lt;summary&gt;
        /// Returns one of two strings depending on whether the content has a value for a property identified by its alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;param name=&quot;recurse&quot;&gt;A value indicating whether to navigate the tree upwards until a property with a value is found.&lt;/param&gt;
        /// &lt;param name=&quot;valueIfTrue&quot;&gt;The value to return if the content has a value for the property.&lt;/param&gt;
        /// &lt;param name=&quot;valueIfFalse&quot;&gt;The value to return if the content has no value for the property.&lt;/param&gt;
        /// &lt;returns&gt;Either &lt;paramref name=&quot;valueIfTrue&quot;/&gt; or &lt;paramref name=&quot;valueIfFalse&quot;/&gt; depending on whether the content
        /// has a value for the property identified by the alias.&lt;/returns&gt;
        public static IHtmlString HasValue(this IPublishedContent content, string alias, bool recurse,
            string valueIfTrue, string valueIfFalse = null)
        {
            return content.HasValue(alias, recurse)
                ? new HtmlString(valueIfTrue)
                : new HtmlString(valueIfFalse ?? string.Empty);
        }

        #endregion

        #region GetPropertyValue

        /// &lt;summary&gt;
        /// Gets the value of a content&#39;s property identified by its alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;returns&gt;The value of the content&#39;s property identified by the alias.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The value comes from &lt;c&gt;IPublishedProperty&lt;/c&gt; field &lt;c&gt;Value&lt;/c&gt; ie it is suitable for use when rendering content.&lt;/para&gt;
        /// &lt;para&gt;If no property with the specified alias exists, or if the property has no value, returns &lt;c&gt;null&lt;/c&gt;.&lt;/para&gt;
        /// &lt;para&gt;If eg a numeric property wants to default to 0 when value source is empty, this has to be done in the converter.&lt;/para&gt;
        /// &lt;para&gt;The alias is case-insensitive.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static object GetPropertyValue(this IPublishedContent content, string alias)
        {
            var property = content.GetProperty(alias);
            return property == null ? null : property.Value;
		}

        /// &lt;summary&gt;
        /// Gets the value of a content&#39;s property identified by its alias, if it exists, otherwise a default value.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;param name=&quot;defaultValue&quot;&gt;The default value.&lt;/param&gt;
        /// &lt;returns&gt;The value of the content&#39;s property identified by the alias, if it exists, otherwise a default value.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The value comes from &lt;c&gt;IPublishedProperty&lt;/c&gt; field &lt;c&gt;Value&lt;/c&gt; ie it is suitable for use when rendering content.&lt;/para&gt;
        /// &lt;para&gt;If no property with the specified alias exists, or if the property has no value, returns &lt;paramref name=&quot;defaultValue&quot;/&gt;.&lt;/para&gt;
        /// &lt;para&gt;If eg a numeric property wants to default to 0 when value source is empty, this has to be done in the converter.&lt;/para&gt;
        /// &lt;para&gt;The alias is case-insensitive.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static object GetPropertyValue(this IPublishedContent content, string alias, string defaultValue)
        {
            var property = content.GetProperty(alias);
            return property == null || property.HasValue == false ? defaultValue : property.Value;
        }

        /// &lt;summary&gt;
        /// Gets the value of a content&#39;s property identified by its alias, if it exists, otherwise a default value.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;param name=&quot;defaultValue&quot;&gt;The default value.&lt;/param&gt;
        /// &lt;returns&gt;The value of the content&#39;s property identified by the alias, if it exists, otherwise a default value.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The value comes from &lt;c&gt;IPublishedProperty&lt;/c&gt; field &lt;c&gt;Value&lt;/c&gt; ie it is suitable for use when rendering content.&lt;/para&gt;
        /// &lt;para&gt;If no property with the specified alias exists, or if the property has no value, returns &lt;paramref name=&quot;defaultValue&quot;/&gt;.&lt;/para&gt;
        /// &lt;para&gt;If eg a numeric property wants to default to 0 when value source is empty, this has to be done in the converter.&lt;/para&gt;
        /// &lt;para&gt;The alias is case-insensitive.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static object GetPropertyValue(this IPublishedContent content, string alias, object defaultValue)
        {
            var property = content.GetProperty(alias);
            return property == null || property.HasValue == false ? defaultValue : property.Value;
        }

        /// &lt;summary&gt;
        /// Recursively gets the value of a content&#39;s property identified by its alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;param name=&quot;recurse&quot;&gt;A value indicating whether to recurse.&lt;/param&gt;
        /// &lt;returns&gt;The recursive value of the content&#39;s property identified by the alias.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Recursively means: walking up the tree from &lt;paramref name=&quot;content&quot;/&gt;, get the first value that can be found.&lt;/para&gt;
        /// &lt;para&gt;The value comes from &lt;c&gt;IPublishedProperty&lt;/c&gt; field &lt;c&gt;Value&lt;/c&gt; ie it is suitable for use when rendering content.&lt;/para&gt;
        /// &lt;para&gt;If no property with the specified alias exists, or if the property has no value, returns &lt;c&gt;null&lt;/c&gt;.&lt;/para&gt;
        /// &lt;para&gt;If eg a numeric property wants to default to 0 when value source is empty, this has to be done in the converter.&lt;/para&gt;
        /// &lt;para&gt;The alias is case-insensitive.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static object GetPropertyValue(this IPublishedContent content, string alias, bool recurse)
        {
            var property = content.GetProperty(alias, recurse);
            return property == null ? null : property.Value;
        }

        /// &lt;summary&gt;
        /// Recursively the value of a content&#39;s property identified by its alias, if it exists, otherwise a default value.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;param name=&quot;recurse&quot;&gt;A value indicating whether to recurse.&lt;/param&gt;
        /// &lt;param name=&quot;defaultValue&quot;&gt;The default value.&lt;/param&gt;
        /// &lt;returns&gt;The value of the content&#39;s property identified by the alias, if it exists, otherwise a default value.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Recursively means: walking up the tree from &lt;paramref name=&quot;content&quot;/&gt;, get the first value that can be found.&lt;/para&gt;
        /// &lt;para&gt;The value comes from &lt;c&gt;IPublishedProperty&lt;/c&gt; field &lt;c&gt;Value&lt;/c&gt; ie it is suitable for use when rendering content.&lt;/para&gt;
        /// &lt;para&gt;If no property with the specified alias exists, or if the property has no value, returns &lt;paramref name=&quot;defaultValue&quot;/&gt;.&lt;/para&gt;
        /// &lt;para&gt;If eg a numeric property wants to default to 0 when value source is empty, this has to be done in the converter.&lt;/para&gt;
        /// &lt;para&gt;The alias is case-insensitive.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static object GetPropertyValue(this IPublishedContent content, string alias, bool recurse, object defaultValue)
        {
            var property = content.GetProperty(alias, recurse);
            return property == null || property.HasValue == false ? defaultValue : property.Value;
        }

        #endregion

        #region GetPropertyValue&lt;T&gt;

        /// &lt;summary&gt;
        /// Gets the value of a content&#39;s property identified by its alias, converted to a specified type.
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;The target property type.&lt;/typeparam&gt;
		/// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;returns&gt;The value of the content&#39;s property identified by the alias, converted to the specified type.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The value comes from &lt;c&gt;IPublishedProperty&lt;/c&gt; field &lt;c&gt;Value&lt;/c&gt; ie it is suitable for use when rendering content.&lt;/para&gt;
        /// &lt;para&gt;If no property with the specified alias exists, or if the property has no value, or if it could not be converted, returns &lt;c&gt;default(T)&lt;/c&gt;.&lt;/para&gt;
        /// &lt;para&gt;If eg a numeric property wants to default to 0 when value source is empty, this has to be done in the converter.&lt;/para&gt;
        /// &lt;para&gt;The alias is case-insensitive.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static T GetPropertyValue&lt;T&gt;(this IPublishedContent content, string alias)
		{
			return content.GetPropertyValue(alias, false, false, default(T));
		}

        /// &lt;summary&gt;
        /// Gets the value of a content&#39;s property identified by its alias, converted to a specified type, if it exists, otherwise a default value.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The target property type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;param name=&quot;defaultValue&quot;&gt;The default value.&lt;/param&gt;
        /// &lt;returns&gt;The value of the content&#39;s property identified by the alias, converted to the specified type, if it exists, otherwise a default value.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The value comes from &lt;c&gt;IPublishedProperty&lt;/c&gt; field &lt;c&gt;Value&lt;/c&gt; ie it is suitable for use when rendering content.&lt;/para&gt;
        /// &lt;para&gt;If no property with the specified alias exists, or if the property has no value, or if it could not be converted, returns &lt;paramref name=&quot;defaultValue&quot;/&gt;.&lt;/para&gt;
        /// &lt;para&gt;If eg a numeric property wants to default to 0 when value source is empty, this has to be done in the converter.&lt;/para&gt;
        /// &lt;para&gt;The alias is case-insensitive.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static T GetPropertyValue&lt;T&gt;(this IPublishedContent content, string alias, T defaultValue)
        {
            return content.GetPropertyValue(alias, false, true, defaultValue);
        }

        /// &lt;summary&gt;
        /// Recursively gets the value of a content&#39;s property identified by its alias, converted to a specified type.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The target property type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;param name=&quot;recurse&quot;&gt;A value indicating whether to recurse.&lt;/param&gt;
        /// &lt;returns&gt;The value of the content&#39;s property identified by the alias, converted to the specified type.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Recursively means: walking up the tree from &lt;paramref name=&quot;content&quot;/&gt;, get the first value that can be found.&lt;/para&gt;
        /// &lt;para&gt;The value comes from &lt;c&gt;IPublishedProperty&lt;/c&gt; field &lt;c&gt;Value&lt;/c&gt; ie it is suitable for use when rendering content.&lt;/para&gt;
        /// &lt;para&gt;If no property with the specified alias exists, or if the property has no value, or if it could not be converted, returns &lt;c&gt;default(T)&lt;/c&gt;.&lt;/para&gt;
        /// &lt;para&gt;If eg a numeric property wants to default to 0 when value source is empty, this has to be done in the converter.&lt;/para&gt;
        /// &lt;para&gt;The alias is case-insensitive.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static T GetPropertyValue&lt;T&gt;(this IPublishedContent content, string alias, bool recurse)
        {
            return content.GetPropertyValue(alias, recurse, false, default(T));
        }

        /// &lt;summary&gt;
        /// Recursively gets the value of a content&#39;s property identified by its alias, converted to a specified type, if it exists, otherwise a default value.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The target property type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;param name=&quot;recurse&quot;&gt;A value indicating whether to recurse.&lt;/param&gt;
        /// &lt;param name=&quot;defaultValue&quot;&gt;The default value.&lt;/param&gt;
        /// &lt;returns&gt;The value of the content&#39;s property identified by the alias, converted to the specified type, if it exists, otherwise a default value.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Recursively means: walking up the tree from &lt;paramref name=&quot;content&quot;/&gt;, get the first value that can be found.&lt;/para&gt;
        /// &lt;para&gt;The value comes from &lt;c&gt;IPublishedProperty&lt;/c&gt; field &lt;c&gt;Value&lt;/c&gt; ie it is suitable for use when rendering content.&lt;/para&gt;
        /// &lt;para&gt;If no property with the specified alias exists, or if the property has no value, or if it could not be converted, returns &lt;paramref name=&quot;defaultValue&quot;/&gt;.&lt;/para&gt;
        /// &lt;para&gt;If eg a numeric property wants to default to 0 when value source is empty, this has to be done in the converter.&lt;/para&gt;
        /// &lt;para&gt;The alias is case-insensitive.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static T GetPropertyValue&lt;T&gt;(this IPublishedContent content, string alias, bool recurse, T defaultValue)
        {
            return content.GetPropertyValue(alias, recurse, true, defaultValue);
        }

        internal static T GetPropertyValue&lt;T&gt;(this IPublishedContent content, string alias, bool recurse, bool withDefaultValue, T defaultValue)
        {
            var property = content.GetProperty(alias, recurse);
            if (property == null) return defaultValue;

            return property.GetValue(withDefaultValue, defaultValue);
		}

		#endregion

        // copied over from Core.PublishedContentExtensions - should be obsoleted
        [Obsolete(&quot;GetRecursiveValue() is obsolete, use GetPropertyValue().&quot;)]
        public static string GetRecursiveValue(this IPublishedContent content, string alias)
        {
            var value = content.GetPropertyValue(alias, true);
            return value == null ? string.Empty : value.ToString();
        }

		#region Search

        public static IEnumerable&lt;IPublishedContent&gt; Search(this IPublishedContent content, string term, bool useWildCards = true, string searchProvider = null)
		{
			var searcher = Examine.ExamineManager.Instance.DefaultSearchProvider;
			if (string.IsNullOrEmpty(searchProvider) == false)
				searcher = Examine.ExamineManager.Instance.SearchProviderCollection[searchProvider];

			var t = term.Escape().Value;
			if (useWildCards)
				t = term.MultipleCharacterWildcard().Value;

			var luceneQuery = &quot;+__Path:(&quot; + content.Path.Replace(&quot;-&quot;, &quot;\\-&quot;) + &quot;*) +&quot; + t;
			var crit = searcher.CreateSearchCriteria().RawQuery(luceneQuery);

			return content.Search(crit, searcher);
		}

        public static IEnumerable&lt;IPublishedContent&gt; SearchDescendants(this IPublishedContent content, string term, bool useWildCards = true, string searchProvider = null)
		{
			return content.Search(term, useWildCards, searchProvider);
		}

        public static IEnumerable&lt;IPublishedContent&gt; SearchChildren(this IPublishedContent content, string term, bool useWildCards = true, string searchProvider = null)
		{
			var searcher = Examine.ExamineManager.Instance.DefaultSearchProvider;
			if (string.IsNullOrEmpty(searchProvider) == false)
				searcher = Examine.ExamineManager.Instance.SearchProviderCollection[searchProvider];

			var t = term.Escape().Value;
			if (useWildCards)
				t = term.MultipleCharacterWildcard().Value;

			var luceneQuery = &quot;+parentID:&quot; + content.Id + &quot; +&quot; + t;
			var crit = searcher.CreateSearchCriteria().RawQuery(luceneQuery);

			return content.Search(crit, searcher);
		}

        public static IEnumerable&lt;IPublishedContent&gt; Search(this IPublishedContent content, Examine.SearchCriteria.ISearchCriteria criteria, Examine.Providers.BaseSearchProvider searchProvider = null)
		{
			var s = Examine.ExamineManager.Instance.DefaultSearchProvider;
			if (searchProvider != null)
				s = searchProvider;

			var results = s.Search(criteria);
			return results.ConvertSearchResultToPublishedContent(UmbracoContext.Current.ContentCache);
		}

		#endregion

        #region ToContentSet

        /// &lt;summary&gt;
        /// Returns the content enumerable as a content set.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;source&quot;&gt;The content enumerable.&lt;/param&gt;
        /// &lt;returns&gt;A content set wrapping the content enumerable.&lt;/returns&gt;
        public static PublishedContentSet&lt;T&gt; ToContentSet&lt;T&gt;(this IEnumerable&lt;T&gt; source)
            where T : class, IPublishedContent
        {
            return new PublishedContentSet&lt;T&gt;(source);
        }

        /// &lt;summary&gt;
        /// Returns the ordered content enumerable as an ordered content set.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;source&quot;&gt;The ordered content enumerable.&lt;/param&gt;
        /// &lt;returns&gt;A ordered content set wrapping the ordered content enumerable.&lt;/returns&gt;
        public static PublishedContentOrderedSet&lt;T&gt; ToContentSet&lt;T&gt;(this IOrderedEnumerable&lt;T&gt; source)
            where T : class, IPublishedContent
        {
            return new PublishedContentOrderedSet&lt;T&gt;(source);
        }

        #endregion

        #region Dynamic Linq Extensions

        // todo - we should keep this file clean and remove dynamic linq stuff from it

        public static IQueryable&lt;IPublishedContent&gt; OrderBy(this IEnumerable&lt;IPublishedContent&gt; source, string predicate)
		{
			var dList = new DynamicPublishedContentList(source);
			return dList.OrderBy&lt;DynamicPublishedContent&gt;(predicate);
		}

		public static IQueryable&lt;IPublishedContent&gt; Where(this IEnumerable&lt;IPublishedContent&gt; list, string predicate)
		{
            // wrap in DynamicPublishedContentList so that the ContentSet is correct
            // though that code is somewhat ugly.

		    var dlist = new DynamicPublishedContentList(new DynamicPublishedContentList(list)
		                                                    .Where&lt;DynamicPublishedContent&gt;(predicate));

		    return dlist.AsQueryable&lt;IPublishedContent&gt;();
		}

		public static IEnumerable&lt;IGrouping&lt;object, IPublishedContent&gt;&gt; GroupBy(this IEnumerable&lt;IPublishedContent&gt; list, string predicate)
		{
			var dList = new DynamicPublishedContentList(list);
			return dList.GroupBy(predicate);
		}

		public static IQueryable Select(this IEnumerable&lt;IPublishedContent&gt; list, string predicate, params object[] values)
		{
			var dList = new DynamicPublishedContentList(list);
			return dList.Select(predicate);
		}

        public static HtmlString Where(this IPublishedContent content, string predicate, string valueIfTrue)
        {
            if (content == null) throw new ArgumentNullException(&quot;content&quot;);
            return content.Where(predicate, valueIfTrue, string.Empty);
        }

        public static HtmlString Where(this IPublishedContent content, string predicate, string valueIfTrue, string valueIfFalse)
        {
            if (content == null) throw new ArgumentNullException(&quot;content&quot;);
            return new HtmlString(content.Where(predicate) ? valueIfTrue : valueIfFalse);
        }

        public static bool Where(this IPublishedContent content, string predicate)
        {
            if (content == null) throw new ArgumentNullException(&quot;content&quot;);
            var dynamicDocumentList = new DynamicPublishedContentList { content.AsDynamicOrNull() };
            var filtered = dynamicDocumentList.Where&lt;DynamicPublishedContent&gt;(predicate);
            return filtered.Count() == 1;
        }
        
        #endregion

        #region AsDynamic

        // it is ok to have dynamic here

        // content should NOT be null
		public static dynamic AsDynamic(this IPublishedContent content)
		{
			if (content == null) throw new ArgumentNullException(&quot;content&quot;);
			return new DynamicPublishedContent(content);
		}

        // content CAN be null
        internal static DynamicPublishedContent AsDynamicOrNull(this IPublishedContent content)
		{
		    return content == null ? null : new DynamicPublishedContent(content);
		}

        #endregion

		#region ContentSet

		public static int Position(this IPublishedContent content)
		{
			return content.GetIndex();
		}

        public static int Index(this IPublishedContent content)
        {
            return content.GetIndex();
        }

        private static int GetIndex(this IPublishedContent content, IEnumerable&lt;IPublishedContent&gt; set)
        {
            var index = set.FindIndex(n =&gt; n.Id == content.Id);
            if (index &lt; 0)
                throw new IndexOutOfRangeException(&quot;Could not find content in the content set.&quot;);
            return index;
        }

		#endregion

		#region IsSomething: misc.

        /// &lt;summary&gt;
        /// Gets a value indicating whether the content is visible.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;A value indicating whether the content is visible.&lt;/returns&gt;
        /// &lt;remarks&gt;A content is not visible if it has an umbracoNaviHide property with a value of &quot;1&quot;. Otherwise,
        /// the content is visible.&lt;/remarks&gt;
        public static bool IsVisible(this IPublishedContent content)
        {
            // note: would be better to ensure we have an IPropertyEditorValueConverter for booleans
            // and then treat the umbracoNaviHide property as a boolean - vs. the hard-coded &quot;1&quot;.

            // rely on the property converter - will return default bool value, ie false, if property
            // is not defined, or has no value, else will return its value.
            return content.GetPropertyValue&lt;bool&gt;(Constants.Conventions.Content.NaviHide) == false;
        }

        /// &lt;summary&gt;
        /// Determines whether the specified content is a specified content type.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content to determine content type of.&lt;/param&gt;
        /// &lt;param name=&quot;docTypeAlias&quot;&gt;The alias of the content type to test against.&lt;/param&gt;
        /// &lt;returns&gt;True if the content is of the specified content type; otherwise false.&lt;/returns&gt;
	    public static bool IsDocumentType(this IPublishedContent content, string docTypeAlias)
	    {
	        return content.DocumentTypeAlias.InvariantEquals(docTypeAlias);
	    }

	    /// &lt;summary&gt;
	    /// Determines whether the specified content is a specified content type or it&#39;s derived types.
	    /// &lt;/summary&gt;
	    /// &lt;param name=&quot;content&quot;&gt;The content to determine content type of.&lt;/param&gt;
	    /// &lt;param name=&quot;docTypeAlias&quot;&gt;The alias of the content type to test against.&lt;/param&gt;
	    /// &lt;param name=&quot;recursive&quot;&gt;When true, recurses up the content type tree to check inheritance; when false just calls IsDocumentType(this IPublishedContent content, string docTypeAlias).&lt;/param&gt;
	    /// &lt;returns&gt;True if the content is of the specified content type or a derived content type; otherwise false.&lt;/returns&gt;
	    public static bool IsDocumentType(this IPublishedContent content, string docTypeAlias, bool recursive)
		{
			if (content.IsDocumentType(docTypeAlias))
				return true;

			if (recursive)
				return IsDocumentTypeRecursive(content, docTypeAlias);
			return false;
		}

		private static bool IsDocumentTypeRecursive(IPublishedContent content, string docTypeAlias)
		{
			var contentTypeService = UmbracoContext.Current.Application.Services.ContentTypeService;
			var type = contentTypeService.GetContentType(content.DocumentTypeAlias);
			while (type != null &amp;&amp; type.ParentId &gt; 0)
			{
				type = contentTypeService.GetContentType(type.ParentId);
				if (type.Alias.InvariantEquals(docTypeAlias))
					return true;
			}
			return false;
		}

		public static bool IsNull(this IPublishedContent content, string alias, bool recurse)
		{
		    return content.HasValue(alias, recurse) == false;
		}

		public static bool IsNull(this IPublishedContent content, string alias)
		{
		    return content.HasValue(alias) == false;
		}

        #endregion

        #region IsSomething: position in set

        public static bool IsFirst(this IPublishedContent content)
        {
            return content.GetIndex() == 0;
        }

        public static HtmlString IsFirst(this IPublishedContent content, string valueIfTrue)
        {
            return content.IsFirst(valueIfTrue, string.Empty);
        }

        public static HtmlString IsFirst(this IPublishedContent content, string valueIfTrue, string valueIfFalse)
        {
            return new HtmlString(content.IsFirst() ? valueIfTrue : valueIfFalse);
        }

        public static bool IsNotFirst(this IPublishedContent content)
        {
            return content.IsFirst() == false;
        }

        public static HtmlString IsNotFirst(this IPublishedContent content, string valueIfTrue)
        {
            return content.IsNotFirst(valueIfTrue, string.Empty);
        }

        public static HtmlString IsNotFirst(this IPublishedContent content, string valueIfTrue, string valueIfFalse)
        {
            return new HtmlString(content.IsNotFirst() ? valueIfTrue : valueIfFalse);
        }

        public static bool IsPosition(this IPublishedContent content, int index)
        {
            return content.GetIndex() == index;
        }

        public static HtmlString IsPosition(this IPublishedContent content, int index, string valueIfTrue)
        {
            return content.IsPosition(index, valueIfTrue, string.Empty);
        }

        public static HtmlString IsPosition(this IPublishedContent content, int index, string valueIfTrue, string valueIfFalse)
        {
            return new HtmlString(content.IsPosition(index) ? valueIfTrue : valueIfFalse);
        }

        public static bool IsModZero(this IPublishedContent content, int modulus)
        {
            return content.GetIndex() % modulus == 0;
        }

        public static HtmlString IsModZero(this IPublishedContent content, int modulus, string valueIfTrue)
        {
            return content.IsModZero(modulus, valueIfTrue, string.Empty);
        }

        public static HtmlString IsModZero(this IPublishedContent content, int modulus, string valueIfTrue, string valueIfFalse)
        {
            return new HtmlString(content.IsModZero(modulus) ? valueIfTrue : valueIfFalse);
        }

        public static bool IsNotModZero(this IPublishedContent content, int modulus)
        {
            return content.IsModZero(modulus) == false;
        }

        public static HtmlString IsNotModZero(this IPublishedContent content, int modulus, string valueIfTrue)
        {
            return content.IsNotModZero(modulus, valueIfTrue, string.Empty);
        }

        public static HtmlString IsNotModZero(this IPublishedContent content, int modulus, string valueIfTrue, string valueIfFalse)
        {
            return new HtmlString(content.IsNotModZero(modulus) ? valueIfTrue : valueIfFalse);
        }

        public static bool IsNotPosition(this IPublishedContent content, int index)
        {
            return content.IsPosition(index) == false;
        }

        public static HtmlString IsNotPosition(this IPublishedContent content, int index, string valueIfTrue)
        {
            return content.IsNotPosition(index, valueIfTrue, string.Empty);
        }

        public static HtmlString IsNotPosition(this IPublishedContent content, int index, string valueIfTrue, string valueIfFalse)
        {
            return new HtmlString(content.IsNotPosition(index) ? valueIfTrue : valueIfFalse);
        }

        public static bool IsLast(this IPublishedContent content)
        {
            return content.GetIndex() == content.ContentSet.Count() - 1;
        }

        public static HtmlString IsLast(this IPublishedContent content, string valueIfTrue)
        {
            return content.IsLast(valueIfTrue, string.Empty);
        }

        public static HtmlString IsLast(this IPublishedContent content, string valueIfTrue, string valueIfFalse)
        {
            return new HtmlString(content.IsLast() ? valueIfTrue : valueIfFalse);
        }

        public static bool IsNotLast(this IPublishedContent content)
        {
            return content.IsLast() == false;
        }

        public static HtmlString IsNotLast(this IPublishedContent content, string valueIfTrue)
        {
            return content.IsNotLast(valueIfTrue, string.Empty);
        }

        public static HtmlString IsNotLast(this IPublishedContent content, string valueIfTrue, string valueIfFalse)
        {
            return new HtmlString(content.IsNotLast() ? valueIfTrue : valueIfFalse);
        }

        public static bool IsEven(this IPublishedContent content)
        {
            return content.GetIndex() % 2 == 0;
        }

        public static HtmlString IsEven(this IPublishedContent content, string valueIfTrue)
        {
            return content.IsEven(valueIfTrue, string.Empty);
        }

        public static HtmlString IsEven(this IPublishedContent content, string valueIfTrue, string valueIfFalse)
        {
            return new HtmlString(content.IsEven() ? valueIfTrue : valueIfFalse);
        }

        public static bool IsOdd(this IPublishedContent content)
        {
            return content.GetIndex() % 2 == 1;
        }

        public static HtmlString IsOdd(this IPublishedContent content, string valueIfTrue)
        {
            return content.IsOdd(valueIfTrue, string.Empty);
        }

        public static HtmlString IsOdd(this IPublishedContent content, string valueIfTrue, string valueIfFalse)
        {
            return new HtmlString(content.IsOdd() ? valueIfTrue : valueIfFalse);
        } 

        #endregion

        #region IsSomething: equality

        public static bool IsEqual(this IPublishedContent content, IPublishedContent other)
		{
			return content.Id == other.Id;
		}

        public static HtmlString IsEqual(this IPublishedContent content, IPublishedContent other, string valueIfTrue)
        {
            return content.IsEqual(other, valueIfTrue, string.Empty);
        }

		public static HtmlString IsEqual(this IPublishedContent content, IPublishedContent other, string valueIfTrue, string valueIfFalse)
		{
			return new HtmlString(content.IsEqual(other) ? valueIfTrue : valueIfFalse);
		}

		public static bool IsNotEqual(this IPublishedContent content, IPublishedContent other)
		{
		    return content.IsEqual(other) == false;
		}

        public static HtmlString IsNotEqual(this IPublishedContent content, IPublishedContent other, string valueIfTrue)
        {
            return content.IsNotEqual(other, valueIfTrue, string.Empty);
        }
        
        public static HtmlString IsNotEqual(this IPublishedContent content, IPublishedContent other, string valueIfTrue, string valueIfFalse)
		{
			return new HtmlString(content.IsNotEqual(other) ? valueIfTrue : valueIfFalse);
		}

        #endregion

        #region IsSomething: ancestors and descendants

        public static bool IsDescendant(this IPublishedContent content, IPublishedContent other)
        {
            return content.Ancestors().Any(x =&gt; x.Id == other.Id);
		}

		public static HtmlString IsDescendant(this IPublishedContent content, IPublishedContent other, string valueIfTrue)
		{
		    return content.IsDescendant(other, valueIfTrue, string.Empty);
		}

		public static HtmlString IsDescendant(this IPublishedContent content, IPublishedContent other, string valueIfTrue, string valueIfFalse)
		{
            return new HtmlString(content.IsDescendant(other) ? valueIfTrue : valueIfFalse);
		}

		public static bool IsDescendantOrSelf(this IPublishedContent content, IPublishedContent other)
		{
            return content.AncestorsOrSelf().Any(x =&gt; x.Id == other.Id);
        }

		public static HtmlString IsDescendantOrSelf(this IPublishedContent content, IPublishedContent other, string valueIfTrue)
		{
            return content.IsDescendantOrSelf(other, valueIfTrue, string.Empty);
        }

		public static HtmlString IsDescendantOrSelf(this IPublishedContent content, IPublishedContent other, string valueIfTrue, string valueIfFalse)
		{
            return new HtmlString(content.IsDescendantOrSelf(other) ? valueIfTrue : valueIfFalse);
        }

		public static bool IsAncestor(this IPublishedContent content, IPublishedContent other)
		{
            // avoid using Descendants(), that&#39;s expensive
		    return other.Ancestors().Any(x =&gt; x.Id == content.Id);
		}

		public static HtmlString IsAncestor(this IPublishedContent content, IPublishedContent other, string valueIfTrue)
		{
            return content.IsAncestor(other, valueIfTrue, string.Empty);
        }

		public static HtmlString IsAncestor(this IPublishedContent content, IPublishedContent other, string valueIfTrue, string valueIfFalse)
		{
            return new HtmlString(content.IsAncestor(other) ? valueIfTrue : valueIfFalse);
        }

		public static bool IsAncestorOrSelf(this IPublishedContent content, IPublishedContent other)
		{
            // avoid using DescendantsOrSelf(), that&#39;s expensive
            return other.AncestorsOrSelf().Any(x =&gt; x.Id == content.Id);
        }

		public static HtmlString IsAncestorOrSelf(this IPublishedContent content, IPublishedContent other, string valueIfTrue)
		{
            return content.IsAncestorOrSelf(other, valueIfTrue, string.Empty);
        }

		public static HtmlString IsAncestorOrSelf(this IPublishedContent content, IPublishedContent other, string valueIfTrue, string valueIfFalse)
		{
            return new HtmlString(content.IsAncestorOrSelf(other) ? valueIfTrue : valueIfFalse);
        }

        #endregion

        #region Axes: ancestors, ancestors-or-self

        // as per XPath 1.0 specs �2.2,
        // - the ancestor axis contains the ancestors of the context node; the ancestors of the context node consist
        //   of the parent of context node and the parent&#39;s parent and so on; thus, the ancestor axis will always
        //   include the root node, unless the context node is the root node.
        // - the ancestor-or-self axis contains the context node and the ancestors of the context node; thus,
        //   the ancestor axis will always include the root node.
        //
        // as per XPath 2.0 specs �3.2.1.1,
        // - the ancestor axis is defined as the transitive closure of the parent axis; it contains the ancestors
        //   of the context node (the parent, the parent of the parent, and so on) - The ancestor axis includes the
        //   root node of the tree in which the context node is found, unless the context node is the root node.
        // - the ancestor-or-self axis contains the context node and the ancestors of the context node; thus,
        //   the ancestor-or-self axis will always include the root node.
        //
        // the ancestor and ancestor-or-self axis are reverse axes ie they contain the context node or nodes that
        // are before the context node in document order.
        //
        // document order is defined by �2.4.1 as:
        // - the root node is the first node.
        // - every node occurs before all of its children and descendants.
        // - the relative order of siblings is the order in which they occur in the children property of their parent node.
        // - children and descendants occur before following siblings.

        /// &lt;summary&gt;
        /// Gets the ancestors of the content.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;The ancestors of the content, in down-top order.&lt;/returns&gt;
        /// &lt;remarks&gt;Does not consider the content itself.&lt;/remarks&gt;
        public static IEnumerable&lt;IPublishedContent&gt; Ancestors(this IPublishedContent content)
        {
            return content.AncestorsOrSelf(false, null);
        }

        /// &lt;summary&gt;
        /// Gets the ancestors of the content, at a level lesser or equal to a specified level.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;maxLevel&quot;&gt;The level.&lt;/param&gt;
        /// &lt;returns&gt;The ancestors of the content, at a level lesser or equal to the specified level, in down-top order.&lt;/returns&gt;
        /// &lt;remarks&gt;Does not consider the content itself. Only content that are &quot;high enough&quot; in the tree are returned.&lt;/remarks&gt;
        public static IEnumerable&lt;IPublishedContent&gt; Ancestors(this IPublishedContent content, int maxLevel)
        {
            return content.AncestorsOrSelf(false, n =&gt; n.Level &lt;= maxLevel);
        }

        /// &lt;summary&gt;
        /// Gets the ancestors of the content, of a specified content type.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;contentTypeAlias&quot;&gt;The content type.&lt;/param&gt;
        /// &lt;returns&gt;The ancestors of the content, of the specified content type, in down-top order.&lt;/returns&gt;
        /// &lt;remarks&gt;Does not consider the content itself. Returns all ancestors, of the specified content type.&lt;/remarks&gt;
        public static IEnumerable&lt;IPublishedContent&gt; Ancestors(this IPublishedContent content, string contentTypeAlias)
        {
            return content.AncestorsOrSelf(false, n =&gt; n.DocumentTypeAlias == contentTypeAlias);
        }

        /// &lt;summary&gt;
        /// Gets the ancestors of the content, of a specified content type.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The content type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;The ancestors of the content, of the specified content type, in down-top order.&lt;/returns&gt;
        /// &lt;remarks&gt;Does not consider the content itself. Returns all ancestors, of the specified content type.&lt;/remarks&gt;
        public static IEnumerable&lt;T&gt; Ancestors&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.Ancestors().OfType&lt;T&gt;();
        }

        /// &lt;summary&gt;
        /// Gets the ancestors of the content, at a level lesser or equal to a specified level, and of a specified content type.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The content type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;maxLevel&quot;&gt;The level.&lt;/param&gt;
        /// &lt;returns&gt;The ancestors of the content, at a level lesser or equal to the specified level, and of the specified
        /// content type, in down-top order.&lt;/returns&gt;
        /// &lt;remarks&gt;Does not consider the content itself. Only content that are &quot;high enough&quot; in the trees, and of the
        /// specified content type, are returned.&lt;/remarks&gt;
        public static IEnumerable&lt;T&gt; Ancestors&lt;T&gt;(this IPublishedContent content, int maxLevel)
            where T : class, IPublishedContent
        {
            return content.Ancestors(maxLevel).OfType&lt;T&gt;();
        }

        /// &lt;summary&gt;
        /// Gets the content and its ancestors.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;The content and its ancestors, in down-top order.&lt;/returns&gt;
        public static IEnumerable&lt;IPublishedContent&gt; AncestorsOrSelf(this IPublishedContent content)
        {
            return content.AncestorsOrSelf(true, null);
        }

        /// &lt;summary&gt;
        /// Gets the content and its ancestors, at a level lesser or equal to a specified level.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;maxLevel&quot;&gt;The level.&lt;/param&gt;
        /// &lt;returns&gt;The content and its ancestors, at a level lesser or equal to the specified level,
        /// in down-top order.&lt;/returns&gt;
        /// &lt;remarks&gt;Only content that are &quot;high enough&quot; in the tree are returned. So it may or may not begin
        /// with the content itself, depending on its level.&lt;/remarks&gt;
        public static IEnumerable&lt;IPublishedContent&gt; AncestorsOrSelf(this IPublishedContent content, int maxLevel)
        {
            return content.AncestorsOrSelf(true, n =&gt; n.Level &lt;= maxLevel);
        }

        /// &lt;summary&gt;
        /// Gets the content and its ancestors, of a specified content type.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;contentTypeAlias&quot;&gt;The content type.&lt;/param&gt;
        /// &lt;returns&gt;The content and its ancestors, of the specified content type, in down-top order.&lt;/returns&gt;
        /// &lt;remarks&gt;May or may not begin with the content itself, depending on its content type.&lt;/remarks&gt;
        public static IEnumerable&lt;IPublishedContent&gt; AncestorsOrSelf(this IPublishedContent content, string contentTypeAlias)
        {
            return content.AncestorsOrSelf(true, n =&gt; n.DocumentTypeAlias == contentTypeAlias);
        }

        /// &lt;summary&gt;
        /// Gets the content and its ancestors, of a specified content type.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The content type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;The content and its ancestors, of the specified content type, in down-top order.&lt;/returns&gt;
        /// &lt;remarks&gt;May or may not begin with the content itself, depending on its content type.&lt;/remarks&gt;
        public static IEnumerable&lt;T&gt; AncestorsOrSelf&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.AncestorsOrSelf().OfType&lt;T&gt;();
        }

        /// &lt;summary&gt;
        /// Gets the content and its ancestor, at a lever lesser or equal to a specified level, and of a specified content type.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The content type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;maxLevel&quot;&gt;The level.&lt;/param&gt;
        /// &lt;returns&gt;The content and its ancestors, at a level lesser or equal to the specified level, and of the specified
        /// content type, in down-top order.&lt;/returns&gt;
        /// &lt;remarks&gt;May or may not begin with the content itself, depending on its level and content type.&lt;/remarks&gt;
        public static IEnumerable&lt;T&gt; AncestorsOrSelf&lt;T&gt;(this IPublishedContent content, int maxLevel)
            where T : class, IPublishedContent
        {
            return content.AncestorsOrSelf(maxLevel).OfType&lt;T&gt;();
        }

        /// &lt;summary&gt;
        /// Gets the ancestor of the content, ie its parent.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;The ancestor of the content.&lt;/returns&gt;
        /// &lt;remarks&gt;This method is here for consistency purposes but does not make much sense.&lt;/remarks&gt;
        public static IPublishedContent Ancestor(this IPublishedContent content)
        {
            return content.Parent;
        }

        /// &lt;summary&gt;
        /// Gets the nearest ancestor of the content, at a lever lesser or equal to a specified level.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;maxLevel&quot;&gt;The level.&lt;/param&gt;
        /// &lt;returns&gt;The nearest (in down-top order) ancestor of the content, at a level lesser or equal to the specified level.&lt;/returns&gt;
        /// &lt;remarks&gt;Does not consider the content itself. May return &lt;c&gt;null&lt;/c&gt;.&lt;/remarks&gt;
        public static IPublishedContent Ancestor(this IPublishedContent content, int maxLevel)
        {
            return content.EnumerateAncestors(false).FirstOrDefault(x =&gt; x.Level &lt;= maxLevel);
        }

        /// &lt;summary&gt;
        /// Gets the nearest ancestor of the content, of a specified content type.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;contentTypeAlias&quot;&gt;The content type alias.&lt;/param&gt;
        /// &lt;returns&gt;The nearest (in down-top order) ancestor of the content, of the specified content type.&lt;/returns&gt;
        /// &lt;remarks&gt;Does not consider the content itself. May return &lt;c&gt;null&lt;/c&gt;.&lt;/remarks&gt;
        public static IPublishedContent Ancestor(this IPublishedContent content, string contentTypeAlias)
        {
            return content.EnumerateAncestors(false).FirstOrDefault(x =&gt; x.DocumentTypeAlias == contentTypeAlias);
        }

        /// &lt;summary&gt;
        /// Gets the nearest ancestor of the content, of a specified content type.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The content type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;The nearest (in down-top order) ancestor of the content, of the specified content type.&lt;/returns&gt;
        /// &lt;remarks&gt;Does not consider the content itself. May return &lt;c&gt;null&lt;/c&gt;.&lt;/remarks&gt;
        public static T Ancestor&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.Ancestors&lt;T&gt;().FirstOrDefault();
        }

        /// &lt;summary&gt;
        /// Gets the nearest ancestor of the content, at the specified level and of the specified content type.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The content type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;maxLevel&quot;&gt;The level.&lt;/param&gt;
        /// &lt;returns&gt;The ancestor of the content, at the specified level and of the specified content type.&lt;/returns&gt;
        /// &lt;remarks&gt;Does not consider the content itself. If the ancestor at the specified level is
        /// not of the specified type, returns &lt;c&gt;null&lt;/c&gt;.&lt;/remarks&gt;
        public static T Ancestor&lt;T&gt;(this IPublishedContent content, int maxLevel)
            where T : class, IPublishedContent
        {
            return content.Ancestors&lt;T&gt;(maxLevel).FirstOrDefault();
        }
        
        /// &lt;summary&gt;
        /// Gets the content or its nearest ancestor.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;The content.&lt;/returns&gt;
        /// &lt;remarks&gt;This method is here for consistency purposes but does not make much sense.&lt;/remarks&gt;
        public static IPublishedContent AncestorOrSelf(this IPublishedContent content)
        {
            return content;
        }

        /// &lt;summary&gt;
        /// Gets the content or its nearest ancestor, at a lever lesser or equal to a specified level.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;maxLevel&quot;&gt;The level.&lt;/param&gt;
        /// &lt;returns&gt;The content or its nearest (in down-top order) ancestor, at a level lesser or equal to the specified level.&lt;/returns&gt;
        /// &lt;remarks&gt;May or may not return the content itself depending on its level. May return &lt;c&gt;null&lt;/c&gt;.&lt;/remarks&gt;
        public static IPublishedContent AncestorOrSelf(this IPublishedContent content, int maxLevel)
        {
            return content.EnumerateAncestors(true).FirstOrDefault(x =&gt; x.Level &lt;= maxLevel);
        }

        /// &lt;summary&gt;
        /// Gets the content or its nearest ancestor, of a specified content type.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;contentTypeAlias&quot;&gt;The content type.&lt;/param&gt;
        /// &lt;returns&gt;The content or its nearest (in down-top order) ancestor, of the specified content type.&lt;/returns&gt;
        /// &lt;remarks&gt;May or may not return the content itself depending on its content type. May return &lt;c&gt;null&lt;/c&gt;.&lt;/remarks&gt;
        public static IPublishedContent AncestorOrSelf(this IPublishedContent content, string contentTypeAlias)
        {
            return content.EnumerateAncestors(true).FirstOrDefault(x =&gt; x.DocumentTypeAlias == contentTypeAlias);
        }

        /// &lt;summary&gt;
        /// Gets the content or its nearest ancestor, of a specified content type.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The content type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;The content or its nearest (in down-top order) ancestor, of the specified content type.&lt;/returns&gt;
        /// &lt;remarks&gt;May or may not return the content itself depending on its content type. May return &lt;c&gt;null&lt;/c&gt;.&lt;/remarks&gt;
        public static T AncestorOrSelf&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.AncestorsOrSelf&lt;T&gt;().FirstOrDefault();
        }

        /// &lt;summary&gt;
        /// Gets the content or its nearest ancestor, at a lever lesser or equal to a specified level, and of a specified content type.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The content type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;maxLevel&quot;&gt;The level.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static T AncestorOrSelf&lt;T&gt;(this IPublishedContent content, int maxLevel)
            where T : class, IPublishedContent
        {
            return content.AncestorsOrSelf&lt;T&gt;(maxLevel).FirstOrDefault();
        }
        
        internal static IEnumerable&lt;IPublishedContent&gt; AncestorsOrSelf(this IPublishedContent content, bool orSelf, Func&lt;IPublishedContent, bool&gt; func)
        {
            var ancestorsOrSelf = content.EnumerateAncestors(orSelf);
            return func == null ? ancestorsOrSelf : ancestorsOrSelf.Where(func);
        }

        /// &lt;summary&gt;
        /// Enumerates ancestors of the content, bottom-up.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;orSelf&quot;&gt;Indicates whether the content should be included.&lt;/param&gt;
        /// &lt;returns&gt;Enumerates bottom-up ie walking up the tree (parent, grand-parent, etc).&lt;/returns&gt;
        internal static IEnumerable&lt;IPublishedContent&gt; EnumerateAncestors(this IPublishedContent content, bool orSelf)
        {
            if (content == null) throw new ArgumentNullException(&quot;content&quot;);
            if (orSelf) yield return content;
            while ((content = content.Parent) != null)
                yield return content;
        }

        #endregion

		#region Axes: descendants, descendants-or-self

        /// &lt;summary&gt;
        /// Returns all DescendantsOrSelf of all content referenced
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;parentNodes&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;docTypeAlias&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// This can be useful in order to return all nodes in an entire site by a type when combined with TypedContentAtRoot
        /// &lt;/remarks&gt;
        public static IEnumerable&lt;IPublishedContent&gt; DescendantsOrSelf(this IEnumerable&lt;IPublishedContent&gt; parentNodes, string docTypeAlias)
        {
            return parentNodes.SelectMany(x =&gt; x.DescendantsOrSelf(docTypeAlias));
        }

        /// &lt;summary&gt;
        /// Returns all DescendantsOrSelf of all content referenced
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;parentNodes&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// This can be useful in order to return all nodes in an entire site by a type when combined with TypedContentAtRoot
        /// &lt;/remarks&gt;
        public static IEnumerable&lt;T&gt; DescendantsOrSelf&lt;T&gt;(this IEnumerable&lt;IPublishedContent&gt; parentNodes)
            where T : class, IPublishedContent
        {
            return parentNodes.SelectMany(x =&gt; x.DescendantsOrSelf&lt;T&gt;());
        } 


        // as per XPath 1.0 specs �2.2,
        // - the descendant axis contains the descendants of the context node; a descendant is a child or a child of a child and so on; thus
        //   the descendant axis never contains attribute or namespace nodes.
        // - the descendant-or-self axis contains the context node and the descendants of the context node.
        //
        // as per XPath 2.0 specs �3.2.1.1,
        // - the descendant axis is defined as the transitive closure of the child axis; it contains the descendants of the context node (the
        //   children, the children of the children, and so on).
        // - the descendant-or-self axis contains the context node and the descendants of the context node.
        //
        // the descendant and descendant-or-self axis are forward axes ie they contain the context node or nodes that are after the context
        // node in document order.
        //
        // document order is defined by �2.4.1 as:
        // - the root node is the first node.
        // - every node occurs before all of its children and descendants.
        // - the relative order of siblings is the order in which they occur in the children property of their parent node.
        // - children and descendants occur before following siblings.

        public static IEnumerable&lt;IPublishedContent&gt; Descendants(this IPublishedContent content)
        {
            return content.DescendantsOrSelf(false, null);
        }

        public static IEnumerable&lt;IPublishedContent&gt; Descendants(this IPublishedContent content, int level)
        {
            return content.DescendantsOrSelf(false, p =&gt; p.Level &gt;= level);
        }

        public static IEnumerable&lt;IPublishedContent&gt; Descendants(this IPublishedContent content, string contentTypeAlias)
		{
			return content.DescendantsOrSelf(false, p =&gt; p.DocumentTypeAlias == contentTypeAlias);
		}

        public static IEnumerable&lt;T&gt; Descendants&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.Descendants().OfType&lt;T&gt;();
        }

        public static IEnumerable&lt;T&gt; Descendants&lt;T&gt;(this IPublishedContent content, int level)
            where T : class, IPublishedContent
        {
            return content.Descendants(level).OfType&lt;T&gt;();
        }
        
        public static IEnumerable&lt;IPublishedContent&gt; DescendantsOrSelf(this IPublishedContent content)
        {
            return content.DescendantsOrSelf(true, null);
        }

        public static IEnumerable&lt;IPublishedContent&gt; DescendantsOrSelf(this IPublishedContent content, int level)
		{
			return content.DescendantsOrSelf(true, p =&gt; p.Level &gt;= level);
		}

        public static IEnumerable&lt;IPublishedContent&gt; DescendantsOrSelf(this IPublishedContent content, string contentTypeAlias)
		{
			return content.DescendantsOrSelf(true, p =&gt; p.DocumentTypeAlias == contentTypeAlias);
		}

        public static IEnumerable&lt;T&gt; DescendantsOrSelf&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.DescendantsOrSelf().OfType&lt;T&gt;();
        }

        public static IEnumerable&lt;T&gt; DescendantsOrSelf&lt;T&gt;(this IPublishedContent content, int level)
            where T : class, IPublishedContent
        {
            return content.DescendantsOrSelf(level).OfType&lt;T&gt;();
        }

        public static IPublishedContent Descendant(this IPublishedContent content)
        {
            return content.Children.FirstOrDefault();
        }

        public static IPublishedContent Descendant(this IPublishedContent content, int level)
        {
            return content.EnumerateDescendants(false).FirstOrDefault(x =&gt; x.Level == level);
        }

        public static IPublishedContent Descendant(this IPublishedContent content, string contentTypeAlias)
        {
            return content.EnumerateDescendants(false).FirstOrDefault(x =&gt; x.DocumentTypeAlias == contentTypeAlias);
        }

        public static T Descendant&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.EnumerateDescendants(false).FirstOrDefault(x =&gt; x is T) as T;
        }

        public static T Descendant&lt;T&gt;(this IPublishedContent content, int level)
            where T : class, IPublishedContent
        {
            return content.Descendant(level) as T;
        }

        public static IPublishedContent DescendantOrSelf(this IPublishedContent content)
        {
            return content;
        }

        public static IPublishedContent DescendantOrSelf(this IPublishedContent content, int level)
        {
            return content.EnumerateDescendants(true).FirstOrDefault(x =&gt; x.Level == level);
        }

        public static IPublishedContent DescendantOrSelf(this IPublishedContent content, string contentTypeAlias)
        {
            return content.EnumerateDescendants(true).FirstOrDefault(x =&gt; x.DocumentTypeAlias == contentTypeAlias);
        }

        public static T DescendantOrSelf&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.EnumerateDescendants(true).FirstOrDefault(x =&gt; x is T) as T;
        }

        public static T DescendantOrSelf&lt;T&gt;(this IPublishedContent content, int level)
            where T : class, IPublishedContent
        {
            return content.DescendantOrSelf(level) as T;
        }
        
        internal static IEnumerable&lt;IPublishedContent&gt; DescendantsOrSelf(this IPublishedContent content, bool orSelf, Func&lt;IPublishedContent, bool&gt; func)
        {
            return content.EnumerateDescendants(orSelf).Where(x =&gt; func == null || func(x));
        }

        internal static IEnumerable&lt;IPublishedContent&gt; EnumerateDescendants(this IPublishedContent content, bool orSelf)
        {
            if (content == null) throw new ArgumentNullException(&quot;content&quot;);
            if (orSelf) yield return content;

            foreach (var child in content.Children)
                foreach (var child2 in child.EnumerateDescendants())
                    yield return child2;
        }

        internal static IEnumerable&lt;IPublishedContent&gt; EnumerateDescendants(this IPublishedContent content)
        {
            yield return content;

            foreach (var child in content.Children)
                foreach (var child2 in child.EnumerateDescendants())
                    yield return child2;
        }
        
        #endregion

		#region Axes: following-sibling, preceding-sibling, following, preceding + pseudo-axes up, down, next, previous

        // up pseudo-axe ~ ancestors
        // bogus, kept for backward compatibility but we should get rid of it
        // better use ancestors

		public static IPublishedContent Up(this IPublishedContent content)
		{
		    return content.Parent;
		}

		public static IPublishedContent Up(this IPublishedContent content, int number)
		{
            if (number &lt; 0)
                throw new ArgumentOutOfRangeException(&quot;number&quot;, &quot;Must be greater than, or equal to, zero.&quot;);
		    return number == 0 ? content : content.EnumerateAncestors(false).Skip(number).FirstOrDefault();
		}

		public static IPublishedContent Up(this IPublishedContent content, string contentTypeAlias)
		{
		    return string.IsNullOrEmpty(contentTypeAlias) 
                ? content.Parent 
                : content.Ancestor(contentTypeAlias);
		}

        // down pseudo-axe ~ children (not descendants)
        // bogus, kept for backward compatibility but we should get rid of it
        // better use descendants

		public static IPublishedContent Down(this IPublishedContent content)
		{
		    return content.Children.FirstOrDefault();
		}

		public static IPublishedContent Down(this IPublishedContent content, int number)
		{
            if (number &lt; 0)
                throw new ArgumentOutOfRangeException(&quot;number&quot;, &quot;Must be greater than, or equal to, zero.&quot;);
		    if (number == 0) return content;

            content = content.Children.FirstOrDefault();
            while (content != null &amp;&amp; --number &gt; 0)
                content = content.Children.FirstOrDefault();

		    return content;
		}

		public static IPublishedContent Down(this IPublishedContent content, string contentTypeAlias)
		{
		    if (string.IsNullOrEmpty(contentTypeAlias))
		        return content.Children.FirstOrDefault();

            // note: this is what legacy did, but with a broken Descendant
            // so fixing Descendant will change how it works...
			return content.Descendant(contentTypeAlias);
		}

        // next pseudo-axe ~ following within the content set
        // bogus, kept for backward compatibility but we should get rid of it

		public static IPublishedContent Next(this IPublishedContent content)
		{
            return content.ContentSet.ElementAtOrDefault(content.GetIndex() + 1);
        }

		public static IPublishedContent Next(this IPublishedContent current, Func&lt;IPublishedContent, bool&gt; func) {
			IPublishedContent next = current.Next();
			while (next != null) {
				if (func(next)) return next;
				next = next.Next();
			}
			return null;
		}

        public static IPublishedContent Next(this IPublishedContent content, int number)
		{
            if (number &lt; 0)
                throw new ArgumentOutOfRangeException(&quot;number&quot;, &quot;Must be greater than, or equal to, zero.&quot;);
            return number == 0 ? content : content.ContentSet.ElementAtOrDefault(content.GetIndex() + number);
        }

        public static IPublishedContent Next(this IPublishedContent content, string contentTypeAlias)
        {
            return content.Next(contentTypeAlias, false);
        }

        public static IPublishedContent Next(this IPublishedContent content, string contentTypeAlias, bool wrap)
        {
            return content.Next(content.ContentSet, x =&gt; x.DocumentTypeAlias.InvariantEquals(contentTypeAlias), wrap);
        }

        public static T Next&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.Next&lt;T&gt;(false);
        }

        public static T Next&lt;T&gt;(this IPublishedContent content, bool wrap)
            where T : class, IPublishedContent
        {
            return content.Next(content.ContentSet, x =&gt; x is T, wrap) as T;
        }

        static IPublishedContent Next(this IPublishedContent content, IEnumerable&lt;IPublishedContent&gt; axis, Func&lt;IPublishedContent, bool&gt; predicate, bool wrap)
        {
            var b4 = true;
            IPublishedContent wrapped = null;
            foreach (var c in axis)
            {
                if (b4)
                {
                    if (c.Id == content.Id)
                        b4 = false;
                    else if (wrap &amp;&amp; wrapped == null &amp;&amp; predicate(c))
                        wrapped = c;
                    continue;
                }
                if (predicate(c))
                    return c;
            }

            return wrapped;
        }

        // previous pseudo-axe ~ preceding within the content set
        // bogus, kept for backward compatibility but we should get rid of it

        public static IPublishedContent Previous(this IPublishedContent content)
		{
            return content.ContentSet.ElementAtOrDefault(content.GetIndex() - 1);
        }

		public static IPublishedContent Previous(this IPublishedContent current, Func&lt;IPublishedContent, bool&gt; func) {
			IPublishedContent prev = current.Previous();
			while (prev != null) {
				if (func(prev)) return prev;
				prev = prev.Previous();
			}
			return null;
		}

		public static IPublishedContent Previous(this IPublishedContent content, int number)
		{
            if (number &lt; 0)
                throw new ArgumentOutOfRangeException(&quot;number&quot;, &quot;Must be greater than, or equal to, zero.&quot;);
            return number == 0 ? content : content.ContentSet.ElementAtOrDefault(content.GetIndex() - number);
        }

		public static IPublishedContent Previous(this IPublishedContent content, string contentTypeAlias)
		{
		    return content.Previous(contentTypeAlias, false);
		}

        public static IPublishedContent Previous(this IPublishedContent content, string contentTypeAlias, bool wrap)
        {
            return content.Next(content.ContentSet.Reverse(), x =&gt; x.DocumentTypeAlias.InvariantEquals(contentTypeAlias), wrap);
        }

        public static T Previous&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.Previous&lt;T&gt;(false);
        }

        public static T Previous&lt;T&gt;(this IPublishedContent content, bool wrap)
            where T : class, IPublishedContent
        {
            return content.Next(content.ContentSet.Reverse(), x =&gt; x is T, wrap) as T;
        }

        //

        [Obsolete(&quot;Obsolete, use FollowingSibling or PrecedingSibling instead.&quot;)]
		public static IPublishedContent Sibling(this IPublishedContent content, int number)
        {
            if (number &lt; 0)
                throw new ArgumentOutOfRangeException(&quot;number&quot;, &quot;Must be greater than, or equal to, zero.&quot;);
            number += 1; // legacy is zero-based
            return content.FollowingSibling(number);
		}

        // contentTypeAlias is case-insensitive
        [Obsolete(&quot;Obsolete, use FollowingSibling or PrecedingSibling instead.&quot;)]
        public static IPublishedContent Sibling(this IPublishedContent content, string contentTypeAlias)
        {
            // note: the original implementation seems to loop on all siblings
            // ie if it reaches the end of the set, it starts again at the beginning.
            // so here we wrap, although it&#39;s not consistent... but anyway those
            // methods should be obsoleted.

            return content.FollowingSibling(contentTypeAlias, true);
        }

        // following-sibling, preceding-sibling axes

        public static IPublishedContent FollowingSibling(this IPublishedContent content)
        {
            return content.Siblings().ElementAtOrDefault(content.GetIndex(content.Siblings()) + 1);
        }

        public static IPublishedContent FollowingSibling(this IPublishedContent content, int number)
        {
            if (number &lt; 0)
                throw new ArgumentOutOfRangeException(&quot;number&quot;, &quot;Must be greater than, or equal to, zero.&quot;);
            return number == 0 ? content : content.Siblings().ElementAtOrDefault(content.GetIndex(content.Siblings()) + number);
        }

        // contentTypeAlias is case-insensitive
        public static IPublishedContent FollowingSibling(this IPublishedContent content, string contentTypeAlias)
        {
            return content.FollowingSibling(contentTypeAlias, false);
        }

        // contentTypeAlias is case-insensitive
        // note: not sure that one makes a lot of sense but it is here for backward compatibility
        public static IPublishedContent FollowingSibling(this IPublishedContent content, string contentTypeAlias, bool wrap)
        {
            return content.Next(content.Siblings(), x =&gt; x.DocumentTypeAlias.InvariantEquals(contentTypeAlias), wrap);
        }

        public static T FollowingSibling&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.FollowingSibling&lt;T&gt;(false);
        }

        public static T FollowingSibling&lt;T&gt;(this IPublishedContent content, bool wrap)
            where T : class, IPublishedContent
        {
            return content.Next(content.Siblings(), x =&gt; x is T, wrap) as T;
        }

        public static IPublishedContent PrecedingSibling(this IPublishedContent content)
        {
            return content.Siblings().ElementAtOrDefault(content.GetIndex(content.Siblings()) - 1);
        }

        public static IPublishedContent PrecedingSibling(this IPublishedContent content, int number)
        {
            if (number &lt; 0)
                throw new ArgumentOutOfRangeException(&quot;number&quot;, &quot;Must be greater than, or equal to, zero.&quot;);
            return number == 0 ? content : content.Siblings().ElementAtOrDefault(content.GetIndex(content.Siblings()) - number);
        }

        // contentTypeAlias is case-insensitive
        public static IPublishedContent PrecedingSibling(this IPublishedContent content, string contentTypeAlias)
        {
            return content.PrecedingSibling(contentTypeAlias, false);
        }

        // contentTypeAlias is case-insensitive
        // note: not sure that one makes a lot of sense but it is here for backward compatibility
        public static IPublishedContent PrecedingSibling(this IPublishedContent content, string contentTypeAlias, bool wrap)
        {
            return content.Next(content.Siblings().Reverse(), x =&gt; x.DocumentTypeAlias.InvariantEquals(contentTypeAlias), wrap);
        }

        public static T PrecedingSibling&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.PrecedingSibling&lt;T&gt;(false);
        }

        public static T PrecedingSibling&lt;T&gt;(this IPublishedContent content, bool wrap)
            where T : class, IPublishedContent
        {
            return content.Next(content.Siblings().Reverse(), x =&gt; x is T, wrap) as T;
        }

        // following, preceding axes - NOT IMPLEMENTED

        // utilities

        public static IEnumerable&lt;IPublishedContent&gt; Siblings(this IPublishedContent content)
        {
            // content.Parent, content.Children and cache.GetAtRoot() should be fast enough,
            // or cached by the content cache, so that we don&#39;t have to implement cache here.

            // returns the true tree siblings, even if the content is in a set
            // get the root docs if parent is null

            // note: I don&#39;t like having to refer to the &quot;current&quot; content cache here, but
            // what else? would need root content to have a special, non-null but hidden,
            // parent...



            var siblings = content.Parent == null
                ? content.ItemType == PublishedItemType.Media ? UmbracoContext.Current.MediaCache.GetAtRoot() : UmbracoContext.Current.ContentCache.GetAtRoot()
                : content.Parent.Children;

            // make sure we run it once
            return siblings.ToArray();
        }

        public static IEnumerable&lt;T&gt; Siblings&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.Siblings().OfType&lt;T&gt;();
        }

        #endregion

        #region Axes: parent

        // Parent is native

        /// &lt;summary&gt;
        /// Gets the parent of the content, of a given content type.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The content type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;The parent of content, of the given content type, else null.&lt;/returns&gt;
        public static T Parent&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            if (content == null) throw new ArgumentNullException(&quot;content&quot;);
            return content.Parent as T;
        }

        #endregion

        #region Axes: children

        /// &lt;summary&gt;
		/// Gets the children of the content.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
		/// &lt;returns&gt;The children of the content.&lt;/returns&gt;
		/// &lt;remarks&gt;
        /// &lt;para&gt;Children are sorted by their sortOrder.&lt;/para&gt;
        /// &lt;para&gt;This method exists for consistency, it is the same as calling content.Children as a property.&lt;/para&gt;
		/// &lt;/remarks&gt;
		public static IEnumerable&lt;IPublishedContent&gt; Children(this IPublishedContent content)
        {
            if (content == null) throw new ArgumentNullException(&quot;content&quot;);
            return content.Children;
        }

        /// &lt;summary&gt;
        /// Gets the children of the content, filtered by a predicate.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;predicate&quot;&gt;The predicate.&lt;/param&gt;
        /// &lt;returns&gt;The children of the content, filtered by the predicate.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Children are sorted by their sortOrder.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static IEnumerable&lt;IPublishedContent&gt; Children(this IPublishedContent content, Func&lt;IPublishedContent, bool&gt; predicate)
        {
            return content.Children().Where(predicate);
        }

        /// &lt;summary&gt;
        /// Gets the children of the content, of any of the specified types.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;One or more content type alias.&lt;/param&gt;
        /// &lt;returns&gt;The children of the content, of any of the specified types.&lt;/returns&gt;
        public static IEnumerable&lt;IPublishedContent&gt; Children(this IPublishedContent content, params string[] alias)
        {
            return content.Children(x =&gt; alias.InvariantContains(x.DocumentTypeAlias));
        }

        /// &lt;summary&gt;
        /// Gets the children of the content, of a given content type.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The content type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;The children of content, of the given content type.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Children are sorted by their sortOrder.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static IEnumerable&lt;T&gt; Children&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.Children().OfType&lt;T&gt;();
        }

        public static IPublishedContent FirstChild(this IPublishedContent content)
        {
            return content.Children().FirstOrDefault();
        }

        public static IPublishedContent FirstChild(this IPublishedContent content, Func&lt;IPublishedContent, bool&gt; predicate)
        {
            return content.Children(predicate).FirstOrDefault();
        }

        public static IPublishedContent FirstChild&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content.Children&lt;T&gt;().FirstOrDefault();
        }

		/// &lt;summary&gt;
		/// Gets the children of the content in a DataTable.
		/// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;contentTypeAliasFilter&quot;&gt;An optional content type alias.&lt;/param&gt;
        /// &lt;returns&gt;The children of the content.&lt;/returns&gt;
		public static DataTable ChildrenAsTable(this IPublishedContent content, string contentTypeAliasFilter = &quot;&quot;)
		{
            return GenerateDataTable(content, contentTypeAliasFilter);
		}

		/// &lt;summary&gt;
        /// Gets the children of the content in a DataTable.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;contentTypeAliasFilter&quot;&gt;An optional content type alias.&lt;/param&gt;
        /// &lt;returns&gt;The children of the content.&lt;/returns&gt;
        private static DataTable GenerateDataTable(IPublishedContent content, string contentTypeAliasFilter = &quot;&quot;)
		{
			var firstNode = contentTypeAliasFilter.IsNullOrWhiteSpace()
								? content.Children.Any()
									? content.Children.ElementAt(0)
									: null
								: content.Children.FirstOrDefault(x =&gt; x.DocumentTypeAlias == contentTypeAliasFilter);
			if (firstNode == null)
				return new DataTable(); //no children found 

			//use new utility class to create table so that we don&#39;t have to maintain code in many places, just one
			var dt = Core.DataTableExtensions.GenerateDataTable(
				//pass in the alias of the first child node since this is the node type we&#39;re rendering headers for
				firstNode.DocumentTypeAlias,
				//pass in the callback to extract the Dictionary&lt;string, string&gt; of all defined aliases to their names
				alias =&gt; GetPropertyAliasesAndNames(alias),
				//pass in a callback to populate the datatable, yup its a bit ugly but it&#39;s already legacy and we just want to maintain code in one place.
				() =&gt;
				{
					//create all row data
					var tableData = Core.DataTableExtensions.CreateTableData();
					//loop through each child and create row data for it
					foreach (var n in content.Children.OrderBy(x =&gt; x.SortOrder))
					{
						if (contentTypeAliasFilter.IsNullOrWhiteSpace() == false)
						{
							if (n.DocumentTypeAlias != contentTypeAliasFilter)
								continue; //skip this one, it doesn&#39;t match the filter
						}

						var standardVals = new Dictionary&lt;string, object&gt;
						    {
									{ &quot;Id&quot;, n.Id },
									{ &quot;NodeName&quot;, n.Name },
									{ &quot;NodeTypeAlias&quot;, n.DocumentTypeAlias },
									{ &quot;CreateDate&quot;, n.CreateDate },
									{ &quot;UpdateDate&quot;, n.UpdateDate },
									{ &quot;CreatorName&quot;, n.CreatorName },
									{ &quot;WriterName&quot;, n.WriterName },
									{ &quot;Url&quot;, n.Url }
								};

						var userVals = new Dictionary&lt;string, object&gt;();
                        foreach (var p in from IPublishedProperty p in n.Properties where p.DataValue != null select p)
                        {
                            // probably want the &quot;object value&quot; of the property here...
							userVals[p.PropertyTypeAlias] = p.Value;
						}
						//add the row data
						Core.DataTableExtensions.AddRowData(tableData, standardVals, userVals);
					}
					return tableData;
				}
				);
			return dt;
		}

        #endregion

        #region Axes: custom

        // todo: in v8, rename this &#39;Root&#39;
        /// &lt;summary&gt;
        /// Gets the &#39;site&#39; content for this content.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;returns&gt;The &#39;site&#39; content ie AncestorOrSelf(1).&lt;/returns&gt;
        public static IPublishedContent Site(this IPublishedContent content)
        {
            return content.AncestorOrSelf(1);
        }

        #endregion

        #region OfTypes

        // the .OfType&lt;T&gt;() filter is nice when there&#39;s only one type
        // this is to support filtering with multiple types

        public static IEnumerable&lt;IPublishedContent&gt; OfTypes(this IEnumerable&lt;IPublishedContent&gt; contents, params Type[] types)
        {
            return contents.Where(x =&gt; types.Contains(x.GetType()));
        }

        public static IEnumerable&lt;IPublishedContent&gt; OfTypes(this IEnumerable&lt;IPublishedContent&gt; contents, params string[] types)
        {
            types = types.Select(x =&gt; x.ToLowerInvariant()).ToArray();
            return contents.Where(x =&gt; types.Contains(x.DocumentTypeAlias.ToLowerInvariant()));
        }

        public static T OfType&lt;T&gt;(this IPublishedContent content)
            where T : class, IPublishedContent
        {
            return content as T;
        }

        #endregion

        #region PropertyAliasesAndNames

        private static Func&lt;string, Dictionary&lt;string, string&gt;&gt; _getPropertyAliasesAndNames;

		/// &lt;summary&gt;
		/// This is used only for unit tests to set the delegate to look up aliases/names dictionary of a content type
		/// &lt;/summary&gt;
		internal static Func&lt;string, Dictionary&lt;string, string&gt;&gt; GetPropertyAliasesAndNames
		{
			get
			{
				return _getPropertyAliasesAndNames ?? (_getPropertyAliasesAndNames = alias =&gt;
					{
						var userFields = ContentType.GetAliasesAndNames(alias);
						//ensure the standard fields are there
						var allFields = new Dictionary&lt;string, string&gt;()
							{
								{&quot;Id&quot;, &quot;Id&quot;},
								{&quot;NodeName&quot;, &quot;NodeName&quot;},
								{&quot;NodeTypeAlias&quot;, &quot;NodeTypeAlias&quot;},
								{&quot;CreateDate&quot;, &quot;CreateDate&quot;},
								{&quot;UpdateDate&quot;, &quot;UpdateDate&quot;},
								{&quot;CreatorName&quot;, &quot;CreatorName&quot;},
								{&quot;WriterName&quot;, &quot;WriterName&quot;},
								{&quot;Url&quot;, &quot;Url&quot;}
							};
						foreach (var f in userFields.Where(f =&gt; allFields.ContainsKey(f.Key) == false))
						{
							allFields.Add(f.Key, f.Value);
						}
						return allFields;
					});
			}
			set { _getPropertyAliasesAndNames = value; }
        }

        #endregion

        #region Culture

        /// &lt;summary&gt;
        /// Gets the culture that would be selected to render a specified content,
        /// within the context of a specified current request.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;content&quot;&gt;The content.&lt;/param&gt;
        /// &lt;param name=&quot;current&quot;&gt;The request Uri.&lt;/param&gt;
        /// &lt;returns&gt;The culture that would be selected to render the content.&lt;/returns&gt;
        public static CultureInfo GetCulture(this IPublishedContent content, Uri current = null)
        {
            return Models.ContentExtensions.GetCulture(UmbracoContext.Current,
                ApplicationContext.Current.Services.DomainService, 
                ApplicationContext.Current.Services.LocalizationService,
                ApplicationContext.Current.Services.ContentService,
                content.Id, content.Path,
                current);
        }

        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[26,9,26,10,1],[27,13,27,70,1],[28,13,28,77,1],[29,9,29,10,1],[42,3,42,4,0],[43,4,43,25,0],[44,3,44,4,0],[53,3,53,4,0],[54,7,54,26,0],[55,3,55,4,0],[64,3,64,4,0],[65,13,65,42,0],[66,3,66,4,0],[75,3,75,4,0],[76,7,76,36,0],[77,3,77,4,0],[85,9,85,10,0],[87,13,87,38,0],[90,21,90,56,0],[91,25,91,141,0],[92,21,92,68,0],[93,25,93,153,0],[94,21,94,88,0],[96,21,96,102,0],[98,21,98,61,0],[100,9,100,10,0],[112,9,112,10,0],[113,13,113,108,0],[114,4,114,60,0],[115,3,115,4,0],[128,9,128,10,1],[129,13,129,75,1],[130,9,130,10,1],[144,9,144,10,1],[145,13,145,71,1],[146,9,146,10,1],[160,9,160,10,1],[161,13,161,51,1],[162,9,162,10,1],[173,9,173,10,1],[174,13,174,60,1],[175,13,175,50,1],[176,9,176,10,1],[189,9,189,10,0],[190,13,192,64,0],[193,9,193,10,0],[207,9,207,10,0],[208,13,210,64,0],[211,9,211,10,0],[230,9,230,10,1],[231,13,231,55,1],[232,13,232,61,1],[233,3,233,4,1],[249,9,249,10,0],[250,13,250,55,0],[251,13,251,99,0],[252,9,252,10,0],[268,9,268,10,0],[269,13,269,55,0],[270,13,270,99,0],[271,9,271,10,0],[288,9,288,10,1],[289,13,289,64,1],[290,13,290,61,1],[291,9,291,10,1],[309,9,309,10,0],[310,13,310,64,0],[311,13,311,99,0],[312,9,312,10,0],[332,3,332,4,1],[333,4,333,69,1],[334,3,334,4,1],[351,9,351,10,1],[352,13,352,79,1],[353,9,353,10,1],[371,9,371,10,0],[372,13,372,80,0],[373,9,373,10,0],[392,9,392,10,0],[393,13,393,81,0],[394,9,394,10,0],[397,9,397,10,1],[398,13,398,64,1],[399,13,399,34,1],[399,35,399,55,0],[401,13,401,70,1],[402,3,402,4,1],[409,9,409,10,1],[410,13,410,63,1],[411,13,411,68,1],[412,9,412,10,1],[417,3,417,4,0],[418,4,418,73,0],[419,4,419,54,0],[420,5,420,89,0],[422,4,422,32,0],[423,4,423,21,0],[424,5,424,48,0],[426,4,426,82,0],[427,4,427,69,0],[429,4,429,42,0],[430,3,430,4,0],[433,3,433,4,0],[434,4,434,62,0],[435,3,435,4,0],[438,3,438,4,0],[439,4,439,73,0],[440,4,440,54,0],[441,5,441,89,0],[443,4,443,32,0],[444,4,444,21,0],[445,5,445,48,0],[447,4,447,59,0],[448,4,448,69,0],[450,4,450,42,0],[451,3,451,4,0],[454,3,454,4,0],[455,4,455,66,0],[456,4,456,31,0],[457,5,457,24,0],[459,4,459,37,0],[460,4,460,94,0],[461,3,461,4,0],[474,9,474,10,1],[475,13,475,55,1],[476,9,476,10,1],[485,9,485,10,0],[486,13,486,62,0],[487,9,487,10,0],[496,3,496,4,1],[497,4,497,56,1],[498,4,498,61,1],[499,3,499,4,1],[502,3,502,4,1],[506,7,507,99,1],[509,7,509,53,1],[510,3,510,4,1],[513,3,513,4,1],[514,4,514,54,1],[515,4,515,36,1],[516,3,516,4,1],[519,3,519,4,0],[520,4,520,54,0],[521,4,521,35,0],[522,3,522,4,0],[525,9,525,10,0],[526,13,526,33,0],[526,34,526,77,0],[527,13,527,72,0],[528,9,528,10,0],[531,9,531,10,0],[532,13,532,33,0],[532,34,532,77,0],[533,13,533,90,0],[534,9,534,10,0],[537,9,537,10,0],[538,13,538,33,0],[538,34,538,77,0],[539,13,539,101,0],[540,13,540,90,0],[541,13,541,42,0],[542,9,542,10,0],[552,3,552,4,1],[553,4,553,24,1],[553,25,553,68,0],[554,4,554,48,1],[555,3,555,4,1],[559,3,559,4,1],[560,7,560,76,1],[561,3,561,4,1],[568,3,568,4,0],[569,4,569,30,0],[570,3,570,4,0],[573,9,573,10,1],[574,13,574,39,1],[575,9,575,10,1],[578,9,578,10,0],[579,13,579,44,0],[579,44,579,62,0],[579,62,579,64,0],[579,13,579,64,0],[580,13,580,27,0],[581,17,581,98,0],[582,13,582,26,0],[583,9,583,10,0],[597,9,597,10,1],[603,13,603,100,1],[604,9,604,10,1],[613,6,613,7,1],[614,10,614,73,1],[615,6,615,7,1],[625,3,625,4,1],[626,4,626,45,1],[627,5,627,17,1],[629,4,629,18,1],[630,5,630,59,1],[631,4,631,17,1],[632,3,632,4,1],[635,3,635,4,1],[636,4,636,92,1],[637,4,637,76,1],[638,4,638,45,1],[639,4,639,5,1],[640,5,640,61,1],[641,5,641,50,1],[642,6,642,18,1],[643,4,643,5,1],[644,4,644,17,1],[645,3,645,4,1],[648,3,648,4,0],[649,7,649,56,0],[650,3,650,4,0],[653,3,653,4,0],[654,7,654,47,0],[655,3,655,4,0],[662,9,662,10,1],[663,13,663,44,1],[664,9,664,10,1],[667,9,667,10,0],[668,13,668,63,0],[669,9,669,10,0],[672,9,672,10,0],[673,13,673,83,0],[674,9,674,10,0],[677,9,677,10,1],[678,13,678,47,1],[679,9,679,10,1],[682,9,682,10,0],[683,13,683,66,0],[684,9,684,10,0],[687,9,687,10,0],[688,13,688,86,0],[689,9,689,10,0],[692,9,692,10,1],[693,13,693,48,1],[694,9,694,10,1],[697,9,697,10,0],[698,13,698,73,0],[699,9,699,10,0],[702,9,702,10,0],[703,13,703,91,0],[704,9,704,10,0],[707,9,707,10,0],[708,13,708,54,0],[709,9,709,10,0],[712,9,712,10,0],[713,13,713,74,0],[714,9,714,10,0],[717,9,717,10,0],[718,13,718,92,0],[719,9,719,10,0],[722,9,722,10,0],[723,13,723,56,0],[724,9,724,10,0],[727,9,727,10,0],[728,13,728,77,0],[729,9,729,10,0],[732,9,732,10,0],[733,13,733,95,0],[734,9,734,10,0],[737,9,737,10,0],[738,13,738,55,0],[739,9,739,10,0],[742,9,742,10,0],[743,13,743,76,0],[744,9,744,10,0],[747,9,747,10,0],[748,13,748,94,0],[749,9,749,10,0],[752,9,752,10,1],[753,13,753,73,1],[754,9,754,10,1],[757,9,757,10,0],[758,13,758,62,0],[759,9,759,10,0],[762,9,762,10,0],[763,13,763,82,0],[764,9,764,10,0],[767,9,767,10,0],[768,13,768,46,0],[769,9,769,10,0],[772,9,772,10,0],[773,13,773,65,0],[774,9,774,10,0],[777,9,777,10,0],[778,13,778,85,0],[779,9,779,10,0],[782,9,782,10,0],[783,13,783,48,0],[784,9,784,10,0],[787,9,787,10,0],[788,13,788,62,0],[789,9,789,10,0],[792,9,792,10,0],[793,13,793,82,0],[794,9,794,10,0],[797,9,797,10,0],[798,13,798,48,0],[799,9,799,10,0],[802,9,802,10,0],[803,13,803,61,0],[804,9,804,10,0],[807,9,807,10,0],[808,13,808,81,0],[809,9,809,10,0],[816,3,816,4,0],[817,4,817,34,0],[818,3,818,4,0],[821,9,821,10,0],[822,13,822,70,0],[823,9,823,10,0],[826,3,826,4,0],[827,4,827,79,0],[828,3,828,4,0],[831,3,831,4,0],[832,7,832,46,0],[833,3,833,4,0],[836,9,836,10,0],[837,13,837,73,0],[838,9,838,10,0],[841,3,841,4,0],[842,4,842,82,0],[843,3,843,4,0],[850,9,850,10,0],[851,13,851,49,0],[851,49,851,65,0],[851,65,851,67,0],[851,13,851,67,0],[852,3,852,4,0],[855,3,855,4,0],[856,7,856,69,0],[857,3,857,4,0],[860,3,860,4,0],[861,13,861,93,0],[862,3,862,4,0],[865,3,865,4,0],[866,13,866,55,0],[866,55,866,71,0],[866,71,866,73,0],[866,13,866,73,0],[867,9,867,10,0],[870,3,870,4,0],[871,13,871,81,0],[872,9,872,10,0],[875,3,875,4,0],[876,13,876,99,0],[877,9,877,10,0],[880,3,880,4,0],[882,7,882,41,0],[882,41,882,59,0],[882,59,882,61,0],[882,7,882,61,0],[883,3,883,4,0],[886,3,886,4,0],[887,13,887,73,0],[888,9,888,10,0],[891,3,891,4,0],[892,13,892,91,0],[893,9,893,10,0],[896,3,896,4,0],[898,13,898,53,0],[898,53,898,71,0],[898,71,898,73,0],[898,13,898,73,0],[899,9,899,10,0],[902,3,902,4,0],[903,13,903,79,0],[904,9,904,10,0],[907,3,907,4,0],[908,13,908,97,0],[909,9,909,10,0],[945,9,945,10,1],[946,13,946,57,1],[947,9,947,10,1],[957,9,957,10,0],[958,13,958,56,0],[958,56,958,75,0],[958,75,958,77,0],[958,13,958,77,0],[959,9,959,10,0],[969,9,969,10,0],[970,13,970,56,0],[970,56,970,95,0],[970,95,970,97,0],[970,13,970,97,0],[971,9,971,10,0],[982,9,982,10,0],[983,13,983,52,0],[984,9,984,10,0],[998,9,998,10,0],[999,13,999,60,0],[1000,9,1000,10,0],[1008,9,1008,10,1],[1009,13,1009,56,1],[1010,9,1010,10,1],[1022,9,1022,10,0],[1023,13,1023,55,0],[1023,55,1023,74,0],[1023,74,1023,76,0],[1023,13,1023,76,0],[1024,9,1024,10,0],[1034,9,1034,10,0],[1035,13,1035,55,0],[1035,55,1035,94,0],[1035,94,1035,96,0],[1035,13,1035,96,0],[1036,9,1036,10,0],[1047,9,1047,10,0],[1048,13,1048,58,0],[1049,9,1049,10,0],[1062,9,1062,10,0],[1063,13,1063,66,0],[1064,9,1064,10,0],[1073,9,1073,10,0],[1074,13,1074,35,0],[1075,9,1075,10,0],[1085,9,1085,10,0],[1086,13,1086,74,0],[1086,74,1086,93,0],[1086,93,1086,95,0],[1086,13,1086,95,0],[1087,9,1087,10,0],[1097,9,1097,10,0],[1098,13,1098,74,0],[1098,74,1098,113,0],[1098,113,1098,115,0],[1098,13,1098,115,0],[1099,9,1099,10,0],[1110,9,1110,10,0],[1111,13,1111,60,0],[1112,9,1112,10,0],[1125,9,1125,10,0],[1126,13,1126,68,0],[1127,9,1127,10,0],[1136,9,1136,10,1],[1137,13,1137,28,1],[1138,9,1138,10,1],[1148,9,1148,10,1],[1149,13,1149,73,1],[1149,73,1149,92,1],[1149,92,1149,94,1],[1149,13,1149,94,1],[1150,9,1150,10,1],[1160,9,1160,10,0],[1161,13,1161,73,0],[1161,73,1161,112,0],[1161,112,1161,114,0],[1161,13,1161,114,0],[1162,9,1162,10,0],[1173,9,1173,10,0],[1174,13,1174,66,0],[1175,9,1175,10,0],[1186,9,1186,10,0],[1187,13,1187,74,0],[1188,9,1188,10,0],[1191,9,1191,10,1],[1192,13,1192,70,1],[1193,13,1193,81,1],[1194,9,1194,10,1],[1224,9,1224,10,0],[1225,13,1225,48,0],[1225,48,1225,81,0],[1225,81,1225,83,0],[1225,13,1225,83,0],[1226,9,1226,10,0],[1238,9,1238,10,0],[1239,13,1239,48,0],[1239,48,1239,72,0],[1239,72,1239,74,0],[1239,13,1239,74,0],[1240,9,1240,10,0],[1263,9,1263,10,1],[1264,13,1264,59,1],[1265,9,1265,10,1],[1268,9,1268,10,0],[1269,13,1269,58,0],[1269,58,1269,74,0],[1269,74,1269,76,0],[1269,13,1269,76,0],[1270,9,1270,10,0],[1273,3,1273,4,0],[1274,4,1274,49,0],[1274,49,1274,88,0],[1274,88,1274,90,0],[1274,4,1274,90,0],[1275,3,1275,4,0],[1279,9,1279,10,0],[1280,13,1280,54,0],[1281,9,1281,10,0],[1285,9,1285,10,0],[1286,13,1286,59,0],[1287,9,1287,10,0],[1290,9,1290,10,1],[1291,13,1291,58,1],[1292,9,1292,10,1],[1295,3,1295,4,0],[1296,4,1296,48,0],[1296,48,1296,64,0],[1296,64,1296,66,0],[1296,4,1296,66,0],[1297,3,1297,4,0],[1300,3,1300,4,0],[1301,4,1301,48,0],[1301,48,1301,87,0],[1301,87,1301,89,0],[1301,4,1301,89,0],[1302,3,1302,4,0],[1306,9,1306,10,0],[1307,13,1307,60,0],[1308,9,1308,10,0],[1312,9,1312,10,0],[1313,13,1313,65,0],[1314,9,1314,10,0],[1317,9,1317,10,0],[1318,13,1318,54,0],[1319,9,1319,10,0],[1322,9,1322,10,0],[1323,13,1323,76,0],[1323,76,1323,92,0],[1323,92,1323,94,0],[1323,13,1323,94,0],[1324,9,1324,10,0],[1327,9,1327,10,0],[1328,13,1328,76,0],[1328,76,1328,115,0],[1328,115,1328,117,0],[1328,13,1328,117,0],[1329,9,1329,10,0],[1333,9,1333,10,0],[1334,13,1334,76,0],[1334,76,1334,82,0],[1334,82,1334,89,0],[1334,13,1334,89,0],[1335,9,1335,10,0],[1339,9,1339,10,0],[1340,13,1340,51,0],[1341,9,1341,10,0],[1344,9,1344,10,0],[1345,13,1345,28,0],[1346,9,1346,10,0],[1349,9,1349,10,0],[1350,13,1350,75,0],[1350,75,1350,91,0],[1350,91,1350,93,0],[1350,13,1350,93,0],[1351,9,1351,10,0],[1354,9,1354,10,0],[1355,13,1355,75,0],[1355,75,1355,114,0],[1355,114,1355,116,0],[1355,13,1355,116,0],[1356,9,1356,10,0],[1360,9,1360,10,0],[1361,13,1361,75,0],[1361,75,1361,81,0],[1361,81,1361,88,0],[1361,13,1361,88,0],[1362,9,1362,10,0],[1366,9,1366,10,0],[1367,13,1367,57,0],[1368,9,1368,10,0],[1371,9,1371,10,1],[1372,13,1372,68,1],[1372,68,1372,91,1],[1372,91,1372,93,1],[1372,13,1372,93,1],[1373,9,1373,10,1],[1403,3,1403,4,1],[1404,7,1404,29,1],[1405,3,1405,4,1],[1408,3,1408,4,0],[1409,13,1409,28,0],[1410,17,1410,109,0],[1411,7,1411,102,0],[1412,3,1412,4,0],[1415,3,1415,4,0],[1416,7,1418,54,0],[1419,3,1419,4,0],[1426,3,1426,4,1],[1427,7,1427,48,1],[1428,3,1428,4,1],[1431,3,1431,4,0],[1432,13,1432,28,0],[1433,17,1433,109,0],[1434,7,1434,23,0],[1434,24,1434,39,0],[1436,13,1436,57,0],[1437,13,1437,52,0],[1438,17,1438,61,0],[1440,7,1440,22,0],[1441,3,1441,4,0],[1444,3,1444,4,0],[1445,7,1445,50,0],[1446,11,1446,52,0],[1450,4,1450,48,0],[1451,3,1451,4,0],[1457,3,1457,4,1],[1458,13,1458,82,1],[1459,9,1459,10,1],[1461,108,1461,109,0],[1462,4,1462,44,0],[1463,4,1463,24,0],[1463,25,1463,26,0],[1464,5,1464,20,0],[1464,21,1464,33,0],[1465,5,1465,24,0],[1466,4,1466,5,0],[1467,4,1467,16,0],[1468,3,1468,4,0],[1471,3,1471,4,0],[1472,13,1472,28,0],[1473,17,1473,109,0],[1474,13,1474,111,0],[1475,9,1475,10,0],[1478,9,1478,10,0],[1479,13,1479,58,0],[1480,9,1480,10,0],[1483,9,1483,10,0],[1484,13,1484,58,0],[1484,58,1484,111,0],[1484,111,1484,119,0],[1484,13,1484,119,0],[1485,9,1485,10,0],[1489,9,1489,10,0],[1490,13,1490,43,0],[1491,9,1491,10,0],[1495,9,1495,10,0],[1496,13,1496,58,0],[1496,58,1496,64,0],[1496,64,1496,77,0],[1496,13,1496,77,0],[1497,9,1497,10,0],[1500,9,1500,10,0],[1501,13,1501,27,0],[1502,13,1502,46,0],[1503,13,1503,20,0],[1503,22,1503,27,0],[1503,28,1503,30,0],[1503,31,1503,35,0],[1504,13,1504,14,0],[1505,17,1505,24,0],[1506,17,1506,18,0],[1507,21,1507,44,0],[1508,25,1508,36,0],[1509,26,1509,70,0],[1510,25,1510,37,0],[1511,21,1511,30,0],[1513,17,1513,34,0],[1514,21,1514,30,0],[1515,13,1515,14,0],[1517,13,1517,28,0],[1518,9,1518,10,0],[1524,3,1524,4,1],[1525,13,1525,82,1],[1526,9,1526,10,1],[1528,112,1528,113,0],[1529,4,1529,48,0],[1530,4,1530,24,0],[1530,25,1530,26,0],[1531,5,1531,20,0],[1531,21,1531,33,0],[1532,5,1532,28,0],[1533,4,1533,5,0],[1534,4,1534,16,0],[1535,3,1535,4,0],[1538,3,1538,4,0],[1539,13,1539,28,0],[1540,17,1540,109,0],[1541,13,1541,111,0],[1542,9,1542,10,0],[1545,3,1545,4,0],[1546,7,1546,56,0],[1547,3,1547,4,0],[1550,9,1550,10,0],[1551,13,1551,68,0],[1551,68,1551,121,0],[1551,121,1551,129,0],[1551,13,1551,129,0],[1552,9,1552,10,0],[1556,9,1556,10,0],[1557,13,1557,47,0],[1558,9,1558,10,0],[1562,9,1562,10,0],[1563,13,1563,68,0],[1563,68,1563,74,0],[1563,74,1563,87,0],[1563,13,1563,87,0],[1564,9,1564,10,0],[1570,9,1570,10,0],[1571,13,1571,28,0],[1572,17,1572,109,0],[1573,13,1573,25,0],[1574,13,1574,53,0],[1575,3,1575,4,0],[1580,9,1580,10,0],[1586,13,1586,69,0],[1587,9,1587,10,0],[1592,9,1592,10,0],[1593,13,1593,100,0],[1594,9,1594,10,0],[1597,9,1597,10,0],[1598,13,1598,28,0],[1599,17,1599,109,0],[1600,13,1600,129,0],[1601,9,1601,10,0],[1605,9,1605,10,0],[1606,13,1606,70,0],[1607,9,1607,10,0],[1612,9,1612,10,0],[1613,13,1613,58,0],[1613,58,1613,111,0],[1613,111,1613,119,0],[1613,13,1613,119,0],[1614,9,1614,10,0],[1618,9,1618,10,0],[1619,13,1619,55,0],[1620,9,1620,10,0],[1624,9,1624,10,0],[1625,13,1625,58,0],[1625,58,1625,64,0],[1625,64,1625,77,0],[1625,13,1625,77,0],[1626,9,1626,10,0],[1629,9,1629,10,0],[1630,13,1630,100,0],[1631,9,1631,10,0],[1634,9,1634,10,0],[1635,13,1635,28,0],[1636,17,1636,109,0],[1637,13,1637,129,0],[1638,9,1638,10,0],[1642,9,1642,10,0],[1643,13,1643,70,0],[1644,9,1644,10,0],[1649,9,1649,10,0],[1650,13,1650,68,0],[1650,68,1650,121,0],[1650,121,1650,129,0],[1650,13,1650,129,0],[1651,9,1651,10,0],[1655,9,1655,10,0],[1656,13,1656,55,0],[1657,9,1657,10,0],[1661,9,1661,10,0],[1662,13,1662,68,0],[1662,68,1662,74,0],[1662,74,1662,87,0],[1662,13,1662,87,0],[1663,9,1663,10,0],[1670,9,1670,10,1],[1683,13,1685,43,1],[1688,13,1688,39,1],[1689,9,1689,10,1],[1693,9,1693,10,0],[1694,13,1694,51,0],[1695,9,1695,10,0],[1711,9,1711,10,0],[1712,13,1712,33,0],[1712,34,1712,77,0],[1713,13,1713,40,0],[1714,9,1714,10,0],[1730,9,1730,10,1],[1731,13,1731,33,1],[1731,34,1731,77,0],[1732,13,1732,37,1],[1733,9,1733,10,1],[1745,9,1745,10,1],[1746,13,1746,56,1],[1747,9,1747,10,1],[1756,9,1756,10,0],[1757,13,1757,42,0],[1757,42,1757,86,0],[1757,86,1757,88,0],[1757,13,1757,88,0],[1758,9,1758,10,0],[1771,9,1771,10,1],[1772,13,1772,51,1],[1773,9,1773,10,1],[1776,9,1776,10,1],[1777,13,1777,56,1],[1778,9,1778,10,1],[1781,9,1781,10,1],[1782,13,1782,65,1],[1783,9,1783,10,1],[1787,9,1787,10,1],[1788,13,1788,59,1],[1789,9,1789,10,1],[1798,3,1798,4,1],[1799,13,1799,71,1],[1800,3,1800,4,1],[1809,3,1809,4,1],[1810,4,1814,48,1],[1814,48,1814,93,1],[1814,93,1814,95,1],[1810,4,1814,95,1],[1815,4,1815,26,1],[1816,5,1816,28,1],[1819,4,1823,14,1],[1823,14,1823,47,1],[1823,47,1826,5,1],[1826,5,1826,6,1],[1826,6,1828,6,1],[1828,6,1828,65,1],[1828,65,1830,6,1],[1830,6,1830,13,1],[1830,13,1830,15,1],[1830,15,1830,20,1],[1830,20,1830,21,1],[1830,21,1830,23,1],[1830,23,1830,24,1],[1830,24,1830,54,1],[1830,54,1830,65,1],[1830,65,1830,66,1],[1830,24,1830,66,1],[1830,66,1831,6,1],[1831,6,1831,7,1],[1831,7,1832,7,1],[1832,7,1832,64,1],[1832,64,1833,7,1],[1833,7,1833,8,1],[1833,8,1834,8,1],[1834,8,1834,58,1],[1834,58,1835,9,1],[1835,9,1835,18,1],[1835,18,1836,7,1],[1836,7,1836,8,1],[1836,8,1838,7,1],[1838,7,1848,11,1],[1848,11,1850,7,1],[1850,7,1850,55,1],[1850,55,1851,25,1],[1851,25,1851,32,1],[1851,32,1851,34,1],[1851,34,1851,39,1],[1851,39,1851,40,1],[1851,40,1851,42,1],[1851,42,1851,43,1],[1851,43,1851,91,1],[1851,91,1851,110,1],[1851,110,1851,119,1],[1851,43,1851,119,1],[1851,119,1852,25,1],[1852,25,1852,26,1],[1852,26,1854,8,1],[1854,8,1854,48,1],[1854,48,1855,7,1],[1855,7,1855,8,1],[1855,8,1857,7,1],[1857,7,1857,78,1],[1857,78,1858,6,1],[1858,6,1858,7,1],[1858,7,1859,6,1],[1859,6,1859,23,1],[1859,23,1860,5,1],[1860,5,1860,6,1],[1860,6,1861,7,1],[1819,4,1861,7,1],[1862,4,1862,14,1],[1863,3,1863,4,1],[1876,9,1876,10,0],[1877,13,1877,46,0],[1878,9,1878,10,0],[1888,9,1888,10,0],[1889,13,1889,40,0],[1889,40,1889,67,0],[1889,67,1889,69,0],[1889,13,1889,69,0],[1890,9,1890,10,0],[1893,9,1893,10,1],[1894,13,1894,39,1],[1894,39,1894,59,1],[1894,59,1894,71,1],[1894,13,1894,71,1],[1895,13,1895,40,1],[1895,40,1895,94,1],[1895,94,1895,96,1],[1895,13,1895,96,1],[1896,9,1896,10,1],[1900,9,1900,10,0],[1901,13,1901,33,0],[1902,9,1902,10,0],[1916,4,1916,5,1],[1917,5,1918,6,1],[1918,6,1918,7,0],[1918,7,1919,7,1],[1919,7,1919,62,0],[1919,62,1921,7,1],[1921,7,1931,10,0],[1931,10,1932,7,1],[1932,7,1932,14,0],[1932,14,1932,16,1],[1932,16,1932,21,0],[1932,21,1932,22,1],[1932,22,1932,24,0],[1932,24,1932,25,1],[1932,25,1932,47,0],[1932,47,1932,84,0],[1932,84,1932,85,0],[1932,25,1932,85,0],[1932,85,1933,7,1],[1933,7,1933,8,0],[1933,8,1934,8,1],[1934,8,1934,38,0],[1934,38,1935,7,1],[1935,7,1935,8,0],[1935,8,1936,7,1],[1936,7,1936,24,0],[1936,24,1937,6,1],[1937,6,1937,7,0],[1937,7,1937,9,1],[1917,5,1937,9,1],[1938,4,1938,5,1],[1939,8,1939,9,1],[1939,10,1939,46,1],[1939,47,1939,48,1],[1954,9,1954,10,0],[1955,13,1960,26,0],[1961,9,1961,10,0]]);
    </script>
  </body>
</html>