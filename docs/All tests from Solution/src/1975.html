<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Models\ContentTypeCompositionBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using Umbraco.Core.Exceptions;

namespace Umbraco.Core.Models
{
    /// &lt;summary&gt;
    /// Represents an abstract class for composition specific ContentType properties and methods
    /// &lt;/summary&gt;
    [Serializable]
    [DataContract(IsReference = true)]
    public abstract class ContentTypeCompositionBase : ContentTypeBase, IContentTypeComposition
    {
        private List&lt;IContentTypeComposition&gt; _contentTypeComposition = new List&lt;IContentTypeComposition&gt;();
        internal List&lt;int&gt; RemovedContentTypeKeyTracker = new List&lt;int&gt;();

        protected ContentTypeCompositionBase(int parentId) : base(parentId)
        {
        }

        protected ContentTypeCompositionBase(IContentTypeComposition parent)
            : this(parent, null)
        {
        }

        protected ContentTypeCompositionBase(IContentTypeComposition parent, string alias)
            : base(parent, alias)
        {
            AddContentType(parent);
        }

        private static readonly Lazy&lt;PropertySelectors&gt; Ps = new Lazy&lt;PropertySelectors&gt;();

        private class PropertySelectors
        {
            public readonly PropertyInfo ContentTypeCompositionSelector =
                ExpressionHelper.GetPropertyInfo&lt;ContentTypeCompositionBase, IEnumerable&lt;IContentTypeComposition&gt;&gt;(x =&gt; x.ContentTypeComposition);
        }

        /// &lt;summary&gt;
        /// Gets or sets the content types that compose this content type.
        /// &lt;/summary&gt;
        [DataMember]
        public IEnumerable&lt;IContentTypeComposition&gt; ContentTypeComposition
        {
            get { return _contentTypeComposition; }
            set
            {
                _contentTypeComposition = value.ToList();
                OnPropertyChanged(Ps.Value.ContentTypeCompositionSelector);
            }
        }

        /// &lt;summary&gt;
        /// Gets the property groups for the entire composition.
        /// &lt;/summary&gt;
        [IgnoreDataMember]
        public IEnumerable&lt;PropertyGroup&gt; CompositionPropertyGroups
        {
            get
            {
                var groups = ContentTypeComposition.SelectMany(x =&gt; x.CompositionPropertyGroups).Union(PropertyGroups);
                return groups;
            }
        }

        /// &lt;summary&gt;
        /// Gets the property types for the entire composition.
        /// &lt;/summary&gt;
        [IgnoreDataMember]
        public IEnumerable&lt;PropertyType&gt; CompositionPropertyTypes
        {
            get
            {
                var propertyTypes = ContentTypeComposition.SelectMany(x =&gt; x.CompositionPropertyTypes).Union(PropertyTypes);
                return propertyTypes;
            }
        }

        /// &lt;summary&gt;
        /// Adds a content type to the composition.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;contentType&quot;&gt;The content type to add.&lt;/param&gt;
        /// &lt;returns&gt;True if the content type was added, otherwise false.&lt;/returns&gt;
        public bool AddContentType(IContentTypeComposition contentType)
        {
            if (contentType.ContentTypeComposition.Any(x =&gt; x.CompositionAliases().Any(ContentTypeCompositionExists)))
                return false;

            if (string.IsNullOrEmpty(Alias) == false &amp;&amp; Alias.Equals(contentType.Alias))
                return false;

            if (ContentTypeCompositionExists(contentType.Alias) == false)
            {
                //Before we actually go ahead and add the ContentType as a Composition we ensure that we don&#39;t
                //end up with duplicate PropertyType aliases - in which case we throw an exception.
                var conflictingPropertyTypeAliases = CompositionPropertyTypes.SelectMany(
                    x =&gt; contentType.CompositionPropertyTypes
                        .Where(y =&gt; y.Alias.Equals(x.Alias, StringComparison.InvariantCultureIgnoreCase))
                        .Select(p =&gt; p.Alias)).ToList();

                if (conflictingPropertyTypeAliases.Any())
                    throw new InvalidCompositionException(Alias, contentType.Alias, conflictingPropertyTypeAliases.ToArray());

                _contentTypeComposition.Add(contentType);
                OnPropertyChanged(Ps.Value.ContentTypeCompositionSelector);
                return true;
            }
            return false;
        }

        /// &lt;summary&gt;
        /// Removes a content type with a specified alias from the composition.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The alias of the content type to remove.&lt;/param&gt;
        /// &lt;returns&gt;True if the content type was removed, otherwise false.&lt;/returns&gt;
        public bool RemoveContentType(string alias)
        {
            if (ContentTypeCompositionExists(alias))
            {
                var contentTypeComposition = ContentTypeComposition.FirstOrDefault(x =&gt; x.Alias == alias);
                if (contentTypeComposition == null)//You can&#39;t remove a composition from another composition
                    return false;

                RemovedContentTypeKeyTracker.Add(contentTypeComposition.Id);

                //If the ContentType we are removing has Compositions of its own these needs to be removed as well
                var compositionIdsToRemove = contentTypeComposition.CompositionIds().ToList();
                if (compositionIdsToRemove.Any())
                    RemovedContentTypeKeyTracker.AddRange(compositionIdsToRemove);

                OnPropertyChanged(Ps.Value.ContentTypeCompositionSelector);
                return _contentTypeComposition.Remove(contentTypeComposition);
            }
            return false;
        }

        /// &lt;summary&gt;
        /// Checks if a ContentType with the supplied alias exists in the list of composite ContentTypes
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;Alias of a &lt;see cref=&quot;ContentType&quot;/&gt;&lt;/param&gt;
        /// &lt;returns&gt;True if ContentType with alias exists, otherwise returns False&lt;/returns&gt;
        public bool ContentTypeCompositionExists(string alias)
        {
            if (ContentTypeComposition.Any(x =&gt; x.Alias.Equals(alias)))
                return true;

            if (ContentTypeComposition.Any(x =&gt; x.ContentTypeCompositionExists(alias)))
                return true;

            return false;
        }

        /// &lt;summary&gt;
        /// Checks whether a PropertyType with a given alias already exists
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyTypeAlias&quot;&gt;Alias of the PropertyType&lt;/param&gt;
        /// &lt;returns&gt;Returns &lt;c&gt;True&lt;/c&gt; if a PropertyType with the passed in alias exists, otherwise &lt;c&gt;False&lt;/c&gt;&lt;/returns&gt;
        public override bool PropertyTypeExists(string propertyTypeAlias)
        {
            return CompositionPropertyTypes.Any(x =&gt; x.Alias == propertyTypeAlias);
        }

        /// &lt;summary&gt;
        /// Adds a PropertyGroup.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;groupName&quot;&gt;Name of the PropertyGroup to add&lt;/param&gt;
        /// &lt;returns&gt;Returns &lt;c&gt;True&lt;/c&gt; if a PropertyGroup with the passed in name was added, otherwise &lt;c&gt;False&lt;/c&gt;&lt;/returns&gt;
        public override bool AddPropertyGroup(string groupName)
        {
            return AddAndReturnPropertyGroup(groupName) != null;
        }

        private PropertyGroup AddAndReturnPropertyGroup(string name)
        {
            // ensure we don&#39;t have it already
            if (PropertyGroups.Any(x =&gt; x.Name == name))
                return null;

            // create the new group
            var group = new PropertyGroup { Name = name, SortOrder = 0 };

            // check if it is inherited - there might be more than 1 but we want the 1st, to
            // reuse its sort order - if there are more than 1 and they have different sort
            // orders... there isn&#39;t much we can do anyways
            var inheritGroup = CompositionPropertyGroups.FirstOrDefault(x =&gt; x.Name == name);
            if (inheritGroup == null)
            {
                // no, just local, set sort order
                var lastGroup = PropertyGroups.LastOrDefault();
                if (lastGroup != null)
                    group.SortOrder = lastGroup.SortOrder + 1;
            }
            else
            {
                // yes, inherited, re-use sort order
                group.SortOrder = inheritGroup.SortOrder;
            }

            // add
            PropertyGroups.Add(group);

            return group;
        }

        /// &lt;summary&gt;
        /// Adds a PropertyType to a specific PropertyGroup
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyType&quot;&gt;&lt;see cref=&quot;PropertyType&quot;/&gt; to add&lt;/param&gt;
        /// &lt;param name=&quot;propertyGroupName&quot;&gt;Name of the PropertyGroup to add the PropertyType to&lt;/param&gt;
        /// &lt;returns&gt;Returns &lt;c&gt;True&lt;/c&gt; if PropertyType was added, otherwise &lt;c&gt;False&lt;/c&gt;&lt;/returns&gt;
        public override bool AddPropertyType(PropertyType propertyType, string propertyGroupName)
        {
            // ensure no duplicate alias - over all composition properties
            if (PropertyTypeExists(propertyType.Alias))
                return false;

            // get and ensure a group local to this content type
            var group = PropertyGroups.Contains(propertyGroupName)
                ? PropertyGroups[propertyGroupName]
                : AddAndReturnPropertyGroup(propertyGroupName);
            if (group == null)
                return false;

            // add property to group
            propertyType.PropertyGroupId = new Lazy&lt;int&gt;(() =&gt; group.Id);
            group.PropertyTypes.Add(propertyType);

            return true;
        }

        /// &lt;summary&gt;
        /// Gets a list of ContentType aliases from the current composition 
        /// &lt;/summary&gt;
        /// &lt;returns&gt;An enumerable list of string aliases&lt;/returns&gt;
        /// &lt;remarks&gt;Does not contain the alias of the Current ContentType&lt;/remarks&gt;
        public IEnumerable&lt;string&gt; CompositionAliases()
        {
            return ContentTypeComposition
                .Select(x =&gt; x.Alias)
                .Union(ContentTypeComposition.SelectMany(x =&gt; x.CompositionAliases()));
        }

        /// &lt;summary&gt;
        /// Gets a list of ContentType Ids from the current composition 
        /// &lt;/summary&gt;
        /// &lt;returns&gt;An enumerable list of integer ids&lt;/returns&gt;
        /// &lt;remarks&gt;Does not contain the Id of the Current ContentType&lt;/remarks&gt;
        public IEnumerable&lt;int&gt; CompositionIds()
        {
            return ContentTypeComposition
                .Select(x =&gt; x.Id)
                .Union(ContentTypeComposition.SelectMany(x =&gt; x.CompositionIds()));
        }

        public override object DeepClone()
        {
            var clone = (ContentTypeCompositionBase)base.DeepClone();
            //turn off change tracking
            clone.DisableChangeTracking();
            //need to manually assign since this is an internal field and will not be automatically mapped
            clone.RemovedContentTypeKeyTracker = new List&lt;int&gt;();
            clone._contentTypeComposition = ContentTypeComposition.Select(x =&gt; (IContentTypeComposition)x.DeepClone()).ToList();
            //this shouldn&#39;t really be needed since we&#39;re not tracking
            clone.ResetDirtyProperties(false);
            //re-enable tracking
            clone.EnableChangeTracking();

            return clone;
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[17,9,17,109,1],[17,9,17,109,1],[18,9,18,75,1],[18,9,18,75,1],[20,62,20,76,1],[21,9,21,10,1],[22,9,22,10,1],[25,15,25,33,0],[26,9,26,10,0],[27,9,27,10,0],[30,15,30,34,1],[31,9,31,10,1],[32,13,32,36,1],[33,9,33,10,1],[35,9,35,92,1],[39,13,40,147,1],[49,17,49,18,1],[49,19,49,50,1],[49,51,49,52,1],[51,13,51,14,1],[52,17,52,58,1],[53,17,53,76,1],[54,13,54,14,1],[64,13,64,14,1],[65,17,65,69,1],[65,69,65,96,1],[65,96,65,120,1],[65,17,65,120,1],[66,17,66,31,1],[67,13,67,14,1],[77,13,77,14,1],[78,17,78,76,1],[78,76,78,102,1],[78,102,78,125,1],[78,17,78,125,1],[79,17,79,38,1],[80,13,80,14,1],[89,9,89,10,1],[90,13,90,61,1],[90,61,90,117,1],[90,117,90,119,1],[90,13,90,119,1],[91,17,91,30,1],[93,13,93,89,1],[94,17,94,30,0],[96,13,96,74,1],[97,13,97,14,1],[100,17,101,26,1],[101,26,102,37,1],[102,37,102,105,1],[102,105,103,38,1],[103,38,103,45,0],[103,45,103,46,1],[101,26,103,46,1],[103,46,103,57,1],[100,17,103,57,1],[105,17,105,58,1],[106,21,106,127,0],[108,17,108,58,1],[109,17,109,76,1],[110,17,110,29,1],[112,13,112,26,1],[113,9,113,10,1],[121,9,121,10,1],[122,13,122,53,1],[123,13,123,14,1],[124,17,124,89,1],[124,89,124,105,1],[124,105,124,107,1],[124,17,124,107,1],[125,17,125,52,1],[126,21,126,34,0],[128,17,128,77,1],[131,17,131,95,1],[132,17,132,50,1],[133,21,133,83,1],[135,17,135,76,1],[136,17,136,79,1],[138,13,138,26,0],[139,9,139,10,1],[147,9,147,10,1],[148,13,148,49,1],[148,49,148,70,1],[148,70,148,72,1],[148,13,148,72,1],[149,17,149,29,1],[151,13,151,49,1],[151,49,151,86,1],[151,86,151,88,1],[151,13,151,88,1],[152,17,152,29,1],[154,13,154,26,1],[155,9,155,10,1],[163,9,163,10,1],[164,13,164,54,1],[164,54,164,82,1],[164,82,164,84,1],[164,13,164,84,1],[165,9,165,10,1],[173,9,173,10,1],[174,13,174,65,1],[175,9,175,10,1],[178,9,178,10,1],[180,13,180,41,1],[180,41,180,55,1],[180,55,180,57,1],[180,13,180,57,1],[181,17,181,29,0],[184,13,184,74,1],[189,13,189,78,1],[189,78,189,92,1],[189,92,189,94,1],[189,13,189,94,1],[190,13,190,38,1],[191,13,191,14,1],[193,17,193,64,1],[194,17,194,39,1],[195,21,195,63,1],[196,13,196,14,1],[198,13,198,14,1],[200,17,200,58,1],[201,13,201,14,1],[204,13,204,39,1],[206,13,206,26,1],[207,9,207,10,1],[216,9,216,10,1],[218,13,218,56,1],[219,17,219,30,1],[222,13,224,64,1],[225,13,225,31,1],[226,17,226,30,0],[229,13,229,64,1],[229,64,229,72,1],[229,72,229,74,1],[229,13,229,74,1],[230,13,230,51,1],[232,13,232,25,1],[233,9,233,10,1],[241,9,241,10,1],[242,13,243,30,1],[243,30,243,37,1],[243,37,244,63,1],[244,63,244,85,1],[244,85,244,88,1],[242,13,244,88,1],[245,9,245,10,1],[253,9,253,10,1],[254,13,255,30,1],[255,30,255,34,1],[255,34,256,63,1],[256,63,256,81,1],[256,81,256,84,1],[254,13,256,84,1],[257,9,257,10,1],[260,9,260,10,1],[261,13,261,70,1],[263,13,263,43,1],[265,13,265,66,1],[266,13,266,80,1],[266,80,266,118,1],[266,118,266,129,1],[266,13,266,129,1],[268,13,268,47,1],[270,13,270,42,1],[272,13,272,26,1],[273,9,273,10,1]]);
    </script>
  </body>
</html>