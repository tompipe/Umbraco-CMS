<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\EnumerableExtensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using Umbraco.Core.Logging;

namespace Umbraco.Core
{
    ///&lt;summary&gt;
    /// Extensions for enumerable sources
    ///&lt;/summary&gt;
    public static class EnumerableExtensions
    {
        public static IEnumerable&lt;IEnumerable&lt;T&gt;&gt; InGroupsOf&lt;T&gt;(this IEnumerable&lt;T&gt; source, int groupSize)
        {
            if (source == null)
                throw new ArgumentNullException(&quot;source&quot;);
            if (groupSize &lt;= 0)
                throw new ArgumentException(&quot;Must be greater than zero.&quot;, &quot;groupSize&quot;);

            return source
                .Select((x, i) =&gt; Tuple.Create(i / groupSize, x))
                .GroupBy(t =&gt; t.Item1, t =&gt; t.Item2);
        }

        /// &lt;summary&gt;The distinct by.&lt;/summary&gt;
        /// &lt;param name=&quot;source&quot;&gt;The source.&lt;/param&gt;
        /// &lt;param name=&quot;keySelector&quot;&gt;The key selector.&lt;/param&gt;
        /// &lt;typeparam name=&quot;TSource&quot;&gt;Source type&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TKey&quot;&gt;Key type&lt;/typeparam&gt;
        /// &lt;returns&gt;the unique list&lt;/returns&gt;
        public static IEnumerable&lt;TSource&gt; DistinctBy&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector)
            where TKey : IEquatable&lt;TKey&gt;
        {
            return source.Distinct(DelegateEqualityComparer&lt;TSource&gt;.CompareMember(keySelector));
        }

        /// &lt;summary&gt;
        /// Returns a sequence of length &lt;paramref name=&quot;count&quot;/&gt; whose elements are the result of invoking &lt;paramref name=&quot;factory&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;factory&quot;&gt;The factory.&lt;/param&gt;
        /// &lt;param name=&quot;count&quot;&gt;The count.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static IEnumerable&lt;T&gt; Range&lt;T&gt;(Func&lt;int, T&gt; factory, int count)
        {
            for (int i = 1; i &lt;= count; i++)
            {
                yield return factory.Invoke(i - 1);
            }
        }

        /// &lt;summary&gt;The if not null.&lt;/summary&gt;
        /// &lt;param name=&quot;items&quot;&gt;The items.&lt;/param&gt;
        /// &lt;param name=&quot;action&quot;&gt;The action.&lt;/param&gt;
        /// &lt;typeparam name=&quot;TItem&quot;&gt;The type&lt;/typeparam&gt;
        public static void IfNotNull&lt;TItem&gt;(this IEnumerable&lt;TItem&gt; items, Action&lt;TItem&gt; action) where TItem : class
        {
            if (items != null)
            {
                foreach (TItem item in items)
                {
                    item.IfNotNull(action);
                }
            }
        }

        /// &lt;summary&gt;The for each.&lt;/summary&gt;
        /// &lt;param name=&quot;items&quot;&gt;The items.&lt;/param&gt;
        /// &lt;param name=&quot;func&quot;&gt;The func.&lt;/param&gt;
        /// &lt;typeparam name=&quot;TItem&quot;&gt;item type&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TResult&quot;&gt;Result type&lt;/typeparam&gt;
        /// &lt;returns&gt;the Results&lt;/returns&gt;
        public static TResult[] ForEach&lt;TItem, TResult&gt;(this IEnumerable&lt;TItem&gt; items, Func&lt;TItem, TResult&gt; func)
        {
            return items.Select(func).ToArray();
        }

        /// &lt;summary&gt;The for each.&lt;/summary&gt;
        /// &lt;param name=&quot;items&quot;&gt;The items.&lt;/param&gt;
        /// &lt;param name=&quot;action&quot;&gt;The action.&lt;/param&gt;
        /// &lt;typeparam name=&quot;TItem&quot;&gt;Item type&lt;/typeparam&gt;
        /// &lt;returns&gt;list of TItem&lt;/returns&gt;
        public static IEnumerable&lt;TItem&gt; ForEach&lt;TItem&gt;(this IEnumerable&lt;TItem&gt; items, Action&lt;TItem&gt; action)
        {
            if (items != null)
            {
                foreach (TItem item in items)
                {
                    action(item);
                }
            }

            return items;
        }

        /// &lt;summary&gt;The flatten list.&lt;/summary&gt;
        /// &lt;param name=&quot;e&quot;&gt;The items.&lt;/param&gt;
        /// &lt;param name=&quot;f&quot;&gt;The select child.&lt;/param&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;Item type&lt;/typeparam&gt;
        /// &lt;returns&gt;list of TItem&lt;/returns&gt;
        [Obsolete(&quot;Do not use, use SelectRecursive instead which has far less potential of re-iterating an iterator which may cause significantly more SQL queries&quot;)]
        public static IEnumerable&lt;T&gt; FlattenList&lt;T&gt;(this IEnumerable&lt;T&gt; e, Func&lt;T, IEnumerable&lt;T&gt;&gt; f)
        {
            return e.SelectMany(c =&gt; f(c).FlattenList(f)).Concat(e);
        }

        /// &lt;summary&gt;
        /// Returns true if all items in the other collection exist in this collection
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TSource&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;other&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static bool ContainsAll&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, IEnumerable&lt;TSource&gt; other)
        {
            return other.Except(source).Any() == false;
        }

        /// &lt;summary&gt;
        /// Returns true if the source contains any of the items in the other list
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TSource&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;other&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static bool ContainsAny&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, IEnumerable&lt;TSource&gt; other)
        {
            return other.Any(source.Contains);
        }

        /// &lt;summary&gt;
        /// Removes all matching items from an &lt;see cref=&quot;IList{T}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;list&quot;&gt;The list.&lt;/param&gt;
        /// &lt;param name=&quot;predicate&quot;&gt;The predicate.&lt;/param&gt;
        /// &lt;remarks&gt;&lt;/remarks&gt;
        public static void RemoveAll&lt;T&gt;(this IList&lt;T&gt; list, Func&lt;T, bool&gt; predicate)
        {
            for (var i = 0; i &lt; list.Count; i++)
            {
                if (predicate(list[i]))
                {
                    list.RemoveAt(i--);
                }
            }
        }

        /// &lt;summary&gt;
        /// Removes all matching items from an &lt;see cref=&quot;ICollection{T}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;list&quot;&gt;The list.&lt;/param&gt;
        /// &lt;param name=&quot;predicate&quot;&gt;The predicate.&lt;/param&gt;
        /// &lt;remarks&gt;&lt;/remarks&gt;
        public static void RemoveAll&lt;T&gt;(this ICollection&lt;T&gt; list, Func&lt;T, bool&gt; predicate)
        {
            var matches = list.Where(predicate).ToArray();
            foreach (var match in matches)
            {
                list.Remove(match);
            }
        }

        public static IEnumerable&lt;TSource&gt; SelectRecursive&lt;TSource&gt;(
          this IEnumerable&lt;TSource&gt; source,
          Func&lt;TSource, IEnumerable&lt;TSource&gt;&gt; recursiveSelector, int maxRecusionDepth = 100)
        {
            var stack = new Stack&lt;IEnumerator&lt;TSource&gt;&gt;();
            stack.Push(source.GetEnumerator());

            try
            {
                while (stack.Count &gt; 0)
                {
                    if (stack.Count &gt; maxRecusionDepth)
                        throw new InvalidOperationException(&quot;Maximum recursion depth reached of &quot; + maxRecusionDepth);

                    if (stack.Peek().MoveNext())
                    {
                        var current = stack.Peek().Current;

                        yield return current;

                        stack.Push(recursiveSelector(current).GetEnumerator());
                    }
                    else
                    {
                        stack.Pop().Dispose();
                    }
                }
            }
            finally
            {
                while (stack.Count &gt; 0)
                {
                    stack.Pop().Dispose();
                }
            }
        }

        /// &lt;summary&gt;
        /// Filters a sequence of values to ignore those which are null.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;coll&quot;&gt;The coll.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;&lt;/remarks&gt;
        public static IEnumerable&lt;T&gt; WhereNotNull&lt;T&gt;(this IEnumerable&lt;T&gt; coll) where T : class
        {
            return coll.Where(x =&gt; x != null);
        }

        public static IEnumerable&lt;TBase&gt; ForAllThatAre&lt;TBase, TActual&gt;(this IEnumerable&lt;TBase&gt; sequence, Action&lt;TActual&gt; projection)
            where TActual : class
        {
            return sequence.Select(
                x =&gt;
                {
                    if (x is TActual)
                    {
                        var casted = x as TActual;
                        projection.Invoke(casted);
                    }
                    return x;
                });
        }

        /// &lt;summary&gt;
        /// Finds the index of the first item matching an expression in an enumerable.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The type of the enumerated objects.&lt;/typeparam&gt;
        /// &lt;param name=&quot;items&quot;&gt;The enumerable to search.&lt;/param&gt;
        /// &lt;param name=&quot;predicate&quot;&gt;The expression to test the items against.&lt;/param&gt;
        /// &lt;returns&gt;The index of the first matching item, or -1.&lt;/returns&gt;
        public static int FindIndex&lt;T&gt;(this IEnumerable&lt;T&gt; items, Func&lt;T, bool&gt; predicate)
        {
            return FindIndex(items, 0, predicate);
        }

        /// &lt;summary&gt;
        /// Finds the index of the first item matching an expression in an enumerable.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The type of the enumerated objects.&lt;/typeparam&gt;
        /// &lt;param name=&quot;items&quot;&gt;The enumerable to search.&lt;/param&gt;
        /// &lt;param name=&quot;startIndex&quot;&gt;The index to start at.&lt;/param&gt;
        /// &lt;param name=&quot;predicate&quot;&gt;The expression to test the items against.&lt;/param&gt;
        /// &lt;returns&gt;The index of the first matching item, or -1.&lt;/returns&gt;
        public static int FindIndex&lt;T&gt;(this IEnumerable&lt;T&gt; items, int startIndex, Func&lt;T, bool&gt; predicate)
        {
            if (items == null) throw new ArgumentNullException(&quot;items&quot;);
            if (predicate == null) throw new ArgumentNullException(&quot;predicate&quot;);
            if (startIndex &lt; 0) throw new ArgumentOutOfRangeException(&quot;startIndex&quot;);

            var index = startIndex;
            if (index &gt; 0)
                items = items.Skip(index);

            foreach (var item in items)
            {
                if (predicate(item)) return index;
                index++;
            }

            return -1;
        }

        ///&lt;summary&gt;Finds the index of the first occurence of an item in an enumerable.&lt;/summary&gt;
        ///&lt;param name=&quot;items&quot;&gt;The enumerable to search.&lt;/param&gt;
        ///&lt;param name=&quot;item&quot;&gt;The item to find.&lt;/param&gt;
        ///&lt;returns&gt;The index of the first matching item, or -1 if the item was not found.&lt;/returns&gt;
        public static int IndexOf&lt;T&gt;(this IEnumerable&lt;T&gt; items, T item)
        {
            return items.FindIndex(i =&gt; EqualityComparer&lt;T&gt;.Default.Equals(item, i));
        }

        /// &lt;summary&gt;
        /// Determines if 2 lists have equal elements within them regardless of how they are sorted
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;other&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// The logic for this is taken from:
        /// http://stackoverflow.com/questions/4576723/test-whether-two-ienumerablet-have-the-same-values-with-the-same-frequencies
        /// 
        /// There&#39;s a few answers, this one seems the best for it&#39;s simplicity and based on the comment of Eamon
        /// &lt;/remarks&gt;
        public static bool UnsortedSequenceEqual&lt;T&gt;(this IEnumerable&lt;T&gt; source, IEnumerable&lt;T&gt; other)
        {
            if (source == null &amp;&amp; other == null) return true;
            if (source == null || other == null) return false;

            var list1Groups = source.ToLookup(i =&gt; i);
            var list2Groups = other.ToLookup(i =&gt; i);
            return list1Groups.Count == list2Groups.Count
               &amp;&amp; list1Groups.All(g =&gt; g.Count() == list2Groups[g.Key].Count());
        }

    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[17,9,17,10,1],[18,13,18,32,1],[19,17,19,59,0],[20,13,20,32,1],[21,17,21,88,0],[23,13,24,35,1],[24,35,24,65,1],[24,65,25,31,1],[25,31,25,38,1],[25,38,25,45,1],[25,45,25,52,1],[25,52,25,54,1],[23,13,25,54,1],[26,9,26,10,1],[36,9,36,10,1],[37,13,37,98,1],[38,9,38,10,1],[60,9,60,10,0],[61,13,61,31,0],[62,13,62,14,0],[63,17,63,24,0],[63,26,63,36,0],[63,37,63,39,0],[63,40,63,45,0],[64,17,64,18,0],[65,21,65,44,0],[66,17,66,18,0],[67,13,67,14,0],[68,9,68,10,0],[77,9,77,10,1],[78,13,78,49,1],[79,9,79,10,1],[87,9,87,10,1],[88,13,88,31,1],[89,13,89,14,1],[90,17,90,24,1],[90,26,90,36,1],[90,37,90,39,1],[90,40,90,45,1],[91,17,91,18,1],[92,21,92,34,1],[93,17,93,18,1],[94,13,94,14,1],[96,13,96,26,1],[97,9,97,10,1],[106,9,106,10,1],[107,13,107,38,1],[107,38,107,57,1],[107,57,107,69,1],[107,13,107,69,1],[108,9,108,10,1],[118,9,118,10,1],[119,13,119,56,1],[120,9,120,10,1],[130,9,130,10,0],[131,13,131,47,0],[132,9,132,10,0],[142,9,142,10,0],[143,18,143,27,0],[143,29,143,43,0],[143,45,143,48,0],[144,13,144,14,0],[145,17,145,40,0],[146,17,146,18,0],[147,21,147,40,0],[148,17,148,18,0],[149,13,149,14,0],[150,9,150,10,0],[160,9,160,10,1],[161,13,161,59,1],[162,13,162,20,1],[162,22,162,31,1],[162,32,162,34,1],[162,35,162,42,1],[163,13,163,14,1],[164,17,164,36,1],[165,13,165,14,1],[166,9,166,10,1],[213,9,213,10,1],[214,13,214,36,1],[214,36,214,45,1],[214,45,214,47,1],[214,13,214,47,1],[215,9,215,10,1],[219,9,219,10,0],[220,13,222,17,0],[222,17,222,18,0],[222,18,223,21,0],[223,21,223,38,0],[223,38,224,21,0],[224,21,224,22,0],[224,22,225,25,0],[225,25,225,51,0],[225,51,226,25,0],[226,25,226,51,0],[226,51,227,21,0],[227,21,227,22,0],[227,22,228,21,0],[228,21,228,30,0],[228,30,229,17,0],[229,17,229,18,0],[229,18,229,20,0],[220,13,229,20,0],[230,9,230,10,0],[240,9,240,10,1],[241,13,241,51,1],[242,9,242,10,1],[253,9,253,10,1],[254,13,254,31,1],[254,32,254,73,0],[255,13,255,35,1],[255,36,255,81,0],[256,13,256,32,1],[256,33,256,85,0],[258,13,258,36,1],[259,13,259,27,1],[260,17,260,43,0],[262,13,262,20,1],[262,22,262,30,1],[262,31,262,33,1],[262,34,262,39,1],[263,13,263,14,1],[264,17,264,37,1],[264,38,264,51,1],[265,17,265,25,1],[266,13,266,14,1],[268,13,268,23,0],[269,9,269,10,1],[276,9,276,10,0],[277,13,277,41,0],[277,41,277,84,0],[277,84,277,86,0],[277,13,277,86,0],[278,9,278,10,0],[294,9,294,10,1],[295,13,295,49,1],[295,50,295,62,1],[296,13,296,49,1],[296,50,296,63,1],[298,13,298,52,1],[298,52,298,53,1],[298,53,298,55,1],[298,13,298,55,1],[299,13,299,51,1],[299,51,299,52,1],[299,52,299,54,1],[299,13,299,54,1],[300,13,301,40,1],[301,40,301,79,1],[301,79,301,81,1],[300,13,301,81,1],[302,9,302,10,1]]);
    </script>
  </body>
</html>