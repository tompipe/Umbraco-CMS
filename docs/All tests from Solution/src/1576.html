<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Security\MembershipProviderBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Specialized;
using System.Configuration.Provider;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using System.Web.Configuration;
using System.Web.Hosting;
using System.Web.Security;
using Umbraco.Core.Logging;

namespace Umbraco.Core.Security
{
    /// &lt;summary&gt;
    /// A base membership provider class offering much of the underlying functionality for initializing and password encryption/hashing.
    /// &lt;/summary&gt;
    public abstract class MembershipProviderBase : MembershipProvider
    {

        public string HashPasswordForStorage(string password)
        {
            string salt;
            var hashed = EncryptOrHashNewPassword(password, out salt);
            return FormatPasswordForStorage(hashed, salt);
        }

        public bool VerifyPassword(string password, string hashedPassword)
        {
            return CheckPassword(password, hashedPassword);
        }

        /// &lt;summary&gt;
        /// Providers can override this setting, default is 7
        /// &lt;/summary&gt;
        public virtual int DefaultMinPasswordLength
        {
            get { return 7; }
        }

        /// &lt;summary&gt;
        /// Providers can override this setting, default is 1
        /// &lt;/summary&gt;
        public virtual int DefaultMinNonAlphanumericChars
        {
            get { return 1; }
        }

        /// &lt;summary&gt;
        /// Providers can override this setting, default is false to use better security
        /// &lt;/summary&gt;
        public virtual bool DefaultUseLegacyEncoding
        {
            get { return false; }
        }

        /// &lt;summary&gt;
        /// Providers can override this setting, by default this is false which means that the provider will 
        /// authenticate the username + password when ChangePassword is called. This property exists purely for
        /// backwards compatibility.
        /// &lt;/summary&gt;
        public virtual bool AllowManuallyChangingPassword
        {
            get { return false; }
        }

        private string _applicationName;
        private bool _enablePasswordReset;
        private bool _enablePasswordRetrieval;
        private int _maxInvalidPasswordAttempts;
        private int _minRequiredNonAlphanumericCharacters;
        private int _minRequiredPasswordLength;
        private int _passwordAttemptWindow;
        private MembershipPasswordFormat _passwordFormat;
        private string _passwordStrengthRegularExpression;
        private bool _requiresQuestionAndAnswer;
        private bool _requiresUniqueEmail;
        private string _customHashAlgorithmType ;
        internal bool UseLegacyEncoding;

        #region Properties


        /// &lt;summary&gt;
        /// Indicates whether the membership provider is configured to allow users to reset their passwords.
        /// &lt;/summary&gt;
        /// &lt;value&gt;&lt;/value&gt;
        /// &lt;returns&gt;true if the membership provider supports password reset; otherwise, false. The default is true.&lt;/returns&gt;
        public override bool EnablePasswordReset
        {
            get { return _enablePasswordReset; }
        }

        /// &lt;summary&gt;
        /// Indicates whether the membership provider is configured to allow users to retrieve their passwords.
        /// &lt;/summary&gt;
        /// &lt;value&gt;&lt;/value&gt;
        /// &lt;returns&gt;true if the membership provider is configured to support password retrieval; otherwise, false. The default is false.&lt;/returns&gt;
        public override bool EnablePasswordRetrieval
        {
            get { return _enablePasswordRetrieval; }
        }

        /// &lt;summary&gt;
        /// Gets the number of invalid password or password-answer attempts allowed before the membership user is locked out.
        /// &lt;/summary&gt;
        /// &lt;value&gt;&lt;/value&gt;
        /// &lt;returns&gt;The number of invalid password or password-answer attempts allowed before the membership user is locked out.&lt;/returns&gt;
        public override int MaxInvalidPasswordAttempts
        {
            get { return _maxInvalidPasswordAttempts; }
        }

        /// &lt;summary&gt;
        /// Gets the minimum number of special characters that must be present in a valid password.
        /// &lt;/summary&gt;
        /// &lt;value&gt;&lt;/value&gt;
        /// &lt;returns&gt;The minimum number of special characters that must be present in a valid password.&lt;/returns&gt;
        public override int MinRequiredNonAlphanumericCharacters
        {
            get { return _minRequiredNonAlphanumericCharacters; }
        }

        /// &lt;summary&gt;
        /// Gets the minimum length required for a password.
        /// &lt;/summary&gt;
        /// &lt;value&gt;&lt;/value&gt;
        /// &lt;returns&gt;The minimum length required for a password. &lt;/returns&gt;
        public override int MinRequiredPasswordLength
        {
            get { return _minRequiredPasswordLength; }
        }

        /// &lt;summary&gt;
        /// Gets the number of minutes in which a maximum number of invalid password or password-answer attempts are allowed before the membership user is locked out.
        /// &lt;/summary&gt;
        /// &lt;value&gt;&lt;/value&gt;
        /// &lt;returns&gt;The number of minutes in which a maximum number of invalid password or password-answer attempts are allowed before the membership user is locked out.&lt;/returns&gt;
        public override int PasswordAttemptWindow
        {
            get { return _passwordAttemptWindow; }
        }

        /// &lt;summary&gt;
        /// Gets a value indicating the format for storing passwords in the membership data store.
        /// &lt;/summary&gt;
        /// &lt;value&gt;&lt;/value&gt;
        /// &lt;returns&gt;One of the &lt;see cref=&quot;T:System.Web.Security.MembershipPasswordFormat&quot;&gt;&lt;/see&gt; values indicating the format for storing passwords in the data store.&lt;/returns&gt;
        public override MembershipPasswordFormat PasswordFormat
        {
            get { return _passwordFormat; }
        }

        /// &lt;summary&gt;
        /// Gets the regular expression used to evaluate a password.
        /// &lt;/summary&gt;
        /// &lt;value&gt;&lt;/value&gt;
        /// &lt;returns&gt;A regular expression used to evaluate a password.&lt;/returns&gt;
        public override string PasswordStrengthRegularExpression
        {
            get { return _passwordStrengthRegularExpression; }
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether the membership provider is configured to require the user to answer a password question for password reset and retrieval.
        /// &lt;/summary&gt;
        /// &lt;value&gt;&lt;/value&gt;
        /// &lt;returns&gt;true if a password answer is required for password reset and retrieval; otherwise, false. The default is true.&lt;/returns&gt;
        public override bool RequiresQuestionAndAnswer
        {
            get { return _requiresQuestionAndAnswer; }
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether the membership provider is configured to require a unique e-mail address for each user name.
        /// &lt;/summary&gt;
        /// &lt;value&gt;&lt;/value&gt;
        /// &lt;returns&gt;true if the membership provider requires a unique e-mail address; otherwise, false. The default is true.&lt;/returns&gt;
        public override bool RequiresUniqueEmail
        {
            get { return _requiresUniqueEmail; }
        }

        /// &lt;summary&gt;
        /// The name of the application using the custom membership provider.
        /// &lt;/summary&gt;
        /// &lt;value&gt;&lt;/value&gt;
        /// &lt;returns&gt;The name of the application using the custom membership provider.&lt;/returns&gt;
        public override string ApplicationName
        {
            get
            {
                return _applicationName;
            }
            set
            {
                if (string.IsNullOrEmpty(value))
                    throw new ProviderException(&quot;ApplicationName cannot be empty.&quot;);

                if (value.Length &gt; 0x100)
                    throw new ProviderException(&quot;Provider application name too long.&quot;);

                _applicationName = value;
            }
        }

        #endregion

        /// &lt;summary&gt;
        /// Initializes the provider.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The friendly name of the provider.&lt;/param&gt;
        /// &lt;param name=&quot;config&quot;&gt;A collection of the name/value pairs representing the provider-specific attributes specified in the configuration for this provider.&lt;/param&gt;
        /// &lt;exception cref=&quot;T:System.ArgumentNullException&quot;&gt;The name of the provider is null.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.InvalidOperationException&quot;&gt;An attempt is made to call 
        /// &lt;see cref=&quot;M:System.Configuration.Provider.ProviderBase.Initialize(System.String,System.Collections.Specialized.NameValueCollection)&quot;&gt;&lt;/see&gt; on a provider after the provider 
        /// has already been initialized.&lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.ArgumentException&quot;&gt;The name of the provider has a length of zero.&lt;/exception&gt;
        public override void Initialize(string name, NameValueCollection config)
        {            
            // Initialize base provider class
            base.Initialize(name, config);

            _enablePasswordRetrieval = config.GetValue(&quot;enablePasswordRetrieval&quot;, false);
            _enablePasswordReset = config.GetValue(&quot;enablePasswordReset&quot;, false);
            _requiresQuestionAndAnswer = config.GetValue(&quot;requiresQuestionAndAnswer&quot;, false);
            _requiresUniqueEmail = config.GetValue(&quot;requiresUniqueEmail&quot;, true);
            _maxInvalidPasswordAttempts = GetIntValue(config, &quot;maxInvalidPasswordAttempts&quot;, 5, false, 0);
            _passwordAttemptWindow = GetIntValue(config, &quot;passwordAttemptWindow&quot;, 10, false, 0);
            _minRequiredPasswordLength = GetIntValue(config, &quot;minRequiredPasswordLength&quot;, DefaultMinPasswordLength, true, 0x80);
            _minRequiredNonAlphanumericCharacters = GetIntValue(config, &quot;minRequiredNonalphanumericCharacters&quot;, DefaultMinNonAlphanumericChars, true, 0x80);
            _passwordStrengthRegularExpression = config[&quot;passwordStrengthRegularExpression&quot;];

            _applicationName = config[&quot;applicationName&quot;];
            if (string.IsNullOrEmpty(_applicationName))
                _applicationName = GetDefaultAppName();

            //by default we will continue using the legacy encoding.
            UseLegacyEncoding = config.GetValue(&quot;useLegacyEncoding&quot;, DefaultUseLegacyEncoding);

            // make sure password format is Hashed by default.
            string str = config[&quot;passwordFormat&quot;] ?? &quot;Hashed&quot;;

            switch (str.ToLower())
            {
                case &quot;clear&quot;:
                    _passwordFormat = MembershipPasswordFormat.Clear;
                    break;

                case &quot;encrypted&quot;:
                    _passwordFormat = MembershipPasswordFormat.Encrypted;
                    break;

                case &quot;hashed&quot;:
                    _passwordFormat = MembershipPasswordFormat.Hashed;
                    break;

                default:
                    throw new ProviderException(&quot;Provider bad password format&quot;);
            }

            if ((PasswordFormat == MembershipPasswordFormat.Hashed) &amp;&amp; EnablePasswordRetrieval)
            {
                var ex = new ProviderException(&quot;Provider can not retrieve a hashed password&quot;);
                LogHelper.Error&lt;MembershipProviderBase&gt;(&quot;Cannot specify a Hashed password format with the enabledPasswordRetrieval option set to true&quot;, ex);
                throw ex;
            }
            
            _customHashAlgorithmType = config.GetValue(&quot;hashAlgorithmType&quot;, string.Empty);
        }

        /// &lt;summary&gt;
        /// Override this method to ensure the password is valid before raising the event
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
        protected override void OnValidatingPassword(ValidatePasswordEventArgs e)
        {
            var attempt = IsPasswordValid(e.Password, MinRequiredNonAlphanumericCharacters, PasswordStrengthRegularExpression, MinRequiredPasswordLength);
            if (attempt.Success == false)
            {
                e.Cancel = true;
                return;
            }

            base.OnValidatingPassword(e);
        }

        protected internal enum PasswordValidityError
        {
            Ok,
            Length,
            AlphanumericChars,
            Strength
        }
        
        /// &lt;summary&gt;
        /// Processes a request to update the password for a membership user.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The user to update the password for.&lt;/param&gt;
        /// &lt;param name=&quot;oldPassword&quot;&gt;This property is ignore for this provider&lt;/param&gt;
        /// &lt;param name=&quot;newPassword&quot;&gt;The new password for the specified user.&lt;/param&gt;
        /// &lt;returns&gt;
        /// true if the password was updated successfully; otherwise, false.
        /// &lt;/returns&gt;
        /// &lt;remarks&gt;
        /// Checks to ensure the AllowManuallyChangingPassword rule is adhered to
        /// &lt;/remarks&gt;       
        public override bool ChangePassword(string username, string oldPassword, string newPassword)
        {
            if (oldPassword.IsNullOrWhiteSpace() &amp;&amp; AllowManuallyChangingPassword == false)
            {
                //If the old password is empty and AllowManuallyChangingPassword is false, than this provider cannot just arbitrarily change the password
                throw new NotSupportedException(&quot;This provider does not support manually changing the password&quot;);
            }

            var args = new ValidatePasswordEventArgs(username, newPassword, false);
            OnValidatingPassword(args);

            if (args.Cancel)
            {
                if (args.FailureInformation != null)
                    throw args.FailureInformation;
                throw new MembershipPasswordException(&quot;Change password canceled due to password validation failure.&quot;);
            }

            if (AllowManuallyChangingPassword == false)
            {
                if (ValidateUser(username, oldPassword) == false) return false;
            }

            return PerformChangePassword(username, oldPassword, newPassword);
        }

        /// &lt;summary&gt;
        /// Processes a request to update the password for a membership user.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The user to update the password for.&lt;/param&gt;
        /// &lt;param name=&quot;oldPassword&quot;&gt;This property is ignore for this provider&lt;/param&gt;
        /// &lt;param name=&quot;newPassword&quot;&gt;The new password for the specified user.&lt;/param&gt;
        /// &lt;returns&gt;
        /// true if the password was updated successfully; otherwise, false.
        /// &lt;/returns&gt;
        protected abstract bool PerformChangePassword(string username, string oldPassword, string newPassword);

        /// &lt;summary&gt;
        /// Processes a request to update the password question and answer for a membership user.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The user to change the password question and answer for.&lt;/param&gt;
        /// &lt;param name=&quot;password&quot;&gt;The password for the specified user.&lt;/param&gt;
        /// &lt;param name=&quot;newPasswordQuestion&quot;&gt;The new password question for the specified user.&lt;/param&gt;
        /// &lt;param name=&quot;newPasswordAnswer&quot;&gt;The new password answer for the specified user.&lt;/param&gt;
        /// &lt;returns&gt;
        /// true if the password question and answer are updated successfully; otherwise, false.
        /// &lt;/returns&gt;
        /// &lt;remarks&gt;
        /// Performs the basic validation before passing off to PerformChangePasswordQuestionAndAnswer
        /// &lt;/remarks&gt;
        public override bool ChangePasswordQuestionAndAnswer(string username, string password, string newPasswordQuestion, string newPasswordAnswer)
        {
            if (RequiresQuestionAndAnswer == false)
            {
                throw new NotSupportedException(&quot;Updating the password Question and Answer is not available if requiresQuestionAndAnswer is not set in web.config&quot;);
            }
            
            if (AllowManuallyChangingPassword == false)
            {
                if (ValidateUser(username, password) == false)
                {
                    return false;
                }
            }

            return PerformChangePasswordQuestionAndAnswer(username, password, newPasswordQuestion, newPasswordAnswer);
        }

        /// &lt;summary&gt;
        /// Processes a request to update the password question and answer for a membership user.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The user to change the password question and answer for.&lt;/param&gt;
        /// &lt;param name=&quot;password&quot;&gt;The password for the specified user.&lt;/param&gt;
        /// &lt;param name=&quot;newPasswordQuestion&quot;&gt;The new password question for the specified user.&lt;/param&gt;
        /// &lt;param name=&quot;newPasswordAnswer&quot;&gt;The new password answer for the specified user.&lt;/param&gt;
        /// &lt;returns&gt;
        /// true if the password question and answer are updated successfully; otherwise, false.
        /// &lt;/returns&gt;
        protected abstract bool PerformChangePasswordQuestionAndAnswer(string username, string password, string newPasswordQuestion, string newPasswordAnswer);

        /// &lt;summary&gt;
        /// Adds a new membership user to the data source.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The user name for the new user.&lt;/param&gt;
        /// &lt;param name=&quot;password&quot;&gt;The password for the new user.&lt;/param&gt;
        /// &lt;param name=&quot;email&quot;&gt;The e-mail address for the new user.&lt;/param&gt;
        /// &lt;param name=&quot;passwordQuestion&quot;&gt;The password question for the new user.&lt;/param&gt;
        /// &lt;param name=&quot;passwordAnswer&quot;&gt;The password answer for the new user&lt;/param&gt;
        /// &lt;param name=&quot;isApproved&quot;&gt;Whether or not the new user is approved to be validated.&lt;/param&gt;
        /// &lt;param name=&quot;providerUserKey&quot;&gt;The unique identifier from the membership data source for the user.&lt;/param&gt;
        /// &lt;param name=&quot;status&quot;&gt;A &lt;see cref=&quot;T:System.Web.Security.MembershipCreateStatus&quot;&gt;&lt;/see&gt; enumeration value indicating whether the user was created successfully.&lt;/param&gt;
        /// &lt;returns&gt;
        /// A &lt;see cref=&quot;T:System.Web.Security.MembershipUser&quot;&gt;&lt;/see&gt; object populated with the information for the newly created user.
        /// &lt;/returns&gt;
        /// &lt;remarks&gt;
        /// Ensures the ValidatingPassword event is executed before executing PerformCreateUser and performs basic membership provider validation of values.
        /// &lt;/remarks&gt;
        public override MembershipUser CreateUser(string username, string password, string email, string passwordQuestion, string passwordAnswer, bool isApproved, object providerUserKey, out MembershipCreateStatus status)
        {
            var valStatus = ValidateNewUser(username, password, email, passwordQuestion, passwordAnswer, isApproved, providerUserKey);
            if (valStatus != MembershipCreateStatus.Success)
            {
                status = valStatus;
                return null;
            }

            return PerformCreateUser(username, password, email, passwordQuestion, passwordAnswer, isApproved, providerUserKey, out status);
        }

        /// &lt;summary&gt;
        /// Performs the validation of the information for creating a new user
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;password&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;email&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;passwordQuestion&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;passwordAnswer&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;isApproved&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;providerUserKey&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected MembershipCreateStatus ValidateNewUser(string username, string password, string email, string passwordQuestion, string passwordAnswer, bool isApproved, object providerUserKey)
        {
            var args = new ValidatePasswordEventArgs(username, password, true);
            OnValidatingPassword(args);
            if (args.Cancel)
            {
                return MembershipCreateStatus.InvalidPassword;
            }

            // Validate password
            var passwordValidAttempt = IsPasswordValid(password, MinRequiredNonAlphanumericCharacters, PasswordStrengthRegularExpression, MinRequiredPasswordLength);
            if (passwordValidAttempt.Success == false)
            {
                return MembershipCreateStatus.InvalidPassword;
            }

            // Validate email
            if (IsEmailValid(email) == false)
            {
                return MembershipCreateStatus.InvalidEmail;
            }

            // Make sure username isn&#39;t all whitespace
            if (string.IsNullOrWhiteSpace(username.Trim()))
            {
                return MembershipCreateStatus.InvalidUserName;
            }

            // Check password question
            if (string.IsNullOrWhiteSpace(passwordQuestion) &amp;&amp; RequiresQuestionAndAnswer)
            {
                return MembershipCreateStatus.InvalidQuestion;
            }

            // Check password answer
            if (string.IsNullOrWhiteSpace(passwordAnswer) &amp;&amp; RequiresQuestionAndAnswer)
            {
                return MembershipCreateStatus.InvalidAnswer;
            }

            return MembershipCreateStatus.Success;
        }

        /// &lt;summary&gt;
        /// Adds a new membership user to the data source.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;The user name for the new user.&lt;/param&gt;
        /// &lt;param name=&quot;password&quot;&gt;The password for the new user.&lt;/param&gt;
        /// &lt;param name=&quot;email&quot;&gt;The e-mail address for the new user.&lt;/param&gt;
        /// &lt;param name=&quot;passwordQuestion&quot;&gt;The password question for the new user.&lt;/param&gt;
        /// &lt;param name=&quot;passwordAnswer&quot;&gt;The password answer for the new user&lt;/param&gt;
        /// &lt;param name=&quot;isApproved&quot;&gt;Whether or not the new user is approved to be validated.&lt;/param&gt;
        /// &lt;param name=&quot;providerUserKey&quot;&gt;The unique identifier from the membership data source for the user.&lt;/param&gt;
        /// &lt;param name=&quot;status&quot;&gt;A &lt;see cref=&quot;T:System.Web.Security.MembershipCreateStatus&quot;&gt;&lt;/see&gt; enumeration value indicating whether the user was created successfully.&lt;/param&gt;
        /// &lt;returns&gt;
        /// A &lt;see cref=&quot;T:System.Web.Security.MembershipUser&quot;&gt;&lt;/see&gt; object populated with the information for the newly created user.
        /// &lt;/returns&gt;
        protected abstract MembershipUser PerformCreateUser(string username, string password, string email, string passwordQuestion, string passwordAnswer, bool isApproved, object providerUserKey, out MembershipCreateStatus status);

        /// &lt;summary&gt;
        /// Gets the members password if password retreival is enabled
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;answer&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public override string GetPassword(string username, string answer)
        {
            if (EnablePasswordRetrieval == false)
                throw new ProviderException(&quot;Password Retrieval Not Enabled.&quot;);

            if (PasswordFormat == MembershipPasswordFormat.Hashed)
                throw new ProviderException(&quot;Cannot retrieve Hashed passwords.&quot;);

            return PerformGetPassword(username, answer);
        }

        /// &lt;summary&gt;
        /// Gets the members password if password retreival is enabled
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;username&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;answer&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected abstract string PerformGetPassword(string username, string answer);

        public override string ResetPassword(string username, string answer)
        {
            if (EnablePasswordReset == false)
            {
                throw new NotSupportedException(&quot;Password reset is not supported&quot;);
            }

            var newPassword = Membership.GeneratePassword(MinRequiredPasswordLength, MinRequiredNonAlphanumericCharacters);

            var args = new ValidatePasswordEventArgs(username, newPassword, true);
            OnValidatingPassword(args);
            if (args.Cancel)
            {
                if (args.FailureInformation != null)
                {
                    throw args.FailureInformation;
                }
                throw new MembershipPasswordException(&quot;Reset password canceled due to password validation failure.&quot;);
            }

            return PerformResetPassword(username, answer, newPassword);
        }

        protected abstract string PerformResetPassword(string username, string answer, string generatedPassword);

        protected internal static Attempt&lt;PasswordValidityError&gt; IsPasswordValid(string password, int minRequiredNonAlphanumericChars, string strengthRegex, int minLength)
        {
            if (minRequiredNonAlphanumericChars &gt; 0)
            {
                var nonAlphaNumeric = Regex.Replace(password, &quot;[a-zA-Z0-9]&quot;, &quot;&quot;, RegexOptions.Multiline | RegexOptions.IgnoreCase);
                if (nonAlphaNumeric.Length &lt; minRequiredNonAlphanumericChars)
                {
                    return Attempt.Fail(PasswordValidityError.AlphanumericChars);
                }
            }

            if (string.IsNullOrEmpty(strengthRegex) == false)
            {
                if (Regex.IsMatch(password, strengthRegex, RegexOptions.Compiled) == false)
                {
                    return Attempt.Fail(PasswordValidityError.Strength);
                }
                
            }

            if (password.Length &lt; minLength)
            {
                return Attempt.Fail(PasswordValidityError.Length);
            }

            return Attempt.Succeed(PasswordValidityError.Ok);
        }
        
        /// &lt;summary&gt;
        /// Gets the name of the default app.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal static string GetDefaultAppName()
        {
            try
            {
                string applicationVirtualPath = HostingEnvironment.ApplicationVirtualPath;
                if (string.IsNullOrEmpty(applicationVirtualPath))
                {
                    return &quot;/&quot;;
                }
                return applicationVirtualPath;
            }
            catch
            {
                return &quot;/&quot;;
            }
        }

        internal static int GetIntValue(NameValueCollection config, string valueName, int defaultValue, bool zeroAllowed, int maxValueAllowed)
        {
            int num;
            string s = config[valueName];
            if (s == null)
            {
                return defaultValue;
            }
            if (!int.TryParse(s, out num))
            {
                if (zeroAllowed)
                {
                    throw new ProviderException(&quot;Value must be non negative integer&quot;);
                }
                throw new ProviderException(&quot;Value must be positive integer&quot;);
            }
            if (zeroAllowed &amp;&amp; (num &lt; 0))
            {
                throw new ProviderException(&quot;Value must be non negativeinteger&quot;);
            }
            if (!zeroAllowed &amp;&amp; (num &lt;= 0))
            {
                throw new ProviderException(&quot;Value must be positive integer&quot;);
            }
            if ((maxValueAllowed &gt; 0) &amp;&amp; (num &gt; maxValueAllowed))
            {
                throw new ProviderException(&quot;Value too big&quot;);
            }
            return num;
        }

        /// &lt;summary&gt;
        /// If the password format is a hashed keyed algorithm then we will pre-pend the salt used to hash the password
        /// to the hashed password itself.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pass&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;salt&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected internal string FormatPasswordForStorage(string pass, string salt)
        {
            if (UseLegacyEncoding)
            {
                return pass;
            }
            
            if (PasswordFormat == MembershipPasswordFormat.Hashed)
            {
                //the better way, we use salt per member
                return salt + pass;
            }
            return pass;
        }

        internal static bool IsEmailValid(string email)
        {
            const string pattern = @&quot;^(?!\.)(&quot;&quot;([^&quot;&quot;\r\\]|\\[&quot;&quot;\r\\])*&quot;&quot;|&quot;
                                   + @&quot;([-a-z0-9!#$%&amp;&#39;*+/=?^_`{|}~]|(?&lt;!\.)\.)*)(?&lt;!\.)&quot;
                                   + @&quot;@[a-z0-9][\w\.-]*[a-z0-9]\.[a-z][a-z\.]*[a-z]$&quot;;

            return Regex.IsMatch(email, pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
        }

        protected internal string EncryptOrHashPassword(string pass, string salt)
        {
            //if we are doing it the old way

            if (UseLegacyEncoding)
            {
                return LegacyEncodePassword(pass);
            }

            //This is the correct way to implement this (as per the sql membership provider)

            if (PasswordFormat == MembershipPasswordFormat.Clear)
                return pass;
            var bytes = Encoding.Unicode.GetBytes(pass);
            var numArray1 = Convert.FromBase64String(salt);
            byte[] inArray;

            if (PasswordFormat == MembershipPasswordFormat.Hashed)
            {
                var hashAlgorithm = GetHashAlgorithm(pass);
                var algorithm = hashAlgorithm as KeyedHashAlgorithm;
                if (algorithm != null)
                {
                    var keyedHashAlgorithm = algorithm;
                    if (keyedHashAlgorithm.Key.Length == numArray1.Length)
                        keyedHashAlgorithm.Key = numArray1;
                    else if (keyedHashAlgorithm.Key.Length &lt; numArray1.Length)
                    {
                        var numArray2 = new byte[keyedHashAlgorithm.Key.Length];
                        Buffer.BlockCopy(numArray1, 0, numArray2, 0, numArray2.Length);
                        keyedHashAlgorithm.Key = numArray2;
                    }
                    else
                    {
                        var numArray2 = new byte[keyedHashAlgorithm.Key.Length];
                        var dstOffset = 0;
                        while (dstOffset &lt; numArray2.Length)
                        {
                            var count = Math.Min(numArray1.Length, numArray2.Length - dstOffset);
                            Buffer.BlockCopy(numArray1, 0, numArray2, dstOffset, count);
                            dstOffset += count;
                        }
                        keyedHashAlgorithm.Key = numArray2;
                    }
                    inArray = keyedHashAlgorithm.ComputeHash(bytes);
                }
                else
                {
                    var buffer = new byte[numArray1.Length + bytes.Length];
                    Buffer.BlockCopy(numArray1, 0, buffer, 0, numArray1.Length);
                    Buffer.BlockCopy(bytes, 0, buffer, numArray1.Length, bytes.Length);
                    inArray = hashAlgorithm.ComputeHash(buffer);
                }
            }
            else
            {
                //this code is copied from the sql membership provider - pretty sure this could be nicely re-written to completely
                // ignore the salt stuff since we are not salting the password when encrypting.
                var password = new byte[numArray1.Length + bytes.Length];
                Buffer.BlockCopy(numArray1, 0, password, 0, numArray1.Length);
                Buffer.BlockCopy(bytes, 0, password, numArray1.Length, bytes.Length);
                inArray = EncryptPassword(password, MembershipPasswordCompatibilityMode.Framework40);
            }
            return Convert.ToBase64String(inArray);
        }

        /// &lt;summary&gt;
        /// Checks the password.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;password&quot;&gt;The password.&lt;/param&gt;
        /// &lt;param name=&quot;dbPassword&quot;&gt;The dbPassword.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected internal bool CheckPassword(string password, string dbPassword)
        {
            switch (PasswordFormat)
            {
                case MembershipPasswordFormat.Encrypted:
                    var decrypted = DecryptPassword(dbPassword);
                    return decrypted == password;
                case MembershipPasswordFormat.Hashed:
                    string salt;
                    var storedHashedPass = StoredPassword(dbPassword, out salt);
                    var hashed = EncryptOrHashPassword(password, salt);
                    return storedHashedPass == hashed;
                case MembershipPasswordFormat.Clear:
                    return password == dbPassword;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        /// &lt;summary&gt;
        /// Encrypt/hash a new password with a new salt
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;newPassword&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;salt&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected internal string EncryptOrHashNewPassword(string newPassword, out string salt)
        {
            salt = GenerateSalt();
            return EncryptOrHashPassword(newPassword, salt);
        }

        protected internal string DecryptPassword(string pass)
        {
            //if we are doing it the old way

            if (UseLegacyEncoding)
            {
                return LegacyUnEncodePassword(pass);
            }

            //This is the correct way to implement this (as per the sql membership provider)

            switch (PasswordFormat)
            {
                case MembershipPasswordFormat.Clear:
                    return pass;
                case MembershipPasswordFormat.Hashed:
                    throw new ProviderException(&quot;Provider can not decrypt hashed password&quot;);
                case MembershipPasswordFormat.Encrypted:
                default:
                    var bytes = DecryptPassword(Convert.FromBase64String(pass));
                    return bytes == null ? null : Encoding.Unicode.GetString(bytes, 16, bytes.Length - 16);
            }
        }

        /// &lt;summary&gt;
        /// Returns the hashed password without the salt if it is hashed
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;storedString&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;salt&quot;&gt;returns the salt&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal string StoredPassword(string storedString, out string salt)
        {
            if (UseLegacyEncoding)
            {
                salt = string.Empty;
                return storedString;
            }

            switch (PasswordFormat)
            {
                case MembershipPasswordFormat.Hashed:
                    var saltLen = GenerateSalt();
                    salt = storedString.Substring(0, saltLen.Length);
                    return storedString.Substring(saltLen.Length);      
                case MembershipPasswordFormat.Clear:                    
                case MembershipPasswordFormat.Encrypted:
                default:
                   salt = string.Empty;
                    return storedString;
                     
            }
        }

        protected internal static string GenerateSalt()
        {
            var numArray = new byte[16];
            new RNGCryptoServiceProvider().GetBytes(numArray);
            return Convert.ToBase64String(numArray);
        }

        protected internal HashAlgorithm GetHashAlgorithm(string password)
        {
            if (UseLegacyEncoding)
            {
                //before we were never checking for an algorithm type so we were always using HMACSHA1
                // for any SHA specified algorithm :( so we&#39;ll need to keep doing that for backwards compat support.
                if (Membership.HashAlgorithmType.InvariantContains(&quot;SHA&quot;))
                {
                    return new HMACSHA1
                        {
                            //the legacy salt was actually the password :(
                            Key = Encoding.Unicode.GetBytes(password)
                        };
                }               
            }
          
            //get the algorithm by name

            if (_customHashAlgorithmType.IsNullOrWhiteSpace())
            {
                _customHashAlgorithmType = Membership.HashAlgorithmType;
            }

            var alg = HashAlgorithm.Create(_customHashAlgorithmType);
            if (alg == null)
            {
                throw new InvalidOperationException(&quot;The hash algorithm specified &quot; + Membership.HashAlgorithmType + &quot; cannot be resolved&quot;);
            }

            return alg;
        }

        /// &lt;summary&gt;
        /// Encodes the password.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;password&quot;&gt;The password.&lt;/param&gt;
        /// &lt;returns&gt;The encoded password.&lt;/returns&gt;
        protected string LegacyEncodePassword(string password)
        {
            string encodedPassword = password;
            switch (PasswordFormat)
            {
                case MembershipPasswordFormat.Clear:
                    break;
                case MembershipPasswordFormat.Encrypted:
                    encodedPassword =
                        Convert.ToBase64String(EncryptPassword(Encoding.Unicode.GetBytes(password)));
                    break;
                case MembershipPasswordFormat.Hashed:
                    var hashAlgorith = GetHashAlgorithm(password);
                    encodedPassword = Convert.ToBase64String(hashAlgorith.ComputeHash(Encoding.Unicode.GetBytes(password)));
                    break;
                default:
                    throw new ProviderException(&quot;Unsupported password format.&quot;);
            }
            return encodedPassword;
        }

        /// &lt;summary&gt;
        /// Unencode password.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;encodedPassword&quot;&gt;The encoded password.&lt;/param&gt;
        /// &lt;returns&gt;The unencoded password.&lt;/returns&gt;
        protected string LegacyUnEncodePassword(string encodedPassword)
        {
            string password = encodedPassword;
            switch (PasswordFormat)
            {
                case MembershipPasswordFormat.Clear:
                    break;
                case MembershipPasswordFormat.Encrypted:
                    password = Encoding.Unicode.GetString(DecryptPassword(Convert.FromBase64String(password)));
                    break;
                case MembershipPasswordFormat.Hashed:
                    throw new ProviderException(&quot;Cannot unencode a hashed password.&quot;);
                default:
                    throw new ProviderException(&quot;Unsupported password format.&quot;);
            }
            return password;
        }

        public override string ToString()
        {
            var result = base.ToString();
            var sb = new StringBuilder(result);
            sb.AppendLine(&quot;Name =&quot; + Name);
            sb.AppendLine(&quot;_applicationName =&quot; + _applicationName);
            sb.AppendLine(&quot;_enablePasswordReset=&quot; + _enablePasswordReset);
            sb.AppendLine(&quot;_enablePasswordRetrieval=&quot; + _enablePasswordRetrieval);
            sb.AppendLine(&quot;_maxInvalidPasswordAttempts=&quot; + _maxInvalidPasswordAttempts);
            sb.AppendLine(&quot;_minRequiredNonAlphanumericCharacters=&quot; + _minRequiredNonAlphanumericCharacters);
            sb.AppendLine(&quot;_minRequiredPasswordLength=&quot; + _minRequiredPasswordLength);
            sb.AppendLine(&quot;_passwordAttemptWindow=&quot; + _passwordAttemptWindow);
            sb.AppendLine(&quot;_passwordFormat=&quot; + _passwordFormat);
            sb.AppendLine(&quot;_passwordStrengthRegularExpression=&quot; + _passwordStrengthRegularExpression);
            sb.AppendLine(&quot;_requiresQuestionAndAnswer=&quot; + _requiresQuestionAndAnswer);
            sb.AppendLine(&quot;_requiresUniqueEmail=&quot; + _requiresUniqueEmail);
            return sb.ToString();
        }

        /// &lt;summary&gt;
        /// Returns the current request IP address for logging if there is one
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected string GetCurrentRequestIpAddress()
        {
            var httpContext = HttpContext.Current == null ? (HttpContextBase) null : new HttpContextWrapper(HttpContext.Current);
            return httpContext.GetCurrentRequestIpAddress();
        }

    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[22,9,22,10,0],[24,13,24,71,0],[25,13,25,59,0],[26,9,26,10,0],[29,9,29,10,0],[30,13,30,60,0],[31,9,31,10,0],[38,17,38,18,1],[38,19,38,28,1],[38,29,38,30,1],[46,17,46,18,1],[46,19,46,28,1],[46,29,46,30,1],[54,17,54,18,1],[54,19,54,32,1],[54,33,54,34,1],[64,17,64,18,0],[64,19,64,32,0],[64,33,64,34,0],[91,17,91,18,1],[91,19,91,47,1],[91,48,91,49,1],[101,17,101,18,1],[101,19,101,51,1],[101,52,101,53,1],[111,17,111,18,1],[111,19,111,54,1],[111,55,111,56,1],[121,17,121,18,1],[121,19,121,64,1],[121,65,121,66,1],[131,17,131,18,1],[131,19,131,53,1],[131,54,131,55,1],[141,17,141,18,1],[141,19,141,49,1],[141,50,141,51,1],[151,17,151,18,1],[151,19,151,42,1],[151,43,151,44,1],[161,17,161,18,1],[161,19,161,61,1],[161,62,161,63,1],[171,17,171,18,1],[171,19,171,53,1],[171,54,171,55,1],[181,17,181,18,1],[181,19,181,47,1],[181,48,181,49,1],[192,13,192,14,1],[193,17,193,41,1],[194,13,194,14,1],[196,13,196,14,0],[197,17,197,49,0],[198,21,198,85,0],[200,17,200,42,0],[201,21,201,88,0],[203,17,203,42,0],[204,13,204,14,0],[220,9,220,10,1],[222,13,222,43,1],[224,13,224,90,1],[225,13,225,82,1],[226,13,226,94,1],[227,13,227,81,1],[228,13,228,106,1],[229,13,229,97,1],[230,13,230,129,1],[231,13,231,157,1],[232,13,232,94,1],[234,13,234,58,1],[235,13,235,56,1],[236,17,236,56,1],[239,13,239,96,1],[242,13,242,63,1],[244,13,244,35,1],[247,21,247,70,1],[248,21,248,27,1],[251,21,251,74,1],[252,21,252,27,1],[255,21,255,71,1],[256,21,256,27,1],[259,21,259,81,0],[262,13,262,96,1],[263,13,263,14,1],[264,17,264,95,1],[265,17,265,157,1],[266,17,266,26,1],[269,13,269,91,1],[270,9,270,10,1],[277,9,277,10,1],[278,13,278,155,1],[279,13,279,42,1],[280,13,280,14,0],[281,17,281,33,0],[282,17,282,24,0],[285,13,285,42,1],[286,9,286,10,1],[309,9,309,10,1],[310,13,310,92,1],[311,13,311,14,1],[313,17,313,114,1],[316,13,316,84,1],[317,13,317,40,1],[319,13,319,29,1],[320,13,320,14,0],[321,17,321,53,0],[322,21,322,51,0],[323,17,323,119,0],[326,13,326,56,1],[327,13,327,14,1],[328,17,328,66,1],[328,67,328,80,1],[329,13,329,14,0],[331,13,331,78,0],[332,9,332,10,1],[359,9,359,10,1],[360,13,360,52,1],[361,13,361,14,1],[362,17,362,165,1],[365,13,365,56,1],[366,13,366,14,1],[367,17,367,63,1],[368,17,368,18,1],[369,21,369,34,1],[371,13,371,14,0],[373,13,373,119,0],[374,9,374,10,1],[406,9,406,10,1],[407,13,407,135,1],[408,13,408,61,1],[409,13,409,14,1],[410,17,410,36,1],[411,17,411,29,1],[414,13,414,140,0],[415,9,415,10,1],[429,9,429,10,1],[430,13,430,80,1],[431,13,431,40,1],[432,13,432,29,1],[433,13,433,14,0],[434,17,434,63,0],[438,13,438,166,1],[439,13,439,55,1],[440,13,440,14,0],[441,17,441,63,0],[445,13,445,46,1],[446,13,446,14,0],[447,17,447,60,0],[451,13,451,60,1],[452,13,452,14,1],[453,17,453,63,1],[457,13,457,90,1],[458,13,458,14,1],[459,17,459,63,1],[463,13,463,88,1],[464,13,464,14,1],[465,17,465,61,1],[468,13,468,51,1],[469,9,469,10,1],[494,9,494,10,1],[495,13,495,50,1],[496,17,496,80,1],[498,13,498,67,1],[499,17,499,82,1],[501,13,501,57,0],[502,9,502,10,0],[513,9,513,10,1],[514,13,514,46,1],[515,13,515,14,1],[516,17,516,84,1],[519,13,519,124,0],[521,13,521,83,0],[522,13,522,40,0],[523,13,523,29,0],[524,13,524,14,0],[525,17,525,53,0],[526,17,526,18,0],[527,21,527,51,0],[529,17,529,118,0],[532,13,532,72,0],[533,9,533,10,0],[538,9,538,10,1],[539,13,539,53,1],[540,13,540,14,1],[541,17,541,132,1],[542,17,542,78,1],[543,17,543,18,1],[544,21,544,82,1],[546,13,546,14,1],[548,13,548,62,1],[549,13,549,14,1],[550,17,550,92,1],[551,17,551,18,1],[552,21,552,73,1],[555,13,555,14,1],[557,13,557,45,1],[558,13,558,14,1],[559,17,559,67,1],[562,13,562,62,1],[563,9,563,10,1],[570,9,570,10,1],[572,13,572,14,1],[573,17,573,91,1],[574,17,574,66,1],[575,17,575,18,1],[576,21,576,32,1],[578,17,578,47,0],[580,13,580,18,0],[581,13,581,14,0],[582,17,582,28,0],[584,9,584,10,1],[587,9,587,10,1],[589,13,589,42,1],[590,13,590,27,1],[591,13,591,14,1],[592,17,592,37,1],[594,13,594,43,0],[595,13,595,14,0],[596,17,596,33,0],[597,17,597,18,0],[598,21,598,87,0],[600,17,600,79,0],[602,13,602,42,0],[603,13,603,14,0],[604,17,604,82,0],[606,13,606,44,0],[607,13,607,14,0],[608,17,608,79,0],[610,13,610,66,0],[611,13,611,14,0],[612,17,612,62,0],[614,13,614,24,0],[615,9,615,10,1],[625,9,625,10,1],[626,13,626,35,1],[627,13,627,14,0],[628,17,628,29,0],[631,13,631,67,1],[632,13,632,14,1],[634,17,634,36,1],[636,13,636,25,1],[637,9,637,10,1],[640,9,640,10,1],[645,13,645,99,1],[646,9,646,10,1],[649,9,649,10,1],[652,13,652,35,1],[653,13,653,14,0],[654,17,654,51,0],[659,13,659,66,1],[660,17,660,29,0],[661,13,661,57,1],[662,13,662,60,1],[665,13,665,67,1],[666,13,666,14,1],[667,17,667,60,1],[668,17,668,69,1],[669,17,669,39,1],[670,17,670,18,1],[671,21,671,56,1],[672,21,672,75,1],[673,25,673,60,0],[674,26,674,79,1],[675,21,675,22,0],[676,25,676,81,0],[677,25,677,88,0],[678,25,678,60,0],[679,21,679,22,0],[681,21,681,22,1],[682,25,682,81,1],[683,25,683,43,1],[684,25,684,61,1],[685,25,685,26,1],[686,29,686,98,1],[687,29,687,89,1],[688,29,688,48,1],[689,25,689,26,1],[690,25,690,60,1],[691,21,691,22,1],[692,21,692,69,1],[693,17,693,18,1],[695,17,695,18,1],[696,21,696,76,1],[697,21,697,81,1],[698,21,698,88,1],[699,21,699,65,1],[700,17,700,18,1],[701,13,701,14,1],[703,13,703,14,1],[706,17,706,74,1],[707,17,707,79,1],[708,17,708,86,1],[709,17,709,102,1],[710,13,710,14,1],[711,13,711,52,1],[712,9,712,10,1],[721,9,721,10,1],[722,13,722,36,1],[725,21,725,65,1],[726,21,726,50,1],[729,21,729,81,1],[730,21,730,72,1],[731,21,731,55,1],[733,21,733,51,1],[735,21,735,61,0],[737,9,737,10,1],[746,9,746,10,1],[747,13,747,35,1],[748,13,748,61,1],[749,9,749,10,1],[752,9,752,10,1],[755,13,755,35,1],[756,13,756,14,0],[757,17,757,53,0],[762,13,762,36,1],[765,21,765,33,0],[767,21,767,93,0],[770,21,770,81,1],[771,21,771,108,1],[773,9,773,10,1],[782,9,782,10,1],[783,13,783,35,1],[784,13,784,14,0],[785,17,785,37,0],[786,17,786,37,0],[789,13,789,36,1],[792,21,792,50,1],[793,21,793,70,1],[794,21,794,67,1],[798,20,798,40,1],[799,21,799,41,1],[802,9,802,10,1],[805,9,805,10,1],[806,13,806,41,1],[807,13,807,63,1],[808,13,808,53,1],[809,9,809,10,1],[812,9,812,10,1],[813,13,813,35,1],[814,13,814,14,1],[817,17,817,75,1],[818,17,818,18,1],[819,21,823,27,1],[825,13,825,14,0],[829,13,829,63,1],[830,13,830,14,1],[831,17,831,73,1],[832,13,832,14,1],[834,13,834,70,1],[835,13,835,29,1],[836,13,836,14,0],[837,17,837,141,0],[840,13,840,24,1],[841,9,841,10,1],[849,9,849,10,0],[850,13,850,47,0],[851,13,851,36,0],[854,21,854,27,0],[856,21,857,102,0],[858,21,858,27,0],[860,21,860,67,0],[861,21,861,125,0],[862,21,862,27,0],[864,21,864,81,0],[866,13,866,36,0],[867,9,867,10,0],[875,9,875,10,0],[876,13,876,47,0],[877,13,877,36,0],[880,21,880,27,0],[882,21,882,112,0],[883,21,883,27,0],[885,21,885,87,0],[887,21,887,81,0],[889,13,889,29,0],[890,9,890,10,0],[893,9,893,10,0],[894,13,894,42,0],[895,13,895,48,0],[896,13,896,44,0],[897,13,897,68,0],[898,13,898,75,0],[899,13,899,83,0],[900,13,900,89,0],[901,13,901,109,0],[902,13,902,87,0],[903,13,903,79,0],[904,13,904,65,0],[905,13,905,103,0],[906,13,906,87,0],[907,13,907,75,0],[908,13,908,34,0],[909,9,909,10,0],[916,9,916,10,0],[917,13,917,130,0],[918,13,918,61,0],[919,9,919,10,0]]);
    </script>
  </body>
</html>