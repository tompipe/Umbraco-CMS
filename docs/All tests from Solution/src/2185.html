<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Diagnostics\MiniDump.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using Umbraco.Core.IO;

namespace Umbraco.Core.Diagnostics
{
    // taken from https://blogs.msdn.microsoft.com/dondu/2010/10/24/writing-minidumps-in-c/
    // and https://blogs.msdn.microsoft.com/dondu/2010/10/31/writing-minidumps-from-exceptions-in-c/
    // which itself got it from http://blog.kalmbach-software.de/2008/12/13/writing-minidumps-in-c/

    internal static class MiniDump
    {
        private static readonly object LockO = new object();

        [Flags]
        public enum Option : uint
        {
            // From dbghelp.h:
            Normal = 0x00000000,
            WithDataSegs = 0x00000001,
            WithFullMemory = 0x00000002,
            WithHandleData = 0x00000004,
            FilterMemory = 0x00000008,
            ScanMemory = 0x00000010,
            WithUnloadedModules = 0x00000020,
            WithIndirectlyReferencedMemory = 0x00000040,
            FilterModulePaths = 0x00000080,
            WithProcessThreadData = 0x00000100,
            WithPrivateReadWriteMemory = 0x00000200,
            WithoutOptionalData = 0x00000400,
            WithFullMemoryInfo = 0x00000800,
            WithThreadInfo = 0x00001000,
            WithCodeSegs = 0x00002000,
            WithoutAuxiliaryState = 0x00004000,
            WithFullAuxiliaryState = 0x00008000,
            WithPrivateWriteCopyMemory = 0x00010000,
            IgnoreInaccessibleMemory = 0x00020000,
            ValidTypeFlags = 0x0003ffff,
        }

        //typedef struct _MINIDUMP_EXCEPTION_INFORMATION {
        //    DWORD ThreadId;
        //    PEXCEPTION_POINTERS ExceptionPointers;
        //    BOOL ClientPointers;
        //} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;
        [StructLayout(LayoutKind.Sequential, Pack = 4)]  // Pack=4 is important! So it works also for x64!
        public struct MiniDumpExceptionInformation
        {
            public uint ThreadId;
            public IntPtr ExceptionPointers;
            [MarshalAs(UnmanagedType.Bool)]
            public bool ClientPointers;
        }

        //BOOL
        //WINAPI
        //MiniDumpWriteDump(
        //    __in HANDLE hProcess,
        //    __in DWORD ProcessId,
        //    __in HANDLE hFile,
        //    __in MINIDUMP_TYPE DumpType,
        //    __in_opt PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
        //    __in_opt PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
        //    __in_opt PMINIDUMP_CALLBACK_INFORMATION CallbackParam
        //    );

        // Overload requiring MiniDumpExceptionInformation
        [DllImport(&quot;dbghelp.dll&quot;, EntryPoint = &quot;MiniDumpWriteDump&quot;, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
        private static extern bool MiniDumpWriteDump(IntPtr hProcess, uint processId, SafeHandle hFile, uint dumpType, ref MiniDumpExceptionInformation expParam, IntPtr userStreamParam, IntPtr callbackParam);

        // Overload supporting MiniDumpExceptionInformation == NULL
        [DllImport(&quot;dbghelp.dll&quot;, EntryPoint = &quot;MiniDumpWriteDump&quot;, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
        private static extern bool MiniDumpWriteDump(IntPtr hProcess, uint processId, SafeHandle hFile, uint dumpType, IntPtr expParam, IntPtr userStreamParam, IntPtr callbackParam);

        [DllImport(&quot;kernel32.dll&quot;, EntryPoint = &quot;GetCurrentThreadId&quot;, ExactSpelling = true)]
        private static extern uint GetCurrentThreadId();

        private static bool Write(SafeHandle fileHandle, Option options, bool withException = false)
        {
            var currentProcess = Process.GetCurrentProcess();
            var currentProcessHandle = currentProcess.Handle;
            var currentProcessId = (uint)currentProcess.Id;

            MiniDumpExceptionInformation exp;

            exp.ThreadId = GetCurrentThreadId();
            exp.ClientPointers = false;
            exp.ExceptionPointers = IntPtr.Zero;

            if (withException)
                exp.ExceptionPointers = Marshal.GetExceptionPointers();

            var bRet = exp.ExceptionPointers == IntPtr.Zero
                ? MiniDumpWriteDump(currentProcessHandle, currentProcessId, fileHandle, (uint) options, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero)
                : MiniDumpWriteDump(currentProcessHandle, currentProcessId, fileHandle, (uint) options, ref exp, IntPtr.Zero, IntPtr.Zero);

            return bRet;
        }

        public static bool Dump(Option options = Option.WithFullMemory, bool withException = false)
        {
            lock (LockO)
            {
                // work around &quot;stack trace is not available while minidump debugging&quot;,
                // by making sure a local var (that we can inspect) contains the stack trace.
                // getting the call stack before it is unwound would require a special exception
                // filter everywhere in our code = not!
                var stacktrace = withException ? Environment.StackTrace : string.Empty;

                var filepath = IOHelper.MapPath(&quot;~/App_Data/MiniDump&quot;);
                if (Directory.Exists(filepath) == false)
                    Directory.CreateDirectory(filepath);

                var filename = Path.Combine(filepath, string.Format(&quot;{0:yyyyMMddTHHmmss}.{1}.dmp&quot;, DateTime.UtcNow, Guid.NewGuid().ToString(&quot;N&quot;).Substring(0, 4)));
                using (var stream = new FileStream(filename, FileMode.Create, FileAccess.ReadWrite, FileShare.Write))
                {
                    return Write(stream.SafeFileHandle, options, withException);
                }
            }
        }

        public static bool OkToDump()
        {
            lock (LockO)
            {
                var filepath = IOHelper.MapPath(&quot;~/App_Data/MiniDump&quot;);
                if (Directory.Exists(filepath) == false) return true;
                var count = Directory.GetFiles(filepath, &quot;*.dmp&quot;).Length;
                return count &lt; 8;
            }
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[15,9,15,61,0],[81,9,81,10,0],[82,13,82,62,0],[83,13,83,62,0],[84,13,84,60,0],[88,13,88,49,0],[89,13,89,40,0],[90,13,90,49,0],[92,13,92,31,0],[93,17,93,72,0],[95,13,97,140,0],[99,13,99,25,0],[100,9,100,10,0],[103,9,103,10,0],[104,13,104,25,0],[105,13,105,14,0],[110,17,110,88,0],[112,17,112,72,0],[113,17,113,57,0],[114,21,114,57,0],[116,17,116,164,0],[117,24,117,117,0],[118,17,118,18,0],[119,21,119,81,0],[122,9,122,10,0],[125,9,125,10,0],[126,13,126,25,0],[127,13,127,14,0],[128,17,128,72,0],[129,17,129,57,0],[129,58,129,70,0],[130,17,130,74,0],[131,17,131,34,0],[133,9,133,10,0]]);
    </script>
  </body>
</html>