<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Models\PublishedContent\PublishedContentSet.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;

namespace Umbraco.Core.Models.PublishedContent
{
    /// &lt;summary&gt;
    /// Represents a set of &lt;see cref=&quot;IPublishedContent&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;The type of content.&lt;/typeparam&gt;
    /// &lt;remarks&gt;
    /// &lt;para&gt;A &lt;c&gt;ContentSet{T}&lt;/c&gt; is created from an &lt;c&gt;IEnumerable{T}&lt;/c&gt; using the &lt;c&gt;ToContentSet&lt;/c&gt;
    /// extension method.&lt;/para&gt;
    /// &lt;para&gt;The content set source is enumerated only once. Same as what you get
    /// when you call ToList on an IEnumerable. Only, ToList enumerates its source when
    /// created, whereas a content set enumerates its source only when the content set itself
    /// is enumerated.&lt;/para&gt;
    /// &lt;/remarks&gt;
    public class PublishedContentSet&lt;T&gt; : IEnumerable&lt;T&gt;
        where T : class, IPublishedContent
    {
        // used by &lt;c&gt;ToContentSet&lt;/c&gt; extension method to initialize a new set from an IEnumerable.
        internal PublishedContentSet(IEnumerable&lt;T&gt; source)
        {
            if (source == null)
                throw new ArgumentNullException(&quot;source&quot;);
            Source = source;
        }

        #region Source

        protected readonly IEnumerable&lt;T&gt; Source;
        
        #endregion

        #region Enumerated

        // cache the enumeration so we don&#39;t enumerate more than once. Same as what you get
        // when you call ToList on an IEnumerable. Only, ToList enumerates its source when
        // created, whereas a content set enumerates its source only when the content set itself
        // is enumerated.

        // cache the wrapped items so if we reset the enumeration, we do not re-wrap everything (only new items).

        private T[] _enumerated;
        private readonly Dictionary&lt;T, IPublishedContentExtended&gt; _xContent = new Dictionary&lt;T, IPublishedContentExtended&gt;();

        // wrap an item, ie create the actual clone for this set
        private T MapContentAsT(T t)
        {
            return MapContent(t) as T;
        }

        internal IPublishedContentExtended MapContent(T t)
        {
            IPublishedContentExtended extend;
            if (_xContent.TryGetValue(t, out extend)) return extend;

            extend = PublishedContentExtended.Extend(t, this);
            var asT = extend as T;
            if (asT == null)
                throw new InvalidOperationException(string.Format(&quot;Failed extend a published content of type {0}.&quot;
                                                                  + &quot;Got {1} when expecting {2}.&quot;, t.GetType().FullName, extend.GetType().FullName, typeof(T).FullName));
            _xContent[t] = extend;
            return extend;
        }

        private T[] Enumerated
        {
            get
            {
                // enumerate the source and cache the result
                // tell clones about their index within the set (for perfs purposes)
                var index = 0;
                return _enumerated ?? (_enumerated = Source.Select(t =&gt;
                    {
                        var extend = MapContent(t);
                        extend.SetIndex(index++);
                        return extend as T;
                    }).ToArray());
            }
        }

        // indicates that the source has changed
        // so the set can clear its inner caches
        // should only be used by DynamicPublishedContentList
        internal void SourceChanged()
        {
            // reset the cached enumeration so it&#39;s enumerated again
            if (_enumerated == null) return;
            _enumerated = null;

            foreach (var item in _xContent.Values)
                item.ClearIndex();

            var removed = _xContent.Keys.Except(Source);
            foreach (var content in removed)
            {
                _xContent[content].ClearContentSet();
                _xContent.Remove(content);
            }
        }

        /// &lt;summary&gt;
        /// Gets the number of items in the set.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;The number of items in the set.&lt;/returns&gt;
        /// &lt;remarks&gt;Will cause the set to be enumerated if it hasn&#39;t been already.&lt;/remarks&gt;
        public virtual int Count
        {
            get { return Enumerated.Length; }
        }
        #endregion

        #region IEnumerable&lt;T&gt;

        public IEnumerator&lt;T&gt; GetEnumerator()
        {
            return ((IEnumerable&lt;T&gt;)Enumerated).GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        #region Wrap methods returning T

        public T ElementAt(int index)
        {
            return MapContentAsT(Source.ElementAt(index));
        }

        public T ElementAtOrDefault(int index)
        {
            var element = Source.ElementAtOrDefault(index);
            return element == null ? null : MapContentAsT(element);
        }

        public T First()
        {
            return MapContentAsT(Source.First());
        }

        public T First(Func&lt;T, bool&gt; predicate)
        {
            return MapContentAsT(Source.First(predicate));
        }

        public T FirstOrDefault()
        {
            var first = Source.FirstOrDefault();
            return first == null ? null : MapContentAsT(first);
        }

        public T FirstOrDefault(Func&lt;T, bool&gt; predicate)
        {
            var first = Source.FirstOrDefault(predicate);
            return first == null ? null : MapContentAsT(first);
        }

        public T Last()
        {
            return MapContentAsT(Source.Last());
        }

        public T Last(Func&lt;T, bool&gt; predicate)
        {
            return MapContentAsT(Source.Last(predicate));
        }

        public T LastOrDefault()
        {
            var last = Source.LastOrDefault();
            return last == null ? null : MapContentAsT(last);
        }

        public T LastOrDefault(Func&lt;T, bool&gt; predicate)
        {
            var last = Source.LastOrDefault(predicate);
            return last == null ? null : MapContentAsT(last);
        }

        public T Single()
        {
            return MapContentAsT(Source.Single());
        }

        public T Single(Func&lt;T, bool&gt; predicate)
        {
            return MapContentAsT(Source.Single(predicate));
        }

        public T SingleOrDefault()
        {
            var single = Source.SingleOrDefault();
            return single == null ? null : MapContentAsT(single);
        }

        public T SingleOrDefault(Func&lt;T, bool&gt; predicate)
        {
            var single = Source.SingleOrDefault(predicate);
            return single == null ? null : MapContentAsT(single);
        }

        #endregion

        #region Wrap methods returning IOrderedEnumerable&lt;T&gt;

        public PublishedContentOrderedSet&lt;T&gt; OrderBy&lt;TKey&gt;(Func&lt;T, TKey&gt; keySelector)
        {
            return new PublishedContentOrderedSet&lt;T&gt;(Source.OrderBy(keySelector));
        }

        public PublishedContentOrderedSet&lt;T&gt; OrderBy&lt;TKey&gt;(Func&lt;T, TKey&gt; keySelector, IComparer&lt;TKey&gt; comparer)
        {
            return new PublishedContentOrderedSet&lt;T&gt;(Source.OrderBy(keySelector, comparer));
        }

        public PublishedContentOrderedSet&lt;T&gt; OrderByDescending&lt;TKey&gt;(Func&lt;T, TKey&gt; keySelector)
        {
            return new PublishedContentOrderedSet&lt;T&gt;(Source.OrderByDescending(keySelector));
        }

        public PublishedContentOrderedSet&lt;T&gt; OrderByDescending&lt;TKey&gt;(Func&lt;T, TKey&gt; keySelector, IComparer&lt;TKey&gt; comparer)
        {
            return new PublishedContentOrderedSet&lt;T&gt;(Source.OrderByDescending(keySelector, comparer));
        }

        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[23,9,23,60,1],[24,9,24,10,1],[25,13,25,32,1],[26,17,26,59,0],[27,13,27,29,1],[28,9,28,10,1],[46,9,46,126,1],[50,9,50,10,1],[51,13,51,39,1],[52,9,52,10,1],[55,9,55,10,1],[57,13,57,54,1],[57,55,57,69,1],[59,13,59,63,1],[60,13,60,35,1],[61,13,61,29,1],[62,17,63,170,0],[64,13,64,35,1],[65,13,65,27,1],[66,9,66,10,1],[71,13,71,14,1],[74,17,74,31,1],[75,17,76,21,1],[76,21,76,22,1],[76,22,77,25,1],[77,25,77,52,1],[77,52,78,25,1],[78,25,78,50,1],[78,50,79,25,1],[79,25,79,44,1],[79,44,80,21,1],[80,21,80,22,1],[80,22,80,35,1],[75,17,80,35,1],[81,13,81,14,1],[88,9,88,10,0],[90,13,90,37,0],[90,38,90,45,0],[91,13,91,32,0],[93,13,93,20,0],[93,22,93,30,0],[93,31,93,33,0],[93,34,93,50,0],[94,17,94,35,0],[96,13,96,57,0],[97,13,97,20,0],[97,22,97,33,0],[97,34,97,36,0],[97,37,97,44,0],[98,13,98,14,0],[99,17,99,54,0],[100,17,100,43,0],[101,13,101,14,0],[102,9,102,10,0],[111,17,111,18,0],[111,19,111,44,0],[111,45,111,46,0],[118,9,118,10,1],[119,13,119,65,1],[120,9,120,10,1],[123,9,123,10,0],[124,13,124,36,0],[125,9,125,10,0],[132,9,132,10,0],[133,13,133,59,0],[134,9,134,10,0],[137,9,137,10,0],[138,13,138,60,0],[139,13,139,68,0],[140,9,140,10,0],[143,9,143,10,1],[144,13,144,50,1],[145,9,145,10,1],[148,9,148,10,1],[149,13,149,59,1],[150,9,150,10,1],[153,9,153,10,0],[154,13,154,49,0],[155,13,155,64,0],[156,9,156,10,0],[159,9,159,10,0],[160,13,160,58,0],[161,13,161,64,0],[162,9,162,10,0],[165,9,165,10,0],[166,13,166,49,0],[167,9,167,10,0],[170,9,170,10,0],[171,13,171,58,0],[172,9,172,10,0],[175,9,175,10,0],[176,13,176,47,0],[177,13,177,62,0],[178,9,178,10,0],[181,9,181,10,0],[182,13,182,56,0],[183,13,183,62,0],[184,9,184,10,0],[187,9,187,10,0],[188,13,188,51,0],[189,9,189,10,0],[192,9,192,10,0],[193,13,193,60,0],[194,9,194,10,0],[197,9,197,10,0],[198,13,198,51,0],[199,13,199,66,0],[200,9,200,10,0],[203,9,203,10,0],[204,13,204,60,0],[205,13,205,66,0],[206,9,206,10,0],[213,9,213,10,0],[214,13,214,83,0],[215,9,215,10,0],[218,9,218,10,0],[219,13,219,93,0],[220,9,220,10,0],[223,9,223,10,0],[224,13,224,93,0],[225,9,225,10,0],[228,9,228,10,0],[229,13,229,103,0],[230,9,230,10,0]]);
    </script>
  </body>
</html>