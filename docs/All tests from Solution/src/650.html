<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\umbraco.presentation\umbraco\Trees\BaseTree.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Xml;
using Umbraco.Core;
using Umbraco.Core.Models.EntityBase;
using Umbraco.Core.Services;
using Umbraco.Web.Trees;
using umbraco.BusinessLogic;
using umbraco.BusinessLogic.Actions;
using umbraco.cms.businesslogic.media;
using umbraco.cms.businesslogic.web;
using umbraco.interfaces;

namespace umbraco.cms.presentation.Trees
{
    /// &lt;summary&gt;
    /// All ITree&#39;s should inherit from BaseTree.
    /// &lt;/summary&gt;
    public abstract class BaseTree : ITree, ITreeService //, IApplicationEventHandler
    {

        public BaseTree(string application)
        {
            this.app = application;
        }

        protected const string FolderIcon = &quot;icon-folder&quot;;
        protected const string FolderIconOpen = &quot;icon-folder&quot;;        

        /// &lt;summary&gt;
        /// Returns the node definition of the root node for this tree
        /// &lt;/summary&gt;
        public XmlTreeNode RootNode
        {
            get 
            {
                Initialize();
                return m_initNode; 
            }
        }

        /// &lt;summary&gt;
        /// By default the init actions that are allowed for all trees are Create, Reload Nodes.
        /// These are the menu items that show up in the context menu for the root node of the current tree.
        /// Should be used in conjunction with the RootNode property
        /// &lt;/summary&gt;
        public List&lt;IAction&gt; RootNodeActions
        {
            get
            {
                Initialize();
                return m_initActions;
            }
        }

        /// &lt;summary&gt;
        /// The actions that are allowed to be performed on this tree. These are the items that may show up on the
        /// context menu for a given node.
        /// &lt;/summary&gt;
        public List&lt;IAction&gt; AllowedActions
        {
            get
            {
                Initialize();
                return m_allowedActions;
            }
        }

        /// &lt;summary&gt;
        /// The tree alias name. By default, if a BaseTree is instantiated by it&#39;s TreeDefinition, then the TreeAlias will be
        /// the name defined in the database. Inheritors can override this property to set the TreeAlias to whatever they choose.
        /// &lt;/summary&gt;
        public virtual string TreeAlias
        {
            get
            {
                if (string.IsNullOrEmpty(m_treeAlias))
                {
                    TreeDefinition treeDef = TreeDefinitionCollection.Instance.FindTree(this);
                    m_treeAlias = (treeDef != null ? treeDef.Tree.Alias : &quot;&quot;);
                }

                return m_treeAlias;
            }
            internal set { m_treeAlias = value; }
        }
        private string m_treeAlias;

        #region ITreeService Members

        /// &lt;summary&gt;
        /// By default the start node id will be -1 which will return all of the nodes
        /// &lt;/summary&gt;
        public virtual int StartNodeID
        {
            get { return -1; }
        }

        public bool ShowContextMenu
        {
            get { return m_showContextMenu; }
            set { m_showContextMenu = value; }
        }

        public bool IsDialog
        {
            get { return m_isDialog; }
            set { m_isDialog = value; }
        }

        /// &lt;summary&gt;
        /// The NodeKey is a string representation of the nodeID. Generally this is used for tree&#39;s whos node&#39;s unique key value is a string in instead 
        /// of an integer such as folder names.
        /// &lt;/summary&gt;
        public string NodeKey
        {
            get { return m_nodeKey; }
            set { m_nodeKey = value; }
        }

        public string FunctionToCall
        {
            get { return m_functionToCall; }
            set { m_functionToCall = value; }
        }

        public TreeDialogModes DialogMode
        {
            get { return m_dialogMode; }
            set { m_dialogMode = value; }
        }

        #endregion

        #region ITree Members

        /// &lt;summary&gt;
        /// The ID of the node to render. This is generally set before calling the render method of the tree. If it is not set then the 
        /// StartNodeID property is used as the node ID to render.
        /// &lt;/summary&gt;
        public virtual int id 
        { 
            set { m_id = value; }
            get { return m_id; }
        }
        public virtual string app 
        { 
            set { m_app = value; }
            get { return m_app; }
        }

        /// &lt;summary&gt;
        /// Renders out any JavaScript methods that may be required for tree functionality. Generally used to load the editor page when
        /// a user clicks on a tree node.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Javascript&quot;&gt;&lt;/param&gt;
        public abstract void RenderJS(ref StringBuilder Javascript);

        /// &lt;summary&gt;
        /// This will call the new Render method which works using a typed XmlTree object instead of the untyped XmlDocument object.
        /// This can still be overriden but is only for backwards compatibility.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Tree&quot;&gt;&lt;/param&gt;
        [Obsolete(&quot;Use the other Render method instead&quot;)]
        public virtual void Render(ref XmlDocument Tree)
        {
            //call our render method by passing in the XmlTree instead of the XmlDocument
            Render(ref m_xTree);
            //now that we have an XmlTree object filled, we&#39;ll serialize it back to the XmlDocument of the ITree
			Tree.LoadXml(m_xTree.ToString(SerializedTreeType.XmlTree));			
        }

        /// &lt;summary&gt;
        /// Classes need to override thid method to create the nodes for the XmlTree
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;tree&quot;&gt;&lt;/param&gt;
        public abstract void Render(ref XmlTree tree);

        #endregion

        protected int m_id;
        protected string m_app;
        protected XmlTreeNode m_initNode;
        private List&lt;IAction&gt; m_initActions = new List&lt;IAction&gt;();
        private List&lt;IAction&gt; m_allowedActions = new List&lt;IAction&gt;();
        
        //these are the request parameters that can be specified.
        //since we want to remove the querystring/httpcontext dependency from
        //our trees, we need to define these as properties.       
        private bool m_showContextMenu = true;
        private bool m_isDialog = false;
        private TreeDialogModes m_dialogMode = TreeDialogModes.none;
        private string m_nodeKey = &quot;&quot;;
        private string m_functionToCall = &quot;&quot;;

        private bool m_isInitialized = false;

        private XmlTree m_xTree = new XmlTree();

        /// &lt;summary&gt;
        /// Provides easy access to the ServiceContext
        /// &lt;/summary&gt;
        protected internal ServiceContext Services
        {
            get { return ApplicationContext.Current.Services; }
        }

        /// &lt;summary&gt;
        /// Initializes the class if it hasn&#39;t been done already
        /// &lt;/summary&gt;
        protected void Initialize()
        {
            if (!m_isInitialized)
            {
                //VERY IMPORTANT! otherwise it will go infinite loop!
                m_isInitialized = true;

                CreateAllowedActions(); //first create the allowed actions
                
                //raise the event, allow developers to modify the collection
                var nodeActions = new NodeActionsEventArgs(false, m_allowedActions);
                OnNodeActionsCreated(nodeActions);
                m_allowedActions = nodeActions.AllowedActions;

                CreateRootNodeActions();//then create the root node actions

                var rootActions = new NodeActionsEventArgs(true, m_initActions);
                OnNodeActionsCreated(rootActions);
                m_initActions = rootActions.AllowedActions;

                CreateRootNode(); //finally, create the root node itself
            }            
        }

        /// &lt;summary&gt;
        /// This method creates the Root node definition for the tree.
        /// Inheritors must override this method to create their own definition.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;rootNode&quot;&gt;&lt;/param&gt;
        protected abstract void CreateRootNode(ref XmlTreeNode rootNode);
        protected void CreateRootNode()
        {
            m_initNode = XmlTreeNode.CreateRoot(this);
			m_initNode.Icon = FolderIcon;
			m_initNode.OpenIcon = FolderIconOpen;
            CreateRootNode(ref m_initNode);
        }


        /// &lt;summary&gt;
        /// This method creates the IAction list for the tree&#39;s root node.
        /// Inheritors can override this method to create their own Context menu.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;actions&quot;&gt;&lt;/param&gt;
        protected virtual void CreateRootNodeActions(ref List&lt;IAction&gt; actions)
        {
            actions.AddRange(GetDefaultRootNodeActions());
        }
        protected void CreateRootNodeActions()
        {
            CreateRootNodeActions(ref m_initActions);
        }

        /// &lt;summary&gt;
        /// This method creates the AllowedActions IAction list for the tree&#39;s nodes.
        /// Inheritors can override this method to create their own Context menu.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;actions&quot;&gt;&lt;/param&gt;
        protected virtual void CreateAllowedActions(ref List&lt;IAction&gt; actions)
        {
            actions.Add(ActionDelete.Instance);

            //raise the event, allow developers to modify the collection
            var e = new NodeActionsEventArgs(false, actions);
            OnNodeActionsCreated(e);
            actions = e.AllowedActions;

        }
        protected void CreateAllowedActions()
        {
            CreateAllowedActions(ref m_allowedActions);
        }

		/// &lt;summary&gt;		
		/// A helper method to re-generate the root node for the current tree.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public XmlTreeNode GenerateRootNode()
		{
			XmlTreeNode node = XmlTreeNode.CreateRoot(this);
			this.CreateRootNode(ref node);
			return node;
		}

        /// &lt;summary&gt;
        /// This method can initialize the ITreeService parameters for this class with another ITreeService object.
        /// This method could be used for Dependency Injection.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;treeParams&quot;&gt;&lt;/param&gt;
        public void SetTreeParameters(ITreeService treeParams)
        {
            this.DialogMode = treeParams.DialogMode;
            this.NodeKey = treeParams.NodeKey;
            this.FunctionToCall = treeParams.FunctionToCall;
            this.IsDialog = treeParams.IsDialog;
            this.ShowContextMenu = treeParams.ShowContextMenu;
            this.id = treeParams.StartNodeID;

            if (!treeParams.ShowContextMenu)
                this.RootNode.Menu = null;
        }

        /// &lt;summary&gt;
        /// Returns the tree service url to render the tree
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public string GetTreeInitUrl()
        {
            TreeService treeSvc = new TreeService(this.StartNodeID, TreeAlias, null, null, TreeDialogModes.none, &quot;&quot;);
            return treeSvc.GetInitUrl();
        }

        /// &lt;summary&gt;
        /// Returns the tree service url to return the tree xml structure from the root node
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public string GetTreeServiceUrl()
        {
            return GetTreeServiceUrl(this.StartNodeID);
        }

        /// &lt;summary&gt;
        /// Returns the tree service url to return the tree xml structure from the node passed in
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public string GetTreeServiceUrl(int id)
        {
			// updated by NH to pass showcontextmenu, isdialog and dialogmode variables
			TreeService treeSvc = new TreeService(id, TreeAlias, this.ShowContextMenu, this.IsDialog, this.DialogMode, &quot;&quot;);
			return treeSvc.GetServiceUrl();            
        }

		/// &lt;summary&gt;
		/// Returns the tree service url to return the tree xml structure based on a string node key.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;nodeKey&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public string GetTreeServiceUrl(string nodeKey)
		{
			TreeService treeSvc = new TreeService(-1, TreeAlias, this.ShowContextMenu, this.IsDialog, this.DialogMode, &quot;&quot;, nodeKey);
			return treeSvc.GetServiceUrl();
		}



        /// &lt;summary&gt;
        /// Returns the tree service url to render the tree in dialog mode
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public virtual string GetTreeDialogUrl()
        {
            TreeService treeSvc = new TreeService(this.StartNodeID, TreeAlias, false, true, this.DialogMode, &quot;&quot;);
            return treeSvc.GetServiceUrl();
        }

        /// &lt;summary&gt;
        /// Returns the tree service url to render tree xml structure from the node passed in, in dialog mode.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public virtual string GetTreeDialogUrl(int id)
        {
            TreeService treeSvc = new TreeService(id, TreeAlias, false, true, this.DialogMode, &quot;&quot;);
            return treeSvc.GetServiceUrl();
        }

		/// &lt;summary&gt;
		/// Returns the serialized data for the nodeId passed in.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// This may not work with ITrees that don&#39;t support the BaseTree structure with TreeService.
		/// If a tree implements other query string data to make it work, this may not function since
		/// it only relies on the 3 parameters.
		/// &lt;/remarks&gt;
		/// &lt;param name=&quot;alias&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;nodeId&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public string GetSerializedNodeData(string nodeId)
		{
			XmlTree xTree = new XmlTree();
			int id;
			if (int.TryParse(nodeId, out id))
				this.id = id;
			else
				this.NodeKey = nodeId;

			this.Render(ref xTree);            

			return xTree.ToString();
		}

        /// &lt;summary&gt;
        /// Returns a boolean value indicating if the ITree passed in is an extension of BaseTree.
        /// This is used to preserve backwards compatibility previous to version 5.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;tree&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static bool IsBaseTree(ITree tree)
        {
            return typeof(BaseTree).IsAssignableFrom(tree.GetType());
        }

        /// &lt;summary&gt;
        /// Converts an ITree into a BaseTree. This is used for Legacy trees that don&#39;t inherit from BaseTree already.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;tree&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;alias&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;appAlias&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;iconClosed&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;iconOpened&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;action&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static BaseTree FromITree(ITree tree, string alias, string appAlias, string iconClosed, string iconOpened, string action)
        {
            TreeService treeSvc = new TreeService(null, alias, null, null, TreeDialogModes.none, appAlias);
            //create the generic XmlTreeNode and fill it with the properties from the db          
			NullTree nullTree = new NullTree(appAlias);
            XmlTreeNode node = XmlTreeNode.CreateRoot(nullTree);
            node.Text = BaseTree.GetTreeHeader(alias);;
            node.Action = action;
            node.Source = treeSvc.GetServiceUrl();
            node.Icon = iconClosed;
            node.OpenIcon = iconOpened;
            node.NodeType = &quot;init&quot; + alias;
			node.NodeType = alias;
            node.NodeID = &quot;init&quot;;
            node.Menu = BaseTree.GetDefaultRootNodeActions();

            //convert the tree to a LegacyTree
            LegacyTree bTree = new LegacyTree(tree, appAlias, node);

            return bTree;
        }

        /// &lt;summary&gt;
        /// Returns the default actions for a root node
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static List&lt;IAction&gt; GetDefaultRootNodeActions()
        {
            List&lt;IAction&gt; actions = new List&lt;IAction&gt;();
            actions.Add(ActionNew.Instance);
            actions.Add(ContextMenuSeperator.Instance);
            actions.Add(ActionRefresh.Instance);
            return actions;
        }

        /// &lt;summary&gt;
        /// Returns the tree header title. If the alias isn&#39;t found in the language files, then it will
        /// return the title stored in the umbracoAppTree table.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string GetTreeHeader(string alias)
        {
            string treeCaption = ui.Text(alias);
            //this is a hack. the tree header title should be in the language files, however, if it is not, we&#39;re just
            //going to make it equal to what is specified in the db.
            if (treeCaption.Length &gt; 0 &amp;&amp; treeCaption.Substring(0, 1) == &quot;[&quot;)
            {
                ApplicationTree tree = ApplicationTree.getByAlias(alias);
                if (tree != null)
                    return tree.Title.SplitPascalCasing().ToFirstUpperInvariant();
            }
            return treeCaption;
        }


        #region Events
        
        //These events are poorly designed because they cannot be implemented in the tree inheritance structure,
        //it would be up to the individual trees to ensure they launch the events which is not ideal.
        //they are also named in appropriately in regards to standards and because everything is by ref, there is no need to 
        //have 2 events, makes no difference if you want to modify the contents of the data.
        public delegate void BeforeNodeRenderEventHandler(ref XmlTree sender, ref XmlTreeNode node, EventArgs e);
        public delegate void AfterNodeRenderEventHandler(ref XmlTree sender, ref XmlTreeNode node, EventArgs e);
        public static event BeforeNodeRenderEventHandler BeforeNodeRender;
        public static event AfterNodeRenderEventHandler AfterNodeRender;

        public static event EventHandler&lt;TreeEventArgs&gt; BeforeTreeRender;
        public static event EventHandler&lt;TreeEventArgs&gt; AfterTreeRender;

        /// &lt;summary&gt;
        /// Raises the &lt;see cref=&quot;E:BeforeNodeRender&quot;/&gt; event.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;e&quot;&gt;The &lt;see cref=&quot;System.EventArgs&quot;/&gt; instance containing the event data.&lt;/param&gt;
        protected virtual void OnBeforeNodeRender(ref XmlTree sender, ref XmlTreeNode node, EventArgs e)
        {
            if (sender != null &amp;&amp; node != null)
            {
                if (BeforeNodeRender != null)
                    BeforeNodeRender(ref sender, ref node, e);    
            }
        }

        /// &lt;summary&gt;
        /// Raises the &lt;see cref=&quot;E:AfterNodeRender&quot;/&gt; event.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;e&quot;&gt;The &lt;see cref=&quot;System.EventArgs&quot;/&gt; instance containing the event data.&lt;/param&gt;
        protected virtual void OnAfterNodeRender(ref XmlTree sender, ref XmlTreeNode node, EventArgs e)
        {
            if (AfterNodeRender != null)
                AfterNodeRender(ref sender, ref node, e);
        }

        protected virtual void OnBeforeTreeRender(object sender, TreeEventArgs e)
        {
            if (BeforeTreeRender != null)
                BeforeTreeRender(sender, e);
        }

        protected virtual void OnAfterTreeRender(object sender, TreeEventArgs e)
        {
            if (AfterTreeRender != null)
                AfterTreeRender(sender, e);
        }

        [Obsolete(&quot;Do not use this method to raise events, it is no longer used and will cause very high performance spikes!&quot;)]
        protected internal virtual void OnBeforeTreeRender(IEnumerable&lt;IUmbracoEntity&gt; sender, TreeEventArgs e, bool isContent)
        {
            if (BeforeTreeRender != null)
            {
                if (isContent)
                {
                    BeforeTreeRender(sender.Select(x =&gt; new Document(x, false)).ToArray(), e);
                }
                else
                {
                    BeforeTreeRender(sender.Select(x =&gt; new Media(x, false)).ToArray(), e);
                }
            }
        }

        [Obsolete(&quot;Do not use this method to raise events, it is no longer used and will cause very high performance spikes!&quot;)]
        protected internal virtual void OnAfterTreeRender(IEnumerable&lt;IUmbracoEntity&gt; sender, TreeEventArgs e, bool isContent)
        {
            if (AfterTreeRender != null)
            {
                if (isContent)
                {
                    AfterTreeRender(sender.Select(x =&gt; new Document(x, false)).ToArray(), e);
                }
                else
                {
                    AfterTreeRender(sender.Select(x =&gt; new Media(x, false)).ToArray(), e);
                }
            }
        }

        /// &lt;summary&gt;
        /// Returns true if there are subscribers to either BeforeTreeRender or AfterTreeRender
        /// &lt;/summary&gt;
        internal bool HasEntityBasedEventSubscribers
        {
            get { return BeforeTreeRender != null || AfterTreeRender != null; }
        }

        /// &lt;summary&gt;
        /// Event that is raised once actions are assigned to nodes
        /// &lt;/summary&gt;
        public static event EventHandler&lt;NodeActionsEventArgs&gt; NodeActionsCreated;

        protected virtual void OnNodeActionsCreated(NodeActionsEventArgs e)
        {
            if (NodeActionsCreated != null)
                NodeActionsCreated(this, e);
        }

        #endregion

        //void IApplicationEventHandler.OnApplicationInitialized(UmbracoApplicationBase umbracoApplication, ApplicationContext applicationContext)
        //{
        //}

        //void IApplicationEventHandler.OnApplicationStarting(UmbracoApplicationBase umbracoApplication, ApplicationContext applicationContext)
        //{
        //}

        //void IApplicationEventHandler.OnApplicationStarted(UmbracoApplicationBase umbracoApplication, ApplicationContext applicationContext)
        //{
        //    TreeController.TreeNodesRendering += TreeController_TreeNodesRendering;
        //}
        
        //static void TreeController_TreeNodesRendering(TreeController sender, TreeNodesRenderingEventArgs e)
        //{
        //    var baseTree = new NullTree(&quot;&quot;);
        //    var legacyTree = new XmlTree();
        //    var toRemove = new List&lt;TreeNode&gt;();

        //    foreach (var node in e.Nodes)
        //    {
        //        //make the legacy node
        //        var xNode = XmlTreeNode.Create(baseTree);
        //        xNode.HasChildren = node.HasChildren;
        //        xNode.IconClass = node.Icon;
        //        xNode.NodeID = node.NodeId;                
        //        xNode.NodeType = sender.TreeAlias;
        //        xNode.Text = node.Title;
        //        xNode.TreeType = sender.TreeAlias;
        //        //we cannot support this
        //        //xNode.OpenIcon = node.Icon;
        //        //xNode.Menu = ??

        //        baseTree.OnBeforeNodeRender(ref legacyTree, ref xNode, new EventArgs());
        //        //if the user has nulled this item, then we need to remove it
        //        if (xNode == null)
        //        {
        //            toRemove.Add(node);
        //        }
        //        else
        //        {
        //            //add to the legacy tree - this mimics what normally happened in legacy trees
        //            legacyTree.Add(xNode);

        //            //now fire the after event
        //            baseTree.OnAfterNodeRender(ref legacyTree, ref xNode, new EventArgs());

        //            //ok now we need to determine if we need to map any changes back to the real node
        //            // these are the only properties that can be mapped back.
        //            node.HasChildren = xNode.HasChildren;
        //            node.Icon = xNode.IconClass;
        //            if (xNode.Icon.IsNullOrWhiteSpace() == false)
        //            {
        //                node.Icon = xNode.Icon;
        //            }
        //            node.NodeType = xNode.NodeType;
        //            node.Title = xNode.Text;
        //        }
        //    }

        //    //now remove the nodes that were removed
        //    foreach (var r in toRemove)
        //    {
        //        e.Nodes.Remove(r);
        //    }
        //}


    }

}
    </pre>
    <script type="text/javascript">
      highlightRanges([[25,9,25,44,1],[26,9,26,10,1],[27,13,27,36,1],[28,9,28,10,1],[39,13,39,14,0],[40,17,40,30,0],[41,17,41,35,0],[42,13,42,14,0],[53,13,53,14,0],[54,17,54,30,0],[55,17,55,38,0],[56,13,56,14,0],[66,13,66,14,0],[67,17,67,30,0],[68,17,68,41,0],[69,13,69,14,0],[79,13,79,14,0],[80,17,80,55,0],[81,17,81,18,0],[82,21,82,95,0],[83,21,83,79,0],[84,17,84,18,0],[86,17,86,36,0],[87,13,87,14,0],[88,26,88,27,0],[88,28,88,48,0],[88,49,88,50,0],[99,17,99,18,0],[99,19,99,29,0],[99,30,99,31,0],[104,17,104,18,0],[104,19,104,44,0],[104,45,104,46,0],[105,17,105,18,0],[105,19,105,45,0],[105,46,105,47,0],[110,17,110,18,0],[110,19,110,37,0],[110,38,110,39,0],[111,17,111,18,0],[111,19,111,38,0],[111,39,111,40,0],[120,17,120,18,0],[120,19,120,36,0],[120,37,120,38,0],[121,17,121,18,0],[121,19,121,37,0],[121,38,121,39,0],[126,17,126,18,0],[126,19,126,43,0],[126,44,126,45,0],[127,17,127,18,0],[127,19,127,44,0],[127,45,127,46,0],[132,17,132,18,0],[132,19,132,39,0],[132,40,132,41,0],[133,17,133,18,0],[133,19,133,40,0],[133,41,133,42,0],[146,17,146,18,0],[146,19,146,32,0],[146,33,146,34,0],[147,17,147,18,0],[147,19,147,31,0],[147,32,147,33,0],[151,17,151,18,1],[151,19,151,33,1],[151,34,151,35,1],[152,17,152,18,0],[152,19,152,32,0],[152,33,152,34,0],[169,9,169,10,0],[171,13,171,33,0],[173,4,173,63,0],[174,9,174,10,0],[187,9,187,67,1],[188,9,188,70,1],[193,9,193,47,1],[194,9,194,41,1],[195,9,195,69,1],[196,9,196,39,1],[197,9,197,46,1],[199,9,199,46,1],[201,9,201,49,1],[208,17,208,18,0],[208,19,208,62,0],[208,63,208,64,0],[215,9,215,10,0],[216,13,216,34,0],[217,13,217,14,0],[219,17,219,40,0],[221,17,221,40,0],[224,17,224,85,0],[225,17,225,51,0],[226,17,226,63,0],[228,17,228,41,0],[230,17,230,81,0],[231,17,231,51,0],[232,17,232,60,0],[234,17,234,34,0],[235,13,235,14,0],[236,9,236,10,0],[245,9,245,10,0],[246,13,246,55,0],[247,4,247,33,0],[248,4,248,41,0],[249,13,249,44,0],[250,9,250,10,0],[259,9,259,10,0],[260,13,260,59,0],[261,9,261,10,0],[263,9,263,10,0],[264,13,264,54,0],[265,9,265,10,0],[273,9,273,10,0],[274,13,274,48,0],[277,13,277,62,0],[278,13,278,37,0],[279,13,279,40,0],[281,9,281,10,0],[283,9,283,10,0],[284,13,284,56,0],[285,9,285,10,0],[292,3,292,4,0],[293,4,293,52,0],[294,4,294,34,0],[295,4,295,16,0],[296,3,296,4,0],[304,9,304,10,0],[305,13,305,53,0],[306,13,306,47,0],[307,13,307,61,0],[308,13,308,49,0],[309,13,309,63,0],[310,13,310,46,0],[312,13,312,45,0],[313,17,313,43,0],[314,9,314,10,0],[321,9,321,10,0],[322,13,322,118,0],[323,13,323,41,0],[324,9,324,10,0],[331,9,331,10,0],[332,13,332,56,0],[333,9,333,10,0],[341,9,341,10,0],[343,4,343,115,0],[344,4,344,35,0],[345,9,345,10,0],[353,3,353,4,0],[354,4,354,124,0],[355,4,355,35,0],[356,3,356,4,0],[365,9,365,10,0],[366,13,366,114,0],[367,13,367,44,0],[368,9,368,10,0],[376,9,376,10,0],[377,13,377,100,0],[378,13,378,44,0],[379,9,379,10,0],[393,3,393,4,0],[394,4,394,34,0],[396,4,396,37,0],[397,5,397,18,0],[399,5,399,27,0],[401,4,401,27,0],[403,4,403,28,0],[404,3,404,4,0],[413,9,413,10,0],[414,13,414,70,0],[415,9,415,10,0],[428,9,428,10,0],[429,13,429,108,0],[431,4,431,47,0],[432,13,432,65,0],[433,13,433,55,0],[433,55,433,56,0],[434,13,434,34,0],[435,13,435,51,0],[436,13,436,36,0],[437,13,437,40,0],[438,13,438,44,0],[439,4,439,26,0],[440,13,440,34,0],[441,13,441,62,0],[444,13,444,69,0],[446,13,446,26,0],[447,9,447,10,0],[454,9,454,10,0],[455,13,455,57,0],[456,13,456,45,0],[457,13,457,56,0],[458,13,458,49,0],[459,13,459,28,0],[460,9,460,10,0],[469,9,469,10,0],[470,13,470,49,0],[473,13,473,78,0],[474,13,474,14,0],[475,17,475,74,0],[476,17,476,34,0],[477,21,477,83,0],[478,13,478,14,0],[479,13,479,32,0],[480,9,480,10,0],[502,9,502,10,0],[503,13,503,48,0],[504,13,504,14,0],[505,17,505,46,0],[506,21,506,63,0],[507,13,507,14,0],[508,9,508,10,0],[515,9,515,10,0],[516,13,516,41,0],[517,17,517,58,0],[518,9,518,10,0],[521,9,521,10,0],[522,13,522,42,0],[523,17,523,45,0],[524,9,524,10,0],[527,9,527,10,0],[528,13,528,41,0],[529,17,529,44,0],[530,9,530,10,0],[534,9,534,10,0],[535,13,535,42,0],[536,13,536,14,0],[537,17,537,31,0],[538,17,538,18,0],[539,21,539,57,0],[539,57,539,79,0],[539,79,539,95,0],[539,21,539,95,0],[540,17,540,18,0],[542,17,542,18,0],[543,21,543,57,0],[543,57,543,76,0],[543,76,543,92,0],[543,21,543,92,0],[544,17,544,18,0],[545,13,545,14,0],[546,9,546,10,0],[550,9,550,10,0],[551,13,551,41,0],[552,13,552,14,0],[553,17,553,31,0],[554,17,554,18,0],[555,21,555,56,0],[555,56,555,78,0],[555,78,555,94,0],[555,21,555,94,0],[556,17,556,18,0],[558,17,558,18,0],[559,21,559,56,0],[559,56,559,75,0],[559,75,559,91,0],[559,21,559,91,0],[560,17,560,18,0],[561,13,561,14,0],[562,9,562,10,0],[569,17,569,18,1],[569,19,569,78,1],[569,79,569,80,1],[578,9,578,10,0],[579,13,579,44,0],[580,17,580,45,0],[581,9,581,10,0]]);
    </script>
  </body>
</html>