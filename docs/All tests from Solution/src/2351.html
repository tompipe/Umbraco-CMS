<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\UmbracoExamine\UmbracoContentIndexer.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Linq;
using Examine;
using Lucene.Net.Documents;
using Umbraco.Core;
using Umbraco.Core.Models;
using Umbraco.Core.Persistence.DatabaseModelDefinitions;
using Umbraco.Core.Services;
using UmbracoExamine.DataServices;
using Examine.LuceneEngine;
using Examine.LuceneEngine.Config;
using UmbracoExamine.Config;
using Lucene.Net.Analysis;
using Lucene.Net.Index;
using Umbraco.Core.Persistence.Querying;
using IContentService = Umbraco.Core.Services.IContentService;
using IMediaService = Umbraco.Core.Services.IMediaService;


namespace UmbracoExamine
{
    /// &lt;summary&gt;
    /// 
    /// &lt;/summary&gt;
    public class UmbracoContentIndexer : BaseUmbracoIndexer
    {
        private readonly IContentService _contentService;
        private readonly IMediaService _mediaService;
        private readonly IDataTypeService _dataTypeService;
        private readonly IUserService _userService;
        private readonly IContentTypeService _contentTypeService;
        private readonly EntityXmlSerializer _serializer = new EntityXmlSerializer();
        private const int PageSize = 10000;

        #region Constructors

        /// &lt;summary&gt;
        /// Default constructor
        /// &lt;/summary&gt;
        public UmbracoContentIndexer()
            : base()
        {
            _contentService = ApplicationContext.Current.Services.ContentService;
            _mediaService = ApplicationContext.Current.Services.MediaService;
            _dataTypeService = ApplicationContext.Current.Services.DataTypeService;
            _userService = ApplicationContext.Current.Services.UserService;
            _contentTypeService = ApplicationContext.Current.Services.ContentTypeService;
        }

        /// &lt;summary&gt;
        /// Constructor to allow for creating an indexer at runtime
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;indexerData&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;indexPath&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;analyzer&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;async&quot;&gt;&lt;/param&gt;
        [Obsolete(&quot;Use the overload that specifies the Umbraco services&quot;)]
        public UmbracoContentIndexer(IIndexCriteria indexerData, DirectoryInfo indexPath, IDataService dataService, Analyzer analyzer, bool async)
            : base(indexerData, indexPath, dataService, analyzer, async)
        {
            _contentService = ApplicationContext.Current.Services.ContentService;
            _mediaService = ApplicationContext.Current.Services.MediaService;
            _dataTypeService = ApplicationContext.Current.Services.DataTypeService;
            _userService = ApplicationContext.Current.Services.UserService;
            _contentTypeService = ApplicationContext.Current.Services.ContentTypeService;
        }

        /// &lt;summary&gt;
        /// Constructor to allow for creating an indexer at runtime
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;indexerData&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;luceneDirectory&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;analyzer&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;async&quot;&gt;&lt;/param&gt;
        [Obsolete(&quot;Use the overload that specifies the Umbraco services&quot;)]
        public UmbracoContentIndexer(IIndexCriteria indexerData, Lucene.Net.Store.Directory luceneDirectory, IDataService dataService, Analyzer analyzer, bool async)
            : base(indexerData, luceneDirectory, dataService, analyzer, async)
        {
            _contentService = ApplicationContext.Current.Services.ContentService;
            _mediaService = ApplicationContext.Current.Services.MediaService;
            _dataTypeService = ApplicationContext.Current.Services.DataTypeService;
            _userService = ApplicationContext.Current.Services.UserService;
            _contentTypeService = ApplicationContext.Current.Services.ContentTypeService;
        }

        /// &lt;summary&gt;
        /// Constructor to allow for creating an indexer at runtime
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;indexerData&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;luceneDirectory&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;contentService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;mediaService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;userService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;analyzer&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;async&quot;&gt;&lt;/param&gt;
        [Obsolete(&quot;Use the overload that specifies the Umbraco services&quot;)]
        public UmbracoContentIndexer(IIndexCriteria indexerData, Lucene.Net.Store.Directory luceneDirectory, IDataService dataService, 
            IContentService contentService, 
            IMediaService mediaService,
            IDataTypeService dataTypeService,
            IUserService userService,
            Analyzer analyzer, bool async)
            : base(indexerData, luceneDirectory, dataService, analyzer, async)
        {
            _contentService = contentService;
            _mediaService = mediaService;
            _dataTypeService = dataTypeService;
            _userService = userService;
            _contentTypeService = ApplicationContext.Current.Services.ContentTypeService;
        }

        /// &lt;summary&gt;
        /// Constructor to allow for creating an indexer at runtime
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;indexerData&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;luceneDirectory&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;contentService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;mediaService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;userService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;contentTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;analyzer&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;async&quot;&gt;&lt;/param&gt;
        public UmbracoContentIndexer(IIndexCriteria indexerData, Lucene.Net.Store.Directory luceneDirectory, IDataService dataService,
            IContentService contentService,
            IMediaService mediaService,
            IDataTypeService dataTypeService,
            IUserService userService,
            IContentTypeService contentTypeService,
            Analyzer analyzer, bool async)
            : base(indexerData, luceneDirectory, dataService, analyzer, async)
        {
            _contentService = contentService;
            _mediaService = mediaService;
            _dataTypeService = dataTypeService;
            _userService = userService;
            _contentTypeService = contentTypeService;
        }

        /// &lt;summary&gt;
        /// Creates an NRT indexer
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;indexerData&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;writer&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;contentTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;async&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;contentService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;mediaService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dataTypeService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;userService&quot;&gt;&lt;/param&gt;
        public UmbracoContentIndexer(IIndexCriteria indexerData, IndexWriter writer, IDataService dataService,
            IContentService contentService,
            IMediaService mediaService,
            IDataTypeService dataTypeService,
            IUserService userService,
            IContentTypeService contentTypeService,
            bool async) 
            : base(indexerData, writer, dataService, async)
        {
            _contentService = contentService;
            _mediaService = mediaService;
            _dataTypeService = dataTypeService;
            _userService = userService;
            _contentTypeService = contentTypeService;
        }

        #endregion

        #region Constants &amp; Fields        

        /// &lt;summary&gt;
        /// Used to store the path of a content object
        /// &lt;/summary&gt;
        public const string IndexPathFieldName = &quot;__Path&quot;;
        public const string NodeTypeAliasFieldName = &quot;__NodeTypeAlias&quot;;
        public const string IconFieldName = &quot;__Icon&quot;;

        /// &lt;summary&gt;
        /// The prefix added to a field when it is duplicated in order to store the original raw value.
        /// &lt;/summary&gt;
        public const string RawFieldPrefix = &quot;__Raw_&quot;;

        /// &lt;summary&gt;
        /// A type that defines the type of index for each Umbraco field (non user defined fields)
        /// Alot of standard umbraco fields shouldn&#39;t be tokenized or even indexed, just stored into lucene
        /// for retreival after searching.
        /// &lt;/summary&gt;
        internal static readonly StaticFieldCollection IndexFieldPolicies
            = new StaticFieldCollection
            {
                new StaticField(&quot;id&quot;, FieldIndexTypes.NOT_ANALYZED, false, string.Empty),
                new StaticField(&quot;key&quot;, FieldIndexTypes.NOT_ANALYZED, false, string.Empty),
                new StaticField(&quot;version&quot;, FieldIndexTypes.NOT_ANALYZED, false, string.Empty),
                new StaticField(&quot;parentID&quot;, FieldIndexTypes.NOT_ANALYZED, false, string.Empty),
                new StaticField(&quot;level&quot;, FieldIndexTypes.NOT_ANALYZED, true, &quot;NUMBER&quot;),
                new StaticField(&quot;writerID&quot;, FieldIndexTypes.NOT_ANALYZED, false, string.Empty),
                new StaticField(&quot;creatorID&quot;, FieldIndexTypes.NOT_ANALYZED, false, string.Empty),
                new StaticField(&quot;nodeType&quot;, FieldIndexTypes.NOT_ANALYZED, false, string.Empty),
                new StaticField(&quot;template&quot;, FieldIndexTypes.NOT_ANALYZED, false, string.Empty),
                new StaticField(&quot;sortOrder&quot;, FieldIndexTypes.NOT_ANALYZED, true, &quot;NUMBER&quot;),
                new StaticField(&quot;createDate&quot;, FieldIndexTypes.NOT_ANALYZED, false, &quot;DATETIME&quot;),
                new StaticField(&quot;updateDate&quot;, FieldIndexTypes.NOT_ANALYZED, false, &quot;DATETIME&quot;),
                new StaticField(&quot;nodeName&quot;, FieldIndexTypes.ANALYZED, false, string.Empty),
                new StaticField(&quot;urlName&quot;, FieldIndexTypes.NOT_ANALYZED, false, string.Empty),
                new StaticField(&quot;writerName&quot;, FieldIndexTypes.ANALYZED, false, string.Empty),
                new StaticField(&quot;creatorName&quot;, FieldIndexTypes.ANALYZED, false, string.Empty),
                new StaticField(&quot;nodeTypeAlias&quot;, FieldIndexTypes.ANALYZED, false, string.Empty),
                new StaticField(&quot;path&quot;, FieldIndexTypes.NOT_ANALYZED, false, string.Empty)
            };

        #endregion

        #region Initialize

        /// &lt;summary&gt;
        /// Set up all properties for the indexer based on configuration information specified. This will ensure that
        /// all of the folders required by the indexer are created and exist. This will also create an instruction
        /// file declaring the computer name that is part taking in the indexing. This file will then be used to
        /// determine the master indexer machine in a load balanced environment (if one exists).
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The friendly name of the provider.&lt;/param&gt;
        /// &lt;param name=&quot;config&quot;&gt;A collection of the name/value pairs representing the provider-specific attributes specified in the configuration for this provider.&lt;/param&gt;
        /// &lt;exception cref=&quot;T:System.ArgumentNullException&quot;&gt;
        /// The name of the provider is null.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.ArgumentException&quot;&gt;
        /// The name of the provider has a length of zero.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;T:System.InvalidOperationException&quot;&gt;
        /// An attempt is made to call &lt;see cref=&quot;M:System.Configuration.Provider.ProviderBase.Initialize(System.String,System.Collections.Specialized.NameValueCollection)&quot;/&gt; on a provider after the provider has already been initialized.
        /// &lt;/exception&gt;
        
        public override void Initialize(string name, NameValueCollection config)
        {

            //check if there&#39;s a flag specifying to support unpublished content,
            //if not, set to false;
            bool supportUnpublished;
            if (config[&quot;supportUnpublished&quot;] != null &amp;&amp; bool.TryParse(config[&quot;supportUnpublished&quot;], out supportUnpublished))
                SupportUnpublishedContent = supportUnpublished;
            else
                SupportUnpublishedContent = false;


            //check if there&#39;s a flag specifying to support protected content,
            //if not, set to false;
            bool supportProtected;
            if (config[&quot;supportProtected&quot;] != null &amp;&amp; bool.TryParse(config[&quot;supportProtected&quot;], out supportProtected))
                SupportProtectedContent = supportProtected;
            else
                SupportProtectedContent = false;

            bool disableXmlDocLookup;
            if (config[&quot;disableXmlDocLookup&quot;] != null &amp;&amp; bool.TryParse(config[&quot;disableXmlDocLookup&quot;], out disableXmlDocLookup))
                DisableXmlDocumentLookup = disableXmlDocLookup;
            else
                DisableXmlDocumentLookup = false;

            base.Initialize(name, config);
        }

        #endregion

        #region Properties

        /// &lt;summary&gt;
        /// Whether to use the cmsContentXml data to re-index when possible (i.e. for published content, media and members)
        /// &lt;/summary&gt;
        public bool DisableXmlDocumentLookup { get; private set; }

        /// &lt;summary&gt;
        /// By default this is false, if set to true then the indexer will include indexing content that is flagged as publicly protected.
        /// This property is ignored if SupportUnpublishedContent is set to true.
        /// &lt;/summary&gt;
        public bool SupportProtectedContent { get; protected internal set; }

        protected override IEnumerable&lt;string&gt; SupportedTypes
        {
            get
            {
                return new string[] { IndexTypes.Content, IndexTypes.Media };
            }
        }

        #endregion

        #region Event handlers

        protected override void OnIndexingError(IndexingErrorEventArgs e)
        {
            DataService.LogService.AddErrorLog(e.NodeId, string.Format(&quot;{0},{1}, IndexSet: {2}&quot;, e.Message, e.InnerException != null ? e.InnerException.ToString() : &quot;&quot;, this.IndexSetName));
            base.OnIndexingError(e);
        }

        /// &lt;summary&gt;
        /// This ensures that the special __Raw_ fields are indexed
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;docArgs&quot;&gt;&lt;/param&gt;

        protected override void OnDocumentWriting(DocumentWritingEventArgs docArgs)
        {
            var d = docArgs.Document;
            foreach (var f in docArgs.Fields.Where(x =&gt; x.Key.StartsWith(RawFieldPrefix)))
            {
                d.Add(new Field(
                   f.Key,
                   f.Value,
                   Field.Store.YES,
                   Field.Index.NO, //don&#39;t index this field, we never want to search by it 
                   Field.TermVector.NO));
            }

            base.OnDocumentWriting(docArgs);
        }

        protected override void OnNodeIndexed(IndexedNodeEventArgs e)
        {
            DataService.LogService.AddVerboseLog(e.NodeId, string.Format(&quot;Index created for node {0}&quot;, e.NodeId));
            base.OnNodeIndexed(e);
        }

        protected override void OnIndexDeleted(DeleteIndexEventArgs e)
        {
            DataService.LogService.AddVerboseLog(-1, string.Format(&quot;Index deleted for term: {0} with value {1}&quot;, e.DeletedTerm.Key, e.DeletedTerm.Value));
            base.OnIndexDeleted(e);
        }

        protected override void OnIndexOptimizing(EventArgs e)
        {
            DataService.LogService.AddInfoLog(-1, string.Format(&quot;Index is being optimized&quot;));
            base.OnIndexOptimizing(e);
        }

        #endregion

        #region Public methods
        
        /// &lt;summary&gt;
        /// Overridden for logging
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        public override void ReIndexNode(XElement node, string type)
        {
            if (!SupportedTypes.Contains(type))
                return;

            if (node.Attribute(&quot;id&quot;) != null)
            {
                DataService.LogService.AddVerboseLog((int)node.Attribute(&quot;id&quot;), string.Format(&quot;ReIndexNode with type: {0}&quot;, type));
                base.ReIndexNode(node, type);
            }
            else
            {
                DataService.LogService.AddErrorLog(-1, string.Format(&quot;ReIndexNode cannot proceed, the format of the XElement is invalid, the xml has no &#39;id&#39; attribute. {0}&quot;, node));
            }
        }

        /// &lt;summary&gt;
        /// Deletes a node from the index.                
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// When a content node is deleted, we also need to delete it&#39;s children from the index so we need to perform a 
        /// custom Lucene search to find all decendents and create Delete item queues for them too.
        /// &lt;/remarks&gt;
        /// &lt;param name=&quot;nodeId&quot;&gt;ID of the node to delete&lt;/param&gt;
        public override void DeleteFromIndex(string nodeId)
        {
            //find all descendants based on path
            var descendantPath = string.Format(@&quot;\-1\,*{0}\,*&quot;, nodeId);
            var rawQuery = string.Format(&quot;{0}:{1}&quot;, IndexPathFieldName, descendantPath);
            var c = InternalSearcher.CreateSearchCriteria();
            var filtered = c.RawQuery(rawQuery);
            var results = InternalSearcher.Search(filtered);

            DataService.LogService.AddVerboseLog(int.Parse(nodeId), string.Format(&quot;DeleteFromIndex with query: {0} (found {1} results)&quot;, rawQuery, results.Count()));

            //need to create a delete queue item for each one found
            foreach (var r in results)
            {
                EnqueueIndexOperation(new IndexOperation()
                    {
                        Operation = IndexOperationType.Delete,
                        Item = new IndexItem(null, &quot;&quot;, r.Id.ToString())
                    });
                //SaveDeleteIndexQueueItem(new KeyValuePair&lt;string, string&gt;(IndexNodeIdFieldName, r.Id.ToString()));
            }

            base.DeleteFromIndex(nodeId);
        }
        #endregion

        #region Protected        

        protected override void PerformIndexAll(string type)
        {
            if (SupportedTypes.Contains(type) == false)
                return;
            
            var pageIndex = 0;

            DataService.LogService.AddInfoLog(-1, string.Format(&quot;PerformIndexAll - Start data queries - {0}&quot;, type));
            var stopwatch = new Stopwatch();
            stopwatch.Start();

            try
            {
                switch (type)
                {
                    case IndexTypes.Content:
                        var contentParentId = -1;
                        if (IndexerData.ParentNodeId.HasValue &amp;&amp; IndexerData.ParentNodeId.Value &gt; 0)
                        {
                            contentParentId = IndexerData.ParentNodeId.Value;
                        }
                        
                        if (SupportUnpublishedContent == false &amp;&amp; DisableXmlDocumentLookup == false)
                        {
                            //get all node Ids that have a published version - this is a fail safe check, in theory
                            // only document nodes that have a published version would exist in the cmsContentXml table
                            var allNodesWithPublishedVersions = ApplicationContext.Current.DatabaseContext.Database.Fetch&lt;int&gt;(
                                &quot;select DISTINCT cmsDocument.nodeId from cmsDocument where cmsDocument.published = 1&quot;);

                            XElement last = null;
                            var trackedIds = new HashSet&lt;string&gt;();

                            ReindexWithXmlEntries(type, contentParentId,
                                () =&gt; _contentTypeService.GetAllContentTypes().ToArray(),
                                (path, pIndex, pSize) =&gt;
                                {
                                    long totalContent;

                                    //sorted by: umbracoNode.level, umbracoNode.parentID, umbracoNode.sortOrder
                                    var result = _contentService.GetPagedXmlEntries(path, pIndex, pSize, out totalContent).ToArray();
                                    var more = result.Length == pSize;

                                    //then like we do in the ContentRepository.BuildXmlCache we need to track what Parents have been processed
                                    // already so that we can then exclude implicitly unpublished content items
                                    var filtered = new List&lt;XElement&gt;();

                                    foreach (var xml in result)
                                    {
                                        var id = xml.AttributeValue&lt;int&gt;(&quot;id&quot;);
                                        
                                        //don&#39;t include this if it doesn&#39;t have a published version
                                        if (allNodesWithPublishedVersions.Contains(id) == false)
                                            continue;

                                        var parentId = xml.AttributeValue&lt;string&gt;(&quot;parentID&quot;);

                                        if (parentId == null) continue; //this shouldn&#39;t happen

                                        //if the parentid is changing
                                        if (last != null &amp;&amp; last.AttributeValue&lt;string&gt;(&quot;parentID&quot;) != parentId)
                                        {
                                            var found = trackedIds.Contains(parentId);
                                            if (found == false)
                                            {
                                                //Need to short circuit here, if the parent is not there it means that the parent is unpublished
                                                // and therefore the child is not published either so cannot be included in the xml cache
                                                continue;
                                            }                                            
                                        }
                                        
                                        last = xml;
                                        trackedIds.Add(xml.AttributeValue&lt;string&gt;(&quot;id&quot;));

                                        filtered.Add(xml);
                                    }

                                    return Tuple.Create(filtered.ToArray(), more);
                                },
                                i =&gt; _contentService.GetById(i));
                        }
                        else
                        {
                            //used to track non-published entities so we can determine what items are implicitly not published
                            //currently this is not in use apart form in tests
                            var notPublished = new HashSet&lt;string&gt;();

                            int currentPageSize;
                            do
                            {
                                long total;

                                IContent[] descendants;
                                if (SupportUnpublishedContent)
                                {
                                    descendants = _contentService.GetPagedDescendants(contentParentId, pageIndex, PageSize, out total, &quot;umbracoNode.id&quot;).ToArray();
                                }
                                else
                                {
                                    //get all paged records but order by level ascending, we need to do this because we need to track which nodes are not published so that we can determine
                                    // which descendent nodes are implicitly not published
                                    descendants = _contentService.GetPagedDescendants(contentParentId, pageIndex, PageSize, out total, &quot;level&quot;, Direction.Ascending, true, (string)null).ToArray();
                                }

                                // need to store decendants count before filtering, in order for loop to work correctly
                                currentPageSize = descendants.Length;

                                //if specific types are declared we need to post filter them
                                //TODO: Update the service layer to join the cmsContentType table so we can query by content type too
                                IEnumerable&lt;IContent&gt; content;
                                if (IndexerData.IncludeNodeTypes.Any())
                                {
                                    content = descendants.Where(x =&gt; IndexerData.IncludeNodeTypes.Contains(x.ContentType.Alias));
                                }
                                else
                                {
                                    content = descendants;
                                }

                                AddNodesToIndex(GetSerializedContent(
                                    SupportUnpublishedContent,
                                    c =&gt; _serializer.Serialize(_contentService, _dataTypeService, _userService, c),
                                    content, notPublished).WhereNotNull(), type);

                                pageIndex++;
                            } while (currentPageSize == PageSize);
                        }

                        break;
                    case IndexTypes.Media:
                        var mediaParentId = -1;

                        if (IndexerData.ParentNodeId.HasValue &amp;&amp; IndexerData.ParentNodeId.Value &gt; 0)
                        {
                            mediaParentId = IndexerData.ParentNodeId.Value;
                        }

                        ReindexWithXmlEntries(type, mediaParentId,
                            () =&gt; _contentTypeService.GetAllMediaTypes().ToArray(),
                            (path, pIndex, pSize) =&gt;
                            {
                                long totalMedia;
                                var result = _mediaService.GetPagedXmlEntries(path, pIndex, pSize, out totalMedia).ToArray();
                                var more = result.Length == pSize;
                                return Tuple.Create(result, more);
                            },
                            i =&gt; _mediaService.GetById(i));

                        break;
                }
            }
            finally
            {
                stopwatch.Stop();
            }
            
            DataService.LogService.AddInfoLog(-1, string.Format(&quot;PerformIndexAll - End data queries - {0}, took {1}ms&quot;, type, stopwatch.ElapsedMilliseconds));
        }

        /// &lt;summary&gt;
        /// Performs a reindex of a type based on looking up entries from the cmsContentXml table - but using callbacks to get this data since
        /// we don&#39;t have a common underlying service interface for the media/content stuff
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;parentId&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;getContentTypes&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;getPagedXmlEntries&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;getContent&quot;&gt;&lt;/param&gt;
        internal void ReindexWithXmlEntries&lt;TContentType&gt;(
            string type, 
            int parentId,
            Func&lt;TContentType[]&gt; getContentTypes, 
            Func&lt;string, int, int, Tuple&lt;XElement[], bool&gt;&gt; getPagedXmlEntries,
            Func&lt;int, IContentBase&gt; getContent)
            where TContentType: IContentTypeComposition
        {
            var pageIndex = 0;

            var contentTypes = getContentTypes();
            var icons = contentTypes.ToDictionary(x =&gt; x.Id, y =&gt; y.Icon);
            var parent = parentId == -1 ? null : getContent(parentId);
            bool more;

            do
            {
                XElement[] xElements;

                if (parentId == -1)
                {
                    var pagedElements = getPagedXmlEntries(&quot;-1&quot;, pageIndex, PageSize);
                    xElements = pagedElements.Item1;
                    more = pagedElements.Item2;
                }
                else if (parent == null)
                {
                    xElements = new XElement[0];
                    more = false;
                }
                else
                {
                    var pagedElements = getPagedXmlEntries(parent.Path, pageIndex, PageSize);
                    xElements = pagedElements.Item1;
                    more = pagedElements.Item2;
                }

                //if specific types are declared we need to post filter them
                //TODO: Update the service layer to join the cmsContentType table so we can query by content type too
                if (IndexerData.IncludeNodeTypes.Any())
                {
                    var includeNodeTypeIds = contentTypes.Where(x =&gt; IndexerData.IncludeNodeTypes.Contains(x.Alias)).Select(x =&gt; x.Id);
                    xElements = xElements.Where(elm =&gt; includeNodeTypeIds.Contains(elm.AttributeValue&lt;int&gt;(&quot;nodeType&quot;))).ToArray();
                }

                foreach (var element in xElements)
                {
                    if (element.Attribute(&quot;icon&quot;) == null)
                    {
                        element.Add(new XAttribute(&quot;icon&quot;, icons[element.AttributeValue&lt;int&gt;(&quot;nodeType&quot;)]));
                    }
                }

                AddNodesToIndex(xElements, type);
                pageIndex++;
            } while (more);
        }

        internal static IEnumerable&lt;XElement&gt; GetSerializedContent(
            bool supportUnpublishdContent, 
            Func&lt;IContent, XElement&gt; serializer, 
            IEnumerable&lt;IContent&gt; content, 
            ISet&lt;string&gt; notPublished)
        {            
            foreach (var c in content)
            {
                if (supportUnpublishdContent == false)
                {
                    //if we don&#39;t support published content and this is not published then track it and return null
                    if (c.Published == false)
                    {
                        notPublished.Add(c.Path);
                        yield return null;
                        continue;
                    }

                    //if we don&#39;t support published content, check if this content item exists underneath any already tracked
                    //unpublished content and if so return null;
                    if (notPublished.Any(path =&gt; c.Path.StartsWith(string.Format(&quot;{0},&quot;, path))))
                    {
                        yield return null;
                        continue;
                    }
                }                

                var xml = serializer(c);                

                //add a custom &#39;icon&#39; attribute
                xml.Add(new XAttribute(&quot;icon&quot;, c.ContentType.Icon));

                yield return xml;
            }
        }

        /// &lt;summary&gt;
        /// Overridden for logging.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        protected override void AddSingleNodeToIndex(XElement node, string type)
        {
            DataService.LogService.AddVerboseLog((int)node.Attribute(&quot;id&quot;), string.Format(&quot;AddSingleNodeToIndex with type: {0}&quot;, type));
            base.AddSingleNodeToIndex(node, type);
        }

        public override void RebuildIndex()
        {
            DataService.LogService.AddInfoLog(-1, &quot;Rebuilding index&quot;);
            base.RebuildIndex();
        }

        /// &lt;summary&gt;
        /// Used to refresh the current IndexerData from the data in the DataService. This can be used
        /// if there are more properties added/removed from the database
        /// &lt;/summary&gt;
        public void RefreshIndexerDataFromDataService()
        {
            //TODO: This would be much better done if the IndexerData property had read/write locks applied
            // to it! Unless we update the base class there&#39;s really no way to prevent the IndexerData from being
            // changed during an operation that is reading from it.
            var newIndexerData = GetIndexerData(IndexSets.Instance.Sets[IndexSetName]);
            IndexerData = newIndexerData;
        }

        /// &lt;summary&gt;
        /// Override this method to strip all html from all user fields before raising the event, then after the event 
        /// ensure our special Path field is added to the collection
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;

        protected override void OnGatheringNodeData(IndexingNodeDataEventArgs e)
        {
            //strip html of all users fields if we detect it has HTML in it. 
            //if that is the case, we&#39;ll create a duplicate &#39;raw&#39; copy of it so that we can return
            //the value of the field &#39;as-is&#39;.
            // Get all user data that we want to index and store into a dictionary 
            foreach (var field in IndexerData.UserFields)
            {
                string fieldVal;
                if (e.Fields.TryGetValue(field.Name, out fieldVal))
                {
                    //check if the field value has html
                    if (XmlHelper.CouldItBeXml(fieldVal))
                    {
                        //First save the raw value to a raw field, we will change the policy of this field by detecting the prefix later
                        e.Fields[RawFieldPrefix + field.Name] = fieldVal;
                        //now replace the original value with the stripped html
                        e.Fields[field.Name] = DataService.ContentService.StripHtml(fieldVal);
                    }
                }
            }

            base.OnGatheringNodeData(e);

            //ensure the special path and node type alias fields is added to the dictionary to be saved to file
            var path = e.Node.Attribute(&quot;path&quot;).Value;
            if (!e.Fields.ContainsKey(IndexPathFieldName))
                e.Fields.Add(IndexPathFieldName, path);

            //this needs to support both schema&#39;s so get the nodeTypeAlias if it exists, otherwise the name
            var nodeTypeAlias = e.Node.Attribute(&quot;nodeTypeAlias&quot;) == null ? e.Node.Name.LocalName : e.Node.Attribute(&quot;nodeTypeAlias&quot;).Value;
            if (!e.Fields.ContainsKey(NodeTypeAliasFieldName))
                e.Fields.Add(NodeTypeAliasFieldName, nodeTypeAlias);

            //add icon 
            var icon = (string)e.Node.Attribute(&quot;icon&quot;);
            if (!e.Fields.ContainsKey(IconFieldName))
                e.Fields.Add(IconFieldName, icon);  
        }

        /// &lt;summary&gt;
        /// Called when a duplicate field is detected in the dictionary that is getting indexed.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;nodeId&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;indexSetName&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;&lt;/param&gt;
        protected override void OnDuplicateFieldWarning(int nodeId, string indexSetName, string fieldName)
        {
            base.OnDuplicateFieldWarning(nodeId, indexSetName, fieldName);

            this.DataService.LogService.AddInfoLog(nodeId, &quot;Field \&quot;&quot; + fieldName + &quot;\&quot; is listed multiple times in the index set \&quot;&quot; + indexSetName + &quot;\&quot;. Please ensure all names are unique&quot;);
        }

        /// &lt;summary&gt;
        /// Overridden to add the path property to the special fields to index
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;allValuesForIndexing&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override Dictionary&lt;string, string&gt; GetSpecialFieldsToIndex(Dictionary&lt;string, string&gt; allValuesForIndexing)
        {
            var fields = base.GetSpecialFieldsToIndex(allValuesForIndexing);

            //adds the special path property to the index
            fields.Add(IndexPathFieldName, allValuesForIndexing[IndexPathFieldName]);

            //adds the special node type alias property to the index
            fields.Add(NodeTypeAliasFieldName, allValuesForIndexing[NodeTypeAliasFieldName]);

            //icon
            if (allValuesForIndexing[IconFieldName].IsNullOrWhiteSpace() == false)
            {
                fields.Add(IconFieldName, allValuesForIndexing[IconFieldName]);    
            }

            return fields;
        }

        /// &lt;summary&gt;
        /// Creates an IIndexCriteria object based on the indexSet passed in and our DataService
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;indexSet&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// If we cannot initialize we will pass back empty indexer data since we cannot read from the database
        /// &lt;/remarks&gt;
        protected override IIndexCriteria GetIndexerData(IndexSet indexSet)
        {
            if (CanInitialize())
            {
                return indexSet.ToIndexCriteria(DataService, IndexFieldPolicies);
            }
            else
            {
                return base.GetIndexerData(indexSet);
            }
        }

        /// &lt;summary&gt;
        /// return the index policy for the field name passed in, if not found, return normal
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override FieldIndexTypes GetPolicy(string fieldName)
        {            
            StaticField def;
            if (IndexFieldPolicies.TryGetValue(fieldName, out def))
            {
                return def.IndexType;
            }
            return FieldIndexTypes.ANALYZED;
        }

        /// &lt;summary&gt;
        /// Ensure that the content of this node is available for indexing (i.e. don&#39;t allow protected
        /// content to be indexed when this is disabled).
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;/summary&gt;
        protected override bool ValidateDocument(XElement node)
        {
            // Test for access if we&#39;re only indexing published content
            // return nothing if we&#39;re not supporting protected content and it is protected, and we&#39;re not supporting unpublished content
            if (SupportUnpublishedContent == false
                &amp;&amp; SupportProtectedContent == false)
            {

                var nodeId = int.Parse(node.Attribute(&quot;id&quot;).Value);

                if (DataService.ContentService.IsProtected(nodeId, node.Attribute(&quot;path&quot;).Value))
                {
                    return false;
                }               
            }
            return base.ValidateDocument(node);
        }

        #endregion
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[38,9,38,86,0],[38,9,38,86,1],[38,9,38,86,0],[38,9,38,86,0],[38,9,38,86,0],[38,9,38,86,0],[47,15,47,21,0],[48,9,48,10,0],[49,13,49,82,0],[50,13,50,78,0],[51,13,51,84,0],[52,13,52,76,0],[53,13,53,90,0],[54,9,54,10,0],[66,15,66,73,0],[67,9,67,10,0],[68,13,68,82,0],[69,13,69,78,0],[70,13,70,84,0],[71,13,71,76,0],[72,13,72,90,0],[73,9,73,10,0],[85,15,85,79,0],[86,9,86,10,0],[87,13,87,82,0],[88,13,88,78,0],[89,13,89,84,0],[90,13,90,76,0],[91,13,91,90,0],[92,9,92,10,0],[113,15,113,79,0],[114,9,114,10,0],[115,13,115,46,0],[116,13,116,42,0],[117,13,117,48,0],[118,13,118,40,0],[119,13,119,90,0],[120,9,120,10,0],[142,15,142,79,0],[143,9,143,10,0],[144,13,144,46,0],[145,13,145,42,0],[146,13,146,48,0],[147,13,147,40,0],[148,13,148,54,0],[149,9,149,10,0],[170,15,170,60,1],[171,9,171,10,1],[172,13,172,46,1],[173,13,173,42,1],[174,13,174,48,1],[175,13,175,40,1],[176,13,176,54,1],[177,9,177,10,1],[200,9,221,15,1],[246,9,246,10,0],[251,13,251,125,0],[252,17,252,64,0],[254,17,254,51,0],[260,13,260,119,0],[261,17,261,60,0],[263,17,263,49,0],[266,13,266,128,0],[267,17,267,64,0],[269,17,269,50,0],[271,13,271,43,0],[272,9,272,10,0],[281,48,281,52,1],[281,53,281,65,0],[287,47,287,51,1],[287,52,287,75,0],[292,13,292,14,1],[293,17,293,78,1],[294,13,294,14,1],[302,9,302,10,0],[303,13,303,190,0],[304,13,304,37,0],[305,9,305,10,0],[313,9,313,10,1],[314,13,314,38,1],[315,13,315,20,1],[315,22,315,27,0],[315,28,315,30,1],[315,31,315,57,1],[315,57,315,89,1],[315,89,315,90,1],[315,31,315,90,1],[316,13,316,14,0],[317,17,322,42,0],[323,13,323,14,0],[325,13,325,45,1],[326,9,326,10,1],[329,9,329,10,1],[330,13,330,115,1],[331,13,331,35,1],[332,9,332,10,1],[335,9,335,10,1],[336,13,336,155,1],[337,13,337,36,1],[338,9,338,10,1],[341,9,341,10,0],[342,13,342,94,0],[343,13,343,39,0],[344,9,344,10,0],[356,9,356,10,1],[357,13,357,48,1],[358,17,358,24,0],[360,13,360,46,1],[361,13,361,14,1],[362,17,362,132,1],[363,17,363,46,1],[364,13,364,14,1],[366,13,366,14,0],[367,17,367,182,0],[368,13,368,14,0],[369,9,369,10,1],[380,9,380,10,1],[382,13,382,73,1],[383,13,383,89,1],[384,13,384,61,1],[385,13,385,49,1],[386,13,386,61,1],[388,13,388,166,1],[391,13,391,20,1],[391,22,391,27,0],[391,28,391,30,1],[391,31,391,38,1],[392,13,392,14,0],[393,17,397,24,0],[399,13,399,14,0],[401,13,401,42,1],[402,9,402,10,1],[408,9,408,10,1],[409,13,409,56,1],[410,17,410,24,0],[412,13,412,31,1],[414,13,414,118,1],[415,13,415,45,1],[416,13,416,31,1],[419,13,419,14,1],[420,17,420,30,1],[423,25,423,50,1],[424,25,424,101,1],[425,25,425,26,1],[426,29,426,78,1],[427,25,427,26,1],[429,25,429,101,1],[430,25,430,26,1],[433,29,434,120,1],[436,29,436,50,1],[437,29,437,68,1],[439,29,440,39,1],[440,39,440,89,1],[440,89,442,33,1],[442,33,442,34,1],[442,34,446,37,1],[446,37,446,134,1],[446,134,447,37,1],[447,37,447,71,1],[447,71,451,37,1],[451,37,451,73,1],[451,73,453,37,1],[453,37,453,44,1],[453,44,453,46,1],[453,46,453,53,0],[453,53,453,54,1],[453,54,453,56,1],[453,56,453,57,1],[453,57,453,63,1],[453,63,454,37,1],[454,37,454,38,0],[454,38,455,41,1],[455,41,455,80,0],[455,80,458,41,1],[458,41,458,97,0],[458,97,459,45,1],[459,45,459,54,0],[459,54,461,41,1],[461,41,461,95,0],[461,95,463,41,1],[463,41,463,62,0],[463,62,463,63,1],[463,63,463,72,0],[463,72,466,41,1],[466,41,466,113,0],[466,113,467,41,1],[467,41,467,42,0],[467,42,468,45,1],[468,45,468,87,0],[468,87,469,45,1],[469,45,469,64,0],[469,64,470,45,1],[470,45,470,46,0],[470,46,473,49,1],[473,49,473,58,0],[473,58,475,41,1],[475,41,475,42,0],[475,42,477,41,1],[477,41,477,52,0],[477,52,478,41,1],[478,41,478,90,0],[478,90,480,41,1],[480,41,480,59,0],[480,59,481,37,1],[481,37,481,38,0],[481,38,483,37,1],[483,37,483,83,1],[483,83,484,33,1],[484,33,484,34,1],[484,34,485,38,1],[485,38,485,64,1],[485,64,485,66,1],[439,29,485,66,1],[486,25,486,26,1],[488,25,488,26,1],[491,29,491,70,1],[495,29,495,30,1],[499,33,499,63,1],[500,33,500,34,1],[501,37,501,164,1],[502,33,502,34,1],[504,33,504,34,0],[507,37,507,196,0],[508,33,508,34,0],[511,33,511,70,1],[516,33,516,72,1],[517,33,517,34,0],[518,37,518,70,0],[518,70,518,128,0],[518,128,518,130,0],[518,37,518,130,0],[519,33,519,34,0],[521,33,521,34,1],[522,37,522,59,1],[523,33,523,34,1],[525,33,527,42,1],[527,42,527,115,1],[527,115,528,82,1],[525,33,528,82,1],[530,33,530,45,1],[531,29,531,30,1],[531,31,531,67,1],[532,25,532,26,1],[534,25,534,31,1],[536,25,536,48,1],[538,25,538,101,1],[539,25,539,26,1],[540,29,540,76,1],[541,25,541,26,1],[543,25,544,35,1],[544,35,544,83,1],[544,83,546,29,1],[546,29,546,30,1],[546,30,548,33,1],[548,33,548,126,1],[548,126,549,33,1],[549,33,549,67,1],[549,67,550,33,1],[550,33,550,67,1],[550,67,551,29,1],[551,29,551,30,1],[551,30,552,34,1],[552,34,552,58,1],[552,58,552,60,1],[543,25,552,60,1],[554,25,554,31,1],[556,13,556,14,1],[558,13,558,14,1],[559,17,559,34,1],[560,13,560,14,1],[562,13,562,159,1],[563,9,563,10,1],[581,9,581,10,1],[582,13,582,31,1],[584,13,584,50,1],[585,13,585,56,1],[585,56,585,60,1],[585,60,585,67,1],[585,67,585,73,1],[585,73,585,75,1],[585,13,585,75,1],[586,13,586,71,1],[590,13,590,14,1],[593,17,593,36,1],[594,17,594,18,1],[595,21,595,87,1],[596,21,596,53,1],[597,21,597,48,1],[598,17,598,18,1],[599,22,599,41,1],[600,17,600,18,1],[601,21,601,49,1],[602,21,602,34,1],[603,17,603,18,1],[605,17,605,18,0],[606,21,606,94,0],[607,21,607,53,0],[608,21,608,48,0],[609,17,609,18,0],[613,17,613,56,1],[614,17,614,18,0],[615,21,615,70,0],[615,70,615,116,0],[615,116,615,130,0],[615,130,615,134,0],[615,134,615,136,0],[615,21,615,136,0],[616,21,616,56,0],[616,56,616,120,0],[616,120,616,132,0],[616,21,616,132,0],[617,17,617,18,0],[619,17,619,24,1],[619,26,619,37,1],[619,38,619,40,1],[619,41,619,50,1],[620,17,620,18,1],[621,21,621,59,1],[622,21,622,22,1],[623,25,623,109,1],[624,21,624,22,1],[625,17,625,18,1],[627,17,627,50,1],[628,17,628,29,1],[629,13,629,14,1],[629,15,629,28,1],[630,9,630,10,1],[674,9,674,10,1],[675,13,675,137,1],[676,13,676,51,1],[677,9,677,10,1],[680,9,680,10,1],[681,13,681,71,1],[682,13,682,33,1],[683,9,683,10,1],[690,9,690,10,0],[694,13,694,88,0],[695,13,695,42,0],[696,9,696,10,0],[705,9,705,10,1],[710,13,710,20,1],[710,22,710,31,1],[710,32,710,34,1],[710,35,710,57,1],[711,13,711,14,1],[713,17,713,68,1],[714,17,714,18,1],[716,21,716,58,1],[717,21,717,22,0],[719,25,719,74,0],[721,25,721,95,0],[722,21,722,22,0],[723,17,723,18,1],[724,13,724,14,1],[726,13,726,41,1],[729,13,729,55,1],[730,13,730,59,1],[731,17,731,56,1],[734,13,734,141,1],[735,13,735,63,1],[736,17,736,69,1],[739,13,739,57,1],[740,13,740,54,1],[741,17,741,51,1],[742,9,742,10,1],[751,9,751,10,1],[752,13,752,75,1],[754,13,754,194,1],[755,9,755,10,1],[763,9,763,10,1],[764,13,764,77,1],[767,13,767,86,1],[770,13,770,94,1],[773,13,773,83,1],[774,13,774,14,1],[775,17,775,80,1],[776,13,776,14,1],[778,13,778,27,1],[779,9,779,10,1],[790,9,790,10,0],[791,13,791,33,0],[792,13,792,14,0],[793,17,793,82,0],[796,13,796,14,0],[797,17,797,54,0],[799,9,799,10,0],[807,9,807,10,1],[809,13,809,68,1],[810,13,810,14,1],[811,17,811,38,1],[813,13,813,45,1],[814,9,814,10,1],[822,9,822,10,1],[825,13,826,53,1],[827,13,827,14,1],[829,17,829,68,1],[831,17,831,98,1],[832,17,832,18,0],[833,21,833,34,0],[835,13,835,14,1],[836,13,836,48,1],[837,9,837,10,1]]);
    </script>
  </body>
</html>