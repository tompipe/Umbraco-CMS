<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Tests\Logging\ParallelForwarderTest.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Diagnostics;
using System.Security.Principal;
using System.Threading;
using log4net;
using log4net.Appender;
using log4net.Config;
using log4net.Core;
using log4net.Filter;
using log4net.Repository;
using Moq;
using NUnit.Framework;
using Umbraco.Core.Logging;

namespace Umbraco.Tests.Logging
{
    /// &lt;summary&gt;
    /// Borrowed from https://github.com/cjbhaines/Log4Net.Async - will reference Nuget packages directly in v8
    /// &lt;/summary&gt;
    [TestFixture]
    public class ParallelForwarderTest : IDisposable
    {
        private ParallelForwardingAppender asyncForwardingAppender;
        private DebugAppender debugAppender;
        private ILoggerRepository repository;
        private ILog log;

        [SetUp]
        public void TestFixtureSetUp()
        {
            debugAppender = new DebugAppender();
            debugAppender.ActivateOptions();

            asyncForwardingAppender = new ParallelForwardingAppender();
            asyncForwardingAppender.AddAppender(debugAppender);
            asyncForwardingAppender.ActivateOptions();

            repository = LogManager.CreateRepository(Guid.NewGuid().ToString());
            BasicConfigurator.Configure(repository, asyncForwardingAppender);

            log = LogManager.GetLogger(repository.Name, &quot;TestLogger&quot;);
        }

        [TearDown]
        public void TearDown()
        {
            LogManager.Shutdown();
        }

        [Test]
        public void CanHandleNullLoggingEvent()
        {
            // Arrange

            // Act
            asyncForwardingAppender.DoAppend((LoggingEvent)null);
            log.Info(&quot;SusequentMessage&quot;);
            asyncForwardingAppender.Close();

            // Assert - should not have had an exception from previous call
            Assert.That(debugAppender.LoggedEventCount, Is.EqualTo(1), &quot;Expected subsequent message only&quot;);
            Assert.That(debugAppender.GetEvents()[0].MessageObject, Is.EqualTo(&quot;SusequentMessage&quot;));
        }

        [Test]
        public void CanHandleNullLoggingEvents()
        {
            // Arrange

            // Act
            asyncForwardingAppender.DoAppend((LoggingEvent[])null);
            log.Info(&quot;SusequentMessage&quot;);
            asyncForwardingAppender.Close();

            // Assert - should not have had an exception from previous call
            Assert.That(debugAppender.LoggedEventCount, Is.EqualTo(1), &quot;Expected subsequent message only&quot;);
            Assert.That(debugAppender.GetEvents()[0].MessageObject, Is.EqualTo(&quot;SusequentMessage&quot;));
        }

        [Test]
        public void CanHandleAppenderThrowing()
        {
            // Arrange
            var badAppender = new Mock&lt;IAppender&gt;();
            asyncForwardingAppender.AddAppender(badAppender.Object);

            badAppender
                .Setup(ba =&gt; ba.DoAppend(It.IsAny&lt;LoggingEvent&gt;()))
                .Throws(new Exception(&quot;Bad Appender&quot;));
                //.Verifiable();

            // Act
            log.Info(&quot;InitialMessage&quot;);
            log.Info(&quot;SusequentMessage&quot;);
            asyncForwardingAppender.Close();

            // Assert
            Assert.That(debugAppender.LoggedEventCount, Is.EqualTo(2));
            Assert.That(debugAppender.GetEvents()[1].MessageObject, Is.EqualTo(&quot;SusequentMessage&quot;));
            badAppender.Verify(appender =&gt; appender.DoAppend(It.IsAny&lt;LoggingEvent&gt;()), Times.Exactly(2));
        }

        [Test]
        public void WillLogFastWhenThereIsASlowAppender()
        {
            const int testSize = 1000;

            // Arrange
            debugAppender.AppendDelay = TimeSpan.FromSeconds(30);
            var watch = new Stopwatch();

            // Act
            watch.Start();
            for (int i = 0; i &lt; testSize; i++)
            {
                log.Error(&quot;Exception&quot;);
            }
            watch.Stop();

            // Assert
            Assert.That(debugAppender.LoggedEventCount, Is.EqualTo(0));
            Assert.That(watch.ElapsedMilliseconds, Is.LessThan(testSize));
            Debug.Print(&quot;Logged {0} errors in {1}ms&quot;, testSize, watch.ElapsedMilliseconds);
        }

        [Test]
        public void WillNotOverflow()
        {
            const int testSize = 1000;

            // Arrange
            debugAppender.AppendDelay = TimeSpan.FromMilliseconds(1);
            asyncForwardingAppender.BufferSize = 100;

            // Act
            for (int i = 0; i &lt; testSize; i++)
            {
                log.Error(&quot;Exception&quot;);
            }

            while (asyncForwardingAppender.BufferEntryCount &gt; 0) ;
            asyncForwardingAppender.Close();

            // Assert
            Assert.That(debugAppender.LoggedEventCount, Is.EqualTo(testSize));
        }

        [Test]
        public void WillTryToFlushBufferOnShutdown()
        {
            const int testSize = 250;

            // Arrange
            debugAppender.AppendDelay = TimeSpan.FromMilliseconds(1);

            // Act
            for (int i = 0; i &lt; testSize; i++)
            {
                log.Error(&quot;Exception&quot;);
            }

            Thread.Sleep(50);

            var numberLoggedBeforeClose = debugAppender.LoggedEventCount;
            asyncForwardingAppender.Close();
            var numberLoggedAfterClose = debugAppender.LoggedEventCount;

            // Assert
            //We can&#39;t use specific numbers here because the timing and counts will be different on different systems.
            Assert.That(numberLoggedBeforeClose, Is.GreaterThan(0), &quot;Some number of Logging events should be logged prior to appender close.&quot;);
            //On some systems, we may not be able to flush all events prior to close, but it is reasonable to assume in this test case
            //that some events should be logged after close.
            Assert.That(numberLoggedAfterClose, Is.GreaterThan(numberLoggedBeforeClose), &quot;Some number of LoggingEvents should be logged after close.&quot;);
            Debug.Print(&quot;Flushed {0} events during shutdown&quot;, numberLoggedAfterClose - numberLoggedBeforeClose);
        }

        [Test, Explicit(&quot;Long-running&quot;)]
        public void WillShutdownIfBufferCannotBeFlushedFastEnough()
        {
            const int testSize = 250;

            // Arrange
            debugAppender.AppendDelay = TimeSpan.FromSeconds(1);
            Stopwatch watch = new Stopwatch();

            // Act
            for (int i = 0; i &lt; testSize; i++)
            {
                log.Error(&quot;Exception&quot;);
            }

            Thread.Sleep(TimeSpan.FromSeconds(2));
            var numberLoggedBeforeClose = debugAppender.LoggedEventCount;

            watch.Start();
            asyncForwardingAppender.Close();
            watch.Stop();

            var numberLoggedAfterClose = debugAppender.LoggedEventCount;

            // Assert
            Assert.That(numberLoggedBeforeClose, Is.GreaterThan(0));
            Assert.That(numberLoggedAfterClose, Is.GreaterThan(numberLoggedBeforeClose));
            Assert.That(numberLoggedAfterClose, Is.LessThan(testSize));
            //We can&#39;t assume what the shutdown time will be.  It will vary from system to system. Don&#39;t test shutdown time.            
            var events = debugAppender.GetEvents();
            var evnt = events[events.Length - 1];
            Assert.That(evnt.MessageObject, Is.EqualTo(&quot;The buffer was not able to be flushed before timeout occurred.&quot;));
            Debug.Print(&quot;Flushed {0} events during shutdown which lasted {1}ms&quot;, numberLoggedAfterClose - numberLoggedBeforeClose, watch.ElapsedMilliseconds);
        }

        [Test]
        public void ThreadContextPropertiesArePreserved()
        {
            // Arrange
            ThreadContext.Properties[&quot;TestProperty&quot;] = &quot;My Value&quot;;
            Assert.That(asyncForwardingAppender.Fix &amp; FixFlags.Properties, Is.EqualTo(FixFlags.Properties), &quot;Properties must be fixed if they are to be preserved&quot;);

            // Act
            log.Info(&quot;Information&quot;);
            asyncForwardingAppender.Close();

            // Assert
            var lastLoggedEvent = debugAppender.GetEvents()[0];
            Assert.That(lastLoggedEvent.Properties[&quot;TestProperty&quot;], Is.EqualTo(&quot;My Value&quot;));
        }

        [Test]
        public void MessagesExcludedByFilterShouldNotBeAppended()
        {
            // Arrange
            var levelFilter =
                new LevelRangeFilter
                {
                    LevelMin = Level.Warn,
                    LevelMax = Level.Error,
                };

            asyncForwardingAppender.AddFilter(levelFilter);

            // Act
            log.Info(&quot;Info&quot;);
            log.Warn(&quot;Warn&quot;);
            log.Error(&quot;Error&quot;);
            log.Fatal(&quot;Fatal&quot;);

            asyncForwardingAppender.Close();

            //Assert
            Assert.That(debugAppender.LoggedEventCount, Is.EqualTo(2));
        }

        [Test]
        public void HelperCanGenerateLoggingEventWithAllProperties()
        {
            // Arrange
            var helper = new LoggingEventHelper(&quot;TestLoggerName&quot;, FixFlags.All);
            ThreadContext.Properties[&quot;MyProperty&quot;] = &quot;MyValue&quot;;
            var exception = new Exception(&quot;SomeError&quot;);

            var stackFrame = new StackFrame(0);
            var currentUser = WindowsIdentity.GetCurrent();
            var loggingTime = DateTime.Now; // Log4Net does not seem to be using UtcNow

            // Act
            var loggingEvent = helper.CreateLoggingEvent(Level.Emergency, &quot;Who&#39;s on live support?&quot;, exception);
            Thread.Sleep(50); // to make sure the time stamp is actually captured

            // Assert
            Assert.That(loggingEvent.Domain, Is.EqualTo(AppDomain.CurrentDomain.FriendlyName), &quot;Domain&quot;);
            //The identity assigned to new threads is dependent upon AppDomain principal policy.
            //Background information here:http://www.neovolve.com/post/2010/10/21/Unit-testing-a-workflow-that-relies-on-ThreadCurrentPrincipalIdentityName.aspx
            //VS2013 does have a principal assigned to new threads in the unit test.
            //It&#39;s probably best not to test that the identity has been set.
            //Assert.That(loggingEvent.Identity, Is.Empty, &quot;Identity: always empty for some reason&quot;);
            Assert.That(loggingEvent.UserName, Is.EqualTo(currentUser == null ? String.Empty : currentUser.Name), &quot;UserName&quot;);
            Assert.That(loggingEvent.ThreadName, Is.EqualTo(Thread.CurrentThread.Name), &quot;ThreadName&quot;);

            Assert.That(loggingEvent.Repository, Is.Null, &quot;Repository: Helper does not have access to this&quot;);
            Assert.That(loggingEvent.LoggerName, Is.EqualTo(&quot;TestLoggerName&quot;), &quot;LoggerName&quot;);

            Assert.That(loggingEvent.Level, Is.EqualTo(Level.Emergency), &quot;Level&quot;);
            //Raised time to within 10 ms.   However, this may not be a valid test.  The time is going to vary from system to system.  The
            //tolerance setting here is arbitrary.
            Assert.That(loggingEvent.TimeStamp, Is.EqualTo(loggingTime).Within(TimeSpan.FromMilliseconds(10)), &quot;TimeStamp&quot;);
            Assert.That(loggingEvent.ExceptionObject, Is.EqualTo(exception), &quot;ExceptionObject&quot;);
            Assert.That(loggingEvent.MessageObject, Is.EqualTo(&quot;Who&#39;s on live support?&quot;), &quot;MessageObject&quot;);

            Assert.That(loggingEvent.LocationInformation.MethodName, Is.EqualTo(stackFrame.GetMethod().Name), &quot;LocationInformation&quot;);
            Assert.That(loggingEvent.Properties[&quot;MyProperty&quot;], Is.EqualTo(&quot;MyValue&quot;), &quot;Properties&quot;);
        }

        private bool _disposed = false;

        //Implement IDisposable.
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    if (asyncForwardingAppender != null)
                    {
                        asyncForwardingAppender.Dispose();
                        asyncForwardingAppender = null;
                    }
                }
                // Free your own state (unmanaged objects).
                // Set large fields to null.
                _disposed = true;
            }
        }

        // Use C# destructor syntax for finalization code.
        ~ParallelForwarderTest()
        {
            // Simply call Dispose(false).
            Dispose(false);
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[30,9,30,10,1],[31,13,31,49,1],[32,13,32,45,1],[34,13,34,72,1],[35,13,35,64,1],[36,13,36,55,1],[38,13,38,81,1],[39,13,39,78,1],[41,13,41,71,1],[42,9,42,10,1],[46,9,46,10,1],[47,13,47,35,1],[48,9,48,10,1],[52,9,52,10,1],[56,13,56,66,1],[57,13,57,42,1],[58,13,58,45,1],[61,13,61,108,1],[62,13,62,101,1],[63,9,63,10,1],[67,9,67,10,1],[71,13,71,68,1],[72,13,72,42,1],[73,13,73,45,1],[76,13,76,108,1],[77,13,77,101,1],[78,9,78,10,1],[82,9,82,10,1],[84,13,84,53,1],[85,13,85,69,1],[87,13,89,56,1],[93,13,93,40,1],[94,13,94,42,1],[95,13,95,45,1],[98,13,98,72,1],[99,13,99,101,1],[100,13,100,107,1],[101,9,101,10,1],[105,9,105,10,1],[109,13,109,66,1],[110,13,110,41,1],[113,13,113,27,1],[114,18,114,27,1],[114,29,114,41,1],[114,43,114,46,1],[115,13,115,14,1],[116,17,116,40,1],[117,13,117,14,1],[118,13,118,26,1],[121,13,121,72,1],[122,13,122,75,1],[123,13,123,92,1],[124,9,124,10,1],[128,9,128,10,1],[132,13,132,70,1],[133,13,133,54,1],[136,18,136,27,1],[136,29,136,41,1],[136,43,136,46,1],[137,13,137,14,1],[138,17,138,40,1],[139,13,139,14,1],[141,13,141,65,1],[141,66,141,67,1],[142,13,142,45,1],[145,13,145,79,1],[146,9,146,10,1],[150,9,150,10,1],[154,13,154,70,1],[157,18,157,27,1],[157,29,157,41,1],[157,43,157,46,1],[158,13,158,14,1],[159,17,159,40,1],[160,13,160,14,1],[162,13,162,30,1],[164,13,164,74,1],[165,13,165,45,1],[166,13,166,73,1],[170,13,170,144,1],[173,13,173,152,1],[174,13,174,113,1],[175,9,175,10,1],[179,9,179,10,0],[183,13,183,65,0],[184,13,184,47,0],[187,18,187,27,0],[187,29,187,41,0],[187,43,187,46,0],[188,13,188,14,0],[189,17,189,40,0],[190,13,190,14,0],[192,13,192,51,0],[193,13,193,74,0],[195,13,195,27,0],[196,13,196,45,0],[197,13,197,26,0],[199,13,199,73,0],[202,13,202,69,0],[203,13,203,90,0],[204,13,204,72,0],[206,13,206,52,0],[207,13,207,50,0],[208,13,208,123,0],[209,13,209,159,0],[210,9,210,10,0],[214,9,214,10,1],[216,13,216,67,1],[217,13,217,165,1],[220,13,220,37,1],[221,13,221,45,1],[224,13,224,64,1],[225,13,225,93,1],[226,9,226,10,1],[230,9,230,10,1],[232,13,237,19,1],[239,13,239,60,1],[242,13,242,30,1],[243,13,243,30,1],[244,13,244,32,1],[245,13,245,32,1],[247,13,247,45,1],[250,13,250,72,1],[251,9,251,10,1],[255,9,255,10,1],[257,13,257,81,1],[258,13,258,64,1],[259,13,259,56,1],[261,13,261,48,1],[262,13,262,60,1],[263,13,263,44,1],[266,13,266,112,1],[267,13,267,30,1],[270,13,270,106,1],[276,13,276,127,1],[277,13,277,103,1],[279,13,279,110,1],[280,13,280,94,1],[282,13,282,83,1],[285,13,285,125,1],[286,13,286,97,1],[287,13,287,108,1],[289,13,289,134,1],[290,13,290,101,1],[291,9,291,10,1],[293,9,293,40,1],[297,9,297,10,1],[298,13,298,27,1],[299,13,299,39,1],[300,9,300,10,1],[303,9,303,10,1],[304,13,304,28,1],[305,13,305,14,1],[306,17,306,31,1],[307,17,307,18,1],[308,21,308,57,1],[309,21,309,22,1],[310,25,310,59,1],[311,25,311,56,1],[312,21,312,22,1],[313,17,313,18,1],[316,17,316,34,1],[317,13,317,14,1],[318,9,318,10,1],[322,9,322,10,0],[322,9,322,10,0],[324,13,324,28,0],[325,9,325,10,0],[325,9,325,10,0]]);
    </script>
  </body>
</html>