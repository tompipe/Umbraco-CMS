<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Models\PropertyTypeCollection.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Linq;
using System.Runtime.Serialization;
using System.Threading;
using Umbraco.Core.Models.EntityBase;

namespace Umbraco.Core.Models
{
    /// &lt;summary&gt;
    /// Represents a collection of &lt;see cref=&quot;PropertyType&quot;/&gt; objects
    /// &lt;/summary&gt;
    [Serializable]
    [DataContract]
    public class PropertyTypeCollection : KeyedCollection&lt;string, PropertyType&gt;, INotifyCollectionChanged, IDeepCloneable
    {
        [IgnoreDataMember]
        private readonly ReaderWriterLockSlim _addLocker = new ReaderWriterLockSlim();

        [IgnoreDataMember]
        internal Action OnAdd;

        internal PropertyTypeCollection()
        {
            
        }

        public PropertyTypeCollection(IEnumerable&lt;PropertyType&gt; properties)
        {
            Reset(properties);
        }

        /// &lt;summary&gt;
        /// Resets the collection to only contain the &lt;see cref=&quot;PropertyType&quot;/&gt; instances referenced in the &lt;paramref name=&quot;properties&quot;/&gt; parameter.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;properties&quot;&gt;The properties.&lt;/param&gt;
        /// &lt;remarks&gt;&lt;/remarks&gt;
        internal void Reset(IEnumerable&lt;PropertyType&gt; properties)
        {
            Clear();
            properties.ForEach(Add);
            OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
        }

        protected override void SetItem(int index, PropertyType item)
        {
            base.SetItem(index, item);
            OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, item, index));
        }

        protected override void RemoveItem(int index)
        {
            var removed = this[index];
            base.RemoveItem(index);
            OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, removed));
        }

        protected override void InsertItem(int index, PropertyType item)
        {
            base.InsertItem(index, item);
            OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, item));
        }

        protected override void ClearItems()
        {
            base.ClearItems();
            OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
        }

        //TODO: Instead of &#39;new&#39; this should explicitly implement one of the collection interfaces members
        internal new void Add(PropertyType item)
        {
            using (new WriteLock(_addLocker))
            {
                var key = GetKeyForItem(item);
                if (key != null)
                {
                    var exists = this.Contains(key);
                    if (exists)
                    {
                        SetItem(IndexOfKey(key), item);
                        return;
                    }
                }

                //check if the item&#39;s sort order is already in use				
                if (this.Any(x =&gt; x.SortOrder == item.SortOrder))
                {
                    //make it the next iteration
                    item.SortOrder = this.Max(x =&gt; x.SortOrder) + 1;
                }

                base.Add(item);
                OnAdd.IfNotNull(x =&gt; x.Invoke());//Could this not be replaced by a Mandate/Contract for ensuring item is not null

                OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, item));
            }
        }

        /// &lt;summary&gt;
        /// Determines whether this collection contains a &lt;see cref=&quot;Property&quot;/&gt; whose alias matches the specified PropertyType.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyAlias&quot;&gt;Alias of the PropertyType.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the collection contains the specified alias; otherwise, &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;&lt;/remarks&gt;
        public new bool Contains(string propertyAlias)
        {
            return this.Any(x =&gt; x.Alias == propertyAlias);
        }

        public void RemoveItem(string propertyTypeAlias)
        {
            var key = IndexOfKey(propertyTypeAlias);
            //Only removes an item if the key was found
            if(key != -1)
                RemoveItem(key);
        }

        public int IndexOfKey(string key)
        {
            for (var i = 0; i &lt; this.Count; i++)
            {
                if (this[i].Alias == key)
                {
                    return i;
                }
            }
            return -1;
        }

        protected override string GetKeyForItem(PropertyType item)
        {
            return item.Alias;
        }

        public event NotifyCollectionChangedEventHandler CollectionChanged;

        protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs args)
        {
            if (CollectionChanged != null)
            {
                CollectionChanged(this, args);
            }
        }

        public object DeepClone()
        {
            var newGroup = new PropertyTypeCollection();
            foreach (var p in this)
            {
                newGroup.Add((PropertyType)p.DeepClone());
            }
            return newGroup;
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[20,9,20,87,1],[20,9,20,87,1],[25,9,25,42,1],[26,9,26,10,1],[28,9,28,10,1],[30,9,30,76,1],[31,9,31,10,1],[32,13,32,31,1],[33,9,33,10,1],[41,9,41,10,1],[42,13,42,21,1],[43,13,43,37,1],[44,13,44,108,1],[45,9,45,10,1],[48,9,48,10,0],[49,13,49,39,0],[50,13,50,119,0],[51,9,51,10,0],[54,9,54,10,1],[55,13,55,39,1],[56,13,56,36,1],[57,13,57,118,1],[58,9,58,10,1],[61,9,61,10,1],[62,13,62,42,1],[63,13,63,112,1],[64,9,64,10,1],[67,9,67,10,1],[68,13,68,31,1],[69,13,69,108,1],[70,9,70,10,1],[74,9,74,10,1],[75,13,75,46,1],[76,13,76,14,1],[77,17,77,47,1],[78,17,78,33,1],[79,17,79,18,1],[80,21,80,53,1],[81,21,81,32,1],[82,21,82,22,0],[83,25,83,56,0],[84,25,84,32,0],[86,17,86,18,1],[89,17,89,35,1],[89,35,89,64,1],[89,64,89,66,1],[89,17,89,66,1],[90,17,90,18,1],[92,21,92,52,1],[92,52,92,63,1],[92,63,92,69,1],[92,21,92,69,1],[93,17,93,18,1],[95,17,95,32,1],[96,17,96,38,1],[96,38,96,48,0],[96,48,96,50,1],[96,17,96,50,1],[98,17,98,116,1],[99,13,99,14,1],[100,9,100,10,1],[109,9,109,10,1],[110,13,110,34,1],[110,34,110,58,1],[110,58,110,60,1],[110,13,110,60,1],[111,9,111,10,1],[114,9,114,10,1],[115,13,115,53,1],[117,13,117,26,1],[118,17,118,33,1],[119,9,119,10,1],[122,9,122,10,1],[123,18,123,27,1],[123,29,123,43,1],[123,45,123,48,1],[124,13,124,14,1],[125,17,125,42,1],[126,17,126,18,1],[127,21,127,30,1],[129,13,129,14,1],[130,13,130,23,1],[131,9,131,10,1],[134,9,134,10,1],[135,13,135,31,1],[136,9,136,10,1],[141,9,141,10,1],[142,13,142,43,1],[143,13,143,14,1],[144,17,144,47,1],[145,13,145,14,1],[146,9,146,10,1],[149,9,149,10,1],[150,13,150,57,1],[151,13,151,20,1],[151,22,151,27,1],[151,28,151,30,1],[151,31,151,35,1],[152,13,152,14,1],[153,17,153,59,1],[154,13,154,14,1],[155,13,155,29,1],[156,9,156,10,1]]);
    </script>
  </body>
</html>