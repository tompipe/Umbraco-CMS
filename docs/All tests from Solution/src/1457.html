<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Sync\WebServiceServerMessenger.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Threading;
using Newtonsoft.Json;
using Umbraco.Core.Configuration;
using Umbraco.Core.Logging;
using umbraco.interfaces;

namespace Umbraco.Core.Sync
{
    /// &lt;summary&gt;
    /// An &lt;see cref=&quot;IServerMessenger&quot;/&gt; that works by messaging servers via web services.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// this messenger sends ALL instructions to ALL servers, including the local server.
    /// the CacheRefresher web service will run ALL instructions, so there may be duplicated,
    /// except for &quot;bulk&quot; refresh, where it excludes those coming from the local server
    /// &lt;/remarks&gt;        
    //
    // TODO see Message() method: stop sending to local server!
    // just need to figure out WebServerUtility permissions issues, if any
    //
    internal class WebServiceServerMessenger : ServerMessengerBase
    {
        private readonly Func&lt;Tuple&lt;string, string&gt;&gt; _getLoginAndPassword;
        private volatile bool _hasLoginAndPassword;
        private readonly object _locker = new object();

        protected string Login { get; private set; }
        protected string Password{ get; private set; }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;WebServiceServerMessenger&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Distribution is disabled.&lt;/remarks&gt;
        internal WebServiceServerMessenger()
            : base(false)
        { }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;WebServiceServerMessenger&quot;/&gt; class with a login and a password.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;login&quot;&gt;The login.&lt;/param&gt;
        /// &lt;param name=&quot;password&quot;&gt;The password.&lt;/param&gt;
        /// &lt;remarks&gt;Distribution will be enabled based on the umbraco config setting.&lt;/remarks&gt;
        internal WebServiceServerMessenger(string login, string password)
            : this(login, password, UmbracoConfig.For.UmbracoSettings().DistributedCall.Enabled)
        {            
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;WebServiceServerMessenger&quot;/&gt; class with a login and a password
        /// and a value indicating whether distribution is enabled.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;login&quot;&gt;The login.&lt;/param&gt;
        /// &lt;param name=&quot;password&quot;&gt;The password.&lt;/param&gt;
        /// &lt;param name=&quot;distributedEnabled&quot;&gt;A value indicating whether distribution is enabled.&lt;/param&gt;
        internal WebServiceServerMessenger(string login, string password, bool distributedEnabled)
            : base(distributedEnabled)
        {
            if (login == null) throw new ArgumentNullException(&quot;login&quot;);
            if (password == null) throw new ArgumentNullException(&quot;password&quot;);

            Login = login;
            Password = password;
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;WebServiceServerMessenger&quot;/&gt; with a function providing
        /// a login and a password.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;getLoginAndPassword&quot;&gt;A function providing a login and a password.&lt;/param&gt;
        /// &lt;remarks&gt;Distribution will be enabled based on the umbraco config setting.&lt;/remarks&gt;
        public WebServiceServerMessenger(Func&lt;Tuple&lt;string, string&gt;&gt; getLoginAndPassword)
            : base(false) // value will be overriden by EnsureUserAndPassword
        {
            _getLoginAndPassword = getLoginAndPassword;
        }

        // lazy-get the login, password, and distributed setting
        protected void EnsureLoginAndPassword()
        {
            if (_hasLoginAndPassword || _getLoginAndPassword == null) return;

            lock (_locker)
            {
                if (_hasLoginAndPassword) return;
                _hasLoginAndPassword = true;

                try
                {
                    var result = _getLoginAndPassword();
                    if (result == null)
                    {
                        Login = null;
                        Password = null;
                        DistributedEnabled = false;
                    }
                    else
                    {
                        Login = result.Item1;
                        Password = result.Item2;
                        DistributedEnabled = UmbracoConfig.For.UmbracoSettings().DistributedCall.Enabled;    
                    }
                }
                catch (Exception ex)
                {
                    LogHelper.Error&lt;WebServiceServerMessenger&gt;(&quot;Could not resolve username/password delegate, server distribution will be disabled&quot;, ex);
                    Login = null;
                    Password = null;
                    DistributedEnabled = false;
                }
            }
        }

        // this exists only for legacy reasons - we should just pass the server identity un-hashed
        public static string GetCurrentServerHash()
        {
            if (SystemUtilities.GetCurrentTrustLevel() != System.Web.AspNetHostingPermissionLevel.Unrestricted)
                throw new NotSupportedException(&quot;FullTrust ASP.NET permission level is required.&quot;);
            return GetServerHash(NetworkHelper.MachineName, System.Web.HttpRuntime.AppDomainAppId);
        }

        public static string GetServerHash(string machineName, string appDomainAppId)
        {
            var hasher = new HashCodeCombiner();
            hasher.AddCaseInsensitiveString(appDomainAppId);
            hasher.AddCaseInsensitiveString(machineName);
            return hasher.GetCombinedHashCode();
        }

        protected override bool RequiresDistributed(IEnumerable&lt;IServerAddress&gt; servers, ICacheRefresher refresher, MessageType messageType)
        {
            EnsureLoginAndPassword();
            return base.RequiresDistributed(servers, refresher, messageType);
        }

        protected override void DeliverRemote(IEnumerable&lt;IServerAddress&gt; servers, ICacheRefresher refresher, MessageType messageType, IEnumerable&lt;object&gt; ids = null, string json = null)
        {
            var idsA = ids == null ? null : ids.ToArray();

            Type arrayType;
            if (GetArrayType(idsA, out arrayType) == false)
                throw new ArgumentException(&quot;All items must be of the same type, either int or Guid.&quot;, &quot;ids&quot;);

            Message(servers, refresher, messageType, idsA, arrayType, json);
        }

        protected virtual void Message(
            IEnumerable&lt;IServerAddress&gt; servers,
            ICacheRefresher refresher,
            MessageType messageType, 
            IEnumerable&lt;object&gt; ids = null,
            Type idArrayType = null,
            string jsonPayload = null)
        {
            LogHelper.Debug&lt;WebServiceServerMessenger&gt;(
                &quot;Performing distributed call for {0}/{1} on servers ({2}), ids: {3}, json: {4}&quot;,
                refresher.GetType,
                () =&gt; messageType,
                () =&gt; string.Join(&quot;;&quot;, servers.Select(x =&gt; x.ToString())),
                () =&gt; ids == null ? &quot;&quot; : string.Join(&quot;;&quot;, ids.Select(x =&gt; x.ToString())),
                () =&gt; jsonPayload ?? &quot;&quot;);

            try
            {
                // NOTE: we are messaging ALL servers including the local server
                // at the moment, the web service,
                //  for bulk (batched) checks the origin and does NOT process the instructions again
                //  for anything else, processes the instructions again (but we don&#39;t use this anymore, batched is the default)
                // TODO: see WebServerHelper, could remove local server from the list of servers

                // the default server messenger uses http requests
                using (var client = new ServerSyncWebServiceClient())
                {
                    var asyncResults = new List&lt;IAsyncResult&gt;();

                    LogStartDispatch();

                    // go through each configured node submitting a request asynchronously
                    // NOTE: &#39;asynchronously&#39; in this case does not mean that it will continue while we give the page back to the user!
                    foreach (var n in servers)
                    {
                        // set the server address
                        client.Url = n.ServerAddress;

                        // add the returned WaitHandle to the list for later checking
                        switch (messageType)
                        {
                            case MessageType.RefreshByJson:
                                asyncResults.Add(client.BeginRefreshByJson(refresher.UniqueIdentifier, jsonPayload, Login, Password, null, null));
                                break;

                            case MessageType.RefreshAll:
                                asyncResults.Add(client.BeginRefreshAll(refresher.UniqueIdentifier, Login, Password, null, null));
                                break;

                            case MessageType.RefreshById:
                                if (idArrayType == null)
                                    throw new InvalidOperationException(&quot;Cannot refresh by id if the idArrayType is null.&quot;);

                                if (idArrayType == typeof(int))
                                {
                                    // bulk of ints is supported
                                    var json = JsonConvert.SerializeObject(ids.Cast&lt;int&gt;().ToArray());
                                    var result = client.BeginRefreshByIds(refresher.UniqueIdentifier, json, Login, Password, null, null);
                                    asyncResults.Add(result);
                                }
                                else // must be guids
                                {
                                    // bulk of guids is not supported, iterate
                                    asyncResults.AddRange(ids.Select(i =&gt; 
                                        client.BeginRefreshByGuid(refresher.UniqueIdentifier, (Guid)i, Login, Password, null, null)));
                                }

                                break;
                            case MessageType.RemoveById:
                                if (idArrayType == null)
                                    throw new InvalidOperationException(&quot;Cannot remove by id if the idArrayType is null.&quot;);

                                // must be ints
                                asyncResults.AddRange(ids.Select(i =&gt; 
                                    client.BeginRemoveById(refresher.UniqueIdentifier, (int)i, Login, Password, null, null)));
                                break;
                        }
                    }

                    // wait for all requests to complete
                    var waitHandles = asyncResults.Select(x =&gt; x.AsyncWaitHandle);
                    WaitHandle.WaitAll(waitHandles.ToArray());

                    // handle results
                    var errorCount = 0;
                    foreach (var asyncResult in asyncResults)
                    {
                        try
                        {
                            switch (messageType)
                            {
                                case MessageType.RefreshByJson:
                                    client.EndRefreshByJson(asyncResult);
                                    break;

                                case MessageType.RefreshAll:
                                    client.EndRefreshAll(asyncResult);
                                    break;

                                case MessageType.RefreshById:
                                    if (idArrayType == typeof(int))
                                        client.EndRefreshById(asyncResult);
                                    else
                                        client.EndRefreshByGuid(asyncResult);
                                    break;

                                case MessageType.RemoveById:
                                    client.EndRemoveById(asyncResult);
                                    break;
                            }
                        }
                        catch (WebException ex)
                        {
                            LogDispatchNodeError(ex);
                            errorCount++;
                        }
                        catch (Exception ex)
                        {
                            LogDispatchNodeError(ex);
                            errorCount++;
                        }
                    }

                    LogDispatchBatchResult(errorCount);
                }
            }
            catch (Exception ee)
            {
                LogDispatchBatchError(ee);
            }
        }

        protected virtual void Message(IEnumerable&lt;RefreshInstructionEnvelope&gt; envelopes)
        {
            var envelopesA = envelopes.ToArray();
            var servers = envelopesA.SelectMany(x =&gt; x.Servers).Distinct();

            try
            {
                // NOTE: we are messaging ALL servers including the local server
                // at the moment, the web service,
                //  for bulk (batched) checks the origin and does NOT process the instructions again
                //  for anything else, processes the instructions again (but we don&#39;t use this anymore, batched is the default)
                // TODO: see WebServerHelper, could remove local server from the list of servers

                using (var client = new ServerSyncWebServiceClient())
                {
                    var asyncResults = new List&lt;IAsyncResult&gt;();

                    LogStartDispatch();

                    // go through each configured node submitting a request asynchronously
                    // NOTE: &#39;asynchronously&#39; in this case does not mean that it will continue while we give the page back to the user!
                    foreach (var server in servers)
                    {
                        // set the server address
                        client.Url = server.ServerAddress;

                        var serverInstructions = envelopesA
                            .Where(x =&gt; x.Servers.Contains(server))
                            .SelectMany(x =&gt; x.Instructions)
                            .Distinct() // only execute distinct instructions - no sense in running the same one.
                            .ToArray();

                        asyncResults.Add(
                            client.BeginBulkRefresh(
                                serverInstructions,
                                GetCurrentServerHash(),
                                Login, Password, null, null));
                    }

                    // wait for all requests to complete
                    var waitHandles = asyncResults.Select(x =&gt; x.AsyncWaitHandle).ToArray();
                    WaitHandle.WaitAll(waitHandles.ToArray());

                    // handle results
                    var errorCount = 0;
                    foreach (var asyncResult in asyncResults)
                    {
                        try
                        {
                            client.EndBulkRefresh(asyncResult);
                        }
                        catch (WebException ex)
                        {
                            LogDispatchNodeError(ex);
                            errorCount++;
                        }
                        catch (Exception ex)
                        {
                            LogDispatchNodeError(ex);
                            errorCount++;
                        }
                    }
                    LogDispatchBatchResult(errorCount);
                }
            }
            catch (Exception ee)
            {
                LogDispatchBatchError(ee);
            }
        }

        #region Logging

        private static void LogDispatchBatchError(Exception ee)
        {
            LogHelper.Error&lt;WebServiceServerMessenger&gt;(&quot;Error refreshing distributed list&quot;, ee);
        }

        private static void LogDispatchBatchResult(int errorCount)
        {
            LogHelper.Debug&lt;WebServiceServerMessenger&gt;(string.Format(&quot;Distributed server push completed with {0} nodes reporting an error&quot;, errorCount == 0 ? &quot;no&quot; : errorCount.ToString(CultureInfo.InvariantCulture)));
        }

        private static void LogDispatchNodeError(Exception ex)
        {
            LogHelper.Error&lt;WebServiceServerMessenger&gt;(&quot;Error refreshing a node in the distributed list&quot;, ex);
        }

        private static void LogDispatchNodeError(WebException ex)
        {
            string url = (ex.Response != null) ? ex.Response.ResponseUri.ToString() : &quot;invalid url (responseUri null)&quot;;
            LogHelper.Error&lt;WebServiceServerMessenger&gt;(&quot;Error refreshing a node in the distributed list, URI attempted: &quot; + url, ex);
        }
        
        private static void LogStartDispatch()
        {
            LogHelper.Info&lt;WebServiceServerMessenger&gt;(&quot;Submitting calls to distributed servers&quot;);
        }

        #endregion
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[30,9,30,56,0],[30,9,30,56,0],[30,9,30,56,0],[32,34,32,38,0],[32,39,32,51,0],[33,36,33,40,0],[33,41,33,53,0],[40,15,40,26,0],[41,9,41,10,0],[41,11,41,12,0],[50,15,50,97,0],[51,9,51,10,0],[52,9,52,10,0],[62,15,62,39,0],[63,9,63,10,0],[64,13,64,31,0],[64,32,64,73,0],[65,13,65,34,0],[65,35,65,79,0],[67,13,67,27,0],[68,13,68,33,0],[69,9,69,10,0],[78,15,78,26,0],[79,9,79,10,0],[80,13,80,56,0],[81,9,81,10,0],[85,9,85,10,0],[86,13,86,70,0],[86,71,86,78,0],[88,13,88,27,0],[89,13,89,14,0],[90,17,90,42,0],[90,43,90,50,0],[91,17,91,45,0],[94,17,94,18,0],[95,21,95,57,0],[96,21,96,40,0],[97,21,97,22,0],[98,25,98,38,0],[99,25,99,41,0],[100,25,100,52,0],[101,21,101,22,0],[103,21,103,22,0],[104,25,104,46,0],[105,25,105,49,0],[106,25,106,106,0],[107,21,107,22,0],[108,17,108,18,0],[109,17,109,37,0],[110,17,110,18,0],[111,21,111,154,0],[112,21,112,34,0],[113,21,113,37,0],[114,21,114,48,0],[115,17,115,18,0],[116,13,116,14,0],[117,9,117,10,0],[121,9,121,10,0],[122,13,122,112,0],[123,17,123,100,0],[124,13,124,100,0],[125,9,125,10,0],[128,9,128,10,1],[129,13,129,49,1],[130,13,130,61,1],[131,13,131,58,1],[132,13,132,49,1],[133,9,133,10,1],[136,9,136,10,0],[137,13,137,38,0],[138,13,138,78,0],[139,9,139,10,0],[142,9,142,10,0],[143,13,143,59,0],[146,13,146,60,0],[147,17,147,111,0],[149,13,149,77,0],[150,9,150,10,0],[159,9,159,10,0],[160,13,163,23,0],[163,23,163,34,0],[163,34,164,23,0],[164,23,164,60,0],[164,60,164,72,0],[164,72,164,74,0],[164,23,164,74,0],[164,74,165,23,0],[165,23,165,75,0],[165,75,165,87,0],[165,87,165,89,0],[165,23,165,89,0],[165,89,166,23,0],[166,23,166,40,0],[166,40,166,42,0],[160,13,166,42,0],[169,13,169,14,0],[177,24,177,69,0],[178,17,178,18,0],[179,21,179,65,0],[181,21,181,40,0],[185,21,185,28,0],[185,30,185,35,0],[185,36,185,38,0],[185,39,185,46,0],[186,21,186,22,0],[188,25,188,54,0],[191,25,191,45,0],[194,33,194,147,0],[195,33,195,39,0],[198,33,198,131,0],[199,33,199,39,0],[202,33,202,57,0],[203,37,203,125,0],[205,33,205,64,0],[206,33,206,34,0],[208,37,208,103,0],[209,37,209,138,0],[210,37,210,62,0],[211,33,211,34,0],[213,33,213,34,0],[215,37,216,41,0],[216,41,216,132,0],[216,132,216,135,0],[215,37,216,135,0],[217,33,217,34,0],[219,33,219,39,0],[221,33,221,57,0],[222,37,222,124,0],[225,33,226,37,0],[226,37,226,124,0],[226,124,226,127,0],[225,33,226,127,0],[227,33,227,39,0],[229,21,229,22,0],[232,21,232,64,0],[232,64,232,81,0],[232,81,232,83,0],[232,21,232,83,0],[233,21,233,63,0],[236,21,236,40,0],[237,21,237,28,0],[237,30,237,45,0],[237,46,237,48,0],[237,49,237,61,0],[238,21,238,22,0],[240,25,240,26,0],[241,29,241,49,0],[244,37,244,74,0],[245,37,245,43,0],[248,37,248,71,0],[249,37,249,43,0],[252,37,252,68,0],[253,41,253,76,0],[255,41,255,78,0],[256,37,256,43,0],[259,37,259,71,0],[260,37,260,43,0],[262,25,262,26,0],[263,25,263,48,0],[264,25,264,26,0],[265,29,265,54,0],[266,29,266,42,0],[267,25,267,26,0],[268,25,268,45,0],[269,25,269,26,0],[270,29,270,54,0],[271,29,271,42,0],[272,25,272,26,0],[273,21,273,22,0],[275,21,275,56,0],[276,17,276,18,0],[277,13,277,14,0],[278,13,278,33,0],[279,13,279,14,0],[280,17,280,43,0],[281,13,281,14,0],[282,9,282,10,0],[285,9,285,10,0],[286,13,286,50,0],[287,13,287,54,0],[287,54,287,63,0],[287,63,287,76,0],[287,13,287,76,0],[290,13,290,14,0],[297,24,297,69,0],[298,17,298,18,0],[299,21,299,65,0],[301,21,301,40,0],[305,21,305,28,0],[305,30,305,40,0],[305,41,305,43,0],[305,44,305,51,0],[306,21,306,22,0],[308,25,308,59,0],[310,25,311,41,0],[311,41,311,67,0],[311,67,312,46,0],[312,46,312,60,0],[312,60,314,40,0],[310,25,314,40,0],[316,25,320,63,0],[321,21,321,22,0],[324,21,324,64,0],[324,64,324,81,0],[324,81,324,93,0],[324,21,324,93,0],[325,21,325,63,0],[328,21,328,40,0],[329,21,329,28,0],[329,30,329,45,0],[329,46,329,48,0],[329,49,329,61,0],[330,21,330,22,0],[332,25,332,26,0],[333,29,333,64,0],[334,25,334,26,0],[335,25,335,48,0],[336,25,336,26,0],[337,29,337,54,0],[338,29,338,42,0],[339,25,339,26,0],[340,25,340,45,0],[341,25,341,26,0],[342,29,342,54,0],[343,29,343,42,0],[344,25,344,26,0],[345,21,345,22,0],[346,21,346,56,0],[347,17,347,18,0],[348,13,348,14,0],[349,13,349,33,0],[350,13,350,14,0],[351,17,351,43,0],[352,13,352,14,0],[353,9,353,10,0],[358,9,358,10,0],[359,13,359,97,0],[360,9,360,10,0],[363,9,363,10,0],[364,13,364,218,0],[365,9,365,10,0],[368,9,368,10,0],[369,13,369,111,0],[370,9,370,10,0],[373,9,373,10,0],[374,13,374,120,0],[375,13,375,134,0],[376,9,376,10,0],[379,9,379,10,0],[380,13,380,98,0],[381,9,381,10,0]]);
    </script>
  </body>
</html>