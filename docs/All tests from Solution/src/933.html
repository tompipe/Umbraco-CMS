<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Scheduling\ScheduledTasks.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Net;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Umbraco.Core;
using Umbraco.Core.Configuration.UmbracoSettings;
using Umbraco.Core.Logging;
using Umbraco.Core.Sync;

namespace Umbraco.Web.Scheduling
{
    //TODO: No scheduled task (i.e. URL) would be secured, so if people are actually using these each task
    // would need to be a publicly available task (URL) which isn&#39;t really very good :(
    // We should really be using the AdminTokenAuthorizeAttribute for this stuff

    internal class ScheduledTasks : RecurringTaskBase
    {
        private readonly ApplicationContext _appContext;
        private readonly IUmbracoSettingsSection _settings;
        private static readonly Hashtable ScheduledTaskTimes = new Hashtable();

        public ScheduledTasks(IBackgroundTaskRunner&lt;RecurringTaskBase&gt; runner, int delayMilliseconds, int periodMilliseconds, 
            ApplicationContext appContext, IUmbracoSettingsSection settings)
            : base(runner, delayMilliseconds, periodMilliseconds)
        {
            _appContext = appContext;
            _settings = settings;
        }

        private async Task ProcessTasksAsync(CancellationToken token)
        {
            var scheduledTasks = _settings.ScheduledTasks.Tasks;
            foreach (var t in scheduledTasks)
            {
                var runTask = false;
                if (ScheduledTaskTimes.ContainsKey(t.Alias) == false)
                {
                    runTask = true;
                    ScheduledTaskTimes.Add(t.Alias, DateTime.Now);
                }

                // Add 1 second to timespan to compensate for differencies in timer
                else if (
                    new TimeSpan(
                        DateTime.Now.Ticks - ((DateTime)ScheduledTaskTimes[t.Alias]).Ticks).TotalSeconds + 1 &gt;= t.Interval)
                {
                    runTask = true;
                    ScheduledTaskTimes[t.Alias] = DateTime.Now;
                }

                if (runTask)
                {
                    var taskResult = await GetTaskByHttpAync(t.Url, token);
                    if (t.Log)
                        LogHelper.Info&lt;ScheduledTasks&gt;(string.Format(&quot;{0} has been called with response: {1}&quot;, t.Alias, taskResult));
                }
            }
        }

        private async Task&lt;bool&gt; GetTaskByHttpAync(string url, CancellationToken token)
        {
            using (var wc = new HttpClient())
            {
                var request = new HttpRequestMessage(HttpMethod.Get, url);

                //TODO: pass custom the authorization header, currently these aren&#39;t really secured!
                //request.Headers.Authorization = AdminTokenAuthorizeAttribute.GetAuthenticationHeaderValue(_appContext);

                try
                {
                    var result = await wc.SendAsync(request, token).ConfigureAwait(false); // ConfigureAwait(false) is recommended? http://blog.stephencleary.com/2012/07/dont-block-on-async-code.html
                    return result.StatusCode == HttpStatusCode.OK;
                }
                catch (Exception ex)
                {
                    LogHelper.Error&lt;ScheduledTasks&gt;(&quot;An error occurred calling web task for url: &quot; + url, ex);
                }
                return false;
            }
        }

        public override bool PerformRun()
        {
            throw new NotImplementedException();
        }

        public override async Task&lt;bool&gt; PerformRunAsync(CancellationToken token)
        {
            if (_appContext == null) return true; // repeat...

            switch (_appContext.GetCurrentServerRole())
            {
                case ServerRole.Slave:
                    LogHelper.Debug&lt;ScheduledTasks&gt;(&quot;Does not run on slave servers.&quot;);
                    return true; // DO repeat, server role can change
                case ServerRole.Unknown:
                    LogHelper.Debug&lt;ScheduledTasks&gt;(&quot;Does not run on servers with unknown role.&quot;);
                    return true; // DO repeat, server role can change
            }

            // ensure we do not run if not main domain, but do NOT lock it
            if (_appContext.MainDom.IsMainDom == false)
            {
                LogHelper.Debug&lt;ScheduledTasks&gt;(&quot;Does not run if not MainDom.&quot;);
                return false; // do NOT repeat, going down
            }

            using (DisposableTimer.DebugDuration&lt;ScheduledTasks&gt;(() =&gt; &quot;Scheduled tasks executing&quot;, () =&gt; &quot;Scheduled tasks complete&quot;))
            {
                try
                {
                    await ProcessTasksAsync(token);
                }
                catch (Exception ee)
                {
                    LogHelper.Error&lt;ScheduledTasks&gt;(&quot;Error executing scheduled task&quot;, ee);
                }
            }

            return true; // repeat
        }

        public override bool IsAsync
        {
            get { return true; }
        }

        public override bool RunsOnShutdown
        {
            get { return false; }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[22,9,22,80,0],[26,15,26,66,0],[27,9,27,10,0],[28,13,28,38,0],[29,13,29,34,0],[30,9,30,10,0],[33,9,33,10,0],[34,13,34,65,0],[35,13,35,20,0],[35,22,35,27,0],[35,28,35,30,0],[35,31,35,45,0],[36,13,36,14,0],[37,17,37,37,0],[38,17,38,70,0],[39,17,39,18,0],[40,21,40,36,0],[41,21,41,67,0],[42,17,42,18,0],[45,22,47,124,0],[48,17,48,18,0],[49,21,49,36,0],[50,21,50,64,0],[51,17,51,18,0],[53,17,53,29,0],[54,17,54,18,0],[55,21,55,76,0],[56,21,56,31,0],[57,25,57,134,0],[58,17,58,18,0],[59,13,59,14,0],[60,9,60,10,0],[63,9,63,10,0],[64,20,64,45,0],[65,13,65,14,0],[66,17,66,75,0],[72,17,72,18,0],[73,21,73,91,0],[74,21,74,67,0],[76,17,76,37,0],[77,17,77,18,0],[78,21,78,111,0],[79,17,79,18,0],[80,17,80,30,0],[82,9,82,10,0],[85,9,85,10,0],[86,13,86,49,0],[90,9,90,10,0],[91,13,91,37,0],[91,38,91,50,0],[93,13,93,56,0],[96,21,96,87,0],[97,21,97,33,0],[99,21,99,99,0],[100,21,100,33,0],[104,13,104,56,0],[105,13,105,14,0],[106,17,106,81,0],[107,17,107,30,0],[110,13,110,72,0],[110,72,110,99,0],[110,99,110,107,0],[110,107,110,133,0],[110,133,110,135,0],[110,13,110,135,0],[111,13,111,14,0],[113,17,113,18,0],[114,21,114,52,0],[115,17,115,18,0],[116,17,116,37,0],[117,17,117,18,0],[118,21,118,91,0],[119,17,119,18,0],[120,13,120,14,0],[122,13,122,25,0],[123,9,123,10,0],[127,17,127,18,0],[127,19,127,31,0],[127,32,127,33,0],[132,17,132,18,0],[132,19,132,32,0],[132,33,132,34,0]]);
    </script>
  </body>
</html>