<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Models\ContentTypeBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using Umbraco.Core.Models.EntityBase;
using Umbraco.Core.Strings;

namespace Umbraco.Core.Models
{
    /// &lt;summary&gt;
    /// Represents an abstract class for base ContentType properties and methods
    /// &lt;/summary&gt;
    [Serializable]
    [DataContract(IsReference = true)]
    [DebuggerDisplay(&quot;Id: {Id}, Name: {Name}, Alias: {Alias}&quot;)]
    public abstract class ContentTypeBase : Entity, IContentTypeBase
    {
        private Lazy&lt;int&gt; _parentId;
        private string _name;
        private int _level;
        private string _path;
        private string _alias;
        private string _description;
        private int _sortOrder;
        private string _icon = &quot;icon-folder&quot;;
        private string _thumbnail = &quot;folder.png&quot;;
        private int _creatorId;
        private bool _allowedAsRoot;
        private bool _isContainer;
        private bool _trashed;
        private PropertyGroupCollection _propertyGroups;
        private PropertyTypeCollection _propertyTypes;
        private IEnumerable&lt;ContentTypeSort&gt; _allowedContentTypes;
        private bool _hasPropertyTypeBeenRemoved;


        protected ContentTypeBase(int parentId)
        {
			Mandate.ParameterCondition(parentId != 0, &quot;parentId&quot;);

            _parentId = new Lazy&lt;int&gt;(() =&gt; parentId);
            _allowedContentTypes = new List&lt;ContentTypeSort&gt;();
            _propertyGroups = new PropertyGroupCollection();
            _propertyTypes = new PropertyTypeCollection();
            _propertyTypes.CollectionChanged += PropertyTypesChanged;
            _additionalData = new Dictionary&lt;string, object&gt;();
        }

		protected ContentTypeBase(IContentTypeBase parent) : this(parent, null)
		{
		}

        protected ContentTypeBase(IContentTypeBase parent, string alias)
        {
            Mandate.ParameterNotNull(parent, &quot;parent&quot;);

            _alias = alias;
            _parentId = new Lazy&lt;int&gt;(() =&gt; parent.Id);
            _allowedContentTypes = new List&lt;ContentTypeSort&gt;();
            _propertyGroups = new PropertyGroupCollection();
            _propertyTypes = new PropertyTypeCollection();
            _propertyTypes.CollectionChanged += PropertyTypesChanged;
            _additionalData = new Dictionary&lt;string, object&gt;();
        }

        private static readonly Lazy&lt;PropertySelectors&gt; Ps = new Lazy&lt;PropertySelectors&gt;();

        private class PropertySelectors
        {
            public readonly PropertyInfo NameSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, string&gt;(x =&gt; x.Name);
            public readonly PropertyInfo ParentIdSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, int&gt;(x =&gt; x.ParentId);
            public readonly PropertyInfo SortOrderSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, int&gt;(x =&gt; x.SortOrder);
            public readonly PropertyInfo LevelSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, int&gt;(x =&gt; x.Level);
            public readonly PropertyInfo PathSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, string&gt;(x =&gt; x.Path);
            public readonly PropertyInfo AliasSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, string&gt;(x =&gt; x.Alias);
            public readonly PropertyInfo DescriptionSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, string&gt;(x =&gt; x.Description);
            public readonly PropertyInfo IconSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, string&gt;(x =&gt; x.Icon);
            public readonly PropertyInfo ThumbnailSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, string&gt;(x =&gt; x.Thumbnail);
            public readonly PropertyInfo CreatorIdSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, int&gt;(x =&gt; x.CreatorId);
            public readonly PropertyInfo AllowedAsRootSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, bool&gt;(x =&gt; x.AllowedAsRoot);
            public readonly PropertyInfo IsContainerSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, bool&gt;(x =&gt; x.IsContainer);
            public readonly PropertyInfo TrashedSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, bool&gt;(x =&gt; x.Trashed);
            public readonly PropertyInfo AllowedContentTypesSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, IEnumerable&lt;ContentTypeSort&gt;&gt;(x =&gt; x.AllowedContentTypes);
            public readonly PropertyInfo PropertyGroupCollectionSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, PropertyGroupCollection&gt;(x =&gt; x.PropertyGroups);
            public readonly PropertyInfo PropertyTypeCollectionSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, IEnumerable&lt;PropertyType&gt;&gt;(x =&gt; x.PropertyTypes);
            public readonly PropertyInfo HasPropertyTypeBeenRemovedSelector = ExpressionHelper.GetPropertyInfo&lt;ContentTypeBase, bool&gt;(x =&gt; x.HasPropertyTypeBeenRemoved);
        }


        protected void PropertyGroupsChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            OnPropertyChanged(Ps.Value.PropertyGroupCollectionSelector);
        }

        protected void PropertyTypesChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            OnPropertyChanged(Ps.Value.PropertyTypeCollectionSelector);
        }

        /// &lt;summary&gt;
        /// Gets or sets the Id of the Parent entity
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Might not be necessary if handled as a relation?&lt;/remarks&gt;
        [DataMember]
        public virtual int ParentId
        {
            get
            {
				var val = _parentId.Value;
				if (val == 0)
				{
					throw new InvalidOperationException(&quot;The ParentId cannot be a value of 0. Perhaps the parent object used to instantiate this object has not been persisted to the data store.&quot;);
				}
				return val;				
            }
            set
            {
                _parentId = new Lazy&lt;int&gt;(() =&gt; value);
                OnPropertyChanged(Ps.Value.ParentIdSelector);
            }
        }

        /// &lt;summary&gt;
        /// Gets or sets the name of the current entity
        /// &lt;/summary&gt;
        [DataMember]
        public virtual string Name
        {
            get { return _name; }
            set { SetPropertyValueAndDetectChanges(value, ref _name, Ps.Value.NameSelector); }
        }

        /// &lt;summary&gt;
        /// Gets or sets the level of the content entity
        /// &lt;/summary&gt;
        [DataMember]
        public virtual int Level //NOTE Is this relevant for a ContentType?
        {
            get { return _level; }
            set { SetPropertyValueAndDetectChanges(value, ref _level, Ps.Value.LevelSelector); }
        }

        /// &lt;summary&gt;
        /// Gets of sets the path
        /// &lt;/summary&gt;
        [DataMember]
        public virtual string Path //NOTE Is this relevant for a ContentType?
        {
            get { return _path; }
            set { SetPropertyValueAndDetectChanges(value, ref _path, Ps.Value.PathSelector); }
        }

        /// &lt;summary&gt;
        /// The Alias of the ContentType
        /// &lt;/summary&gt;
        [DataMember]
        public virtual string Alias
        {
            get { return _alias; }
            set
            {
                SetPropertyValueAndDetectChanges(
                    value.ToCleanString(CleanStringType.Alias | CleanStringType.UmbracoCase), 
                    ref _alias, 
                    Ps.Value.AliasSelector);
            }
        }

        /// &lt;summary&gt;
        /// Description for the ContentType
        /// &lt;/summary&gt;
        [DataMember]
        public virtual string Description
        {
            get { return _description; }
            set { SetPropertyValueAndDetectChanges(value, ref _description, Ps.Value.DescriptionSelector); }
        }

        /// &lt;summary&gt;
        /// Gets or sets the sort order of the content entity
        /// &lt;/summary&gt;
        [DataMember]
        public virtual int SortOrder
        {
            get { return _sortOrder; }
            set { SetPropertyValueAndDetectChanges(value, ref _sortOrder, Ps.Value.SortOrderSelector); }
        }

        /// &lt;summary&gt;
        /// Name of the icon (sprite class) used to identify the ContentType
        /// &lt;/summary&gt;
        [DataMember]
        public virtual string Icon
        {
            get { return _icon; }
            set { SetPropertyValueAndDetectChanges(value, ref _icon, Ps.Value.IconSelector); }
        }

        /// &lt;summary&gt;
        /// Name of the thumbnail used to identify the ContentType
        /// &lt;/summary&gt;
        [DataMember]
        public virtual string Thumbnail
        {
            get { return _thumbnail; }
            set { SetPropertyValueAndDetectChanges(value, ref _thumbnail, Ps.Value.ThumbnailSelector); }
        }

        /// &lt;summary&gt;
        /// Gets or sets the Id of the user who created this ContentType
        /// &lt;/summary&gt;
        [DataMember]
        public virtual int CreatorId
        {
            get { return _creatorId; }
            set { SetPropertyValueAndDetectChanges(value, ref _creatorId, Ps.Value.CreatorIdSelector); }
        }

        /// &lt;summary&gt;
        /// Gets or Sets a boolean indicating whether this ContentType is allowed at the root
        /// &lt;/summary&gt;
        [DataMember]
        public virtual bool AllowedAsRoot
        {
            get { return _allowedAsRoot; }
            set { SetPropertyValueAndDetectChanges(value, ref _allowedAsRoot, Ps.Value.AllowedAsRootSelector); }
        }

        /// &lt;summary&gt;
        /// Gets or Sets a boolean indicating whether this ContentType is a Container
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// ContentType Containers doesn&#39;t show children in the tree, but rather in grid-type view.
        /// &lt;/remarks&gt;
        [DataMember]
        public virtual bool IsContainer
        {
            get { return _isContainer; }
            set { SetPropertyValueAndDetectChanges(value, ref _isContainer, Ps.Value.IsContainerSelector); }
        }

        /// &lt;summary&gt;
        /// Boolean indicating whether this ContentType is Trashed or not.
        /// If ContentType is Trashed it will be located in the Recyclebin.
        /// &lt;/summary&gt;
        [DataMember]
        public virtual bool Trashed //NOTE Is this relevant for a ContentType?
        {
            get { return _trashed; }
            set { SetPropertyValueAndDetectChanges(value, ref _trashed, Ps.Value.TrashedSelector); }
        }

        private IDictionary&lt;string, object&gt; _additionalData;
        /// &lt;summary&gt;
        /// Some entities may expose additional data that other&#39;s might not, this custom data will be available in this collection
        /// &lt;/summary&gt;
        [EditorBrowsable(EditorBrowsableState.Never)]
        IDictionary&lt;string, object&gt; IUmbracoEntity.AdditionalData
        {
            get { return _additionalData; }
        }

        /// &lt;summary&gt;
        /// Gets or sets a list of integer Ids for allowed ContentTypes
        /// &lt;/summary&gt;
        [DataMember]
        public virtual IEnumerable&lt;ContentTypeSort&gt; AllowedContentTypes
        {
            get { return _allowedContentTypes; }
            set
            {
                SetPropertyValueAndDetectChanges(value, ref _allowedContentTypes, Ps.Value.AllowedContentTypesSelector,
                    //Custom comparer for enumerable
                    new DelegateEqualityComparer&lt;IEnumerable&lt;ContentTypeSort&gt;&gt;(
                        (sorts, enumerable) =&gt; sorts.UnsortedSequenceEqual(enumerable),
                        sorts =&gt; sorts.GetHashCode()));                
            }
        }

        /// &lt;summary&gt;
        /// List of PropertyGroups available on this ContentType
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// A PropertyGroup corresponds to a Tab in the UI
        /// &lt;/remarks&gt;
        [DataMember]
        public virtual PropertyGroupCollection PropertyGroups
        {
            get { return _propertyGroups; }
            set
            {
                _propertyGroups = value;
                _propertyGroups.CollectionChanged += PropertyGroupsChanged;
                PropertyGroupsChanged(_propertyGroups, new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
            }
        }

        /// &lt;summary&gt;
        /// Gets all property types, across all property groups.
        /// &lt;/summary&gt;
        [IgnoreDataMember]
        [DoNotClone]
        public virtual IEnumerable&lt;PropertyType&gt; PropertyTypes
        {
            get
            {
                return _propertyTypes.Union(PropertyGroups.SelectMany(x =&gt; x.PropertyTypes));
            }
        }

        /// &lt;summary&gt;
        /// Gets or sets the property types that are not in a group.
        /// &lt;/summary&gt;
        public IEnumerable&lt;PropertyType&gt; NoGroupPropertyTypes
        {
            get { return _propertyTypes; }
            set
            {
                _propertyTypes = new PropertyTypeCollection(value);
                _propertyTypes.CollectionChanged += PropertyTypesChanged;
                PropertyTypesChanged(_propertyTypes, new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
            }
        }

        /// &lt;summary&gt;
        /// A boolean flag indicating if a property type has been removed from this instance.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// This is currently (specifically) used in order to know that we need to refresh the content cache which 
        /// needs to occur when a property has been removed from a content type
        /// &lt;/remarks&gt;
        [IgnoreDataMember]
        internal bool HasPropertyTypeBeenRemoved
        {
            get { return _hasPropertyTypeBeenRemoved; }
            private set
            {
                _hasPropertyTypeBeenRemoved = value;
                OnPropertyChanged(Ps.Value.HasPropertyTypeBeenRemovedSelector);
            }
        }

        /// &lt;summary&gt;
        /// Checks whether a PropertyType with a given alias already exists
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyTypeAlias&quot;&gt;Alias of the PropertyType&lt;/param&gt;
        /// &lt;returns&gt;Returns &lt;c&gt;True&lt;/c&gt; if a PropertyType with the passed in alias exists, otherwise &lt;c&gt;False&lt;/c&gt;&lt;/returns&gt;
        public abstract bool PropertyTypeExists(string propertyTypeAlias);

        /// &lt;summary&gt;
        /// Adds a PropertyGroup.
        /// This method will also check if a group already exists with the same name and link it to the parent.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;groupName&quot;&gt;Name of the PropertyGroup to add&lt;/param&gt;
        /// &lt;returns&gt;Returns &lt;c&gt;True&lt;/c&gt; if a PropertyGroup with the passed in name was added, otherwise &lt;c&gt;False&lt;/c&gt;&lt;/returns&gt;
        public abstract bool AddPropertyGroup(string groupName);

        /// &lt;summary&gt;
        /// Adds a PropertyType to a specific PropertyGroup
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyType&quot;&gt;&lt;see cref=&quot;PropertyType&quot;/&gt; to add&lt;/param&gt;
        /// &lt;param name=&quot;propertyGroupName&quot;&gt;Name of the PropertyGroup to add the PropertyType to&lt;/param&gt;
        /// &lt;returns&gt;Returns &lt;c&gt;True&lt;/c&gt; if PropertyType was added, otherwise &lt;c&gt;False&lt;/c&gt;&lt;/returns&gt;
        public abstract bool AddPropertyType(PropertyType propertyType, string propertyGroupName);

        /// &lt;summary&gt;
        /// Adds a PropertyType, which does not belong to a PropertyGroup.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyType&quot;&gt;&lt;see cref=&quot;PropertyType&quot;/&gt; to add&lt;/param&gt;
        /// &lt;returns&gt;Returns &lt;c&gt;True&lt;/c&gt; if PropertyType was added, otherwise &lt;c&gt;False&lt;/c&gt;&lt;/returns&gt;
        public bool AddPropertyType(PropertyType propertyType)
        {
            if (PropertyTypeExists(propertyType.Alias) == false)
            {
                _propertyTypes.Add(propertyType);                
                return true;
            }

            return false;
        }

        /// &lt;summary&gt;
        /// Moves a PropertyType to a specified PropertyGroup
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyTypeAlias&quot;&gt;Alias of the PropertyType to move&lt;/param&gt;
        /// &lt;param name=&quot;propertyGroupName&quot;&gt;Name of the PropertyGroup to move the PropertyType to&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;If &lt;paramref name=&quot;propertyGroupName&quot;/&gt; is null then the property is moved back to 
        /// &quot;generic properties&quot; ie does not have a tab anymore.&lt;/remarks&gt;
        public bool MovePropertyType(string propertyTypeAlias, string propertyGroupName)
        {
            // note: not dealing with alias casing at all here?

            // get property, ensure it exists
            var propertyType = PropertyTypes.FirstOrDefault(x =&gt; x.Alias == propertyTypeAlias);
            if (propertyType == null) return false;

            // get new group, if required, and ensure it exists
            var newPropertyGroup = propertyGroupName == null
                ? null
                : PropertyGroups.FirstOrDefault(x =&gt; x.Name == propertyGroupName);
            if (propertyGroupName != null &amp;&amp; newPropertyGroup == null) return false;

            // get old group
            var oldPropertyGroup = PropertyGroups.FirstOrDefault(x =&gt; 
                x.PropertyTypes.Any(y =&gt; y.Alias == propertyTypeAlias));

            // set new group
            propertyType.PropertyGroupId = newPropertyGroup == null ? null : new Lazy&lt;int&gt;(() =&gt; newPropertyGroup.Id, false);

            // remove from old group, if any - add to new group, if any
            if (oldPropertyGroup != null)
                oldPropertyGroup.PropertyTypes.RemoveItem(propertyTypeAlias);
            if (newPropertyGroup != null)
                newPropertyGroup.PropertyTypes.Add(propertyType);

            return true;
        }

        /// &lt;summary&gt;
        /// Removes a PropertyType from the current ContentType
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyTypeAlias&quot;&gt;Alias of the &lt;see cref=&quot;PropertyType&quot;/&gt; to remove&lt;/param&gt;
        public void RemovePropertyType(string propertyTypeAlias)
        {
            //check if the property exist in one of our collections
            if (PropertyGroups.Any(group =&gt; group.PropertyTypes.Any(pt =&gt; pt.Alias == propertyTypeAlias))
                || _propertyTypes.Any(x =&gt; x.Alias == propertyTypeAlias))
            {
                //set the flag that a property has been removed
                HasPropertyTypeBeenRemoved = true;
            }

            foreach (var propertyGroup in PropertyGroups)
            {
                propertyGroup.PropertyTypes.RemoveItem(propertyTypeAlias);
            }

            if (_propertyTypes.Any(x =&gt; x.Alias == propertyTypeAlias))
            {
                _propertyTypes.RemoveItem(propertyTypeAlias);               
            }
        }

        /// &lt;summary&gt;
        /// Removes a PropertyGroup from the current ContentType
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyGroupName&quot;&gt;Name of the &lt;see cref=&quot;PropertyGroup&quot;/&gt; to remove&lt;/param&gt;
        public void RemovePropertyGroup(string propertyGroupName)
        {
            // if no group exists with that name, do nothing
            var group = PropertyGroups[propertyGroupName];
            if (group == null) return;

            // re-assign the group&#39;s properties to no group
            foreach (var property in group.PropertyTypes)
            {
                property.PropertyGroupId = null;
                _propertyTypes.Add(property);
            }

            // actually remove the group
            PropertyGroups.RemoveItem(propertyGroupName);
            OnPropertyChanged(Ps.Value.PropertyGroupCollectionSelector);
        }

        /// &lt;summary&gt;
        /// Sets the ParentId from the lazy integer id
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;id&quot;&gt;Id of the Parent&lt;/param&gt;
        public void SetLazyParentId(Lazy&lt;int&gt; id)
        {
            _parentId = id;
        }

        /// &lt;summary&gt;
        /// PropertyTypes that are not part of a PropertyGroup
        /// &lt;/summary&gt;
        [IgnoreDataMember]
        internal PropertyTypeCollection PropertyTypeCollection
        {
             get { return _propertyTypes; }
        }

        /// &lt;summary&gt;
        /// Indicates whether a specific property on the current &lt;see cref=&quot;IContent&quot;/&gt; entity is dirty.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyName&quot;&gt;Name of the property to check&lt;/param&gt;
        /// &lt;returns&gt;True if Property is dirty, otherwise False&lt;/returns&gt;
        public override bool IsPropertyDirty(string propertyName)
        {
            bool existsInEntity = base.IsPropertyDirty(propertyName);

            bool anyDirtyGroups = PropertyGroups.Any(x =&gt; x.IsPropertyDirty(propertyName));
            bool anyDirtyTypes = PropertyTypes.Any(x =&gt; x.IsPropertyDirty(propertyName));

            return existsInEntity || anyDirtyGroups || anyDirtyTypes;
        }

        /// &lt;summary&gt;
        /// Indicates whether the current entity is dirty.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;True if entity is dirty, otherwise False&lt;/returns&gt;
        public override bool IsDirty()
        {
            bool dirtyEntity = base.IsDirty();

            bool dirtyGroups = PropertyGroups.Any(x =&gt; x.IsDirty());
            bool dirtyTypes = PropertyTypes.Any(x =&gt; x.IsDirty());

            return dirtyEntity || dirtyGroups || dirtyTypes;
        }

        /// &lt;summary&gt;
        /// Resets dirty properties by clearing the dictionary used to track changes.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// Please note that resetting the dirty properties could potentially
        /// obstruct the saving of a new or updated entity.
        /// &lt;/remarks&gt;
        public override void ResetDirtyProperties()
        {
            base.ResetDirtyProperties();

            //loop through each property group to reset the property types
            var propertiesReset = new List&lt;int&gt;();

            foreach (var propertyGroup in PropertyGroups)
            {
                propertyGroup.ResetDirtyProperties();
                foreach (var propertyType in propertyGroup.PropertyTypes)
                {
                    propertyType.ResetDirtyProperties();
                    propertiesReset.Add(propertyType.Id);
                }
            }
            //then loop through our property type collection since some might not exist on a property group
            //but don&#39;t re-reset ones we&#39;ve already done.
            foreach (var propertyType in PropertyTypes.Where(x =&gt; propertiesReset.Contains(x.Id) == false))
            {
                propertyType.ResetDirtyProperties();
            }
        }

        public override object DeepClone()
        {
            var clone = (ContentTypeBase)base.DeepClone();
            //turn off change tracking
            clone.DisableChangeTracking();
            //need to manually wire up the event handlers for the property type collections - we&#39;ve ensured
            // its ignored from the auto-clone process because its return values are unions, not raw and 
            // we end up with duplicates, see: http://issues.umbraco.org/issue/U4-4842

            clone._propertyTypes = (PropertyTypeCollection)_propertyTypes.DeepClone();
            clone._propertyTypes.CollectionChanged += clone.PropertyTypesChanged;
            //this shouldn&#39;t really be needed since we&#39;re not tracking
            clone.ResetDirtyProperties(false);
            //re-enable tracking
            clone.EnableChangeTracking();

            return clone;
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[29,9,29,46,1],[29,9,29,46,1],[30,9,30,50,1],[30,9,30,50,1],[41,9,41,48,1],[42,9,42,10,1],[43,4,43,58,1],[45,13,45,45,1],[45,45,45,53,1],[45,53,45,55,1],[45,13,45,55,1],[46,13,46,64,1],[47,13,47,61,1],[48,13,48,59,1],[49,13,49,70,1],[50,13,50,64,1],[51,9,51,10,1],[53,56,53,74,0],[54,3,54,4,0],[55,3,55,4,0],[57,9,57,73,1],[58,9,58,10,1],[59,13,59,56,1],[61,13,61,28,1],[62,13,62,45,1],[62,45,62,54,1],[62,54,62,56,1],[62,13,62,56,1],[63,13,63,64,1],[64,13,64,61,1],[65,13,65,59,1],[66,13,66,70,1],[67,13,67,64,1],[68,9,68,10,1],[70,9,70,92,1],[74,13,74,128,1],[75,13,75,133,1],[76,13,76,135,1],[77,13,77,127,1],[78,13,78,128,1],[79,13,79,130,1],[80,13,80,142,1],[81,13,81,128,1],[82,13,82,138,1],[83,13,83,135,1],[84,13,84,144,1],[85,13,85,140,1],[86,13,86,132,1],[87,13,87,180,1],[88,13,88,174,1],[89,13,89,174,1],[90,13,90,170,1],[95,9,95,10,1],[96,13,96,73,1],[97,9,97,10,1],[100,9,100,10,1],[101,13,101,72,1],[102,9,102,10,1],[112,13,112,14,1],[113,5,113,31,1],[114,5,114,18,1],[115,5,115,6,0],[116,6,116,182,0],[118,5,118,16,1],[119,13,119,14,1],[121,13,121,14,1],[122,17,122,49,1],[122,49,122,54,1],[122,54,122,56,1],[122,17,122,56,1],[123,17,123,62,1],[124,13,124,14,1],[133,17,133,18,1],[133,19,133,32,1],[133,33,133,34,1],[134,17,134,18,1],[134,19,134,93,1],[134,94,134,95,1],[143,17,143,18,1],[143,19,143,33,1],[143,34,143,35,1],[144,17,144,18,1],[144,19,144,95,1],[144,96,144,97,1],[153,17,153,18,1],[153,19,153,32,1],[153,33,153,34,1],[154,17,154,18,1],[154,19,154,93,1],[154,94,154,95,1],[163,17,163,18,1],[163,19,163,33,1],[163,34,163,35,1],[165,13,165,14,1],[166,17,169,45,1],[170,13,170,14,1],[179,17,179,18,1],[179,19,179,39,1],[179,40,179,41,1],[180,17,180,18,1],[180,19,180,107,1],[180,108,180,109,1],[189,17,189,18,1],[189,19,189,37,1],[189,38,189,39,1],[190,17,190,18,1],[190,19,190,103,1],[190,104,190,105,1],[199,17,199,18,1],[199,19,199,32,1],[199,33,199,34,1],[200,17,200,18,1],[200,19,200,93,1],[200,94,200,95,1],[209,17,209,18,1],[209,19,209,37,1],[209,38,209,39,1],[210,17,210,18,1],[210,19,210,103,1],[210,104,210,105,1],[219,17,219,18,1],[219,19,219,37,1],[219,38,219,39,1],[220,17,220,18,1],[220,19,220,103,1],[220,104,220,105,1],[229,17,229,18,1],[229,19,229,41,1],[229,42,229,43,1],[230,17,230,18,1],[230,19,230,111,1],[230,112,230,113,1],[242,17,242,18,1],[242,19,242,39,1],[242,40,242,41,1],[243,17,243,18,1],[243,19,243,107,1],[243,108,243,109,1],[253,17,253,18,1],[253,19,253,35,1],[253,36,253,37,1],[254,17,254,18,1],[254,19,254,99,1],[254,100,254,101,1],[264,17,264,18,1],[264,19,264,42,1],[264,43,264,44,1],[273,17,273,18,1],[273,19,273,47,1],[273,48,273,49,1],[275,13,275,14,1],[276,17,279,48,1],[279,48,279,87,1],[279,87,280,34,1],[280,34,280,53,0],[280,53,280,56,1],[276,17,280,56,1],[281,13,281,14,1],[293,17,293,18,1],[293,19,293,42,1],[293,43,293,44,1],[295,13,295,14,1],[296,17,296,41,1],[297,17,297,76,1],[298,17,298,131,1],[299,13,299,14,1],[310,13,310,14,1],[311,17,311,76,1],[311,76,311,91,1],[311,91,311,94,1],[311,17,311,94,1],[312,13,312,14,1],[320,17,320,18,1],[320,19,320,41,1],[320,42,320,43,1],[322,13,322,14,1],[323,17,323,68,1],[324,17,324,74,1],[325,17,325,129,1],[326,13,326,14,1],[339,17,339,18,0],[339,19,339,54,0],[339,55,339,56,0],[341,13,341,14,1],[342,17,342,53,1],[343,17,343,80,1],[344,13,344,14,1],[376,9,376,10,1],[377,13,377,65,1],[378,13,378,14,1],[379,17,379,50,1],[380,17,380,29,1],[383,13,383,26,1],[384,9,384,10,1],[395,9,395,10,0],[399,13,399,66,0],[399,66,399,94,0],[399,94,399,96,0],[399,13,399,96,0],[400,13,400,38,0],[400,39,400,52,0],[403,13,405,54,0],[405,54,405,81,0],[405,81,405,83,0],[403,13,405,83,0],[406,13,406,71,0],[406,72,406,85,0],[409,13,410,17,0],[410,17,410,42,0],[410,42,410,70,0],[410,70,410,71,0],[410,17,410,71,0],[410,71,410,73,0],[409,13,410,73,0],[413,13,413,98,0],[413,98,413,117,0],[413,117,413,126,0],[413,13,413,126,0],[416,13,416,42,0],[417,17,417,78,0],[418,13,418,42,0],[419,17,419,66,0],[421,13,421,25,0],[422,9,422,10,0],[429,9,429,10,1],[431,13,431,45,1],[431,45,431,75,1],[431,75,431,104,1],[431,104,431,105,1],[431,45,431,105,1],[431,105,432,44,1],[432,44,432,72,0],[432,72,432,74,1],[431,13,432,74,1],[433,13,433,14,1],[435,17,435,51,1],[436,13,436,14,1],[438,13,438,20,1],[438,22,438,39,1],[438,40,438,42,1],[438,43,438,57,1],[439,13,439,14,1],[440,17,440,75,1],[441,13,441,14,1],[443,13,443,41,1],[443,41,443,69,0],[443,69,443,71,1],[443,13,443,71,1],[444,13,444,14,0],[445,17,445,62,0],[446,13,446,14,0],[447,9,447,10,1],[454,9,454,10,1],[456,13,456,59,1],[457,13,457,31,1],[457,32,457,39,0],[460,13,460,20,1],[460,22,460,34,1],[460,35,460,37,1],[460,38,460,57,1],[461,13,461,14,1],[462,17,462,49,1],[463,17,463,46,1],[464,13,464,14,1],[467,13,467,58,1],[468,13,468,73,1],[469,9,469,10,1],[476,9,476,10,1],[477,13,477,28,1],[478,9,478,10,1],[486,18,486,19,1],[486,20,486,42,1],[486,43,486,44,1],[495,9,495,10,1],[496,13,496,70,1],[498,13,498,59,1],[498,59,498,90,1],[498,90,498,92,1],[498,13,498,92,1],[499,13,499,57,1],[499,57,499,88,1],[499,88,499,90,1],[499,13,499,90,1],[501,13,501,70,1],[502,9,502,10,1],[509,9,509,10,1],[510,13,510,47,1],[512,13,512,56,1],[512,56,512,67,1],[512,67,512,69,1],[512,13,512,69,1],[513,13,513,54,1],[513,54,513,65,1],[513,65,513,67,1],[513,13,513,67,1],[515,13,515,61,1],[516,9,516,10,1],[526,9,526,10,1],[527,13,527,41,1],[530,13,530,51,1],[532,13,532,20,1],[532,22,532,39,1],[532,40,532,42,1],[532,43,532,57,1],[533,13,533,14,1],[534,17,534,54,1],[535,17,535,24,1],[535,26,535,42,1],[535,43,535,45,1],[535,46,535,73,1],[536,17,536,18,1],[537,21,537,57,1],[538,21,538,58,1],[539,17,539,18,1],[540,13,540,14,1],[543,13,543,20,1],[543,22,543,38,1],[543,39,543,41,1],[543,42,543,67,1],[543,67,543,106,1],[543,106,543,107,1],[543,42,543,107,1],[544,13,544,14,1],[545,17,545,53,1],[546,13,546,14,1],[547,9,547,10,1],[550,9,550,10,1],[551,13,551,59,1],[553,13,553,43,1],[558,13,558,87,1],[559,13,559,82,1],[561,13,561,47,1],[563,13,563,42,1],[565,13,565,26,1],[566,9,566,10,1]]);
    </script>
  </body>
</html>