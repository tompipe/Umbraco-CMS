<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Persistence\Querying\ExpressionVisitorBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using Umbraco.Core.Persistence.SqlSyntax;

namespace Umbraco.Core.Persistence.Querying
{
    /// &lt;summary&gt;
    /// Represents an expression which caches the visitor&#39;s result.
    /// &lt;/summary&gt;
    internal class CachedExpression : Expression
    {
        private string _visitResult;

        /// &lt;summary&gt;
        /// Gets or sets the inner Expression.
        /// &lt;/summary&gt;
        public Expression InnerExpression { get; private set; }

        /// &lt;summary&gt;
        /// Gets or sets the compiled SQL statement output.
        /// &lt;/summary&gt;
        public string VisitResult
        {
            get { return _visitResult; }
            set
            {
                if (Visited)
                    throw new InvalidOperationException(&quot;Cached expression has already been visited.&quot;);
                _visitResult = value;
                Visited = true;
            }
        }

        /// &lt;summary&gt;
        /// Gets or sets a value indicating whether the cache Expression has been compiled already.
        /// &lt;/summary&gt;
        public bool Visited { get; private set; }

        /// &lt;summary&gt;
        /// Replaces the inner expression.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;expression&quot;&gt;expression.&lt;/param&gt;
        /// &lt;remarks&gt;The new expression is assumed to have different parameter but produce the same SQL statement.&lt;/remarks&gt;
        public void Wrap(Expression expression)
        {
            InnerExpression = expression;
        }
    }

    /// &lt;summary&gt;
    /// An expression tree parser to create SQL statements and SQL parameters based on a strongly typed expression.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;This object is stateful and cannot be re-used to parse an expression.&lt;/remarks&gt;
    internal abstract class ExpressionVisitorBase
    {
        protected ExpressionVisitorBase(ISqlSyntaxProvider sqlSyntax)
        {
            SqlSyntax = sqlSyntax;
        }

        /// &lt;summary&gt;
        /// Gets or sets a value indicating whether the visited expression has been visited already,
        /// in which case visiting will just populate the SQL parameters.
        /// &lt;/summary&gt;
        protected bool Visited { get; set; }

        /// &lt;summary&gt;
        /// Gets or sets the SQL syntax provider for the current database.
        /// &lt;/summary&gt;
        protected ISqlSyntaxProvider SqlSyntax { get; private set; }

        /// &lt;summary&gt;
        /// Gets the list of SQL parameters.
        /// &lt;/summary&gt;
        protected readonly List&lt;object&gt; SqlParameters = new List&lt;object&gt;();

        /// &lt;summary&gt;
        /// Gets the SQL parameters.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public object[] GetSqlParameters()
        {
            return SqlParameters.ToArray();
        }

        /// &lt;summary&gt;
        /// Visits the expression and produces the corresponding SQL statement.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;expression&quot;&gt;The expression&lt;/param&gt;
        /// &lt;returns&gt;The SQL statement corresponding to the expression.&lt;/returns&gt;
        /// &lt;remarks&gt;Also populates the SQL parameters.&lt;/remarks&gt;
        public virtual string Visit(Expression expression)
        {
            // if the expression is a CachedExpression,
            // visit the inner expression if not already visited
            var cachedExpression = expression as CachedExpression;
            if (cachedExpression != null)
            {
                Visited = cachedExpression.Visited;
                expression = cachedExpression.InnerExpression;
            }

            if (expression == null) return string.Empty;

            string result;

            switch (expression.NodeType)
            {
                case ExpressionType.Lambda:
                    result = VisitLambda(expression as LambdaExpression);
                    break;
                case ExpressionType.MemberAccess:
                    result = VisitMemberAccess(expression as MemberExpression);
                    break;
                case ExpressionType.Constant:
                    result = VisitConstant(expression as ConstantExpression);
                    break;
                case ExpressionType.Add:
                case ExpressionType.AddChecked:
                case ExpressionType.Subtract:
                case ExpressionType.SubtractChecked:
                case ExpressionType.Multiply:
                case ExpressionType.MultiplyChecked:
                case ExpressionType.Divide:
                case ExpressionType.Modulo:
                case ExpressionType.And:
                case ExpressionType.AndAlso:
                case ExpressionType.Or:
                case ExpressionType.OrElse:
                case ExpressionType.LessThan:
                case ExpressionType.LessThanOrEqual:
                case ExpressionType.GreaterThan:
                case ExpressionType.GreaterThanOrEqual:
                case ExpressionType.Equal:
                case ExpressionType.NotEqual:
                case ExpressionType.Coalesce:
                case ExpressionType.ArrayIndex:
                case ExpressionType.RightShift:
                case ExpressionType.LeftShift:
                case ExpressionType.ExclusiveOr:
                    result = VisitBinary(expression as BinaryExpression);
                    break;
                case ExpressionType.Negate:
                case ExpressionType.NegateChecked:
                case ExpressionType.Not:
                case ExpressionType.Convert:
                case ExpressionType.ConvertChecked:
                case ExpressionType.ArrayLength:
                case ExpressionType.Quote:
                case ExpressionType.TypeAs:
                    result = VisitUnary(expression as UnaryExpression);
                    break;
                case ExpressionType.Parameter:
                    result = VisitParameter(expression as ParameterExpression);
                    break;
                case ExpressionType.Call:
                    result = VisitMethodCall(expression as MethodCallExpression);
                    break;
                case ExpressionType.New:
                    result = VisitNew(expression as NewExpression);
                    break;
                case ExpressionType.NewArrayInit:
                case ExpressionType.NewArrayBounds:
                    result = VisitNewArray(expression as NewArrayExpression);
                    break;
                default:
                    result = expression.ToString();
                    break;
            }

            // if the expression is a CachedExpression,
            // and is not already compiled, assign the result
            if (cachedExpression != null)
            {
                if (cachedExpression.Visited == false)
                    cachedExpression.VisitResult = result;
                result = cachedExpression.VisitResult;
            }

            return result;
        }

        protected abstract string VisitMemberAccess(MemberExpression m);

        protected virtual string VisitLambda(LambdaExpression lambda)
        {
            if (lambda.Body.NodeType == ExpressionType.MemberAccess)
            {
                var m = lambda.Body as MemberExpression;

                if (m != null &amp;&amp; m.Expression != null)
                {
                    //This deals with members that are boolean (i.e. x =&gt; IsTrashed )
                    var r = VisitMemberAccess(m);

                    SqlParameters.Add(true);

                    return Visited ? string.Empty : string.Format(&quot;{0} = @{1}&quot;, r, SqlParameters.Count - 1);
                }

            }
            return Visit(lambda.Body);
        }

        protected virtual string VisitBinary(BinaryExpression b)
        {
            var left = string.Empty;
            var right = string.Empty;

            var operand = BindOperant(b.NodeType);
            if (operand == &quot;AND&quot; || operand == &quot;OR&quot;)
            {
                var m = b.Left as MemberExpression;
                if (m != null &amp;&amp; m.Expression != null)
                {
                    string r = VisitMemberAccess(m);

                    SqlParameters.Add(1);

                    //don&#39;t execute if compiled
                    if (Visited == false)
                    {
                        left = string.Format(&quot;{0} = @{1}&quot;, r, SqlParameters.Count - 1);
                    }
                }
                else
                {
                    left = Visit(b.Left);
                }
                m = b.Right as MemberExpression;
                if (m != null &amp;&amp; m.Expression != null)
                {
                    var r = VisitMemberAccess(m);

                    SqlParameters.Add(1);

                    //don&#39;t execute if compiled
                    if (Visited == false)
                    {
                        right = string.Format(&quot;{0} = @{1}&quot;, r, SqlParameters.Count - 1);
                    }
                }
                else
                {
                    right = Visit(b.Right);
                }
            }
            else if (operand == &quot;=&quot;)
            {
                // deal with (x == true|false) - most common
                var constRight = b.Right as ConstantExpression;
                if (constRight != null &amp;&amp; constRight.Type == typeof(bool))
                    return (bool)constRight.Value ? VisitNotNot(b.Left) : VisitNot(b.Left);
                right = Visit(b.Right);

                // deal with (true|false == x) - why not
                var constLeft = b.Left as ConstantExpression;
                if (constLeft != null &amp;&amp; constLeft.Type == typeof(bool))
                    return (bool)constLeft.Value ? VisitNotNot(b.Right) : VisitNot(b.Right);
                left = Visit(b.Left);
            }
            else if (operand == &quot;&lt;&gt;&quot;)
            {
                // deal with (x != true|false) - most common
                var constRight = b.Right as ConstantExpression;
                if (constRight != null &amp;&amp; constRight.Type == typeof(bool))
                    return (bool)constRight.Value ? VisitNot(b.Left) : VisitNotNot(b.Left);
                right = Visit(b.Right);

                // deal with (true|false != x) - why not
                var constLeft = b.Left as ConstantExpression;
                if (constLeft != null &amp;&amp; constLeft.Type == typeof(bool))
                    return (bool)constLeft.Value ? VisitNot(b.Right) : VisitNotNot(b.Right);
                left = Visit(b.Left);
            }
            else
            {
                left = Visit(b.Left);
                right = Visit(b.Right);
            }

            if (operand == &quot;=&quot; &amp;&amp; right == &quot;null&quot;) operand = &quot;is&quot;;
            else if (operand == &quot;&lt;&gt;&quot; &amp;&amp; right == &quot;null&quot;) operand = &quot;is not&quot;;
            else if (operand == &quot;=&quot; || operand == &quot;&lt;&gt;&quot;)
            {
                //if (IsTrueExpression(right)) right = GetQuotedTrueValue();
                //else if (IsFalseExpression(right)) right = GetQuotedFalseValue();

                //if (IsTrueExpression(left)) left = GetQuotedTrueValue();
                //else if (IsFalseExpression(left)) left = GetQuotedFalseValue();

            }

            switch (operand)
            {
                case &quot;MOD&quot;:
                case &quot;COALESCE&quot;:
                    //don&#39;t execute if compiled
                    if (Visited == false)
                    {
                        return string.Format(&quot;{0}({1},{2})&quot;, operand, left, right);
                    }
                    //already compiled, return
                    return string.Empty;
                default:
                    //don&#39;t execute if compiled
                    if (Visited == false)
                    {
                        return string.Concat(&quot;(&quot;, left, &quot; &quot;, operand, &quot; &quot;, right, &quot;)&quot;);
                    }
                    //already compiled, return
                    return string.Empty;
            }
        }

        protected virtual List&lt;object&gt; VisitExpressionList(ReadOnlyCollection&lt;Expression&gt; original)
        {
            var list = new List&lt;object&gt;();
            for (int i = 0, n = original.Count; i &lt; n; i++)
            {
                if (original[i].NodeType == ExpressionType.NewArrayInit ||
                    original[i].NodeType == ExpressionType.NewArrayBounds)
                {
                    list.AddRange(VisitNewArrayFromExpressionList(original[i] as NewArrayExpression));
                }
                else
                {
                    list.Add(Visit(original[i]));
                }
            }
            return list;
        }

        protected virtual string VisitNew(NewExpression nex)
        {
            // TODO : check !
            var member = Expression.Convert(nex, typeof(object));
            var lambda = Expression.Lambda&lt;Func&lt;object&gt;&gt;(member);
            try
            {
                var getter = lambda.Compile();
                var o = getter();

                SqlParameters.Add(o);

                //don&#39;t execute if compiled
                if (Visited == false)
                {
                    return string.Format(&quot;@{0}&quot;, SqlParameters.Count - 1);
                }
                //already compiled, return
                return string.Empty;
            }
            catch (InvalidOperationException)
            {
                //don&#39;t execute if compiled
                if (Visited == false)
                {
                    // FieldName ?
                    List&lt;object&gt; exprs = VisitExpressionList(nex.Arguments);
                    var r = new StringBuilder();
                    foreach (var e in exprs)
                    {
                        r.AppendFormat(&quot;{0}{1}&quot;,
                            r.Length &gt; 0 ? &quot;,&quot; : &quot;&quot;,
                            e);
                    }
                    return r.ToString();
                }
                //already compiled, return
                return string.Empty;
            }
        }

        protected virtual string VisitParameter(ParameterExpression p)
        {
            return p.Name;
        }

        protected virtual string VisitConstant(ConstantExpression c)
        {
            if (c.Value == null)
                return &quot;null&quot;;

            SqlParameters.Add(c.Value);

            //don&#39;t execute if compiled
            if (Visited == false)
            {
                return string.Format(&quot;@{0}&quot;, SqlParameters.Count - 1);
            }
            //already compiled, return
            return string.Empty;
        }

        protected virtual string VisitUnary(UnaryExpression u)
        {
            switch (u.NodeType)
            {
                case ExpressionType.Not:
                    return VisitNot(u.Operand);
                default:
                    return Visit(u.Operand);
            }
        }

        private string VisitNot(Expression exp)
        {
            var o = Visit(exp);

            // use a &quot;NOT (...)&quot; syntax instead of &quot;&lt;&gt;&quot; since we don&#39;t know whether &quot;&lt;&gt;&quot; works in all sql servers
            // also, x.StartsWith(...) translates to &quot;x LIKE &#39;...%&#39;&quot; which we cannot &quot;&lt;&gt;&quot; and have to &quot;NOT (...&quot;)

            switch (exp.NodeType)
            {
                case ExpressionType.MemberAccess:
                    // false property , i.e. x =&gt; !Trashed
                    SqlParameters.Add(true);
                    //don&#39;t execute if compiled
                    if (Visited == false)
                    {
                        return string.Format(&quot;NOT ({0} = @{1})&quot;, o, SqlParameters.Count - 1);
                    }
                    //already compiled, return
                    return string.Empty;
                default:
                    //don&#39;t execute if compiled
                    if (Visited == false)
                    {
                        // could be anything else, such as: x =&gt; !x.Path.StartsWith(&quot;-20&quot;)
                        return string.Concat(&quot;NOT (&quot;, o, &quot;)&quot;);
                    }
                    //already compiled, return
                    return string.Empty;
            }
        }

        private string VisitNotNot(Expression exp)
        {
            var o = Visit(exp);

            switch (exp.NodeType)
            {
                case ExpressionType.MemberAccess:
                    // true property, i.e. x =&gt; Trashed
                    SqlParameters.Add(true);

                    //don&#39;t execute if compiled
                    if (Visited == false)
                    {
                        return string.Format(&quot;({0} = @{1})&quot;, o, SqlParameters.Count - 1);
                    }
                    //already compiled, return
                    return string.Empty;
                default:
                    // could be anything else, such as: x =&gt; x.Path.StartsWith(&quot;-20&quot;)
                    return o;
            }
        }

        protected virtual string VisitNewArray(NewArrayExpression na)
        {
            var exprs = VisitExpressionList(na.Expressions);

            //don&#39;t execute if compiled
            if (Visited == false)
            {
                var r = new StringBuilder();
                foreach (var e in exprs)
                {
                    r.Append(r.Length &gt; 0 ? &quot;,&quot; + e : e);
                }

                return r.ToString();
            }
            //already compiled, return
            return string.Empty;
        }

        protected virtual List&lt;object&gt; VisitNewArrayFromExpressionList(NewArrayExpression na)
        {
            var exprs = VisitExpressionList(na.Expressions);
            return exprs;
        }

        protected virtual string BindOperant(ExpressionType e)
        {
            switch (e)
            {
                case ExpressionType.Equal:
                    return &quot;=&quot;;
                case ExpressionType.NotEqual:
                    return &quot;&lt;&gt;&quot;;
                case ExpressionType.GreaterThan:
                    return &quot;&gt;&quot;;
                case ExpressionType.GreaterThanOrEqual:
                    return &quot;&gt;=&quot;;
                case ExpressionType.LessThan:
                    return &quot;&lt;&quot;;
                case ExpressionType.LessThanOrEqual:
                    return &quot;&lt;=&quot;;
                case ExpressionType.AndAlso:
                    return &quot;AND&quot;;
                case ExpressionType.OrElse:
                    return &quot;OR&quot;;
                case ExpressionType.Add:
                    return &quot;+&quot;;
                case ExpressionType.Subtract:
                    return &quot;-&quot;;
                case ExpressionType.Multiply:
                    return &quot;*&quot;;
                case ExpressionType.Divide:
                    return &quot;/&quot;;
                case ExpressionType.Modulo:
                    return &quot;MOD&quot;;
                case ExpressionType.Coalesce:
                    return &quot;COALESCE&quot;;
                default:
                    return e.ToString();
            }
        }

        protected virtual string VisitMethodCall(MethodCallExpression m)
        {
            //Here&#39;s what happens with a MethodCallExpression:
            //  If a method is called that contains a single argument,
            //      then m.Object is the object on the left hand side of the method call, example:
            //      x.Path.StartsWith(content.Path)
            //          m.Object = x.Path
            //          and m.Arguments.Length == 1, therefor m.Arguments[0] == content.Path
            //  If a method is called that contains multiple arguments, then m.Object == null and the
            //      m.Arguments collection contains the left hand side of the method call, example:
            //      x.Path.SqlStartsWith(content.Path, TextColumnType.NVarchar)
            //          m.Object == null
            //          m.Arguments.Length == 3, therefor, m.Arguments[0] == x.Path, m.Arguments[1] == content.Path, m.Arguments[2] == TextColumnType.NVarchar
            // So, we need to cater for these scenarios.

            var objectForMethod = m.Object ?? m.Arguments[0];
            var visitedObjectForMethod = Visit(objectForMethod);
            var methodArgs = m.Object == null
                ? m.Arguments.Skip(1).ToArray()
                : m.Arguments.ToArray();

            switch (m.Method.Name)
            {
                case &quot;ToString&quot;:
                    SqlParameters.Add(objectForMethod.ToString());
                    //don&#39;t execute if compiled
                    if (Visited == false)
                        return string.Format(&quot;@{0}&quot;, SqlParameters.Count - 1);
                    //already compiled, return
                    return string.Empty;
                case &quot;ToUpper&quot;:
                    //don&#39;t execute if compiled
                    if (Visited == false)
                        return string.Format(&quot;upper({0})&quot;, visitedObjectForMethod);
                    //already compiled, return
                    return string.Empty;
                case &quot;ToLower&quot;:
                    //don&#39;t execute if compiled
                    if (Visited == false)
                        return string.Format(&quot;lower({0})&quot;, visitedObjectForMethod);
                    //already compiled, return
                    return string.Empty;
                case &quot;SqlWildcard&quot;:
                case &quot;StartsWith&quot;:
                case &quot;EndsWith&quot;:
                case &quot;Contains&quot;:
                case &quot;Equals&quot;:
                case &quot;SqlStartsWith&quot;:
                case &quot;SqlEndsWith&quot;:
                case &quot;SqlContains&quot;:
                case &quot;SqlEquals&quot;:
                case &quot;InvariantStartsWith&quot;:
                case &quot;InvariantEndsWith&quot;:
                case &quot;InvariantContains&quot;:
                case &quot;InvariantEquals&quot;:

                    //special case, if it is &#39;Contains&#39; and the argument that Contains is being called on is 
                    //Enumerable and the methodArgs is the actual member access, then it&#39;s an SQL IN clause
                    if (m.Object == null 
                        &amp;&amp; m.Arguments[0].Type != typeof(string)
                        &amp;&amp; m.Arguments.Count == 2
                        &amp;&amp; methodArgs.Length == 1 
                        &amp;&amp; methodArgs[0].NodeType == ExpressionType.MemberAccess
                        &amp;&amp; TypeHelper.IsTypeAssignableFrom&lt;IEnumerable&gt;(m.Arguments[0].Type))
                    {
                        goto case &quot;SqlIn&quot;;
                    }

                    string compareValue;

                    if (methodArgs[0].NodeType != ExpressionType.Constant)
                    {
                        //This occurs when we are getting a value from a non constant such as: x =&gt; x.Path.StartsWith(content.Path)
                        // So we&#39;ll go get the value:
                        var member = Expression.Convert(methodArgs[0], typeof(object));
                        var lambda = Expression.Lambda&lt;Func&lt;object&gt;&gt;(member);
                        var getter = lambda.Compile();
                        compareValue = getter().ToString();
                    }
                    else
                    {
                        compareValue = methodArgs[0].ToString();
                    }

                    //default column type
                    var colType = TextColumnType.NVarchar;

                    //then check if the col type argument has been passed to the current method (this will be the case for methods like
                    // SqlContains and other Sql methods)
                    if (methodArgs.Length &gt; 1)
                    {
                        var colTypeArg = methodArgs.FirstOrDefault(x =&gt; x is ConstantExpression &amp;&amp; x.Type == typeof(TextColumnType));
                        if (colTypeArg != null)
                        {
                            colType = (TextColumnType)((ConstantExpression)colTypeArg).Value;
                        }
                    }

                    return HandleStringComparison(visitedObjectForMethod, compareValue, m.Method.Name, colType);

                case &quot;Replace&quot;:
                    string searchValue;

                    if (methodArgs[0].NodeType != ExpressionType.Constant)
                    {
                        //This occurs when we are getting a value from a non constant such as: x =&gt; x.Path.StartsWith(content.Path)
                        // So we&#39;ll go get the value:
                        var member = Expression.Convert(methodArgs[0], typeof(object));
                        var lambda = Expression.Lambda&lt;Func&lt;object&gt;&gt;(member);
                        var getter = lambda.Compile();
                        searchValue = getter().ToString();
                    }
                    else
                    {
                        searchValue = methodArgs[0].ToString();
                    }

                    if (methodArgs[0].Type != typeof(string) &amp;&amp; TypeHelper.IsTypeAssignableFrom&lt;IEnumerable&gt;(methodArgs[0].Type))
                    {
                        throw new NotSupportedException(&quot;An array Contains method is not supported&quot;);
                    }

                    string replaceValue;

                    if (methodArgs[1].NodeType != ExpressionType.Constant)
                    {
                        //This occurs when we are getting a value from a non constant such as: x =&gt; x.Path.StartsWith(content.Path)
                        // So we&#39;ll go get the value:
                        var member = Expression.Convert(methodArgs[1], typeof(object));
                        var lambda = Expression.Lambda&lt;Func&lt;object&gt;&gt;(member);
                        var getter = lambda.Compile();
                        replaceValue = getter().ToString();
                    }
                    else
                    {
                        replaceValue = methodArgs[1].ToString();
                    }

                    if (methodArgs[1].Type != typeof(string) &amp;&amp; TypeHelper.IsTypeAssignableFrom&lt;IEnumerable&gt;(methodArgs[1].Type))
                    {
                        throw new NotSupportedException(&quot;An array Contains method is not supported&quot;);
                    }

                    SqlParameters.Add(RemoveQuote(searchValue));

                    SqlParameters.Add(RemoveQuote(replaceValue));

                    //don&#39;t execute if compiled
                    if (Visited == false)
                        return string.Format(&quot;replace({0}, @{1}, @{2})&quot;, visitedObjectForMethod, SqlParameters.Count - 2, SqlParameters.Count - 1);
                    //already compiled, return
                    return string.Empty;

                //case &quot;Substring&quot;:
                //    var startIndex = Int32.Parse(args[0].ToString()) + 1;
                //    if (args.Count == 2)
                //    {
                //        var length = Int32.Parse(args[1].ToString());
                //        return string.Format(&quot;substring({0} from {1} for {2})&quot;,
                //                         r,
                //                         startIndex,
                //                         length);
                //    }
                //    else
                //        return string.Format(&quot;substring({0} from {1})&quot;,
                //                         r,
                //                         startIndex);
                //case &quot;Round&quot;:
                //case &quot;Floor&quot;:
                //case &quot;Ceiling&quot;:
                //case &quot;Coalesce&quot;:
                //case &quot;Abs&quot;:
                //case &quot;Sum&quot;:
                //    return string.Format(&quot;{0}({1}{2})&quot;,
                //                         m.Method.Name,
                //                         r,
                //                         args.Count == 1 ? string.Format(&quot;,{0}&quot;, args[0]) : &quot;&quot;);
                //case &quot;Concat&quot;:
                //    var s = new StringBuilder();
                //    foreach (Object e in args)
                //    {
                //        s.AppendFormat(&quot; || {0}&quot;, e);
                //    }
                //    return string.Format(&quot;{0}{1}&quot;, r, s);

                case &quot;SqlIn&quot;:

                    if (m.Object == null &amp;&amp; methodArgs.Length == 1 &amp;&amp; methodArgs[0].NodeType == ExpressionType.MemberAccess)
                    {
                        var memberAccess = VisitMemberAccess((MemberExpression) methodArgs[0]);
                        
                        var member = Expression.Convert(m.Arguments[0], typeof(object));
                        var lambda = Expression.Lambda&lt;Func&lt;object&gt;&gt;(member);
                        var getter = lambda.Compile();

                        var inArgs = (IEnumerable)getter();

                        var sIn = new StringBuilder();
                        foreach (var e in inArgs)
                        {
                            SqlParameters.Add(e);

                            sIn.AppendFormat(&quot;{0}{1}&quot;,
                                sIn.Length &gt; 0 ? &quot;,&quot; : &quot;&quot;,
                                string.Format(&quot;@{0}&quot;, SqlParameters.Count - 1));
                        }

                        return string.Format(&quot;{0} IN ({1})&quot;, memberAccess, sIn);
                    }

                    throw new NotSupportedException(&quot;SqlIn must contain the member being accessed&quot;);

                //case &quot;Desc&quot;:
                //    return string.Format(&quot;{0} DESC&quot;, r);
                //case &quot;Alias&quot;:
                //case &quot;As&quot;:
                //    return string.Format(&quot;{0} As {1}&quot;, r,
                //                                GetQuotedColumnName(RemoveQuoteFromAlias(RemoveQuote(args[0].ToString()))));

                default:

                    throw new ArgumentOutOfRangeException(&quot;No logic supported for &quot; + m.Method.Name);

                    //var s2 = new StringBuilder();
                    //foreach (Object e in args)
                    //{
                    //    s2.AppendFormat(&quot;,{0}&quot;, GetQuotedValue(e, e.GetType()));
                    //}
                    //return string.Format(&quot;{0}({1}{2})&quot;, m.Method.Name, r, s2.ToString());
            }
        }

        public virtual string GetQuotedTableName(string tableName)
        {
            return Visited ? tableName : string.Format(&quot;\&quot;{0}\&quot;&quot;, tableName);
        }

        public virtual string GetQuotedColumnName(string columnName)
        {
            return Visited ? columnName : string.Format(&quot;\&quot;{0}\&quot;&quot;, columnName);
        }

        public virtual string GetQuotedName(string name)
        {
            return Visited ? name : string.Format(&quot;\&quot;{0}\&quot;&quot;, name);
        }

        protected string HandleStringComparison(string col, string val, string verb, TextColumnType columnType)
        {
            switch (verb)
            {
                case &quot;SqlWildcard&quot;:
                    SqlParameters.Add(RemoveQuote(val));
                    //don&#39;t execute if compiled
                    if (Visited == false)
                        return SqlSyntax.GetStringColumnWildcardComparison(col, SqlParameters.Count - 1, columnType);
                    //already compiled, return
                    return string.Empty;
                case &quot;Equals&quot;:
                    SqlParameters.Add(RemoveQuote(val));
                    //don&#39;t execute if compiled
                    if (Visited == false)
                        return SqlSyntax.GetStringColumnEqualComparison(col, SqlParameters.Count - 1, columnType);
                    //already compiled, return
                    return string.Empty;
                case &quot;StartsWith&quot;:
                    SqlParameters.Add(string.Format(&quot;{0}{1}&quot;,
                        RemoveQuote(val),
                        SqlSyntax.GetWildcardPlaceholder()));
                    //don&#39;t execute if compiled
                    if (Visited == false)
                        return SqlSyntax.GetStringColumnWildcardComparison(col, SqlParameters.Count - 1, columnType);
                    //already compiled, return
                    return string.Empty;
                case &quot;EndsWith&quot;:
                    SqlParameters.Add(string.Format(&quot;{0}{1}&quot;,
                        SqlSyntax.GetWildcardPlaceholder(),
                        RemoveQuote(val)));
                    //don&#39;t execute if compiled
                    if (Visited == false)
                        return SqlSyntax.GetStringColumnWildcardComparison(col, SqlParameters.Count - 1, columnType);
                    //already compiled, return
                    return string.Empty;
                case &quot;Contains&quot;:
                    SqlParameters.Add(string.Format(&quot;{0}{1}{0}&quot;,
                        SqlSyntax.GetWildcardPlaceholder(),
                        RemoveQuote(val)));
                    //don&#39;t execute if compiled
                    if (Visited == false)
                        return SqlSyntax.GetStringColumnWildcardComparison(col, SqlParameters.Count - 1, columnType);
                    //already compiled, return
                    return string.Empty;
                case &quot;InvariantEquals&quot;:
                case &quot;SqlEquals&quot;:
                    //recurse
                    return HandleStringComparison(col, val, &quot;Equals&quot;, columnType);
                case &quot;InvariantStartsWith&quot;:
                case &quot;SqlStartsWith&quot;:
                    //recurse
                    return HandleStringComparison(col, val, &quot;StartsWith&quot;, columnType);
                case &quot;InvariantEndsWith&quot;:
                case &quot;SqlEndsWith&quot;:
                    //recurse
                    return HandleStringComparison(col, val, &quot;EndsWith&quot;, columnType);
                case &quot;InvariantContains&quot;:
                case &quot;SqlContains&quot;:
                    //recurse
                    return HandleStringComparison(col, val, &quot;Contains&quot;, columnType);
                default:
                    throw new ArgumentOutOfRangeException(&quot;verb&quot;);
            }
        }

        //public virtual string GetQuotedValue(object value, Type fieldType, Func&lt;object, string&gt; escapeCallback = null, Func&lt;Type, bool&gt; shouldQuoteCallback = null)
        //{
        //    if (value == null) return &quot;NULL&quot;;

        //    if (escapeCallback == null)
        //    {
        //        escapeCallback = EscapeParam;
        //    }
        //    if (shouldQuoteCallback == null)
        //    {
        //        shouldQuoteCallback = ShouldQuoteValue;
        //    }

        //    if (!fieldType.UnderlyingSystemType.IsValueType &amp;&amp; fieldType != typeof(string))
        //    {
        //        //if (TypeSerializer.CanCreateFromString(fieldType))
        //        //{
        //        //    return &quot;&#39;&quot; + escapeCallback(TypeSerializer.SerializeToString(value)) + &quot;&#39;&quot;;
        //        //}

        //        throw new NotSupportedException(
        //            string.Format(&quot;Property of type: {0} is not supported&quot;, fieldType.FullName));
        //    }

        //    if (fieldType == typeof(int))
        //        return ((int)value).ToString(CultureInfo.InvariantCulture);

        //    if (fieldType == typeof(float))
        //        return ((float)value).ToString(CultureInfo.InvariantCulture);

        //    if (fieldType == typeof(double))
        //        return ((double)value).ToString(CultureInfo.InvariantCulture);

        //    if (fieldType == typeof(decimal))
        //        return ((decimal)value).ToString(CultureInfo.InvariantCulture);

        //    if (fieldType == typeof(DateTime))
        //    {
        //        return &quot;&#39;&quot; + escapeCallback(((DateTime)value).ToIsoString()) + &quot;&#39;&quot;;
        //    }

        //    if (fieldType == typeof(bool))
        //        return ((bool)value) ? Convert.ToString(1, CultureInfo.InvariantCulture) : Convert.ToString(0, CultureInfo.InvariantCulture);

        //    return shouldQuoteCallback(fieldType)
        //               ? &quot;&#39;&quot; + escapeCallback(value) + &quot;&#39;&quot;
        //               : value.ToString();
        //}

        public virtual string EscapeParam(object paramValue)
        {
            return paramValue == null ? string.Empty : SqlSyntax.EscapeString(paramValue.ToString());
        }

        public virtual bool ShouldQuoteValue(Type fieldType)
        {
            return true;
        }

        protected virtual string RemoveQuote(string exp)
        {
            if ((exp.StartsWith(&quot;\&quot;&quot;) || exp.StartsWith(&quot;`&quot;) || exp.StartsWith(&quot;&#39;&quot;))
                    &amp;&amp;
                    (exp.EndsWith(&quot;\&quot;&quot;) || exp.EndsWith(&quot;`&quot;) || exp.EndsWith(&quot;&#39;&quot;)))
            {
                exp = exp.Remove(0, 1);
                exp = exp.Remove(exp.Length - 1, 1);
            }
            return exp;
        }

        //protected virtual string RemoveQuoteFromAlias(string expression)
        //{

        //    if ((expression.StartsWith(&quot;\&quot;&quot;) || expression.StartsWith(&quot;`&quot;) || expression.StartsWith(&quot;&#39;&quot;))
        //        &amp;&amp;
        //        (expression.EndsWith(&quot;\&quot;&quot;) || expression.EndsWith(&quot;`&quot;) || expression.EndsWith(&quot;&#39;&quot;)))
        //    {
        //        expression = expression.Remove(0, 1);
        //        expression = expression.Remove(expression.Length - 1, 1);
        //    }
        //    return expression;
        //}
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[22,45,22,49,1],[22,50,22,62,1],[29,17,29,18,1],[29,19,29,39,1],[29,40,29,41,1],[31,13,31,14,1],[32,17,32,29,1],[33,21,33,104,0],[34,17,34,38,1],[35,17,35,32,1],[36,13,36,14,1],[42,31,42,35,1],[42,36,42,48,1],[50,9,50,10,1],[51,13,51,42,1],[52,9,52,10,1],[61,9,61,70,1],[62,9,62,10,1],[63,13,63,35,1],[64,9,64,10,1],[70,34,70,38,1],[70,39,70,43,1],[75,50,75,54,1],[75,55,75,67,1],[80,9,80,76,1],[87,9,87,10,1],[88,13,88,44,1],[89,9,89,10,1],[98,9,98,10,1],[101,13,101,67,1],[102,13,102,42,1],[103,13,103,14,1],[104,17,104,52,1],[105,17,105,63,1],[106,13,106,14,1],[108,13,108,36,1],[108,37,108,57,0],[112,13,112,41,1],[115,21,115,74,1],[116,21,116,27,1],[118,21,118,80,1],[119,21,119,27,1],[121,21,121,78,1],[122,21,122,27,1],[146,21,146,74,1],[147,21,147,27,1],[156,21,156,72,1],[157,21,157,27,1],[159,21,159,80,0],[160,21,160,27,0],[162,21,162,82,1],[163,21,163,27,1],[165,21,165,68,1],[166,21,166,27,1],[169,21,169,78,0],[170,21,170,27,0],[172,21,172,52,0],[173,21,173,27,0],[178,13,178,42,1],[179,13,179,14,1],[180,17,180,55,1],[181,21,181,59,1],[182,17,182,55,1],[183,13,183,14,1],[185,13,185,27,1],[186,9,186,10,1],[191,9,191,10,1],[192,13,192,69,1],[193,13,193,14,1],[194,17,194,57,1],[196,17,196,55,1],[197,17,197,18,1],[199,21,199,50,1],[201,21,201,45,1],[203,21,203,109,1],[206,13,206,14,0],[207,13,207,39,1],[208,9,208,10,1],[211,9,211,10,1],[212,13,212,37,1],[213,13,213,38,1],[215,13,215,51,1],[216,13,216,53,1],[217,13,217,14,1],[218,17,218,52,1],[219,17,219,55,1],[220,17,220,18,0],[221,21,221,53,0],[223,21,223,42,0],[226,21,226,42,0],[227,21,227,22,0],[228,25,228,88,0],[229,21,229,22,0],[230,17,230,18,0],[232,17,232,18,1],[233,21,233,42,1],[234,17,234,18,1],[235,17,235,49,1],[236,17,236,55,1],[237,17,237,18,0],[238,21,238,50,0],[240,21,240,42,0],[243,21,243,42,0],[244,21,244,22,0],[245,25,245,89,0],[246,21,246,22,0],[247,17,247,18,0],[249,17,249,18,1],[250,21,250,44,1],[251,17,251,18,1],[252,13,252,14,1],[253,18,253,37,1],[254,13,254,14,1],[256,17,256,64,1],[257,17,257,75,1],[258,21,258,92,1],[259,17,259,40,1],[262,17,262,62,1],[263,17,263,73,1],[264,21,264,93,0],[265,17,265,38,1],[266,13,266,14,1],[267,18,267,38,1],[268,13,268,14,1],[270,17,270,64,1],[271,17,271,75,1],[272,21,272,92,1],[273,17,273,40,1],[276,17,276,62,1],[277,17,277,73,1],[278,21,278,93,0],[279,17,279,38,1],[280,13,280,14,1],[282,13,282,14,1],[283,17,283,38,1],[284,17,284,40,1],[285,13,285,14,1],[287,13,287,51,1],[287,52,287,67,1],[288,18,288,57,1],[288,58,288,77,1],[289,18,289,56,1],[290,13,290,14,1],[297,13,297,14,1],[299,13,299,29,1],[304,21,304,42,0],[305,21,305,22,0],[306,25,306,84,0],[309,21,309,41,0],[312,21,312,42,1],[313,21,313,22,1],[314,25,314,88,1],[317,21,317,41,0],[319,9,319,10,1],[322,9,322,10,0],[323,13,323,43,0],[324,18,324,27,0],[324,29,324,47,0],[324,49,324,54,0],[324,56,324,59,0],[325,13,325,14,0],[326,17,327,75,0],[328,17,328,18,0],[329,21,329,103,0],[330,17,330,18,0],[332,17,332,18,0],[333,21,333,50,0],[334,17,334,18,0],[335,13,335,14,0],[336,13,336,25,0],[337,9,337,10,0],[340,9,340,10,1],[342,13,342,66,1],[343,13,343,66,1],[345,13,345,14,1],[346,17,346,47,1],[347,17,347,34,1],[349,17,349,38,1],[352,17,352,38,1],[353,17,353,18,1],[354,21,354,75,1],[357,17,357,37,0],[359,13,359,46,0],[360,13,360,14,0],[362,17,362,38,0],[363,17,363,18,0],[365,21,365,77,0],[366,21,366,49,0],[367,21,367,28,0],[367,30,367,35,0],[367,36,367,38,0],[367,39,367,44,0],[368,21,368,22,0],[369,25,371,32,0],[372,21,372,22,0],[373,21,373,41,0],[376,17,376,37,0],[378,9,378,10,1],[381,9,381,10,0],[382,13,382,27,0],[383,9,383,10,0],[386,9,386,10,1],[387,13,387,33,1],[388,17,388,31,1],[390,13,390,40,1],[393,13,393,34,1],[394,13,394,14,1],[395,17,395,71,1],[398,13,398,33,0],[399,9,399,10,1],[402,9,402,10,1],[403,13,403,32,1],[406,21,406,48,1],[408,21,408,45,1],[410,9,410,10,1],[413,9,413,10,1],[414,13,414,32,1],[419,13,419,34,1],[423,21,423,45,1],[425,21,425,42,1],[426,21,426,22,1],[427,25,427,94,1],[430,21,430,41,0],[433,21,433,42,1],[434,21,434,22,1],[436,25,436,63,1],[439,21,439,41,0],[441,9,441,10,1],[444,9,444,10,1],[445,13,445,32,1],[447,13,447,34,1],[451,21,451,45,1],[454,21,454,42,1],[455,21,455,22,1],[456,25,456,90,1],[459,21,459,41,0],[462,21,462,30,0],[464,9,464,10,1],[467,9,467,10,0],[468,13,468,61,0],[471,13,471,34,0],[472,13,472,14,0],[473,17,473,45,0],[474,17,474,24,0],[474,26,474,31,0],[474,32,474,34,0],[474,35,474,40,0],[475,17,475,18,0],[476,21,476,58,0],[477,17,477,18,0],[479,17,479,37,0],[482,13,482,33,0],[483,9,483,10,0],[486,9,486,10,0],[487,13,487,61,0],[488,13,488,26,0],[489,9,489,10,0],[492,9,492,10,1],[493,13,493,23,1],[496,21,496,32,1],[498,21,498,33,1],[500,21,500,32,1],[502,21,502,33,1],[504,21,504,32,1],[506,21,506,33,1],[508,21,508,34,1],[510,21,510,33,1],[512,21,512,32,0],[514,21,514,32,0],[516,21,516,32,0],[518,21,518,32,0],[520,21,520,34,0],[522,21,522,39,0],[524,21,524,41,0],[526,9,526,10,1],[529,9,529,10,1],[543,13,543,62,1],[544,13,544,65,1],[545,13,547,41,1],[549,13,549,35,1],[552,21,552,67,1],[554,21,554,42,1],[555,25,555,79,1],[557,21,557,41,0],[560,21,560,42,1],[561,25,561,84,1],[563,21,563,41,0],[566,21,566,42,0],[567,25,567,84,0],[569,21,569,41,0],[586,21,591,94,1],[592,21,592,22,1],[593,25,593,43,1],[598,21,598,75,1],[599,21,599,22,1],[602,25,602,88,1],[603,25,603,78,1],[604,25,604,55,1],[605,25,605,60,1],[606,21,606,22,1],[608,21,608,22,1],[609,25,609,65,1],[610,21,610,22,1],[613,21,613,59,1],[617,21,617,47,1],[618,21,618,22,1],[619,25,619,73,1],[619,73,619,132,1],[619,132,619,134,1],[619,25,619,134,1],[620,25,620,48,1],[621,25,621,26,1],[622,29,622,94,1],[623,25,623,26,1],[624,21,624,22,1],[626,21,626,113,1],[631,21,631,75,1],[632,21,632,22,0],[635,25,635,88,0],[636,25,636,78,0],[637,25,637,55,0],[638,25,638,59,0],[639,21,639,22,0],[641,21,641,22,1],[642,25,642,64,1],[643,21,643,22,1],[645,21,645,130,1],[646,21,646,22,0],[647,25,647,102,0],[652,21,652,75,1],[653,21,653,22,0],[656,25,656,88,0],[657,25,657,78,0],[658,25,658,55,0],[659,25,659,60,0],[660,21,660,22,0],[662,21,662,22,1],[663,25,663,65,1],[664,21,664,22,1],[666,21,666,130,1],[667,21,667,22,0],[668,25,668,102,0],[671,21,671,65,1],[673,21,673,66,1],[676,21,676,42,1],[677,25,677,148,1],[679,21,679,41,0],[715,21,715,125,1],[716,21,716,22,1],[717,25,717,96,1],[719,25,719,89,1],[720,25,720,78,1],[721,25,721,55,1],[723,25,723,60,1],[725,25,725,55,1],[726,25,726,32,1],[726,34,726,39,1],[726,40,726,42,1],[726,43,726,49,1],[727,25,727,26,1],[728,29,728,50,1],[730,29,732,81,1],[733,25,733,26,1],[735,25,735,81,1],[738,21,738,101,0],[749,21,749,102,0],[758,9,758,10,1],[761,9,761,10,0],[762,13,762,78,0],[763,9,763,10,0],[766,9,766,10,0],[767,13,767,80,0],[768,9,768,10,0],[771,9,771,10,0],[772,13,772,68,0],[773,9,773,10,0],[776,9,776,10,1],[777,13,777,26,1],[780,21,780,57,1],[782,21,782,42,1],[783,25,783,118,1],[785,21,785,41,0],[787,21,787,57,1],[789,21,789,42,1],[790,25,790,115,1],[792,21,792,41,0],[794,21,796,62,1],[798,21,798,42,1],[799,25,799,118,1],[801,21,801,41,1],[803,21,805,44,1],[807,21,807,42,1],[808,25,808,118,1],[810,21,810,41,0],[812,21,814,44,1],[816,21,816,42,1],[817,25,817,118,1],[819,21,819,41,0],[823,21,823,83,1],[827,21,827,87,1],[831,21,831,85,1],[835,21,835,85,1],[837,21,837,67,0],[839,9,839,10,1],[891,9,891,10,0],[892,13,892,102,0],[893,9,893,10,0],[896,9,896,10,0],[897,13,897,25,0],[898,9,898,10,0],[901,9,901,10,1],[902,13,904,84,1],[905,13,905,14,1],[906,17,906,40,1],[907,17,907,53,1],[908,13,908,14,1],[909,13,909,24,1],[910,9,910,10,1]]);
    </script>
  </body>
</html>