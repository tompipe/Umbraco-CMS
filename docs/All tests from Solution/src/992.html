<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\PropertyEditors\MultipleTextStringPropertyEditor.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Umbraco.Core;
using Umbraco.Core.Logging;
using Umbraco.Core.Models;
using Umbraco.Core.Models.Editors;
using Umbraco.Core.PropertyEditors;
using Umbraco.Core.Services;

namespace Umbraco.Web.PropertyEditors
{
    [PropertyEditor(Constants.PropertyEditors.MultipleTextstringAlias, &quot;Repeatable textstrings&quot;, &quot;multipletextbox&quot;, ValueType = PropertyEditorValueTypes.Text, Icon=&quot;icon-ordered-list&quot;, Group=&quot;lists&quot;)]
    public class MultipleTextStringPropertyEditor : PropertyEditor
    {
        protected override PropertyValueEditor CreateValueEditor()
        {
            return new MultipleTextStringPropertyValueEditor(base.CreateValueEditor());
        }

        protected override PreValueEditor CreatePreValueEditor()
        {
            return new MultipleTextStringPreValueEditor();
        }

        /// &lt;summary&gt;
        /// A custom pre-value editor class to deal with the legacy way that the pre-value data is stored.
        /// &lt;/summary&gt;
        internal class MultipleTextStringPreValueEditor : PreValueEditor
        {
            public MultipleTextStringPreValueEditor()
            {
                //create the fields
                Fields.Add(new PreValueField(new IntegerValidator())
                {
                    Description = &quot;Enter the minimum amount of text boxes to be displayed&quot;,
                    Key = &quot;min&quot;,
                    View = &quot;requiredfield&quot;,
                    Name = &quot;Minimum&quot;
                });
                Fields.Add(new PreValueField(new IntegerValidator())
                {
                    Description = &quot;Enter the maximum amount of text boxes to be displayed, enter 0 for unlimited&quot;,
                    Key = &quot;max&quot;,
                    View = &quot;requiredfield&quot;,
                    Name = &quot;Maximum&quot;
                });
            }

            /// &lt;summary&gt;
            /// Need to change how we persist the values so they are compatible with the legacy way we store values
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;editorValue&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;currentValue&quot;&gt;&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public override IDictionary&lt;string, PreValue&gt; ConvertEditorToDb(IDictionary&lt;string, object&gt; editorValue, PreValueCollection currentValue)
            {
                //the values from the editor will be min/max fieds and we need to format to json in one field
                var min = (editorValue.ContainsKey(&quot;min&quot;) ? editorValue[&quot;min&quot;].ToString() : &quot;0&quot;).TryConvertTo&lt;int&gt;();
                var max = (editorValue.ContainsKey(&quot;max&quot;) ? editorValue[&quot;max&quot;].ToString() : &quot;0&quot;).TryConvertTo&lt;int&gt;();

                var json = JObject.FromObject(new {Minimum = min.Success ? min.Result : 0, Maximum = max.Success ? max.Result : 0});

                return new Dictionary&lt;string, PreValue&gt; { { &quot;0&quot;, new PreValue(json.ToString(Formatting.None)) } };
            }

            /// &lt;summary&gt;
            /// Need to deal with the legacy way of storing pre-values and turn them into nice values for the editor
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;defaultPreVals&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;persistedPreVals&quot;&gt;&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public override IDictionary&lt;string, object&gt; ConvertDbToEditor(IDictionary&lt;string, object&gt; defaultPreVals, PreValueCollection persistedPreVals)
            {
                var preVals = persistedPreVals.FormatAsDictionary();
                var stringVal = preVals.Any() ? preVals.First().Value.Value : &quot;&quot;;
                var returnVal = new Dictionary&lt;string, object&gt; { { &quot;min&quot;, 0 }, { &quot;max&quot;, 0 } };
                if (stringVal.IsNullOrWhiteSpace() == false)
                {
                    try
                    {
                        var json = JsonConvert.DeserializeObject&lt;JObject&gt;(stringVal);
                        if (json[&quot;Minimum&quot;] != null)
                        {
                            //by default pre-values are sent out with an id/value pair
                            returnVal[&quot;min&quot;] = json[&quot;Minimum&quot;].Value&lt;int&gt;();
                        }
                        if (json[&quot;Maximum&quot;] != null)
                        {
                            returnVal[&quot;max&quot;] = json[&quot;Maximum&quot;].Value&lt;int&gt;();
                        }
                    }
                    catch (Exception e)
                    {
                        //this shouldn&#39;t happen unless there&#39;s already a bad formatted pre-value
                        LogHelper.WarnWithException&lt;MultipleTextStringPreValueEditor&gt;(&quot;Could not deserialize value to json &quot; + stringVal, e);
                        return returnVal;
                    }
                }

                return returnVal;
            }
        }

        /// &lt;summary&gt;
        /// Custom value editor so we can format the value for the editor and the database
        /// &lt;/summary&gt;
        internal class MultipleTextStringPropertyValueEditor : PropertyValueEditorWrapper
        {
            public MultipleTextStringPropertyValueEditor(PropertyValueEditor wrapped) : base(wrapped)
            {
            }
            
            /// &lt;summary&gt;
            /// The value passed in from the editor will be an array of simple objects so we&#39;ll need to parse them to get the string
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;editorValue&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;currentValue&quot;&gt;&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            /// &lt;remarks&gt;
            /// We will also check the pre-values here, if there are more items than what is allowed we&#39;ll just trim the end
            /// &lt;/remarks&gt;
            public override object ConvertEditorToDb(ContentPropertyData editorValue, object currentValue)
            {
                var asArray = editorValue.Value as JArray;
                if (asArray == null)
                {
                    return null;
                }

                var preVals = editorValue.PreValues.FormatAsDictionary();
                var max = -1;
                if (preVals.Any())
                {
                    try
                    {
                        var json = JsonConvert.DeserializeObject&lt;JObject&gt;(preVals.First().Value.Value);
                        max = int.Parse(json[&quot;Maximum&quot;].ToString());
                    }
                    catch (Exception)
                    {
                        //swallow
                        max = -1;
                    }                    
                }

                //The legacy property editor saved this data as new line delimited! strange but we have to maintain that.
                var array = asArray.OfType&lt;JObject&gt;()
                                   .Where(x =&gt; x[&quot;value&quot;] != null)
                                   .Select(x =&gt; x[&quot;value&quot;].Value&lt;string&gt;());
                
                //only allow the max if over 0
                if (max &gt; 0)
                {
                    return string.Join(Environment.NewLine, array.Take(max));    
                }
                
                return string.Join(Environment.NewLine, array);
            }

            /// &lt;summary&gt;
            /// We are actually passing back an array of simple objects instead of an array of strings because in angular a primitive (string) value
            /// cannot have 2 way binding, so to get around that each item in the array needs to be an object with a string.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;propertyType&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;dataTypeService&quot;&gt;&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            /// &lt;remarks&gt;
            /// The legacy property editor saved this data as new line delimited! strange but we have to maintain that.
            /// &lt;/remarks&gt;
            public override object ConvertDbToEditor(Property property, PropertyType propertyType, IDataTypeService dataTypeService)
            {
                return property.Value == null
                                  ? new JObject[] {}
                                  : property.Value.ToString().Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries)
                                           .Select(x =&gt; JObject.FromObject(new {value = x}));


            }

        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[21,9,21,10,0],[22,13,22,88,0],[23,9,23,10,0],[26,9,26,10,0],[27,13,27,59,0],[28,9,28,10,0],[35,13,35,54,0],[36,13,36,14,0],[38,17,44,20,0],[45,17,51,20,0],[52,13,52,14,0],[61,13,61,14,0],[63,17,63,118,0],[64,17,64,118,0],[66,17,66,133,0],[68,17,68,115,0],[69,13,69,14,0],[78,13,78,14,0],[79,17,79,69,0],[80,17,80,82,0],[81,17,81,95,0],[82,17,82,61,0],[83,17,83,18,0],[85,21,85,22,0],[86,25,86,86,0],[87,25,87,53,0],[88,25,88,26,0],[90,29,90,77,0],[91,25,91,26,0],[92,25,92,53,0],[93,25,93,26,0],[94,29,94,77,0],[95,25,95,26,0],[96,21,96,22,0],[97,21,97,40,0],[98,21,98,22,0],[100,25,100,142,0],[101,25,101,42,0],[103,17,103,18,0],[105,17,105,34,0],[106,13,106,14,0],[114,89,114,102,0],[115,13,115,14,0],[116,13,116,14,0],[128,13,128,14,0],[129,17,129,59,0],[130,17,130,37,0],[131,17,131,18,0],[132,21,132,33,0],[135,17,135,74,0],[136,17,136,30,0],[137,17,137,35,0],[138,17,138,18,0],[140,21,140,22,0],[141,25,141,104,0],[142,25,142,69,0],[143,21,143,22,0],[144,21,144,38,0],[145,21,145,22,0],[147,25,147,34,0],[148,21,148,22,0],[149,17,149,18,0],[152,17,153,48,0],[153,48,153,66,0],[153,66,154,49,0],[154,49,154,75,0],[154,75,154,77,0],[152,17,154,77,0],[157,17,157,29,0],[158,17,158,18,0],[159,21,159,78,0],[162,17,162,64,0],[163,13,163,14,0],[177,13,177,14,0],[178,17,181,57,0],[181,57,181,92,0],[181,92,181,94,0],[178,17,181,94,0],[184,13,184,14,0]]);
    </script>
  </body>
</html>