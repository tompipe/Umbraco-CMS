<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Persistence\Repositories\RepositoryBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Umbraco.Core.Cache;
using Umbraco.Core.Collections;
using Umbraco.Core.Logging;
using Umbraco.Core.Models.EntityBase;

using Umbraco.Core.Persistence.Querying;
using Umbraco.Core.Persistence.UnitOfWork;

namespace Umbraco.Core.Persistence.Repositories
{
    public abstract class RepositoryBase : DisposableObject
    {
        private readonly IUnitOfWork _work;
        private readonly CacheHelper _cache;

        protected RepositoryBase(IUnitOfWork work, CacheHelper cache, ILogger logger)
        {
            if (work == null) throw new ArgumentNullException(&quot;work&quot;);
            if (cache == null) throw new ArgumentNullException(&quot;cache&quot;);
            if (logger == null) throw new ArgumentNullException(&quot;logger&quot;);
            Logger = logger;
            _work = work;
            _cache = cache;
        }

        /// &lt;summary&gt;
        /// Returns the Unit of Work added to the repository
        /// &lt;/summary&gt;
        protected internal IUnitOfWork UnitOfWork
        {
            get { return _work; }
        }

        /// &lt;summary&gt;
        /// Internal for testing purposes
        /// &lt;/summary&gt;
        internal Guid UnitKey
        {
            get { return (Guid)_work.Key; }
        }

        protected CacheHelper RepositoryCache
        {
            get { return _cache; }
        }

        /// &lt;summary&gt;
        /// The runtime cache used for this repo - by standard this is the runtime cache exposed by the CacheHelper but can be overridden
        /// &lt;/summary&gt;
        protected virtual IRuntimeCacheProvider RuntimeCache
        {
            get { return _cache.RuntimeCache; }
        }

        public static string GetCacheIdKey&lt;T&gt;(object id)
        {
            return string.Format(&quot;{0}{1}&quot;, GetCacheTypeKey&lt;T&gt;(), id);
        }

        public static string GetCacheTypeKey&lt;T&gt;()
        {
            return string.Format(&quot;uRepo_{0}_&quot;, typeof(T).Name);
        }

        protected ILogger Logger { get; private set; }
    }

    /// &lt;summary&gt;
    /// Represent an abstract Repository, which is the base of the Repository implementations
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TEntity&quot;&gt;Type of &lt;see cref=&quot;IAggregateRoot&quot;/&gt; entity for which the repository is used&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TId&quot;&gt;Type of the Id used for this entity&lt;/typeparam&gt;
    public abstract class RepositoryBase&lt;TId, TEntity&gt; : RepositoryBase, IRepositoryQueryable&lt;TId, TEntity&gt;, IUnitOfWorkRepository
        where TEntity : class, IAggregateRoot
    {
        protected RepositoryBase(IUnitOfWork work, CacheHelper cache, ILogger logger)
            : base(work, cache, logger)
        {
        }


        #region Static Queries

        private IQuery&lt;TEntity&gt; _hasIdQuery;

        #endregion

        protected virtual TId GetEntityId(TEntity entity)
        {
            return (TId)(object)entity.Id;
        }

        /// &lt;summary&gt;
        /// The runtime cache used for this repo by default is the isolated cache for this type
        /// &lt;/summary&gt;
        protected override IRuntimeCacheProvider RuntimeCache
        {
            get { return RepositoryCache.IsolatedRuntimeCache.GetOrCreateCache&lt;TEntity&gt;(); }
        }

        private IRepositoryCachePolicyFactory&lt;TEntity, TId&gt; _cachePolicyFactory;
        /// &lt;summary&gt;
        /// Returns the Cache Policy for the repository
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// The Cache Policy determines how each entity or entity collection is cached
        /// &lt;/remarks&gt;
        protected virtual IRepositoryCachePolicyFactory&lt;TEntity, TId&gt; CachePolicyFactory
        {
            get
            {
                return _cachePolicyFactory ?? (_cachePolicyFactory = new DefaultRepositoryCachePolicyFactory&lt;TEntity, TId&gt;(
                    RuntimeCache,
                    new RepositoryCachePolicyOptions(() =&gt;
                    {
                        //create it once if it is needed (no need for locking here)
                        if (_hasIdQuery == null)
                        {
                            _hasIdQuery = Query&lt;TEntity&gt;.Builder.Where(x =&gt; x.Id != 0);
                        }

                        //Get count of all entities of current type (TEntity) to ensure cached result is correct
                        return PerformCount(_hasIdQuery);
                    })));
            }
        }

        /// &lt;summary&gt;
        /// Adds or Updates an entity of type TEntity
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;This method is backed by an &lt;see cref=&quot;IRuntimeCacheProvider&quot;/&gt; cache&lt;/remarks&gt;
        /// &lt;param name=&quot;entity&quot;&gt;&lt;/param&gt;
        public void AddOrUpdate(TEntity entity)
        {
            if (entity.HasIdentity == false)
            {
                UnitOfWork.RegisterAdded(entity, this);
            }
            else
            {
                UnitOfWork.RegisterChanged(entity, this);
            }
        }

        /// &lt;summary&gt;
        /// Deletes the passed in entity
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;entity&quot;&gt;&lt;/param&gt;
        public virtual void Delete(TEntity entity)
        {
            if (UnitOfWork != null)
            {
                UnitOfWork.RegisterRemoved(entity, this);
            }
        }

        protected abstract TEntity PerformGet(TId id);
        /// &lt;summary&gt;
        /// Gets an entity by the passed in Id utilizing the repository&#39;s cache policy
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public TEntity Get(TId id)
        {
            using (var p = CachePolicyFactory.CreatePolicy())
            {
                return p.Get(id, PerformGet);
            }
        }

        protected abstract IEnumerable&lt;TEntity&gt; PerformGetAll(params TId[] ids);
        /// &lt;summary&gt;
        /// Gets all entities of type TEntity or a list according to the passed in Ids
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;ids&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public IEnumerable&lt;TEntity&gt; GetAll(params TId[] ids)
        {
            //ensure they are de-duplicated, easy win if people don&#39;t do this as this can cause many excess queries
            ids = ids.Distinct()
                //don&#39;t query by anything that is a default of T (like a zero)
                //TODO: I think we should enabled this in case accidental calls are made to get all with invalid ids
                //.Where(x =&gt; Equals(x, default(TId)) == false)
                .ToArray();

            if (ids.Length &gt; 2000)
            {
                throw new InvalidOperationException(&quot;Cannot perform a query with more than 2000 parameters&quot;);
            }

            using (var p = CachePolicyFactory.CreatePolicy())
            {
                var result = p.GetAll(ids, PerformGetAll);
                return result;
            }          
        }
        
        protected abstract IEnumerable&lt;TEntity&gt; PerformGetByQuery(IQuery&lt;TEntity&gt; query);
        /// &lt;summary&gt;
        /// Gets a list of entities by the passed in query
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;query&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public IEnumerable&lt;TEntity&gt; GetByQuery(IQuery&lt;TEntity&gt; query)
        {
            return PerformGetByQuery(query)
                //ensure we don&#39;t include any null refs in the returned collection!
                .WhereNotNull();
        }

        protected abstract bool PerformExists(TId id);
        /// &lt;summary&gt;
        /// Returns a boolean indicating whether an entity with the passed Id exists
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool Exists(TId id)
        {
            using (var p = CachePolicyFactory.CreatePolicy())
            {
                return p.Exists(id, PerformExists);
            }
        }

        protected abstract int PerformCount(IQuery&lt;TEntity&gt; query);
        /// &lt;summary&gt;
        /// Returns an integer with the count of entities found with the passed in query
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;query&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public int Count(IQuery&lt;TEntity&gt; query)
        {
            return PerformCount(query);
        }
        
        /// &lt;summary&gt;
        /// Unit of work method that tells the repository to persist the new entity
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;entity&quot;&gt;&lt;/param&gt;
        public virtual void PersistNewItem(IEntity entity)
        {
            var casted = (TEntity)entity;

            using (var p = CachePolicyFactory.CreatePolicy())
            {
                p.CreateOrUpdate(casted, PersistNewItem);
            }
        }

        /// &lt;summary&gt;
        /// Unit of work method that tells the repository to persist the updated entity
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;entity&quot;&gt;&lt;/param&gt;
        public virtual void PersistUpdatedItem(IEntity entity)
        {
            var casted = (TEntity)entity;

            using (var p = CachePolicyFactory.CreatePolicy())
            {
                p.CreateOrUpdate(casted, PersistUpdatedItem);
            }
        }

        /// &lt;summary&gt;
        /// Unit of work method that tells the repository to persist the deletion of the entity
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;entity&quot;&gt;&lt;/param&gt;
        public virtual void PersistDeletedItem(IEntity entity)
        {
            var casted = (TEntity)entity;

            using (var p = CachePolicyFactory.CreatePolicy())
            {
                p.Remove(casted, PersistDeletedItem);
            }            
        }
        

        protected abstract void PersistNewItem(TEntity item);
        protected abstract void PersistUpdatedItem(TEntity item);
        protected abstract void PersistDeletedItem(TEntity item);


        /// &lt;summary&gt;
        /// Dispose disposable properties
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// Ensure the unit of work is disposed
        /// &lt;/remarks&gt;
        protected override void DisposeResources()
        {
            UnitOfWork.DisposeIfDisposable();
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[20,9,20,86,1],[21,9,21,10,1],[22,13,22,30,1],[22,31,22,71,0],[23,13,23,31,1],[23,32,23,73,0],[24,13,24,32,1],[24,33,24,75,0],[25,13,25,29,1],[26,13,26,26,1],[27,13,27,28,1],[28,9,28,10,1],[35,17,35,18,1],[35,19,35,32,1],[35,33,35,34,1],[43,17,43,18,0],[43,19,43,42,0],[43,43,43,44,0],[48,17,48,18,1],[48,19,48,33,1],[48,34,48,35,1],[56,17,56,18,0],[56,19,56,46,0],[56,47,56,48,0],[60,9,60,10,1],[61,13,61,70,1],[62,9,62,10,1],[65,9,65,10,1],[66,13,66,64,1],[67,9,67,10,1],[69,36,69,40,1],[69,41,69,53,1],[81,15,81,40,1],[82,9,82,10,1],[83,9,83,10,1],[93,9,93,10,0],[94,13,94,43,0],[95,9,95,10,0],[102,17,102,18,1],[102,19,102,91,1],[102,92,102,93,1],[115,13,115,14,1],[116,17,119,21,1],[119,21,119,22,0],[119,22,121,25,1],[121,25,121,49,0],[121,49,122,25,1],[122,25,122,26,0],[122,26,123,29,1],[123,29,123,88,0],[123,88,124,25,1],[124,25,124,26,0],[124,26,127,25,1],[127,25,127,58,0],[127,58,128,21,1],[128,21,128,22,0],[128,22,128,26,1],[116,17,128,26,1],[129,13,129,14,1],[138,9,138,10,1],[139,13,139,45,1],[140,13,140,14,1],[141,17,141,56,1],[142,13,142,14,1],[144,13,144,14,1],[145,17,145,58,1],[146,13,146,14,1],[147,9,147,10,1],[154,9,154,10,1],[155,13,155,36,1],[156,13,156,14,1],[157,17,157,58,1],[158,13,158,14,1],[159,9,159,10,1],[168,9,168,10,1],[169,20,169,61,1],[170,13,170,14,1],[171,17,171,46,1],[173,9,173,10,1],[182,9,182,10,1],[184,13,188,28,1],[190,13,190,35,1],[191,13,191,14,0],[192,17,192,110,0],[195,20,195,61,1],[196,13,196,14,1],[197,17,197,59,1],[198,17,198,31,1],[200,9,200,10,1],[209,9,209,10,1],[210,13,212,33,1],[213,9,213,10,1],[222,9,222,10,1],[223,20,223,61,1],[224,13,224,14,1],[225,17,225,52,1],[227,9,227,10,1],[236,9,236,10,1],[237,13,237,40,1],[238,9,238,10,1],[245,9,245,10,1],[246,13,246,42,1],[248,20,248,61,1],[249,13,249,14,1],[250,17,250,58,1],[251,13,251,14,1],[252,9,252,10,1],[259,9,259,10,1],[260,13,260,42,1],[262,20,262,61,1],[263,13,263,14,1],[264,17,264,62,1],[265,13,265,14,1],[266,9,266,10,1],[273,9,273,10,1],[274,13,274,42,1],[276,20,276,61,1],[277,13,277,14,1],[278,17,278,54,1],[279,13,279,14,1],[280,9,280,10,1],[295,9,295,10,1],[296,13,296,46,1],[297,9,297,10,1]]);
    </script>
  </body>
</html>