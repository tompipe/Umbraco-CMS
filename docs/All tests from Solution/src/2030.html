<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Models\EntityBase\TracksChangesEntityBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;

namespace Umbraco.Core.Models.EntityBase
{
    /// &lt;summary&gt;
    /// A base class for use to implement IRememberBeingDirty/ICanBeDirty
    /// &lt;/summary&gt;
    [Serializable]
    [DataContract(IsReference = true)]
    public abstract class TracksChangesEntityBase : IRememberBeingDirty
    {
        //TODO: This needs to go on to ICanBeDirty http://issues.umbraco.org/issue/U4-5662
        public virtual IEnumerable&lt;string&gt; GetDirtyProperties()
        {
            return _propertyChangedInfo == null
                ? Enumerable.Empty&lt;string&gt;()
                : _propertyChangedInfo.Where(x =&gt; x.Value).Select(x =&gt; x.Key);
        }

        private bool _changeTrackingEnabled = true;

        /// &lt;summary&gt;
        /// Tracks the properties that have changed
        /// &lt;/summary&gt;
        private IDictionary&lt;string, bool&gt; _propertyChangedInfo;

        /// &lt;summary&gt;
        /// Tracks the properties that we&#39;re changed before the last commit (or last call to ResetDirtyProperties)
        /// &lt;/summary&gt;
        private IDictionary&lt;string, bool&gt; _lastPropertyChangedInfo;

        /// &lt;summary&gt;
        /// Property changed event
        /// &lt;/summary&gt;
        public event PropertyChangedEventHandler PropertyChanged;

        /// &lt;summary&gt;
        /// Method to call on a property setter.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyInfo&quot;&gt;The property info.&lt;/param&gt;
        protected virtual void OnPropertyChanged(PropertyInfo propertyInfo)
        {
            //return if we&#39;re not tracking changes
            if (_changeTrackingEnabled == false) return;

            if (_propertyChangedInfo == null)
                _propertyChangedInfo = new Dictionary&lt;string, bool&gt;();

            _propertyChangedInfo[propertyInfo.Name] = true;

            if (PropertyChanged != null)
                PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyInfo.Name));
        }

        /// &lt;summary&gt;
        /// Indicates whether a specific property on the current entity is dirty.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyName&quot;&gt;Name of the property to check&lt;/param&gt;
        /// &lt;returns&gt;True if Property is dirty, otherwise False&lt;/returns&gt;
        public virtual bool IsPropertyDirty(string propertyName)
        {
            return _propertyChangedInfo != null &amp;&amp; _propertyChangedInfo.Any(x =&gt; x.Key == propertyName);
        }

        /// &lt;summary&gt;
        /// Indicates whether the current entity is dirty.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;True if entity is dirty, otherwise False&lt;/returns&gt;
        public virtual bool IsDirty()
        {
            return _propertyChangedInfo != null &amp;&amp; _propertyChangedInfo.Any();
        }

        /// &lt;summary&gt;
        /// Indicates that the entity had been changed and the changes were committed
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public virtual bool WasDirty()
        {
            return _lastPropertyChangedInfo != null &amp;&amp; _lastPropertyChangedInfo.Any();
        }

        /// &lt;summary&gt;
        /// Indicates whether a specific property on the current entity was changed and the changes were committed
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;propertyName&quot;&gt;Name of the property to check&lt;/param&gt;
        /// &lt;returns&gt;True if Property was changed, otherwise False. Returns false if the entity had not been previously changed.&lt;/returns&gt;
        public virtual bool WasPropertyDirty(string propertyName)
        {
            return _lastPropertyChangedInfo != null &amp;&amp; _lastPropertyChangedInfo.Any(x =&gt; x.Key == propertyName);
        }

        /// &lt;summary&gt;
        /// Resets the remembered dirty properties from before the last commit
        /// &lt;/summary&gt;
        public void ForgetPreviouslyDirtyProperties()
        {
            //NOTE: We cannot .Clear() because when we memberwise clone this will be the SAME
            // instance as the one on the clone, so we need to create a new instance.
            _lastPropertyChangedInfo = null;
        }

        /// &lt;summary&gt;
        /// Resets dirty properties by clearing the dictionary used to track changes.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// Please note that resetting the dirty properties could potentially
        /// obstruct the saving of a new or updated entity.
        /// &lt;/remarks&gt;
        public virtual void ResetDirtyProperties()
        {
            ResetDirtyProperties(true);
        }

        /// &lt;summary&gt;
        /// Resets dirty properties by clearing the dictionary used to track changes.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;rememberPreviouslyChangedProperties&quot;&gt;
        /// true if we are to remember the last changes made after resetting
        /// &lt;/param&gt;
        /// &lt;remarks&gt;
        /// Please note that resetting the dirty properties could potentially
        /// obstruct the saving of a new or updated entity.
        /// &lt;/remarks&gt;
        public virtual void ResetDirtyProperties(bool rememberPreviouslyChangedProperties)
        {
            if (rememberPreviouslyChangedProperties)
            {
                //copy the changed properties to the last changed properties
                if (_propertyChangedInfo != null)
                {
                    _lastPropertyChangedInfo = _propertyChangedInfo.ToDictionary(v =&gt; v.Key, v =&gt; v.Value);
                }
            }

            //NOTE: We cannot .Clear() because when we memberwise clone this will be the SAME
            // instance as the one on the clone, so we need to create a new instance.
            _propertyChangedInfo = null;
        }

        public void ResetChangeTrackingCollections()
        {
            _propertyChangedInfo = null;
            _lastPropertyChangedInfo = null;
        }

        public void DisableChangeTracking()
        {
            _changeTrackingEnabled = false;
        }

        public void EnableChangeTracking()
        {
            _changeTrackingEnabled = true;
        }

        /// &lt;summary&gt;
        /// Used by inheritors to set the value of properties, this will detect if the property value actually changed and if it did
        /// it will ensure that the property has a dirty flag set.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;newVal&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;origVal&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;propertySelector&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;returns true if the value changed&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// This is required because we don&#39;t want a property to show up as &quot;dirty&quot; if the value is the same. For example, when we
        /// save a document type, nearly all properties are flagged as dirty just because we&#39;ve &#39;reset&#39; them, but they are all set
        /// to the same value, so it&#39;s really not dirty.
        /// &lt;/remarks&gt;
        internal void SetPropertyValueAndDetectChanges&lt;T&gt;(T newVal, ref T origVal, PropertyInfo propertySelector)
        {
            if ((typeof(T) == typeof(string) == false) &amp;&amp; TypeHelper.IsTypeAssignableFrom&lt;IEnumerable&gt;(typeof(T)))
            {
                throw new InvalidOperationException(&quot;This method does not support IEnumerable instances. For IEnumerable instances a manual custom equality check will be required&quot;);
            }

            SetPropertyValueAndDetectChanges(newVal, ref origVal, propertySelector, EqualityComparer&lt;T&gt;.Default);
        }

        /// &lt;summary&gt;
        /// Used by inheritors to set the value of properties, this will detect if the property value actually changed and if it did
        /// it will ensure that the property has a dirty flag set.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;newVal&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;origVal&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;propertySelector&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;comparer&quot;&gt;The equality comparer to use&lt;/param&gt;
        /// &lt;returns&gt;returns true if the value changed&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// This is required because we don&#39;t want a property to show up as &quot;dirty&quot; if the value is the same. For example, when we
        /// save a document type, nearly all properties are flagged as dirty just because we&#39;ve &#39;reset&#39; them, but they are all set
        /// to the same value, so it&#39;s really not dirty.
        /// &lt;/remarks&gt;
        internal void SetPropertyValueAndDetectChanges&lt;T&gt;(T newVal, ref T origVal, PropertyInfo propertySelector, IEqualityComparer&lt;T&gt; comparer)
        {
            //don&#39;t track changes, just set the value
            if (_changeTrackingEnabled == false)
            {
                //set the original value
                origVal = newVal;
            }
            else
            {
                //check changed
                var changed = comparer.Equals(origVal, newVal) == false;

                //set the original value
                origVal = newVal;

                //raise the event if it was changed
                if (changed)
                {
                    OnPropertyChanged(propertySelector);
                }
            }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[20,9,20,10,1],[21,13,23,51,1],[23,51,23,58,1],[23,58,23,72,1],[23,72,23,77,1],[23,77,23,79,1],[21,13,23,79,1],[24,9,24,10,1],[26,9,26,52,1],[48,9,48,10,1],[50,13,50,49,1],[50,50,50,57,1],[52,13,52,46,1],[53,17,53,71,1],[55,13,55,60,1],[57,13,57,41,1],[58,17,58,95,1],[59,9,59,10,1],[67,9,67,10,1],[68,13,68,82,1],[68,82,68,103,1],[68,103,68,105,1],[68,13,68,105,1],[69,9,69,10,1],[76,9,76,10,1],[77,13,77,79,1],[78,9,78,10,1],[85,9,85,10,1],[86,13,86,87,1],[87,9,87,10,1],[95,9,95,10,1],[96,13,96,90,1],[96,90,96,111,1],[96,111,96,113,1],[96,13,96,113,1],[97,9,97,10,1],[103,9,103,10,0],[106,13,106,45,0],[107,9,107,10,0],[117,9,117,10,1],[118,13,118,40,1],[119,9,119,10,1],[132,9,132,10,1],[133,13,133,53,1],[134,13,134,14,1],[136,17,136,50,1],[137,17,137,18,1],[138,21,138,87,1],[138,87,138,92,1],[138,92,138,99,1],[138,99,138,106,1],[138,106,138,108,1],[138,21,138,108,1],[139,17,139,18,1],[140,13,140,14,1],[144,13,144,41,1],[145,9,145,10,1],[148,9,148,10,1],[149,13,149,41,1],[150,13,150,45,1],[151,9,151,10,1],[154,9,154,10,1],[155,13,155,44,1],[156,9,156,10,1],[159,9,159,10,1],[160,13,160,43,1],[161,9,161,10,1],[177,9,177,10,1],[178,13,178,115,1],[179,13,179,14,0],[180,17,180,182,0],[183,13,183,114,1],[184,9,184,10,1],[201,9,201,10,1],[203,13,203,49,1],[204,13,204,14,1],[206,17,206,34,1],[207,13,207,14,1],[209,13,209,14,1],[211,17,211,73,1],[214,17,214,34,1],[217,17,217,29,1],[218,17,218,18,1],[219,21,219,57,1],[220,17,220,18,1],[221,13,221,14,1],[222,9,222,10,1]]);
    </script>
  </body>
</html>