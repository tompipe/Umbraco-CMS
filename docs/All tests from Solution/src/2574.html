<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\umbraco.datalayer\RecordsReaderAdapter.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/************************************************************************************
 * 
 *  Umbraco Data Layer
 *  MIT Licensed work
 *  ï¿½2008 Ruben Verborgh
 * 
 ***********************************************************************************/

using System;
using System.Data;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;

namespace umbraco.DataLayer
{
    /// &lt;summary&gt;
    /// Class that adapts a generic data reader to an IRecordsReader.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;D&quot;&gt;The data reader class&lt;/typeparam&gt;
    public abstract class RecordsReaderAdapter&lt;D&gt; : IRecordsReader
                                            where D : IDataReader, IDataRecord, IEnumerable
    {
        #region Private Fields

        /// &lt;summary&gt; Wrapped data reader. &lt;/summary&gt;
        private readonly D m_DataReader;

        /* Use the DebugDataLayer compile constant to get information about the opened RecordsReaderAdapters. */
        #if DEBUG &amp;&amp; DebugDataLayer

            /// &lt;summary&gt;Application unique identifier of this RecordsReaderAdapter.&lt;/summary&gt;
            /// &lt;remarks&gt;Used to track different instantiations for debug purposes.&lt;/remarks&gt;
            private readonly int m_Id;

            /// &lt;summary&gt;Application unique identifier that will be assigned to the next new RecordsReaderAdapter.&lt;/summary&gt;
            /// &lt;remarks&gt;Used to track different instantiations for debug purposes.&lt;/remarks&gt;
            private static int m_GlobalId = 0;

            /// &lt;summary&gt;List of identifiers of open RecordsReaderAdapters.&lt;/summary&gt;
            /// &lt;remarks&gt;Used to track different instantiations for debug purposes.&lt;/remarks&gt;
            private static List&lt;int&gt; m_OpenDataReaderIds = new List&lt;int&gt;();

        #endif

        #endregion

        #region Public Properties
        /// &lt;summary&gt;Gets the internal data reader.&lt;/summary&gt;
        /// &lt;value&gt;The data reader.&lt;/value&gt;
        public D DataReader
        {
            get { return m_DataReader; }
        }

        /// &lt;summary&gt;Gets the internal data reader.&lt;/summary&gt;
        /// &lt;value&gt;The data reader.&lt;/value&gt;
        /// &lt;remarks&gt;Obsolete. You should NOT try to close or dispose the RawDataReader,
        ///          but instead close or dispose this RecordsReaderAdapter.
        ///          Inheriting classes can call the protected DataReader property.&lt;/remarks&gt;
        [Obsolete(&quot;Only for backwards compatibility.&quot;, false)]
        public D RawDataReader
        {
            get { return m_DataReader; }
        }

        #endregion

        #region Constructors and destructors
        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;RecordsReaderAdapter&amp;lt;D&amp;gt;&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;dataReader&quot;&gt;The data reader.&lt;/param&gt;
        public RecordsReaderAdapter(D dataReader)
        {
            m_DataReader = dataReader;

            #if DEBUG &amp;&amp; DebugDataLayer
                lock (m_OpenDataReaderIds)
                {
                    // Get application unique identifier
                    m_Id = m_GlobalId++;
                    // Signal the creation of this new RecordsReaderAdapter
                    m_OpenDataReaderIds.Add(m_Id);
                    StackFrame stackFrame = new StackFrame(4);
                    string caller = stackFrame.GetMethod().ReflectedType.Name + &quot;.&quot; + stackFrame.GetMethod().Name;
                    Trace.TraceInformation(m_Id + &quot;. RecordsReader created by &quot; + caller + &quot;. &quot;
                                               + &quot;Open Data Readers: &quot; + m_OpenDataReaderIds.Count);
                }
            #endif
        }

        /// &lt;summary&gt;
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// &lt;see cref=&quot;RecordsReaderAdapter&amp;lt;D&amp;gt;&quot;/&gt; is reclaimed by garbage collection.
        /// &lt;/summary&gt;
        ~RecordsReaderAdapter()
        {
            Dispose(false);
        }
        #endregion

        #region IRecordsReader Members

        /// &lt;summary&gt;
        /// Closes the data reader.
        /// &lt;/summary&gt;
        public virtual void Close()
        {
            try
            {
                m_DataReader.Close();
            }
            catch { }

            #if DEBUG &amp;&amp; DebugDataLayer
                // Log closing
                lock (m_OpenDataReaderIds)
                {
                    m_OpenDataReaderIds.Remove(m_Id);
                    Trace.TraceInformation(m_Id + &quot;. RecordsReader closed. &quot;
                                               + &quot;Open Data Readers: &quot; + m_OpenDataReaderIds.Count);
                }
            #endif
        }

        /// &lt;summary&gt;
        /// Gets the depth of nesting of the current row.
        /// &lt;/summary&gt;
        /// &lt;value&gt;The depth of nesting of the current row.&lt;/value&gt;
        public int Depth
        {
            get { return m_DataReader.Depth; }
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether this instance is closed.
        /// &lt;/summary&gt;
        /// &lt;value&gt;&lt;c&gt;true&lt;/c&gt; if this instance is closed; otherwise, &lt;c&gt;false&lt;/c&gt;.&lt;/value&gt;
        public bool IsClosed
        {
            get { return m_DataReader.IsClosed; }
        }

        /// &lt;summary&gt;
        /// Advances to the next record.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// &lt;c&gt;true&lt;/c&gt; if there are more records; otherwise, &lt;c&gt;false&lt;/c&gt;.
        /// &lt;/returns&gt;
        public bool Read()
        {
            return m_DataReader.Read();
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether this instance has records.
        /// &lt;/summary&gt;
        /// &lt;value&gt;
        /// 	&lt;c&gt;true&lt;/c&gt; if this instance has records; otherwise, &lt;c&gt;false&lt;/c&gt;.
        /// &lt;/value&gt;
        public abstract bool HasRecords { get; }

        /// &lt;summary&gt;
        /// Gets the value of the specified field.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;FieldType&quot;&gt;The field type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the specified field&lt;/returns&gt;
        public FieldType Get&lt;FieldType&gt;(string fieldName)
        {
            switch (typeof(FieldType).FullName)
            {
                case &quot;System.Boolean&quot;:  return (FieldType)(object)GetBoolean(fieldName);
                case &quot;System.Byte&quot;:     return (FieldType)(object)GetByte(fieldName);
                case &quot;System.DateTime&quot;: return (FieldType)(object)GetDateTime(fieldName);
                case &quot;System.Decimal&quot;:  return (FieldType)(object)GetDecimal(fieldName);
                case &quot;System.Double&quot;:   return (FieldType)(object)GetDouble(fieldName);
                case &quot;System.Single&quot;:   return (FieldType)(object)GetFloat(fieldName);
                case &quot;System.Guid&quot;:     return (FieldType)(object)GetGuid(fieldName);
                case &quot;System.Int16&quot;:    return (FieldType)(object)GetShort(fieldName);
                case &quot;System.Int32&quot;:    return (FieldType)(object)GetInt(fieldName);
                case &quot;System.Int64&quot;:    return (FieldType)(object)GetLong(fieldName);
                case &quot;System.String&quot;:   return (FieldType)(object)GetString(fieldName);
                default:                return (FieldType)GetObject(fieldName);
            }
        }

        /// &lt;summary&gt;
        /// Gets the value of the specified field as a bool.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the field.&lt;/returns&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;No column with the specified name was found.&lt;/exception&gt;
        public bool GetBoolean(string fieldName)
        {
            return m_DataReader.GetBoolean(GetOrdinal(fieldName));
        }

        /// &lt;summary&gt;
        /// Gets the value of the specified field as a byte.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the field.&lt;/returns&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;No column with the specified name was found.&lt;/exception&gt;
        public byte GetByte(string fieldName)
        {
            // this is needed as SQL CE 4 doesn&#39;t support smallint/tinyint as IDENTITY columns. So some columns that are
            // int16 in SQL Server (smallint/tinyint) will be int32 (int) in SQL CE 4
            int fieldNo = GetOrdinal(fieldName);
            Type t = m_DataReader.GetFieldType(fieldNo);
            if (t.FullName.ToLower() == &quot;system.int32&quot;) // SQL CE4 behavior
                return Byte.Parse(m_DataReader.GetInt32(fieldNo).ToString());

            return m_DataReader.GetByte(fieldNo);
        }

        /// &lt;summary&gt;
        /// Gets the value of the specified field as a DateTime.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the field.&lt;/returns&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;No column with the specified name was found.&lt;/exception&gt;
        public DateTime GetDateTime(string fieldName)
        {
            return m_DataReader.GetDateTime(GetOrdinal(fieldName));
        }

        /// &lt;summary&gt;
        /// Gets the value of the specified field as a decimal.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the field.&lt;/returns&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;No column with the specified name was found.&lt;/exception&gt;
        public decimal GetDecimal(string fieldName)
        {
            return m_DataReader.GetDecimal(GetOrdinal(fieldName));
        }

        /// &lt;summary&gt;
        /// Gets the value of the specified field as a double.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the field.&lt;/returns&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;No column with the specified name was found.&lt;/exception&gt;
        public double GetDouble(string fieldName)
        {
            return m_DataReader.GetDouble(GetOrdinal(fieldName));
        }

        /// &lt;summary&gt;
        /// Gets the value of the specified field as a float.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the field.&lt;/returns&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;No column with the specified name was found.&lt;/exception&gt;
        public float GetFloat(string fieldName)
        {
            return m_DataReader.GetFloat(GetOrdinal(fieldName));
        }

        /// &lt;summary&gt;
        /// Gets the value of the specified field as a Guid.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the field.&lt;/returns&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;No column with the specified name was found.&lt;/exception&gt;
        public Guid GetGuid(string fieldName)
        {
            return m_DataReader.GetGuid(GetOrdinal(fieldName));
        }

        /// &lt;summary&gt;
        /// Gets the value of the specified field as a short.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the field.&lt;/returns&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;No column with the specified name was found.&lt;/exception&gt;
        public short GetShort(string fieldName)
        {
            // this is needed as SQL CE 4 doesn&#39;t support smallint/tinyint as IDENTITY columns. So some columns that are
            // int16 in SQL Server (smallint/tinyint) will be int32 (int) in SQL CE 4
            int fieldNo = GetOrdinal(fieldName);
            Type t = m_DataReader.GetFieldType(fieldNo);
            if (t.FullName == &quot;System.Int32&quot;)
                return (short) m_DataReader.GetInt32(fieldNo);

            return m_DataReader.GetInt16(fieldNo);
        }

        /// &lt;summary&gt;
        /// Gets the value of the specified field as an int.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the field.&lt;/returns&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;No column with the specified name was found.&lt;/exception&gt;
        public int GetInt(string fieldName)
        {
            int ordinal = GetOrdinal(fieldName);
            return m_DataReader.IsDBNull(ordinal) ? -1 : m_DataReader.GetInt32(ordinal);
        }

        /// &lt;summary&gt;
        /// Gets the value of the specified field as a long.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the field.&lt;/returns&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;No column with the specified name was found.&lt;/exception&gt;
        public long GetLong(string fieldName)
        {
            return m_DataReader.GetInt64(GetOrdinal(fieldName));
        }

        /// &lt;summary&gt;
        /// Gets the value of the specified field as a string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the field.&lt;/returns&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;No column with the specified name was found.&lt;/exception&gt;
        public string GetString(string fieldName)
        {
            int ordinal = GetOrdinal(fieldName);
            return m_DataReader.IsDBNull(ordinal) ? null : m_DataReader.GetString(ordinal);
        }

        /// &lt;summary&gt;
        /// Gets the value of the specified field.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The value of the field.&lt;/returns&gt;
        /// &lt;exception cref=&quot;System.IndexOutOfRangeException&quot;&gt;No column with the specified name was found.&lt;/exception&gt;
        public object GetObject(string fieldName)
        {
            int ordinal = GetOrdinal(fieldName);
            return m_DataReader.IsDBNull(ordinal) ? null : m_DataReader.GetValue(ordinal);
        }

        /// &lt;summary&gt;
        /// Determines whether the specified field is null.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;
        /// 	&lt;c&gt;true&lt;/c&gt; if the specified field is null; otherwise, &lt;c&gt;false&lt;/c&gt;.
        /// &lt;/returns&gt;
        public bool IsNull(string fieldName)
        {
            return m_DataReader.IsDBNull(GetOrdinal(fieldName));
        }

        /// &lt;summary&gt;
        /// Determines whether a field with the specified field name exists in the record.
        /// The field can still contain a null value.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;Name of the field.&lt;/param&gt;
        /// &lt;returns&gt;
        /// 	&lt;c&gt;true&lt;/c&gt; if the specified field exists; otherwise, &lt;c&gt;false&lt;/c&gt;.
        /// &lt;/returns&gt;
        public bool ContainsField(string fieldName)
        {
            bool fieldExists;
            try
            {
                GetOrdinal(fieldName);
                fieldExists = true;
            }
            catch
            {
                // GetOrdinal failed, field was not found.
                fieldExists = false;
            }
            return fieldExists;
        }

        /// &lt;summary&gt;
        /// Returns the index of the field with the specified name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fieldName&quot;&gt;The name of the field.&lt;/param&gt;
        /// &lt;returns&gt;The index of the field.&lt;/returns&gt;
        protected virtual int GetOrdinal(string fieldName)
        {
            return m_DataReader.GetOrdinal(fieldName);
        }

        #endregion

        #region IEnumerable Members

        /// &lt;summary&gt;
        /// Returns an enumerator that iterates through the records.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot;&gt;&lt;/see&gt; object that can be used to iterate through records.
        /// &lt;/returns&gt;
        public IEnumerator GetEnumerator()
        {
            return m_DataReader.GetEnumerator();
        }

        #endregion

        #region IDisposable Members

        /// &lt;summary&gt;
        /// Performs application-defined tasks associated with freeing, releasing,
        /// or resetting unmanaged resources.
        /// &lt;/summary&gt;
        public void Dispose()
        {
            Dispose(true);
        }

        /// &lt;summary&gt;
        /// Releases unmanaged and - optionally - managed resources.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;disposing&quot;&gt;&lt;c&gt;true&lt;/c&gt; to release both managed and unmanaged resources;
        ///                         &lt;c&gt;false&lt;/c&gt; to release only unmanaged resources.&lt;/param&gt;
        protected virtual void Dispose(bool disposing)
        {
            // Try to close the data reader if it&#39;s still open
            try
            {
                if (m_DataReader != null &amp;&amp; !m_DataReader.IsClosed)
                    Close();
            }
            finally
            {
                // Try to dispose the data reader
                try
                {
                    if (m_DataReader != null)
                        m_DataReader.Dispose();
                }
                catch { }
                // Dispose methods should call SuppressFinalize
                if (disposing)
                {
                    GC.SuppressFinalize(this);
                }
            }
        }

        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[38,13,38,47,1],[42,13,42,76,1],[53,17,53,18,0],[53,19,53,39,0],[53,40,53,41,0],[64,17,64,18,0],[64,19,64,39,0],[64,40,64,41,0],[74,9,74,50,1],[75,9,75,10,1],[76,13,76,39,1],[79,17,79,43,1],[80,17,80,18,1],[82,21,82,41,1],[84,21,84,51,1],[85,21,85,63,1],[86,21,86,115,1],[87,21,88,101,1],[89,17,89,18,1],[91,9,91,10,1],[98,9,98,10,0],[98,9,98,10,0],[99,13,99,28,0],[100,9,100,10,0],[100,9,100,10,0],[109,9,109,10,1],[111,13,111,14,1],[112,17,112,38,1],[113,13,113,14,1],[114,13,114,18,0],[114,19,114,20,0],[114,21,114,22,0],[118,17,118,43,1],[119,17,119,18,1],[120,21,120,54,1],[121,21,122,101,1],[123,17,123,18,1],[125,9,125,10,1],[133,17,133,18,0],[133,19,133,45,0],[133,46,133,47,0],[142,17,142,18,0],[142,19,142,48,0],[142,49,142,50,0],[152,9,152,10,1],[153,13,153,40,1],[154,9,154,10,1],[171,9,171,10,0],[172,13,172,48,0],[174,41,174,89,0],[175,41,175,86,0],[176,41,176,90,0],[177,41,177,89,0],[178,41,178,88,0],[179,41,179,87,0],[180,41,180,86,0],[181,41,181,87,0],[182,41,182,85,0],[183,41,183,86,0],[184,41,184,88,0],[185,41,185,80,0],[187,9,187,10,0],[196,9,196,10,1],[197,13,197,67,1],[198,9,198,10,1],[207,9,207,10,0],[210,13,210,49,0],[211,13,211,57,0],[212,13,212,56,0],[213,17,213,78,0],[215,13,215,50,0],[216,9,216,10,0],[225,9,225,10,1],[226,13,226,68,1],[227,9,227,10,1],[236,9,236,10,0],[237,13,237,67,0],[238,9,238,10,0],[247,9,247,10,0],[248,13,248,66,0],[249,9,249,10,0],[258,9,258,10,0],[259,13,259,65,0],[260,9,260,10,0],[269,9,269,10,1],[270,13,270,64,1],[271,9,271,10,1],[280,9,280,10,1],[283,13,283,49,1],[284,13,284,57,1],[285,13,285,46,1],[286,17,286,63,1],[288,13,288,51,0],[289,9,289,10,1],[298,9,298,10,1],[299,13,299,49,1],[300,13,300,89,1],[301,9,301,10,1],[310,9,310,10,0],[311,13,311,65,0],[312,9,312,10,0],[321,9,321,10,1],[322,13,322,49,1],[323,13,323,92,1],[324,9,324,10,1],[333,9,333,10,0],[334,13,334,49,0],[335,13,335,91,0],[336,9,336,10,0],[346,9,346,10,1],[347,13,347,65,1],[348,9,348,10,1],[359,9,359,10,0],[362,13,362,14,0],[363,17,363,39,0],[364,17,364,36,0],[365,13,365,14,0],[366,13,366,18,0],[367,13,367,14,0],[369,17,369,37,0],[370,13,370,14,0],[371,13,371,32,0],[372,9,372,10,0],[380,9,380,10,1],[381,13,381,55,1],[382,9,382,10,1],[395,9,395,10,0],[396,13,396,49,0],[397,9,397,10,0],[408,9,408,10,1],[409,13,409,27,1],[410,9,410,10,1],[418,9,418,10,1],[421,13,421,14,1],[422,17,422,68,1],[423,21,423,29,1],[424,13,424,14,1],[426,13,426,14,1],[429,17,429,18,1],[430,21,430,46,1],[431,25,431,48,1],[432,17,432,18,1],[433,17,433,22,0],[433,23,433,24,0],[433,25,433,26,0],[435,17,435,31,1],[436,17,436,18,1],[437,21,437,47,1],[438,17,438,18,1],[439,13,439,14,1],[440,9,440,10,1]]);
    </script>
  </body>
</html>