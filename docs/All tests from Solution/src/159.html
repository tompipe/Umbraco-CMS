<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Tests\Strings\StringExtensionsTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Diagnostics;
using System.Globalization;
using NUnit.Framework;
using Umbraco.Core;
using Umbraco.Core.ObjectResolution;
using Umbraco.Core.Strings;

namespace Umbraco.Tests.Strings
{
    [TestFixture]
    public class StringExtensionsTests
    {
	    [SetUp]
	    public void Setup()
	    {
            ShortStringHelperResolver.Reset();
            ShortStringHelperResolver.Current = new ShortStringHelperResolver(new MockShortStringHelper());
	        Resolution.Freeze();
	    }

        [TearDown]
        public void TearDown()
        {
            ShortStringHelperResolver.Reset();
        }

        [TestCase(&quot;hello&quot;, &quot;world&quot;, false)]
        [TestCase(&quot;hello&quot;, &quot;hello&quot;, true)]
        [TestCase(&quot;hellohellohellohellohellohellohello&quot;, &quot;hellohellohellohellohellohellohelloo&quot;, false)]
        [TestCase(&quot;hellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohello&quot;, &quot;hellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohelloo&quot;, false)]
        [TestCase(&quot;hellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohello&quot;, &quot;hellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohello&quot;, true)]
        public void String_To_Guid(string first, string second, bool result)
        {
            Debug.Print(&quot;First: &quot; + first.ToGuid());
            Debug.Print(&quot;Second: &quot; + second.ToGuid());
            Assert.AreEqual(result, first.ToGuid() == second.ToGuid());
        }

        [TestCase(&quot;alert(&#39;hello&#39;);&quot;, false)]
        [TestCase(&quot;~/Test.js&quot;, true)]
        [TestCase(&quot;../Test.js&quot;, true)]
        [TestCase(&quot;/Test.js&quot;, true)]
        [TestCase(&quot;Test.js&quot;, true)]
        [TestCase(&quot;Test.js==&quot;, false)]
        [TestCase(&quot;/Test.js function(){return true;}&quot;, false)]
        public void Detect_Is_JavaScript_Path(string input, bool result)
        {
            var output = input.DetectIsJavaScriptPath();
            Assert.AreEqual(result, output.Success);
        }

        [TestCase(&quot;hello.txt&quot;, &quot;hello&quot;)]
        [TestCase(&quot;this.is.a.Txt&quot;, &quot;this.is.a&quot;)]
        [TestCase(&quot;this.is.not.a. Txt&quot;, &quot;this.is.not.a. Txt&quot;)]
        [TestCase(&quot;not a file&quot;,&quot;not a file&quot;)]
        public void Strip_File_Extension(string input, string result)
        {
            var stripped = input.StripFileExtension();
            Assert.AreEqual(stripped, result);
        }

	    [TestCase(&quot;This is a string to encrypt&quot;)]
		[TestCase(&quot;This is a string to encrypt\nThis is a second line&quot;)]
		[TestCase(&quot;    White space is preserved    &quot;)]
		[TestCase(&quot;\nWhite space is preserved\n&quot;)]
		public void Encrypt_And_Decrypt(string input)
		{
			var encrypted = input.EncryptWithMachineKey();
			var decrypted = encrypted.DecryptWithMachineKey();
			Assert.AreNotEqual(input, encrypted);
			Assert.AreEqual(input, decrypted);
		}

		[Test()]
		public void Encrypt_And_Decrypt_Long_Value()
		{
			// Generate a really long string
			char[] chars = { &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;\n&#39; };

			string valueToTest = string.Empty;

			// Create a string 7035 chars long
			for (int i = 0; i &lt; 1005; i++)
				for (int j = 0; j &lt; chars.Length; j++)
					valueToTest += chars[j].ToString();

			var encrypted = valueToTest.EncryptWithMachineKey();
			var decrypted = encrypted.DecryptWithMachineKey();
			Assert.AreNotEqual(valueToTest, encrypted);
			Assert.AreEqual(valueToTest, decrypted);
		}

        [TestCase(&quot;Hello this is my string&quot;, &quot; string&quot;, &quot;Hello this is my&quot;)]
        [TestCase(&quot;Hello this is my string strung&quot;, &quot; string&quot;, &quot;Hello this is my string strung&quot;)]
        [TestCase(&quot;Hello this is my string string&quot;, &quot; string&quot;, &quot;Hello this is my&quot;)]
        [TestCase(&quot;Hello this is my string string&quot;, &quot;g&quot;, &quot;Hello this is my string strin&quot;)]
        [TestCase(&quot;Hello this is my string string&quot;, &quot;ello this is my string string&quot;, &quot;H&quot;)]
        [TestCase(&quot;Hello this is my string string&quot;, &quot;Hello this is my string string&quot;, &quot;&quot;)]
        public void TrimEnd(string input, string forTrimming, string shouldBe)
        {
            var trimmed = input.TrimEnd(forTrimming);
            Assert.AreEqual(shouldBe, trimmed);
        }

        [TestCase(&quot;Hello this is my string&quot;, &quot;hello&quot;, &quot; this is my string&quot;)]
        [TestCase(&quot;Hello this is my string&quot;, &quot;Hello this&quot;, &quot; is my string&quot;)]
        [TestCase(&quot;Hello this is my string&quot;, &quot;Hello this is my &quot;, &quot;string&quot;)]
        [TestCase(&quot;Hello this is my string&quot;, &quot;Hello this is my string&quot;, &quot;&quot;)]
        public void TrimStart(string input, string forTrimming, string shouldBe)
        {
            var trimmed = input.TrimStart(forTrimming);
            Assert.AreEqual(shouldBe, trimmed);
        }

        [TestCase(&quot;Hello this is my string&quot;, &quot;hello&quot;, &quot;replaced&quot;, &quot;replaced this is my string&quot;, StringComparison.CurrentCultureIgnoreCase)]
        [TestCase(&quot;Hello this is hello my string&quot;, &quot;hello&quot;, &quot;replaced&quot;, &quot;replaced this is replaced my string&quot;, StringComparison.CurrentCultureIgnoreCase)]
        [TestCase(&quot;Hello this is my string&quot;, &quot;nonexistent&quot;, &quot;replaced&quot;, &quot;Hello this is my string&quot;, StringComparison.CurrentCultureIgnoreCase)]
        [TestCase(&quot;Hellohello this is my string&quot;, &quot;hello&quot;, &quot;replaced&quot;, &quot;replacedreplaced this is my string&quot;, StringComparison.CurrentCultureIgnoreCase)]
        // Ensure replacing with the same string doesn&#39;t cause infinite loop.
        [TestCase(&quot;Hello this is my string&quot;, &quot;hello&quot;, &quot;hello&quot;, &quot;hello this is my string&quot;, StringComparison.CurrentCultureIgnoreCase)]
        public void ReplaceWithStringComparison(string input, string oldString, string newString, string shouldBe, StringComparison stringComparison)
        {
            var replaced = input.Replace(oldString, newString, stringComparison);
            Assert.AreEqual(shouldBe, replaced);
        }

        [TestCase(null, null)]
        [TestCase(&quot;&quot;, &quot;&quot;)]
        [TestCase(&quot;x&quot;, &quot;X&quot;)]
        [TestCase(&quot;xyzT&quot;, &quot;XyzT&quot;)]
        [TestCase(&quot;XyzT&quot;, &quot;XyzT&quot;)]
        public void ToFirstUpper(string input, string expected)
        {
            var output = input.ToFirstUpper();
            Assert.AreEqual(expected, output);
        }

        [TestCase(null, null)]
        [TestCase(&quot;&quot;, &quot;&quot;)]
        [TestCase(&quot;X&quot;, &quot;x&quot;)]
        [TestCase(&quot;XyZ&quot;, &quot;xyZ&quot;)]
        [TestCase(&quot;xyZ&quot;, &quot;xyZ&quot;)]
        public void ToFirstLower(string input, string expected)
        {
            var output = input.ToFirstLower();
            Assert.AreEqual(expected, output);
        }

        // FORMAT STRINGS

        // note: here we just ensure that the proper helper gets called properly
        // but the &quot;legacy&quot; tests have moved to the legacy helper tests

        [Test]
        public void ToUrlAlias()
        {
            var output = &quot;JUST-ANYTHING&quot;.ToUrlSegment();
            Assert.AreEqual(&quot;URL-SEGMENT::JUST-ANYTHING&quot;, output);
        }

        [Test]
        public void FormatUrl()
        {
            var output = &quot;JUST-ANYTHING&quot;.ToUrlSegment();
            Assert.AreEqual(&quot;URL-SEGMENT::JUST-ANYTHING&quot;, output);
        }

        [Test]
        public void ToUmbracoAlias()
        {
            var output = &quot;JUST-ANYTHING&quot;.ToSafeAlias();
            Assert.AreEqual(&quot;SAFE-ALIAS::JUST-ANYTHING&quot;, output);
        }

        [Test]
        public void ToSafeAlias()
        {
            var output = &quot;JUST-ANYTHING&quot;.ToSafeAlias();
            Assert.AreEqual(&quot;SAFE-ALIAS::JUST-ANYTHING&quot;, output);
        }

        [Test]
        public void ToSafeAliasWithCulture()
        {
            var output = &quot;JUST-ANYTHING&quot;.ToSafeAlias(CultureInfo.InvariantCulture);
            Assert.AreEqual(&quot;SAFE-ALIAS-CULTURE::JUST-ANYTHING&quot;, output);
        }

        [Test]
        public void ToUrlSegment()
        {
            var output = &quot;JUST-ANYTHING&quot;.ToUrlSegment();
            Assert.AreEqual(&quot;URL-SEGMENT::JUST-ANYTHING&quot;, output);
        }

        [Test]
        public void ToUrlSegmentWithCulture()
        {
            var output = &quot;JUST-ANYTHING&quot;.ToUrlSegment(CultureInfo.InvariantCulture);
            Assert.AreEqual(&quot;URL-SEGMENT-CULTURE::JUST-ANYTHING&quot;, output);
        }

        [Test]
        public void ToSafeFileName()
        {
            var output = &quot;JUST-ANYTHING&quot;.ToSafeFileName();
            Assert.AreEqual(&quot;SAFE-FILE-NAME::JUST-ANYTHING&quot;, output);
        }

        [Test]
        public void ToSafeFileNameWithCulture()
        {
            var output = &quot;JUST-ANYTHING&quot;.ToSafeFileName(CultureInfo.InvariantCulture);
            Assert.AreEqual(&quot;SAFE-FILE-NAME-CULTURE::JUST-ANYTHING&quot;, output);
        }

        [Test]
        public void ConvertCase()
        {
            var output = &quot;JUST-ANYTHING&quot;.ToCleanString(CleanStringType.Unchanged);
            Assert.AreEqual(&quot;CLEAN-STRING-A::JUST-ANYTHING&quot;, output);
        }

        [Test]
        public void SplitPascalCasing()
        {
            var output = &quot;JUST-ANYTHING&quot;.SplitPascalCasing();
            Assert.AreEqual(&quot;SPLIT-PASCAL-CASING::JUST-ANYTHING&quot;, output);
        }

        [Test]
        public void ReplaceManyWithCharMap()
        {
            var output = &quot;JUST-ANYTHING&quot;.ReplaceMany(null);
            Assert.AreEqual(&quot;REPLACE-MANY-A::JUST-ANYTHING&quot;, output);
        }

        [Test]
        public void ReplaceManyByOneChar()
        {
            var output = &quot;JUST-ANYTHING&quot;.ReplaceMany(new char[] {}, &#39;*&#39;);
            Assert.AreEqual(&quot;REPLACE-MANY-B::JUST-ANYTHING&quot;, output);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[16,6,16,7,1],[17,13,17,47,1],[18,13,18,108,1],[19,10,19,30,1],[20,6,20,7,1],[24,9,24,10,1],[25,13,25,47,1],[26,9,26,10,1],[34,9,34,10,1],[35,13,35,53,1],[36,13,36,55,1],[37,13,37,72,1],[38,9,38,10,1],[48,9,48,10,1],[49,13,49,57,1],[50,13,50,53,1],[51,9,51,10,1],[58,9,58,10,1],[59,13,59,55,1],[60,13,60,47,1],[61,9,61,10,1],[68,3,68,4,1],[69,4,69,50,1],[70,4,70,54,1],[71,4,71,41,1],[72,4,72,38,1],[73,3,73,4,1],[77,3,77,4,1],[79,4,79,58,1],[81,4,81,38,1],[84,9,84,18,1],[84,20,84,28,1],[84,30,84,33,1],[85,10,85,19,1],[85,21,85,37,1],[85,39,85,42,1],[86,6,86,41,1],[88,4,88,56,1],[89,4,89,54,1],[90,4,90,47,1],[91,4,91,44,1],[92,3,92,4,1],[101,9,101,10,1],[102,13,102,54,1],[103,13,103,48,1],[104,9,104,10,1],[111,9,111,10,1],[112,13,112,56,1],[113,13,113,48,1],[114,9,114,10,1],[123,9,123,10,1],[124,13,124,82,1],[125,13,125,49,1],[126,9,126,10,1],[134,9,134,10,1],[135,13,135,47,1],[136,13,136,47,1],[137,9,137,10,1],[145,9,145,10,1],[146,13,146,47,1],[147,13,147,47,1],[148,9,148,10,1],[157,9,157,10,1],[158,13,158,57,1],[159,13,159,67,1],[160,9,160,10,1],[164,9,164,10,1],[165,13,165,57,1],[166,13,166,67,1],[167,9,167,10,1],[171,9,171,10,1],[172,13,172,56,1],[173,13,173,66,1],[174,9,174,10,1],[178,9,178,10,1],[179,13,179,56,1],[180,13,180,66,1],[181,9,181,10,1],[185,9,185,10,1],[186,13,186,84,1],[187,13,187,74,1],[188,9,188,10,1],[192,9,192,10,1],[193,13,193,57,1],[194,13,194,67,1],[195,9,195,10,1],[199,9,199,10,1],[200,13,200,85,1],[201,13,201,75,1],[202,9,202,10,1],[206,9,206,10,1],[207,13,207,59,1],[208,13,208,70,1],[209,9,209,10,1],[213,9,213,10,1],[214,13,214,87,1],[215,13,215,78,1],[216,9,216,10,1],[220,9,220,10,1],[221,13,221,83,1],[222,13,222,70,1],[223,9,223,10,1],[227,9,227,10,1],[228,13,228,62,1],[229,13,229,75,1],[230,9,230,10,1],[234,9,234,10,1],[235,13,235,60,1],[236,13,236,70,1],[237,9,237,10,1],[241,9,241,10,1],[242,13,242,74,1],[243,13,243,70,1],[244,9,244,10,1]]);
    </script>
  </body>
</html>