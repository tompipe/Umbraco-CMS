<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Models\Mapping\ContentTypeModelMapperExtensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using AutoMapper;
using Umbraco.Core;
using Umbraco.Core.Models;
using Umbraco.Core.PropertyEditors;
using Umbraco.Web.Models.ContentEditing;

namespace Umbraco.Web.Models.Mapping
{
    /// &lt;summary&gt;
    /// Used as a shared way to do the underlying mapping for content types base classes
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// We used to use &#39;Include&#39; Automapper inheritance functionality and although this works, the unit test
    ///     to assert mappings fails which is an Automapper bug. So instead we will use an extension method for the mappings
    ///     to re-use mappings.
    /// &lt;/remarks&gt;
    internal static class ContentTypeModelMapperExtensions
    {

        public static IMappingExpression&lt;TSource, PropertyGroup&gt; MapPropertyGroupBasicToPropertyGroupPersistence&lt;TSource, TPropertyTypeBasic&gt;(
            this IMappingExpression&lt;TSource, PropertyGroup&gt; mapping)
            where TSource : PropertyGroupBasic&lt;TPropertyTypeBasic&gt; 
            where TPropertyTypeBasic : PropertyTypeBasic
        {
            return mapping
                .ForMember(dest =&gt; dest.Id, map =&gt; map.Condition(source =&gt; source.Id &gt; 0))
                .ForMember(dest =&gt; dest.Key, map =&gt; map.Ignore())
                .ForMember(dest =&gt; dest.HasIdentity, map =&gt; map.Ignore())
                .ForMember(dest =&gt; dest.CreateDate, map =&gt; map.Ignore())
                .ForMember(dest =&gt; dest.UpdateDate, map =&gt; map.Ignore())
                .ForMember(dest =&gt; dest.PropertyTypes, map =&gt; map.Ignore());
        }

        public static IMappingExpression&lt;TSource, PropertyGroupDisplay&lt;TPropertyTypeDisplay&gt;&gt; MapPropertyGroupBasicToPropertyGroupDisplay&lt;TSource, TPropertyTypeBasic, TPropertyTypeDisplay&gt;(
            this IMappingExpression&lt;TSource, PropertyGroupDisplay&lt;TPropertyTypeDisplay&gt;&gt; mapping)
            where TSource : PropertyGroupBasic&lt;TPropertyTypeBasic&gt;
            where TPropertyTypeBasic : PropertyTypeBasic 
            where TPropertyTypeDisplay : PropertyTypeDisplay
        {
            return mapping
                .ForMember(dest =&gt; dest.Id, expression =&gt; expression.Condition(source =&gt; source.Id &gt; 0))
                .ForMember(g =&gt; g.ContentTypeId, expression =&gt; expression.Ignore())
                .ForMember(g =&gt; g.ParentTabContentTypes, expression =&gt; expression.Ignore())
                .ForMember(g =&gt; g.ParentTabContentTypeNames, expression =&gt; expression.Ignore())
                .ForMember(g =&gt; g.Properties, expression =&gt; expression.MapFrom(display =&gt; display.Properties.Select(Mapper.Map&lt;TPropertyTypeDisplay&gt;)));
        }

        public static void AfterMapContentTypeSaveToEntity&lt;TSource, TDestination&gt;(
            TSource source, TDestination dest,
            ApplicationContext applicationContext)
            where TSource : ContentTypeSave
            where TDestination : IContentTypeComposition
        {
            //sync compositions
            var current = dest.CompositionAliases().ToArray();
            var proposed = source.CompositeContentTypes;

            var remove = current.Where(x =&gt; proposed.Contains(x) == false);
            var add = proposed.Where(x =&gt; current.Contains(x) == false);

            foreach (var rem in remove)
            {
                dest.RemoveContentType(rem);
            }

            foreach (var a in add)
            {
                //TODO: Remove N+1 lookup
                var addCt = applicationContext.Services.ContentTypeService.GetContentType(a);
                if (addCt != null)
                    dest.AddContentType(addCt);
            }
        }

        public static void AfterMapMediaTypeSaveToEntity&lt;TSource, TDestination&gt;(
            TSource source, TDestination dest,
            ApplicationContext applicationContext)
            where TSource : MediaTypeSave
            where TDestination : IContentTypeComposition
        {
            //sync compositions
            var current = dest.CompositionAliases().ToArray();
            var proposed = source.CompositeContentTypes;

            var remove = current.Where(x =&gt; proposed.Contains(x) == false);
            var add = proposed.Where(x =&gt; current.Contains(x) == false);

            foreach (var rem in remove)
            {
                dest.RemoveContentType(rem);
            }

            foreach (var a in add)
            {
                //TODO: Remove N+1 lookup
                var addCt = applicationContext.Services.ContentTypeService.GetMediaType(a);
                if (addCt != null)
                    dest.AddContentType(addCt);
            }
        }

        public static IMappingExpression&lt;TSource, TDestination&gt; MapBaseContentTypeSaveToDisplay&lt;TSource, TPropertyTypeSource, TDestination, TPropertyTypeDestination&gt;(
            this IMappingExpression&lt;TSource, TDestination&gt; mapping)
            where TSource : ContentTypeSave&lt;TPropertyTypeSource&gt;
            where TDestination : ContentTypeCompositionDisplay&lt;TPropertyTypeDestination&gt; 
            where TPropertyTypeDestination : PropertyTypeDisplay 
            where TPropertyTypeSource : PropertyTypeBasic
        {
            return mapping
                .ForMember(dto =&gt; dto.CreateDate, expression =&gt; expression.Ignore())
                .ForMember(dto =&gt; dto.UpdateDate, expression =&gt; expression.Ignore())
                .ForMember(dto =&gt; dto.ListViewEditorName, expression =&gt; expression.Ignore())
                .ForMember(dto =&gt; dto.Notifications, expression =&gt; expression.Ignore())
                .ForMember(dto =&gt; dto.Errors, expression =&gt; expression.Ignore())
                .ForMember(dto =&gt; dto.LockedCompositeContentTypes, exp =&gt; exp.Ignore())
                .ForMember(dto =&gt; dto.Groups, expression =&gt; expression.ResolveUsing(new PropertyGroupDisplayResolver&lt;TSource, TPropertyTypeSource, TPropertyTypeDestination&gt;()));
        }

        public static IMappingExpression&lt;TSource, TDestination&gt; MapBaseContentTypeEntityToDisplay&lt;TSource, TDestination, TPropertyTypeDisplay&gt;(
            this IMappingExpression&lt;TSource, TDestination&gt; mapping, ApplicationContext applicationContext, Lazy&lt;PropertyEditorResolver&gt; propertyEditorResolver)
            where TSource : IContentTypeComposition
            where TDestination : ContentTypeCompositionDisplay&lt;TPropertyTypeDisplay&gt;
            where TPropertyTypeDisplay : PropertyTypeDisplay, new()
        {
            return mapping
                .ForMember(display =&gt; display.Notifications, expression =&gt; expression.Ignore())
                .ForMember(display =&gt; display.Errors, expression =&gt; expression.Ignore())
                .ForMember(display =&gt; display.AllowAsRoot, expression =&gt; expression.MapFrom(type =&gt; type.AllowedAsRoot))
                .ForMember(display =&gt; display.ListViewEditorName, expression =&gt; expression.Ignore())
                //Ignore because this is not actually used for content types
                .ForMember(display =&gt; display.Trashed, expression =&gt; expression.Ignore())

                .ForMember(
                    dto =&gt; dto.AllowedContentTypes,
                    expression =&gt; expression.MapFrom(dto =&gt; dto.AllowedContentTypes.Select(x =&gt; x.Id.Value)))
                    
                .ForMember(
                    dto =&gt; dto.CompositeContentTypes,
                    expression =&gt; expression.MapFrom(dto =&gt; dto.ContentTypeComposition))

                .ForMember(
                    dto =&gt; dto.LockedCompositeContentTypes,
                    expression =&gt; expression.ResolveUsing(new LockedCompositionsResolver(applicationContext)))

                .ForMember(
                    dto =&gt; dto.Groups,
                    expression =&gt; expression.ResolveUsing(new PropertyTypeGroupResolver&lt;TPropertyTypeDisplay&gt;(applicationContext, propertyEditorResolver)));
        }

        /// &lt;summary&gt;
        /// Display -&gt; Entity class base mapping logic
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TSource&quot;&gt;&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TDestination&quot;&gt;&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TSourcePropertyType&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;mapping&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;applicationContext&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;        
        public static IMappingExpression&lt;TSource, TDestination&gt; MapBaseContentTypeSaveToEntity&lt;TSource, TSourcePropertyType, TDestination&gt;(
            this IMappingExpression&lt;TSource, TDestination&gt; mapping, ApplicationContext applicationContext)
            //where TSource : ContentTypeCompositionDisplay
            where TSource : ContentTypeSave&lt;TSourcePropertyType&gt;
            where TDestination : IContentTypeComposition 
            where TSourcePropertyType : PropertyTypeBasic
        {
            return mapping
                //only map id if set to something higher then zero
                .ForMember(dto =&gt; dto.Id, expression =&gt; expression.Condition(display =&gt; (Convert.ToInt32(display.Id) &gt; 0)))
                .ForMember(dto =&gt; dto.Id, expression =&gt; expression.MapFrom(display =&gt; Convert.ToInt32(display.Id)))

                //These get persisted as part of the saving procedure, nothing to do with the display model
                .ForMember(dto =&gt; dto.CreateDate, expression =&gt; expression.Ignore())
                .ForMember(dto =&gt; dto.UpdateDate, expression =&gt; expression.Ignore())

                .ForMember(dto =&gt; dto.AllowedAsRoot, expression =&gt; expression.MapFrom(display =&gt; display.AllowAsRoot))
                .ForMember(dto =&gt; dto.CreatorId, expression =&gt; expression.Ignore())
                .ForMember(dto =&gt; dto.Level, expression =&gt; expression.Ignore())
                .ForMember(dto =&gt; dto.SortOrder, expression =&gt; expression.Ignore())
                //ignore, we&#39;ll do this in after map
                .ForMember(dto =&gt; dto.PropertyGroups, expression =&gt; expression.Ignore())
                .ForMember(dto =&gt; dto.NoGroupPropertyTypes, expression =&gt; expression.Ignore())
                // ignore, composition is managed in AfterMapContentTypeSaveToEntity
                .ForMember(dest =&gt; dest.ContentTypeComposition, opt =&gt; opt.Ignore())
                
                .ForMember(
                    dto =&gt; dto.AllowedContentTypes,
                    expression =&gt; expression.MapFrom(dto =&gt; dto.AllowedContentTypes.Select((t, i) =&gt; new ContentTypeSort(t, i))))

                .AfterMap((source, dest) =&gt;
                {
                    // handle property groups and property types
                    // note that ContentTypeSave has
                    // - all groups, inherited and local; only *one* occurence per group *name*
                    // - potentially including the generic properties group
                    // - all properties, inherited and local
                    //
                    // also, see PropertyTypeGroupResolver.ResolveCore:
                    // - if a group is local *and* inherited, then Inherited is true
                    //   and the identifier is the identifier of the *local* group
                    //
                    // IContentTypeComposition AddPropertyGroup, AddPropertyType methods do some
                    // unique-alias-checking, etc that is *not* compatible with re-mapping everything
                    // the way we do it here, so we should exclusively do it by
                    // - managing a property group&#39;s PropertyTypes collection
                    // - managing the content type&#39;s PropertyTypes collection (for generic properties)

                    // handle actual groups (non-generic-properties)
                    var destOrigGroups = dest.PropertyGroups.ToArray(); // local groups
                    var destOrigProperties = dest.PropertyTypes.ToArray(); // all properties, in groups or not
                    var destGroups = new List&lt;PropertyGroup&gt;();
                    var sourceGroups = source.Groups.Where(x =&gt; x.IsGenericProperties == false).ToArray();
                    foreach (var sourceGroup in sourceGroups)
                    {
                        // get the dest group
                        var destGroup = MapSaveGroup(sourceGroup, destOrigGroups);

                        // handle local properties
                        var destProperties = sourceGroup.Properties
                            .Where(x =&gt; x.Inherited == false)
                            .Select(x =&gt; MapSaveProperty(x, destOrigProperties))
                            .ToArray();

                        // if the group has no local properties, skip it, ie sort-of garbage-collect
                        // local groups which would not have local properties anymore
                        if (destProperties.Length == 0)
                            continue;

                        // ensure no duplicate alias, then assign the group properties collection
                        EnsureUniqueAliases(destProperties);
                        destGroup.PropertyTypes = new PropertyTypeCollection(destProperties);
                        destGroups.Add(destGroup);
                    }

                    // ensure no duplicate name, then assign the groups collection
                    EnsureUniqueNames(destGroups);
                    dest.PropertyGroups = new PropertyGroupCollection(destGroups);

                    // because the property groups collection was rebuilt, there is no need to remove
                    // the old groups - they are just gone and will be cleared by the repository

                    // handle non-grouped (ie generic) properties
                    var genericPropertiesGroup = source.Groups.FirstOrDefault(x =&gt; x.IsGenericProperties);
                    if (genericPropertiesGroup != null)
                    {
                        // handle local properties
                        var destProperties = genericPropertiesGroup.Properties
                            .Where(x =&gt; x.Inherited == false)
                            .Select(x =&gt; MapSaveProperty(x, destOrigProperties))
                            .ToArray();

                        // ensure no duplicate alias, then assign the generic properties collection
                        EnsureUniqueAliases(destProperties);
                        dest.NoGroupPropertyTypes = new PropertyTypeCollection(destProperties);
                    }

                    // because all property collections were rebuilt, there is no need to remove
                    // some old properties, they are just gone and will be cleared by the repository
                });
        }

        private static PropertyGroup MapSaveGroup&lt;TPropertyType&gt;(PropertyGroupBasic&lt;TPropertyType&gt; sourceGroup, IEnumerable&lt;PropertyGroup&gt; destOrigGroups)
            where TPropertyType: PropertyTypeBasic
        {
            PropertyGroup destGroup;
            if (sourceGroup.Id &gt; 0)
            {
                // update an existing group
                // ensure it is still there, then map/update
                destGroup = destOrigGroups.FirstOrDefault(x =&gt; x.Id == sourceGroup.Id);
                if (destGroup != null)
                {
                    Mapper.Map(sourceGroup, destGroup);
                    return destGroup;
                }

                // force-clear the ID as it does not match anything
                sourceGroup.Id = 0;
            }

            // insert a new group, or update an existing group that has
            // been deleted in the meantime and we need to re-create
            // map/create
            destGroup = Mapper.Map&lt;PropertyGroup&gt;(sourceGroup);
            return destGroup;
        }

        private static PropertyType MapSaveProperty(PropertyTypeBasic sourceProperty, IEnumerable&lt;PropertyType&gt; destOrigProperties)
        {
            PropertyType destProperty;
            if (sourceProperty.Id &gt; 0)
            {
                // updateg an existing property
                // ensure it is still there, then map/update
                destProperty = destOrigProperties.FirstOrDefault(x =&gt; x.Id == sourceProperty.Id);
                if (destProperty != null)
                {
                    Mapper.Map(sourceProperty, destProperty);
                    return destProperty;
                }

                // force-clear the ID as it does not match anything
                sourceProperty.Id = 0;
            }

            // insert a new property, or update an existing property that has 
            // been deletedin the meantime and we need to re-create
            // map/create
            destProperty = Mapper.Map&lt;PropertyType&gt;(sourceProperty);
            return destProperty;
        }

        private static void EnsureUniqueAliases(IEnumerable&lt;PropertyType&gt; properties)
        {
            var propertiesA = properties.ToArray();
            var distinctProperties = propertiesA
                .Select(x =&gt; x.Alias.ToUpperInvariant())
                .Distinct()
                .Count();
            if (distinctProperties != propertiesA.Length)
                throw new InvalidOperationException(&quot;Cannot map properties due to alias conflict.&quot;);
        }

        private static void EnsureUniqueNames(IEnumerable&lt;PropertyGroup&gt; groups)
        {
            var groupsA = groups.ToArray();
            var distinctProperties = groupsA
                .Select(x =&gt; x.Name.ToUpperInvariant())
                .Distinct()
                .Count();
            if (distinctProperties != groupsA.Length)
                throw new InvalidOperationException(&quot;Cannot map groups due to name conflict.&quot;);
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[27,9,27,10,1],[28,13,29,52,1],[29,52,29,76,1],[29,76,29,89,1],[29,89,29,90,1],[29,52,29,90,1],[29,90,30,53,1],[30,53,30,65,1],[30,65,31,61,1],[31,61,31,73,1],[31,73,32,60,1],[32,60,32,72,1],[32,72,33,60,1],[33,60,33,72,1],[33,72,34,63,1],[34,63,34,75,1],[34,75,34,77,1],[28,13,34,77,1],[35,9,35,10,1],[42,9,42,10,1],[43,13,44,59,1],[44,59,44,90,1],[44,90,44,103,0],[44,103,44,104,1],[44,59,44,104,1],[44,104,45,64,1],[45,64,45,83,1],[45,83,46,72,1],[46,72,46,91,1],[46,91,47,76,1],[47,76,47,95,1],[47,95,48,61,1],[48,61,48,151,1],[48,151,48,153,1],[43,13,48,153,1],[49,9,49,10,1],[56,9,56,10,1],[58,13,58,63,1],[59,13,59,57,1],[61,13,61,45,1],[61,45,61,74,0],[61,74,61,76,1],[61,13,61,76,1],[62,13,62,43,1],[62,43,62,71,0],[62,71,62,73,1],[62,13,62,73,1],[64,13,64,20,1],[64,22,64,29,0],[64,30,64,32,1],[64,33,64,39,1],[65,13,65,14,0],[66,17,66,45,0],[67,13,67,14,0],[69,13,69,20,1],[69,22,69,27,0],[69,28,69,30,1],[69,31,69,34,1],[70,13,70,14,0],[72,17,72,94,0],[73,17,73,35,0],[74,21,74,48,0],[75,13,75,14,0],[76,9,76,10,1],[83,9,83,10,1],[85,13,85,63,1],[86,13,86,57,1],[88,13,88,45,1],[88,45,88,74,0],[88,74,88,76,1],[88,13,88,76,1],[89,13,89,43,1],[89,43,89,71,0],[89,71,89,73,1],[89,13,89,73,1],[91,13,91,20,1],[91,22,91,29,0],[91,30,91,32,1],[91,33,91,39,1],[92,13,92,14,0],[93,17,93,45,0],[94,13,94,14,0],[96,13,96,20,1],[96,22,96,27,0],[96,28,96,30,1],[96,31,96,34,1],[97,13,97,14,0],[99,17,99,92,0],[100,17,100,35,0],[101,21,101,48,0],[102,13,102,14,0],[103,9,103,10,1],[111,9,111,10,1],[112,13,113,65,1],[113,65,113,84,1],[113,84,114,65,1],[114,65,114,84,1],[114,84,115,73,1],[115,73,115,92,1],[115,92,116,68,1],[116,68,116,87,1],[116,87,117,61,1],[117,61,117,80,1],[117,80,118,75,1],[118,75,118,87,1],[118,87,119,61,1],[119,61,119,176,1],[119,176,119,178,1],[112,13,119,178,1],[120,9,120,10,1],[127,9,127,10,1],[128,13,129,76,1],[129,76,129,95,1],[129,95,130,69,1],[130,69,130,88,1],[130,88,131,74,1],[131,74,131,120,1],[131,120,132,81,1],[132,81,132,100,1],[132,100,134,70,1],[134,70,134,89,1],[134,89,138,35,1],[138,35,138,109,1],[138,109,142,35,1],[142,35,142,88,1],[142,88,146,35,1],[146,35,146,110,1],[146,110,150,35,1],[150,35,150,155,1],[150,155,150,157,1],[128,13,150,157,1],[151,9,151,10,1],[168,9,168,10,1],[169,13,171,57,1],[171,57,171,89,1],[171,89,171,122,1],[171,122,171,123,1],[171,57,171,123,1],[171,123,172,57,1],[172,57,172,115,1],[172,115,175,65,1],[175,65,175,84,1],[175,84,176,65,1],[176,65,176,84,1],[176,84,178,68,1],[178,68,178,118,1],[178,118,179,64,1],[179,64,179,83,1],[179,83,180,60,1],[180,60,180,79,1],[180,79,181,64,1],[181,64,181,83,1],[181,83,183,69,1],[183,69,183,88,1],[183,88,184,75,1],[184,75,184,94,1],[184,94,186,72,1],[186,72,186,84,1],[186,84,190,35,1],[190,35,190,129,1],[190,129,193,17,1],[193,17,193,18,1],[193,18,211,21,1],[211,21,211,72,1],[211,72,212,21,1],[212,21,212,75,1],[212,75,213,21,1],[213,21,213,64,1],[213,64,214,21,1],[214,21,214,65,1],[214,65,214,95,1],[214,95,214,107,1],[214,21,214,107,1],[214,107,215,21,1],[215,21,215,28,1],[215,28,215,30,1],[215,30,215,45,1],[215,45,215,46,1],[215,46,215,48,1],[215,48,215,49,1],[215,49,215,61,1],[215,61,216,21,1],[216,21,216,22,1],[216,22,218,25,1],[218,25,218,83,1],[218,83,221,25,1],[221,25,222,41,1],[222,41,222,61,1],[222,61,223,42,1],[223,42,223,80,1],[223,80,224,40,1],[221,25,224,40,1],[224,40,228,25,1],[228,25,228,56,1],[228,56,229,29,1],[229,29,229,38,1],[229,38,232,25,1],[232,25,232,61,1],[232,61,233,25,1],[233,25,233,94,1],[233,94,234,25,1],[234,25,234,51,1],[234,51,235,21,1],[235,21,235,22,1],[235,22,238,21,1],[238,21,238,51,1],[238,51,239,21,1],[239,21,239,83,1],[239,83,245,21,1],[245,21,245,84,1],[245,84,245,105,1],[245,105,245,107,1],[245,21,245,107,1],[245,107,246,21,1],[246,21,246,56,1],[246,56,247,21,1],[247,21,247,22,1],[247,22,249,25,1],[249,25,250,41,1],[250,41,250,61,1],[250,61,251,42,1],[251,42,251,80,1],[251,80,252,40,1],[249,25,252,40,1],[252,40,255,25,1],[255,25,255,61,1],[255,61,256,25,1],[256,25,256,96,1],[256,96,257,21,1],[257,21,257,22,1],[257,22,261,17,1],[261,17,261,18,1],[261,18,261,20,1],[169,13,261,20,1],[262,9,262,10,1],[266,9,266,10,1],[268,13,268,36,1],[269,13,269,14,1],[272,17,272,64,1],[272,64,272,86,1],[272,86,272,88,1],[272,17,272,88,1],[273,17,273,39,1],[274,17,274,18,1],[275,21,275,56,1],[276,21,276,38,1],[280,17,280,36,1],[281,13,281,14,1],[286,13,286,64,1],[287,13,287,30,1],[288,9,288,10,1],[291,9,291,10,1],[293,13,293,39,1],[294,13,294,14,1],[297,17,297,71,1],[297,71,297,96,1],[297,96,297,98,1],[297,17,297,98,1],[298,17,298,42,1],[299,17,299,18,1],[300,21,300,62,1],[301,21,301,41,1],[305,17,305,39,1],[306,13,306,14,1],[311,13,311,69,1],[312,13,312,33,1],[313,9,313,10,1],[316,9,316,10,1],[317,13,317,52,1],[318,13,319,30,1],[319,30,319,56,1],[319,56,321,26,1],[318,13,321,26,1],[322,13,322,58,1],[323,17,323,101,0],[324,9,324,10,1],[327,9,327,10,1],[328,13,328,44,1],[329,13,330,30,1],[330,30,330,55,1],[330,55,332,26,1],[329,13,332,26,1],[333,13,333,54,1],[334,17,334,96,0],[335,9,335,10,1]]);
    </script>
  </body>
</html>