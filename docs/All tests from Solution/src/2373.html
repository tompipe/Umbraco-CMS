<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\umbraco.cms\helpers\xhtml.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using Umbraco.Core.Configuration;


namespace umbraco.cms.helpers
{
	/// &lt;summary&gt;
	/// Summary description for xhtml.
	/// &lt;/summary&gt;
	public class xhtml
	{
		public xhtml()
		{
			//
			// TODO: Add constructor logic here
			//
		}

        public static string TidyHtml(string html) {
            TidyNet.Tidy tidy = new TidyNet.Tidy();

            /* Set the options you want */
            tidy.Options.DocType = TidyNet.DocType.Strict;
            tidy.Options.DropFontTags = true;
            tidy.Options.LogicalEmphasis = true;
            if (GlobalSettings.EditXhtmlMode == &quot;true&quot;)
            {
                tidy.Options.Xhtml = true;
                tidy.Options.XmlOut = true;
            }
            else {
                tidy.Options.XmlOut = false;
                tidy.Options.Xhtml = false;
            }
            tidy.Options.MakeClean = true;
            tidy.Options.TidyMark = false;

            // To avoid entity encoding
            tidy.Options.CharEncoding = (TidyNet.CharEncoding)Enum.Parse(typeof(TidyNet.CharEncoding), UmbracoConfig.For.UmbracoSettings().Content.TidyCharEncoding);


            /* Declare the parameters that is needed */
            TidyNet.TidyMessageCollection tmc = new TidyNet.TidyMessageCollection();
            MemoryStream input = new MemoryStream();
            MemoryStream output = new MemoryStream();

            byte[] byteArray = System.Text.Encoding.UTF8.GetBytes(html);
            input.Write(byteArray, 0, byteArray.Length);
            input.Position = 0;
            tidy.Parse(input, output, tmc);

            string tidyed = System.Text.Encoding.UTF8.GetString(output.ToArray());

            // only return body
            string regex = @&quot;&lt;/{0,1}body[^&gt;]*&gt;&quot;;
            System.Text.RegularExpressions.RegexOptions options = ((System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace | System.Text.RegularExpressions.RegexOptions.Multiline)
                | System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            System.Text.RegularExpressions.Regex reg = new System.Text.RegularExpressions.Regex(regex, options);
            string[] s = reg.Split(tidyed);
            if (s.Length &gt; 1)
                return s[1];
            else
                return &quot;[tidy error]&quot;;
        }

		public static string BootstrapTidy(string html) 
		{
			string emptyTags = &quot;,br,hr,input,img,&quot;;	
			string regex = &quot;(&lt;[^\\?][^(&gt;| )]*&gt;)|&lt;([^\\?][^(&gt;| )]*)([^&gt;]*)&gt;&quot;;
			Hashtable replaceTag = new Hashtable();
			replaceTag.Add(&quot;strong&quot;, &quot;b&quot;);
			replaceTag.Add(&quot;em&quot;, &quot;i&quot;);

			System.Text.RegularExpressions.RegexOptions options = ((System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace | System.Text.RegularExpressions.RegexOptions.Multiline) 
				| System.Text.RegularExpressions.RegexOptions.IgnoreCase);
			System.Text.RegularExpressions.Regex reg = new System.Text.RegularExpressions.Regex(regex, options);

			foreach (Match m in reg.Matches(html)) 
			{
				string orgTag = &quot;&quot;;
				string tag = &quot;&quot;;
				string cleanTag = &quot;&quot;;

				if (m.Groups.Count &lt; 2 || (m.Groups[2].Value.ToLower() != &quot;img&quot; || (m.Groups[2].Value.ToLower() == &quot;img&quot; &amp;&amp; m.Value.IndexOf (&quot;?UMBRACO_MACRO&quot;) == -1))) 
				{

					if (m.Groups[1].Value != &quot;&quot;) 
					{
						orgTag = m.Groups[1].Value;
						cleanTag = replaceTags(m.Groups[1].Value.ToLower().Replace(&quot;&lt;&quot;, &quot;&quot;).Replace(&quot;/&gt;&quot;, &quot;&quot;).Replace(&quot;&gt;&quot;, &quot;&quot;).Trim(), replaceTag);
						tag = &quot;&lt;&quot; + cleanTag + &quot;&gt;&quot;;
					}
					else 
					{
						orgTag = &quot;&lt;&quot; + m.Groups[2].Value + m.Groups[3].Value + &quot;&gt;&quot;;

						// loop through the attributes and make them lowercase
						cleanTag = replaceTags(m.Groups[2].Value.ToLower(), replaceTag);
						tag = &quot;&lt;&quot; + cleanTag + returnLowerCaseAttributes(m.Groups[3].Value) + &quot;&gt;&quot;;
					}

					// Check for empty tags
					if (bool.Parse(GlobalSettings.EditXhtmlMode) &amp;&amp; emptyTags.IndexOf(&quot;,&quot;+cleanTag+&quot;,&quot;) &gt; -1 &amp;&amp; tag.IndexOf(&quot;/&gt;&quot;) == -1)
						tag = tag.Replace(&quot;&gt;&quot;, &quot; /&gt;&quot;);

					html = html.Replace(orgTag, tag);
				}

			}
			return html;
		}

		private static string replaceTags(string tag, Hashtable replaceTag) 
		{
			string closeBracket = &quot;&quot;;
			if (tag.Substring(0,1) == &quot;/&quot;) 
			{
				closeBracket = &quot;/&quot;;
				tag = tag.Substring(1, tag.Length-1);
			}

			if (replaceTag.ContainsKey(tag))
				return closeBracket+replaceTag[tag].ToString();
			else
				return closeBracket+tag;
		}

		[Obsolete(&quot;Has been superceded by Umbraco.Core.XmlHelper.GetAttributesFromElement&quot;)]
		public static Hashtable ReturnAttributes(String tag)
		{
			var h = new Hashtable();
			foreach (var i in Umbraco.Core.XmlHelper.GetAttributesFromElement(tag))
			{
				h.Add(i.Key, i.Value);
			}
			return h;
		}

		private static string returnLowerCaseAttributes(String tag) 
		{
			string newTag = &quot;&quot;;
			MatchCollection m = Regex.Matches(tag, &quot;(?&lt;attributeName&gt;\\S*)=\&quot;(?&lt;attributeValue&gt;[^\&quot;]*)\&quot;|(?&lt;attributeName&gt;\\S*)=(?&lt;attributeValue&gt;[^( |&gt;)]*)(&gt;| )&quot;,  RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace);
			foreach (System.Text.RegularExpressions.Match attributeSet in m) 
				newTag += &quot; &quot; + attributeSet.Groups[&quot;attributeName&quot;].Value.ToString().ToLower() + &quot;=\&quot;&quot; + attributeSet.Groups[&quot;attributeValue&quot;].Value.ToString() + &quot;\&quot;&quot;;

			return newTag;
		}

        // helper method gotten from:
        // http://stackoverflow.com/questions/20762/how-do-you-remove-invalid-hexadecimal-characters-from-an-xml-based-data-source-p#comment8130028_641632
	    internal static string RemoveIllegalXmlCharacters(string inString)
        {

            if (inString == null) return null;

            StringBuilder sbOutput = new StringBuilder();
            char ch;

            for (int i = 0; i &lt; inString.Length; i++)
            {
                ch = inString[i];
                if ((ch &gt;= 0x0020 &amp;&amp; ch &lt;= 0xD7FF) ||
                    (ch &gt;= 0xE000 &amp;&amp; ch &lt;= 0xFFFD) ||
                    ch == 0x0009 ||
                    ch == 0x000A ||
                    ch == 0x000D)
                {
                    sbOutput.Append(ch);
                }
            }
            return sbOutput.ToString();

        }
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[16,3,16,17,0],[17,3,17,4,0],[21,3,21,4,0],[23,52,23,53,0],[24,13,24,52,0],[27,13,27,59,0],[28,13,28,46,0],[29,13,29,49,0],[30,13,30,56,0],[31,13,31,14,0],[32,17,32,43,0],[33,17,33,44,0],[34,13,34,14,0],[35,18,35,19,0],[36,17,36,45,0],[37,17,37,44,0],[38,13,38,14,0],[39,13,39,43,0],[40,13,40,43,0],[43,13,43,166,0],[47,13,47,85,0],[48,13,48,53,0],[49,13,49,54,0],[51,13,51,73,0],[52,13,52,57,0],[53,13,53,32,0],[54,13,54,44,0],[56,13,56,83,0],[59,13,59,49,0],[60,13,61,75,0],[62,13,62,113,0],[63,13,63,44,0],[64,13,64,30,0],[65,17,65,29,0],[67,17,67,39,0],[68,9,68,10,0],[71,3,71,4,0],[72,4,72,43,0],[73,4,73,68,0],[74,4,74,43,0],[75,4,75,34,0],[76,4,76,30,0],[78,4,79,63,0],[80,4,80,104,0],[82,4,82,11,0],[82,13,82,20,0],[82,21,82,23,0],[82,24,82,41,0],[83,4,83,5,0],[84,5,84,24,0],[85,5,85,21,0],[86,5,86,26,0],[88,5,88,156,0],[89,5,89,6,0],[91,6,91,34,0],[92,6,92,7,0],[93,7,93,34,0],[94,7,94,130,0],[95,7,95,34,0],[96,6,96,7,0],[98,6,98,7,0],[99,7,99,66,0],[102,7,102,71,0],[103,7,103,81,0],[104,6,104,7,0],[107,6,107,122,0],[108,7,108,37,0],[110,6,110,39,0],[111,5,111,6,0],[113,4,113,5,0],[114,4,114,16,0],[115,3,115,4,0],[118,3,118,4,0],[119,4,119,29,0],[120,4,120,34,0],[121,4,121,5,0],[122,5,122,24,0],[123,5,123,42,0],[124,4,124,5,0],[126,4,126,36,0],[127,5,127,52,0],[129,5,129,29,0],[130,3,130,4,0],[134,3,134,4,0],[135,4,135,28,0],[136,4,136,11,0],[136,13,136,18,0],[136,19,136,21,0],[136,22,136,74,0],[137,4,137,5,0],[138,5,138,27,0],[139,4,139,5,0],[140,4,140,13,0],[141,3,141,4,0],[144,3,144,4,0],[145,4,145,23,0],[146,4,146,221,0],[147,4,147,11,0],[147,13,147,62,0],[147,63,147,65,0],[147,66,147,67,0],[148,5,148,157,0],[150,4,150,18,0],[151,3,151,4,0],[156,9,156,10,0],[158,13,158,34,0],[158,35,158,47,0],[160,13,160,58,0],[163,18,163,27,0],[163,29,163,48,0],[163,50,163,53,0],[164,13,164,14,0],[165,17,165,34,0],[166,17,170,34,0],[171,17,171,18,0],[172,21,172,41,0],[173,17,173,18,0],[174,13,174,14,0],[175,13,175,40,0],[177,9,177,10,0]]);
    </script>
  </body>
</html>