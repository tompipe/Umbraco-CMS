<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Media\Exif\JPEGFile.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Text;

namespace Umbraco.Core.Media.Exif
{
    /// &lt;summary&gt;
    /// Represents the binary view of a JPEG compressed file.
    /// &lt;/summary&gt;
    internal class JPEGFile : ImageFile
    {
        #region Member Variables
        private JPEGSection jfifApp0;
        private JPEGSection jfxxApp0;
        private JPEGSection exifApp1;
        private uint makerNoteOffset;
        private long exifIFDFieldOffset, gpsIFDFieldOffset, interopIFDFieldOffset, firstIFDFieldOffset;
        private long thumbOffsetLocation, thumbSizeLocation;
        private uint thumbOffsetValue, thumbSizeValue;
        private bool makerNoteProcessed;
        #endregion

        #region Properties
        /// &lt;summary&gt;
        /// Gets or sets the byte-order of the Exif properties.
        /// &lt;/summary&gt;
        public BitConverterEx.ByteOrder ByteOrder { get; set; }
        /// &lt;summary&gt;
        /// Gets or sets the sections contained in the &lt;see cref=&quot;ImageFile&quot;/&gt;.
        /// &lt;/summary&gt;
        public List&lt;JPEGSection&gt; Sections { get; private set; }
        /// &lt;summary&gt;
        /// Gets or sets non-standard trailing data following the End of Image (EOI) marker.
        /// &lt;/summary&gt;
        public byte[] TrailingData { get; private set; }
        #endregion

        #region Constructor
        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;ExifFile&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;stream&quot;&gt;A &lt;see cref=&quot;Sytem.IO.Stream&quot;/&gt; that contains image data.&lt;/param&gt;
        /// &lt;param name=&quot;encoding&quot;&gt;The encoding to be used for text metadata when the source encoding is unknown.&lt;/param&gt;
        protected internal JPEGFile(Stream stream, Encoding encoding)
        {
            Format = ImageFileFormat.JPEG;
            Sections = new List&lt;JPEGSection&gt;();
            TrailingData = new byte[0];
            Encoding = encoding;

            stream.Seek(0, SeekOrigin.Begin);

            // Read the Start of Image (SOI) marker. SOI marker is represented
            // with two bytes: 0xFF, 0xD8.
            byte[] markerbytes = new byte[2];
            if (stream.Read(markerbytes, 0, 2) != 2 || markerbytes[0] != 0xFF || markerbytes[1] != 0xD8)
                throw new NotValidJPEGFileException();
            stream.Seek(0, SeekOrigin.Begin);

            // Search and read sections until we reach the end of file.
            while (stream.Position != stream.Length)
            {
                // Read the next section marker. Section markers are two bytes 
                // with values 0xFF, 0x?? where ?? must not be 0x00 or 0xFF.
                if (stream.Read(markerbytes, 0, 2) != 2 || markerbytes[0] != 0xFF || markerbytes[1] == 0x00 || markerbytes[1] == 0xFF)
                    throw new NotValidJPEGFileException();

                JPEGMarker marker = (JPEGMarker)markerbytes[1];

                byte[] header = new byte[0];
                // SOI, EOI and RST markers do not contain any header
                if (marker != JPEGMarker.SOI &amp;&amp; marker != JPEGMarker.EOI &amp;&amp; !(marker &gt;= JPEGMarker.RST0 &amp;&amp; marker &lt;= JPEGMarker.RST7))
                {
                    // Length of the header including the length bytes.
                    // This value is a 16-bit unsigned integer 
                    // in big endian byte-order.
                    byte[] lengthbytes = new byte[2];
                    if (stream.Read(lengthbytes, 0, 2) != 2)
                        throw new NotValidJPEGFileException();
                    long length = (long)BitConverterEx.BigEndian.ToUInt16(lengthbytes, 0);

                    // Read section header.
                    header = new byte[length - 2];
                    int bytestoread = header.Length;
                    while (bytestoread &gt; 0)
                    {
                        int count = Math.Min(bytestoread, 4 * 1024);
                        int bytesread = stream.Read(header, header.Length - bytestoread, count);
                        if (bytesread == 0)
                            throw new NotValidJPEGFileException();
                        bytestoread -= bytesread;
                    }
                }

                // Start of Scan (SOS) sections and RST sections are immediately
                // followed by entropy coded data. For that, we need to read until
                // the next section marker once we reach a SOS or RST.
                byte[] entropydata = new byte[0];
                if (marker == JPEGMarker.SOS || (marker &gt;= JPEGMarker.RST0 &amp;&amp; marker &lt;= JPEGMarker.RST7))
                {
                    long position = stream.Position;

                    // Search for the next section marker
                    while (true)
                    {
                        // Search for an 0xFF indicating start of a marker
                        int nextbyte = 0;
                        do
                        {
                            nextbyte = stream.ReadByte();
                            if (nextbyte == -1)
                                throw new NotValidJPEGFileException();
                        } while ((byte)nextbyte != 0xFF);

                        // Skip filler bytes (0xFF)
                        do
                        {
                            nextbyte = stream.ReadByte();
                            if (nextbyte == -1)
                                throw new NotValidJPEGFileException();
                        } while ((byte)nextbyte == 0xFF);

                        // Looks like a section marker. The next byte must not be 0x00.
                        if ((byte)nextbyte != 0x00)
                        {
                            // We reached a section marker. Calculate the
                            // length of the entropy coded data.
                            stream.Seek(-2, SeekOrigin.Current);
                            long edlength = stream.Position - position;
                            stream.Seek(-edlength, SeekOrigin.Current);

                            // Read entropy coded data
                            entropydata = new byte[edlength];
                            int bytestoread = entropydata.Length;
                            while (bytestoread &gt; 0)
                            {
                                int count = Math.Min(bytestoread, 4 * 1024);
                                int bytesread = stream.Read(entropydata, entropydata.Length - bytestoread, count);
                                if (bytesread == 0)
                                    throw new NotValidJPEGFileException();
                                bytestoread -= bytesread;
                            }

                            break;
                        }
                    }
                }

                // Store section.
                JPEGSection section = new JPEGSection(marker, header, entropydata);
                Sections.Add(section);

                // Some propriety formats store data past the EOI marker
                if (marker == JPEGMarker.EOI)
                {
                    int bytestoread = (int)(stream.Length - stream.Position);
                    TrailingData = new byte[bytestoread];
                    while (bytestoread &gt; 0)
                    {
                        int count = (int)Math.Min(bytestoread, 4 * 1024);
                        int bytesread = stream.Read(TrailingData, TrailingData.Length - bytestoread, count);
                        if (bytesread == 0)
                            throw new NotValidJPEGFileException();
                        bytestoread -= bytesread;
                    }
                }
            }

            // Read metadata sections
            ReadJFIFAPP0();
            ReadJFXXAPP0();
            ReadExifAPP1();

            // Process the maker note
            makerNoteProcessed = false;
        }
        #endregion

        #region Instance Methods
        /// &lt;summary&gt;
        /// Saves the JPEG/Exif image to the given stream.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;filename&quot;&gt;The path to the JPEG/Exif file.&lt;/param&gt;
        /// &lt;param name=&quot;preserveMakerNote&quot;&gt;Determines whether the maker note offset of
        /// the original file will be preserved.&lt;/param&gt;
        public void Save(Stream stream, bool preserveMakerNote)
        {
            WriteJFIFApp0();
            WriteJFXXApp0();
            WriteExifApp1(preserveMakerNote);

            // Write sections
            foreach (JPEGSection section in Sections)
            {
                // Section header (including length bytes and section marker) 
                // must not exceed 64 kB.
                if (section.Header.Length + 2 + 2 &gt; 64 * 1024)
                    throw new SectionExceeds64KBException();

                // APP sections must have a header.
                // Otherwise skip the entire section.
                if (section.Marker &gt;= JPEGMarker.APP0 &amp;&amp; section.Marker &lt;= JPEGMarker.APP15 &amp;&amp; section.Header.Length == 0)
                    continue;

                // Write section marker
                stream.Write(new byte[] { 0xFF, (byte)section.Marker }, 0, 2);

                // SOI, EOI and RST markers do not contain any header
                if (section.Marker != JPEGMarker.SOI &amp;&amp; section.Marker != JPEGMarker.EOI &amp;&amp; !(section.Marker &gt;= JPEGMarker.RST0 &amp;&amp; section.Marker &lt;= JPEGMarker.RST7))
                {
                    // Header length including the length field itself
                    stream.Write(BitConverterEx.BigEndian.GetBytes((ushort)(section.Header.Length + 2)), 0, 2);

                    // Write section header
                    if (section.Header.Length != 0)
                        stream.Write(section.Header, 0, section.Header.Length);
                }

                // Write entropy coded data
                if (section.EntropyData.Length != 0)
                    stream.Write(section.EntropyData, 0, section.EntropyData.Length);
            }

            // Write trailing data, if any
            if (TrailingData.Length != 0)
                stream.Write(TrailingData, 0, TrailingData.Length);
        }

        /// &lt;summary&gt;
        /// Saves the JPEG/Exif image with the given filename.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;filename&quot;&gt;The path to the JPEG/Exif file.&lt;/param&gt;
        /// &lt;param name=&quot;preserveMakerNote&quot;&gt;Determines whether the maker note offset of
        /// the original file will be preserved.&lt;/param&gt;
        public void Save(string filename, bool preserveMakerNote)
        {
            using (FileStream stream = new FileStream(filename, FileMode.Create, FileAccess.Write, FileShare.None))
            {
                Save(stream, preserveMakerNote);
            }
        }

        /// &lt;summary&gt;
        /// Saves the JPEG/Exif image with the given filename.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;filename&quot;&gt;The path to the JPEG/Exif file.&lt;/param&gt;
        public override void Save(string filename)
        {
            Save(filename, true);
        }

        /// &lt;summary&gt;
        /// Saves the JPEG/Exif image to the given stream.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;filename&quot;&gt;The path to the JPEG/Exif file.&lt;/param&gt;
        public override void Save(Stream stream)
        {
            Save(stream, true);
        }

        /// &lt;summary&gt;
        /// Returns a System.Drawing.Image created with image data.
        /// &lt;/summary&gt;
        public override Image ToImage()
        {
            MemoryStream stream = new MemoryStream();
            Save(stream);
            return Image.FromStream(stream);
        }
        #endregion

        #region Private Helper Methods
        /// &lt;summary&gt;
        /// Reads the APP0 section containing JFIF metadata.
        /// &lt;/summary&gt;
        private void ReadJFIFAPP0()
        {
            // Find the APP0 section containing JFIF metadata
            jfifApp0 = Sections.Find(a =&gt; (a.Marker == JPEGMarker.APP0) &amp;&amp;
                a.Header.Length &gt;= 5 &amp;&amp;
                (Encoding.ASCII.GetString(a.Header, 0, 5) == &quot;JFIF\0&quot;));

            // If there is no APP0 section, return.
            if (jfifApp0 == null)
                return;

            byte[] header = jfifApp0.Header;
            BitConverterEx jfifConv = BitConverterEx.BigEndian;

            // Version
            ushort version = jfifConv.ToUInt16(header, 5);
            Properties.Add(new JFIFVersion(ExifTag.JFIFVersion, version));

            // Units
            byte unit = header[7];
            Properties.Add(new ExifEnumProperty&lt;JFIFDensityUnit&gt;(ExifTag.JFIFUnits, (JFIFDensityUnit)unit));

            // X and Y densities
            ushort xdensity = jfifConv.ToUInt16(header, 8);
            Properties.Add(new ExifUShort(ExifTag.XDensity, xdensity));
            ushort ydensity = jfifConv.ToUInt16(header, 10);
            Properties.Add(new ExifUShort(ExifTag.YDensity, ydensity));

            // Thumbnails pixel count
            byte xthumbnail = header[12];
            Properties.Add(new ExifByte(ExifTag.JFIFXThumbnail, xthumbnail));
            byte ythumbnail = header[13];
            Properties.Add(new ExifByte(ExifTag.JFIFYThumbnail, ythumbnail));

            // Read JFIF thumbnail
            int n = xthumbnail * ythumbnail;
            byte[] jfifThumbnail = new byte[n];
            Array.Copy(header, 14, jfifThumbnail, 0, n);
            Properties.Add(new JFIFThumbnailProperty(ExifTag.JFIFThumbnail, new JFIFThumbnail(JFIFThumbnail.ImageFormat.JPEG, jfifThumbnail)));
        }
        /// &lt;summary&gt;
        /// Replaces the contents of the APP0 section with the JFIF properties.
        /// &lt;/summary&gt;
        private bool WriteJFIFApp0()
        {
            // Which IFD sections do we have?
            List&lt;ExifProperty&gt; ifdjfef = new List&lt;ExifProperty&gt;();
            foreach (ExifProperty prop in Properties)
            {
                if (prop.IFD == IFD.JFIF)
                    ifdjfef.Add(prop);
            }

            if (ifdjfef.Count == 0)
            {
                // Nothing to write
                return false;
            }


            // Create a memory stream to write the APP0 section to
            MemoryStream ms = new MemoryStream();

            // JFIF identifer
            ms.Write(Encoding.ASCII.GetBytes(&quot;JFIF\0&quot;), 0, 5);

            // Write tags
            foreach (ExifProperty prop in ifdjfef)
            {
                ExifInterOperability interop = prop.Interoperability;
                byte[] data = interop.Data;
                if (BitConverterEx.SystemByteOrder != BitConverterEx.ByteOrder.BigEndian &amp;&amp; interop.TypeID == 3)
                    Array.Reverse(data);
                ms.Write(data, 0, data.Length);
            }

            ms.Close();

            // Return APP0 header
            jfifApp0.Header = ms.ToArray();
            return true;
        }
        /// &lt;summary&gt;
        /// Reads the APP0 section containing JFIF extension metadata.
        /// &lt;/summary&gt;
        private void ReadJFXXAPP0()
        {
            // Find the APP0 section containing JFIF metadata
            jfxxApp0 = Sections.Find(a =&gt; (a.Marker == JPEGMarker.APP0) &amp;&amp;
                a.Header.Length &gt;= 5 &amp;&amp;
                (Encoding.ASCII.GetString(a.Header, 0, 5) == &quot;JFXX\0&quot;));

            // If there is no APP0 section, return.
            if (jfxxApp0 == null)
                return;

            byte[] header = jfxxApp0.Header;

            // Version
            JFIFExtension version = (JFIFExtension)header[5];
            Properties.Add(new ExifEnumProperty&lt;JFIFExtension&gt;(ExifTag.JFXXExtensionCode, version));

            // Read thumbnail
            if (version == JFIFExtension.ThumbnailJPEG)
            {
                byte[] data = new byte[header.Length - 6];
                Array.Copy(header, 6, data, 0, data.Length);
                Properties.Add(new JFIFThumbnailProperty(ExifTag.JFXXThumbnail, new JFIFThumbnail(JFIFThumbnail.ImageFormat.JPEG, data)));
            }
            else if (version == JFIFExtension.Thumbnail24BitRGB)
            {
                // Thumbnails pixel count
                byte xthumbnail = header[6];
                Properties.Add(new ExifByte(ExifTag.JFXXXThumbnail, xthumbnail));
                byte ythumbnail = header[7];
                Properties.Add(new ExifByte(ExifTag.JFXXYThumbnail, ythumbnail));
                byte[] data = new byte[3 * xthumbnail * ythumbnail];
                Array.Copy(header, 8, data, 0, data.Length);
                Properties.Add(new JFIFThumbnailProperty(ExifTag.JFXXThumbnail, new JFIFThumbnail(JFIFThumbnail.ImageFormat.BMP24Bit, data)));
            }
            else if (version == JFIFExtension.ThumbnailPaletteRGB)
            {
                // Thumbnails pixel count
                byte xthumbnail = header[6];
                Properties.Add(new ExifByte(ExifTag.JFXXXThumbnail, xthumbnail));
                byte ythumbnail = header[7];
                Properties.Add(new ExifByte(ExifTag.JFXXYThumbnail, ythumbnail));
                byte[] palette = new byte[768];
                Array.Copy(header, 8, palette, 0, palette.Length);
                byte[] data = new byte[xthumbnail * ythumbnail];
                Array.Copy(header, 8 + 768, data, 0, data.Length);
                Properties.Add(new JFIFThumbnailProperty(ExifTag.JFXXThumbnail, new JFIFThumbnail(palette, data)));
            }
        }
        /// &lt;summary&gt;
        /// Replaces the contents of the APP0 section with the JFIF extension properties.
        /// &lt;/summary&gt;
        private bool WriteJFXXApp0()
        {
            // Which IFD sections do we have?
            List&lt;ExifProperty&gt; ifdjfef = new List&lt;ExifProperty&gt;();
            foreach (ExifProperty prop in Properties)
            {
                if (prop.IFD == IFD.JFXX)
                    ifdjfef.Add(prop);
            }

            if (ifdjfef.Count == 0)
            {
                // Nothing to write
                return false;
            }

            // Create a memory stream to write the APP0 section to
            MemoryStream ms = new MemoryStream();

            // JFIF identifer
            ms.Write(Encoding.ASCII.GetBytes(&quot;JFXX\0&quot;), 0, 5);

            // Write tags
            foreach (ExifProperty prop in ifdjfef)
            {
                ExifInterOperability interop = prop.Interoperability;
                byte[] data = interop.Data;
                if (BitConverterEx.SystemByteOrder != BitConverterEx.ByteOrder.BigEndian &amp;&amp; interop.TypeID == 3)
                    Array.Reverse(data);
                ms.Write(data, 0, data.Length);
            }

            ms.Close();

            // Return APP0 header
            jfxxApp0.Header = ms.ToArray();
            return true;
        }

        /// &lt;summary&gt;
        /// Reads the APP1 section containing Exif metadata.
        /// &lt;/summary&gt;
        private void ReadExifAPP1()
        {
            // Find the APP1 section containing Exif metadata
            exifApp1 = Sections.Find(a =&gt; (a.Marker == JPEGMarker.APP1) &amp;&amp;
                a.Header.Length &gt;= 6 &amp;&amp;
                (Encoding.ASCII.GetString(a.Header, 0, 6) == &quot;Exif\0\0&quot;));

            // If there is no APP1 section, add a new one after the last APP0 section (if any).
            if (exifApp1 == null)
            {
                int insertionIndex = Sections.FindLastIndex(a =&gt; a.Marker == JPEGMarker.APP0);
                if (insertionIndex == -1) insertionIndex = 0;
                insertionIndex++;
                exifApp1 = new JPEGSection(JPEGMarker.APP1);
                Sections.Insert(insertionIndex, exifApp1);
                if (BitConverterEx.SystemByteOrder == BitConverterEx.ByteOrder.LittleEndian)
                    ByteOrder = BitConverterEx.ByteOrder.LittleEndian;
                else
                    ByteOrder = BitConverterEx.ByteOrder.BigEndian;
                return;
            }

            byte[] header = exifApp1.Header;
            SortedList&lt;int, IFD&gt; ifdqueue = new SortedList&lt;int, IFD&gt;();
            makerNoteOffset = 0;

            // TIFF header
            int tiffoffset = 6;
            if (header[tiffoffset] == 0x49 &amp;&amp; header[tiffoffset + 1] == 0x49)
                ByteOrder = BitConverterEx.ByteOrder.LittleEndian;
            else if (header[tiffoffset] == 0x4D &amp;&amp; header[tiffoffset + 1] == 0x4D)
                ByteOrder = BitConverterEx.ByteOrder.BigEndian;
            else
                throw new NotValidExifFileException();

            // TIFF header may have a different byte order
            BitConverterEx.ByteOrder tiffByteOrder = ByteOrder;
            if (BitConverterEx.LittleEndian.ToUInt16(header, tiffoffset + 2) == 42)
                tiffByteOrder = BitConverterEx.ByteOrder.LittleEndian;
            else if (BitConverterEx.BigEndian.ToUInt16(header, tiffoffset + 2) == 42)
                tiffByteOrder = BitConverterEx.ByteOrder.BigEndian;
            else
                throw new NotValidExifFileException();

            // Offset to 0th IFD
            int ifd0offset = (int)BitConverterEx.ToUInt32(header, tiffoffset + 4, tiffByteOrder, BitConverterEx.SystemByteOrder);
            ifdqueue.Add(ifd0offset, IFD.Zeroth);

            BitConverterEx conv = new BitConverterEx(ByteOrder, BitConverterEx.SystemByteOrder);
            int thumboffset = -1;
            int thumblength = 0;
            int thumbtype = -1;
            // Read IFDs
            while (ifdqueue.Count != 0)
            {
                int ifdoffset = tiffoffset + ifdqueue.Keys[0];
                IFD currentifd = ifdqueue.Values[0];
                ifdqueue.RemoveAt(0);

                // Field count
                ushort fieldcount = conv.ToUInt16(header, ifdoffset);
                for (short i = 0; i &lt; fieldcount; i++)
                {
                    // Read field info
                    int fieldoffset = ifdoffset + 2 + 12 * i;
                    ushort tag = conv.ToUInt16(header, fieldoffset);
                    ushort type = conv.ToUInt16(header, fieldoffset + 2);
                    uint count = conv.ToUInt32(header, fieldoffset + 4);
                    byte[] value = new byte[4];
                    Array.Copy(header, fieldoffset + 8, value, 0, 4);

                    // Fields containing offsets to other IFDs
                    if (currentifd == IFD.Zeroth &amp;&amp; tag == 0x8769)
                    {
                        int exififdpointer = (int)conv.ToUInt32(value, 0);
                        ifdqueue.Add(exififdpointer, IFD.EXIF);
                    }
                    else if (currentifd == IFD.Zeroth &amp;&amp; tag == 0x8825)
                    {
                        int gpsifdpointer = (int)conv.ToUInt32(value, 0);
                        ifdqueue.Add(gpsifdpointer, IFD.GPS);
                    }
                    else if (currentifd == IFD.EXIF &amp;&amp; tag == 0xa005)
                    {
                        int interopifdpointer = (int)conv.ToUInt32(value, 0);
                        ifdqueue.Add(interopifdpointer, IFD.Interop);
                    }

                    // Save the offset to maker note data
                    if (currentifd == IFD.EXIF &amp;&amp; tag == 37500)
                        makerNoteOffset = conv.ToUInt32(value, 0);

                    // Calculate the bytes we need to read
                    uint baselength = 0;
                    if (type == 1 || type == 2 || type == 7)
                        baselength = 1;
                    else if (type == 3)
                        baselength = 2;
                    else if (type == 4 || type == 9)
                        baselength = 4;
                    else if (type == 5 || type == 10)
                        baselength = 8;
                    uint totallength = count * baselength;

                    // If field value does not fit in 4 bytes
                    // the value field is an offset to the actual
                    // field value
                    int fieldposition = 0;
                    if (totallength &gt; 4)
                    {
                        fieldposition = tiffoffset + (int)conv.ToUInt32(value, 0);
                        value = new byte[totallength];
                        Array.Copy(header, fieldposition, value, 0, totallength);
                    }

                    // Compressed thumbnail data
                    if (currentifd == IFD.First &amp;&amp; tag == 0x201)
                    {
                        thumbtype = 0;
                        thumboffset = (int)conv.ToUInt32(value, 0);
                    }
                    else if (currentifd == IFD.First &amp;&amp; tag == 0x202)
                        thumblength = (int)conv.ToUInt32(value, 0);

                    // Uncompressed thumbnail data
                    if (currentifd == IFD.First &amp;&amp; tag == 0x111)
                    {
                        thumbtype = 1;
                        // Offset to first strip
                        if (type == 3)
                            thumboffset = (int)conv.ToUInt16(value, 0);
                        else
                            thumboffset = (int)conv.ToUInt32(value, 0);
                    }
                    else if (currentifd == IFD.First &amp;&amp; tag == 0x117)
                    {
                        thumblength = 0;
                        for (int j = 0; j &lt; count; j++)
                        {
                            if (type == 3)
                                thumblength += (int)conv.ToUInt16(value, 0);
                            else
                                thumblength += (int)conv.ToUInt32(value, 0);
                        }
                    }

                    // Create the exif property from the interop data
                    ExifProperty prop = ExifPropertyFactory.Get(tag, type, count, value, ByteOrder, currentifd, Encoding);
                    Properties.Add(prop);
                }

                // 1st IFD pointer
                int firstifdpointer = (int)conv.ToUInt32(header, ifdoffset + 2 + 12 * fieldcount);
                if (firstifdpointer != 0)
                    ifdqueue.Add(firstifdpointer, IFD.First);
                // Read thumbnail
                if (thumboffset != -1 &amp;&amp; thumblength != 0 &amp;&amp; Thumbnail == null)
                {
                    if (thumbtype == 0)
                    {
                        using (MemoryStream ts = new MemoryStream(header, tiffoffset + thumboffset, thumblength))
                        {
                            Thumbnail = ImageFile.FromStream(ts);
                        }
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// Replaces the contents of the APP1 section with the Exif properties.
        /// &lt;/summary&gt;
        private bool WriteExifApp1(bool preserveMakerNote)
        {
            // Zero out IFD field offsets. We will fill those as we write the IFD sections
            exifIFDFieldOffset = 0;
            gpsIFDFieldOffset = 0;
            interopIFDFieldOffset = 0;
            firstIFDFieldOffset = 0;
            // We also do not know the location of the embedded thumbnail yet
            thumbOffsetLocation = 0;
            thumbOffsetValue = 0;
            thumbSizeLocation = 0;
            thumbSizeValue = 0;
            // Write thumbnail tags if they are missing, remove otherwise
            if (Thumbnail == null)
            {
                Properties.Remove(ExifTag.ThumbnailJPEGInterchangeFormat);
                Properties.Remove(ExifTag.ThumbnailJPEGInterchangeFormatLength);
            }
            else
            {
                if (!Properties.ContainsKey(ExifTag.ThumbnailJPEGInterchangeFormat))
                    Properties.Add(new ExifUInt(ExifTag.ThumbnailJPEGInterchangeFormat, 0));
                if (!Properties.ContainsKey(ExifTag.ThumbnailJPEGInterchangeFormatLength))
                    Properties.Add(new ExifUInt(ExifTag.ThumbnailJPEGInterchangeFormatLength, 0));
            }

            // Which IFD sections do we have?
            Dictionary&lt;ExifTag, ExifProperty&gt; ifdzeroth = new Dictionary&lt;ExifTag, ExifProperty&gt;();
            Dictionary&lt;ExifTag, ExifProperty&gt; ifdexif = new Dictionary&lt;ExifTag, ExifProperty&gt;();
            Dictionary&lt;ExifTag, ExifProperty&gt; ifdgps = new Dictionary&lt;ExifTag, ExifProperty&gt;();
            Dictionary&lt;ExifTag, ExifProperty&gt; ifdinterop = new Dictionary&lt;ExifTag, ExifProperty&gt;();
            Dictionary&lt;ExifTag, ExifProperty&gt; ifdfirst = new Dictionary&lt;ExifTag, ExifProperty&gt;();

            foreach (ExifProperty prop in Properties)
            {
                switch (prop.IFD)
                {
                    case IFD.Zeroth:
                        ifdzeroth.Add(prop.Tag, prop);
                        break;
                    case IFD.EXIF:
                        ifdexif.Add(prop.Tag, prop);
                        break;
                    case IFD.GPS:
                        ifdgps.Add(prop.Tag, prop);
                        break;
                    case IFD.Interop:
                        ifdinterop.Add(prop.Tag, prop);
                        break;
                    case IFD.First:
                        ifdfirst.Add(prop.Tag, prop);
                        break;
                }
            }

            // Add IFD pointers if they are missing
            // We will write the pointer values later on
            if (ifdexif.Count != 0 &amp;&amp; !ifdzeroth.ContainsKey(ExifTag.EXIFIFDPointer))
                ifdzeroth.Add(ExifTag.EXIFIFDPointer, new ExifUInt(ExifTag.EXIFIFDPointer, 0));
            if (ifdgps.Count != 0 &amp;&amp; !ifdzeroth.ContainsKey(ExifTag.GPSIFDPointer))
                ifdzeroth.Add(ExifTag.GPSIFDPointer, new ExifUInt(ExifTag.GPSIFDPointer, 0));
            if (ifdinterop.Count != 0 &amp;&amp; !ifdexif.ContainsKey(ExifTag.InteroperabilityIFDPointer))
                ifdexif.Add(ExifTag.InteroperabilityIFDPointer, new ExifUInt(ExifTag.InteroperabilityIFDPointer, 0));

            // Remove IFD pointers if IFD sections are missing
            if (ifdexif.Count == 0 &amp;&amp; ifdzeroth.ContainsKey(ExifTag.EXIFIFDPointer))
                ifdzeroth.Remove(ExifTag.EXIFIFDPointer);
            if (ifdgps.Count == 0 &amp;&amp; ifdzeroth.ContainsKey(ExifTag.GPSIFDPointer))
                ifdzeroth.Remove(ExifTag.GPSIFDPointer);
            if (ifdinterop.Count == 0 &amp;&amp; ifdexif.ContainsKey(ExifTag.InteroperabilityIFDPointer))
                ifdexif.Remove(ExifTag.InteroperabilityIFDPointer);

            if (ifdzeroth.Count == 0 &amp;&amp; ifdgps.Count == 0 &amp;&amp; ifdinterop.Count == 0 &amp;&amp; ifdfirst.Count == 0 &amp;&amp; Thumbnail == null)
            {
                // Nothing to write
                return false;
            }

            // We will need these bitconverter to write byte-ordered data
            BitConverterEx bceExif = new BitConverterEx(BitConverterEx.SystemByteOrder, ByteOrder);

            // Create a memory stream to write the APP1 section to
            MemoryStream ms = new MemoryStream();

            // Exif identifer
            ms.Write(Encoding.ASCII.GetBytes(&quot;Exif\0\0&quot;), 0, 6);

            // TIFF header
            // Byte order
            long tiffoffset = ms.Position;
            ms.Write((ByteOrder == BitConverterEx.ByteOrder.LittleEndian ? new byte[] { 0x49, 0x49 } : new byte[] { 0x4D, 0x4D }), 0, 2);
            // TIFF ID
            ms.Write(bceExif.GetBytes((ushort)42), 0, 2);
            // Offset to 0th IFD
            ms.Write(bceExif.GetBytes((uint)8), 0, 4);

            // Write IFDs
            WriteIFD(ms, ifdzeroth, IFD.Zeroth, tiffoffset, preserveMakerNote);
            uint exififdrelativeoffset = (uint)(ms.Position - tiffoffset);
            WriteIFD(ms, ifdexif, IFD.EXIF, tiffoffset, preserveMakerNote);
            uint gpsifdrelativeoffset = (uint)(ms.Position - tiffoffset);
            WriteIFD(ms, ifdgps, IFD.GPS, tiffoffset, preserveMakerNote);
            uint interopifdrelativeoffset = (uint)(ms.Position - tiffoffset);
            WriteIFD(ms, ifdinterop, IFD.Interop, tiffoffset, preserveMakerNote);
            uint firstifdrelativeoffset = (uint)(ms.Position - tiffoffset);
            WriteIFD(ms, ifdfirst, IFD.First, tiffoffset, preserveMakerNote);

            // Now that we now the location of IFDs we can go back and write IFD offsets
            if (exifIFDFieldOffset != 0)
            {
                ms.Seek(exifIFDFieldOffset, SeekOrigin.Begin);
                ms.Write(bceExif.GetBytes(exififdrelativeoffset), 0, 4);
            }
            if (gpsIFDFieldOffset != 0)
            {
                ms.Seek(gpsIFDFieldOffset, SeekOrigin.Begin);
                ms.Write(bceExif.GetBytes(gpsifdrelativeoffset), 0, 4);
            }
            if (interopIFDFieldOffset != 0)
            {
                ms.Seek(interopIFDFieldOffset, SeekOrigin.Begin);
                ms.Write(bceExif.GetBytes(interopifdrelativeoffset), 0, 4);
            }
            if (firstIFDFieldOffset != 0)
            {
                ms.Seek(firstIFDFieldOffset, SeekOrigin.Begin);
                ms.Write(bceExif.GetBytes(firstifdrelativeoffset), 0, 4);
            }
            // We can write thumbnail location now
            if (thumbOffsetLocation != 0)
            {
                ms.Seek(thumbOffsetLocation, SeekOrigin.Begin);
                ms.Write(bceExif.GetBytes(thumbOffsetValue), 0, 4);
            }
            if (thumbSizeLocation != 0)
            {
                ms.Seek(thumbSizeLocation, SeekOrigin.Begin);
                ms.Write(bceExif.GetBytes(thumbSizeValue), 0, 4);
            }

            ms.Close();

            // Return APP1 header
            exifApp1.Header = ms.ToArray();
            return true;
        }

        private void WriteIFD(MemoryStream stream, Dictionary&lt;ExifTag, ExifProperty&gt; ifd, IFD ifdtype, long tiffoffset, bool preserveMakerNote)
        {
            BitConverterEx conv = new BitConverterEx(BitConverterEx.SystemByteOrder, ByteOrder);

            // Create a queue of fields to write
            Queue&lt;ExifProperty&gt; fieldqueue = new Queue&lt;ExifProperty&gt;();
            foreach (ExifProperty prop in ifd.Values)
                if (prop.Tag != ExifTag.MakerNote)
                    fieldqueue.Enqueue(prop);
            // Push the maker note data to the end
            if (ifd.ContainsKey(ExifTag.MakerNote))
                fieldqueue.Enqueue(ifd[ExifTag.MakerNote]);

            // Offset to start of field data from start of TIFF header
            uint dataoffset = (uint)(2 + ifd.Count * 12 + 4 + stream.Position - tiffoffset);
            uint currentdataoffset = dataoffset;
            long absolutedataoffset = stream.Position + (2 + ifd.Count * 12 + 4);

            bool makernotewritten = false;
            // Field count
            stream.Write(conv.GetBytes((ushort)ifd.Count), 0, 2);
            // Fields
            while (fieldqueue.Count != 0)
            {
                ExifProperty field = fieldqueue.Dequeue();
                ExifInterOperability interop = field.Interoperability;

                uint fillerbytecount = 0;

                // Try to preserve the makernote data offset
                if (!makernotewritten &amp;&amp;
                    !makerNoteProcessed &amp;&amp;
                    makerNoteOffset != 0 &amp;&amp;
                    ifdtype == IFD.EXIF &amp;&amp;
                    field.Tag != ExifTag.MakerNote &amp;&amp;
                    interop.Data.Length &gt; 4 &amp;&amp;
                    currentdataoffset + interop.Data.Length &gt; makerNoteOffset &amp;&amp;
                    ifd.ContainsKey(ExifTag.MakerNote))
                {
                    // Delay writing this field until we write makernote data
                    fieldqueue.Enqueue(field);
                    continue;
                }
                else if (field.Tag == ExifTag.MakerNote)
                {
                    makernotewritten = true;
                    // We may need to write filler bytes to preserve maker note offset
                    if (preserveMakerNote &amp;&amp; !makerNoteProcessed &amp;&amp; (makerNoteOffset &gt; currentdataoffset))
                        fillerbytecount = makerNoteOffset - currentdataoffset;
                    else
                        fillerbytecount = 0;
                }

                // Tag
                stream.Write(conv.GetBytes(interop.TagID), 0, 2);
                // Type
                stream.Write(conv.GetBytes(interop.TypeID), 0, 2);
                // Count
                stream.Write(conv.GetBytes(interop.Count), 0, 4);
                // Field data
                byte[] data = interop.Data;
                if (ByteOrder != BitConverterEx.SystemByteOrder &amp;&amp;
                    (interop.TypeID == 3 || interop.TypeID == 4 || interop.TypeID == 9 ||
                    interop.TypeID == 5 || interop.TypeID == 10))
                {
                    int vlen = 4;
                    if (interop.TypeID == 3) vlen = 2;
                    int n = data.Length / vlen;

                    for (int i = 0; i &lt; n; i++)
                        Array.Reverse(data, i * vlen, vlen);
                }

                // Fields containing offsets to other IFDs
                // Just store their offets, we will write the values later on when we know the lengths of IFDs
                if (ifdtype == IFD.Zeroth &amp;&amp; interop.TagID == 0x8769)
                    exifIFDFieldOffset = stream.Position;
                else if (ifdtype == IFD.Zeroth &amp;&amp; interop.TagID == 0x8825)
                    gpsIFDFieldOffset = stream.Position;
                else if (ifdtype == IFD.EXIF &amp;&amp; interop.TagID == 0xa005)
                    interopIFDFieldOffset = stream.Position;
                else if (ifdtype == IFD.First &amp;&amp; interop.TagID == 0x201)
                    thumbOffsetLocation = stream.Position;
                else if (ifdtype == IFD.First &amp;&amp; interop.TagID == 0x202)
                    thumbSizeLocation = stream.Position;

                // Write 4 byte field value or field data
                if (data.Length &lt;= 4)
                {
                    stream.Write(data, 0, data.Length);
                    for (int i = data.Length; i &lt; 4; i++)
                        stream.WriteByte(0);
                }
                else
                {
                    // Pointer to data area relative to TIFF header
                    stream.Write(conv.GetBytes(currentdataoffset + fillerbytecount), 0, 4);
                    // Actual data
                    long currentoffset = stream.Position;
                    stream.Seek(absolutedataoffset, SeekOrigin.Begin);
                    // Write filler bytes
                    for (int i = 0; i &lt; fillerbytecount; i++)
                        stream.WriteByte(0xFF);
                    stream.Write(data, 0, data.Length);
                    stream.Seek(currentoffset, SeekOrigin.Begin);
                    // Increment pointers
                    currentdataoffset += fillerbytecount + (uint)data.Length;
                    absolutedataoffset += fillerbytecount + data.Length;
                }
            }
            // Offset to 1st IFD
            // We will write zeros for now. This will be filled after we write all IFDs
            if (ifdtype == IFD.Zeroth)
                firstIFDFieldOffset = stream.Position;
            stream.Write(new byte[] { 0, 0, 0, 0 }, 0, 4);

            // Seek to end of IFD
            stream.Seek(absolutedataoffset, SeekOrigin.Begin);

            // Write thumbnail data
            if (ifdtype == IFD.First)
            {
                if (Thumbnail != null)
                {
                    MemoryStream ts = new MemoryStream();
                    Thumbnail.Save(ts);
                    ts.Close();
                    byte[] thumb = ts.ToArray();
                    thumbOffsetValue = (uint)(stream.Position - tiffoffset);
                    thumbSizeValue = (uint)thumb.Length;
                    stream.Write(thumb, 0, thumb.Length);
                    ts.Dispose();
                }
                else
                {
                    thumbOffsetValue = 0;
                    thumbSizeValue = 0;
                }
            }
        }
        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[29,53,29,57,0],[29,58,29,62,0],[33,45,33,49,0],[33,50,33,62,0],[37,38,37,42,0],[37,43,37,55,0],[46,9,46,70,0],[47,9,47,10,0],[48,13,48,43,0],[49,13,49,48,0],[50,13,50,40,0],[51,13,51,33,0],[53,13,53,46,0],[57,13,57,46,0],[58,13,58,105,0],[59,17,59,55,0],[60,13,60,46,0],[63,13,63,53,0],[64,13,64,14,0],[67,17,67,135,0],[68,21,68,59,0],[70,17,70,64,0],[72,17,72,45,0],[74,17,74,135,0],[75,17,75,18,0],[79,21,79,54,0],[80,21,80,61,0],[81,25,81,63,0],[82,21,82,91,0],[85,21,85,51,0],[86,21,86,53,0],[87,21,87,44,0],[88,21,88,22,0],[89,25,89,69,0],[90,25,90,97,0],[91,25,91,44,0],[92,29,92,67,0],[93,25,93,50,0],[94,21,94,22,0],[95,17,95,18,0],[100,17,100,50,0],[101,17,101,106,0],[102,17,102,18,0],[103,21,103,53,0],[106,21,106,33,0],[107,21,107,22,0],[109,25,109,42,0],[111,25,111,26,0],[112,29,112,58,0],[113,29,113,48,0],[114,33,114,71,0],[115,25,115,26,0],[115,27,115,58,0],[119,25,119,26,0],[120,29,120,58,0],[121,29,121,48,0],[122,33,122,71,0],[123,25,123,26,0],[123,27,123,58,0],[126,25,126,52,0],[127,25,127,26,0],[130,29,130,65,0],[131,29,131,72,0],[132,29,132,72,0],[135,29,135,62,0],[136,29,136,66,0],[137,29,137,52,0],[138,29,138,30,0],[139,33,139,77,0],[140,33,140,115,0],[141,33,141,52,0],[142,37,142,75,0],[143,33,143,58,0],[144,29,144,30,0],[146,29,146,35,0],[148,21,148,22,0],[149,17,149,18,0],[152,17,152,84,0],[153,17,153,39,0],[156,17,156,46,0],[157,17,157,18,0],[158,21,158,78,0],[159,21,159,58,0],[160,21,160,44,0],[161,21,161,22,0],[162,25,162,74,0],[163,25,163,109,0],[164,25,164,44,0],[165,29,165,67,0],[166,25,166,50,0],[167,21,167,22,0],[168,17,168,18,0],[169,13,169,14,0],[172,13,172,28,0],[173,13,173,28,0],[174,13,174,28,0],[177,13,177,40,0],[178,9,178,10,0],[189,9,189,10,0],[190,13,190,29,0],[191,13,191,29,0],[192,13,192,46,0],[195,13,195,20,0],[195,22,195,41,0],[195,42,195,44,0],[195,45,195,53,0],[196,13,196,14,0],[199,17,199,63,0],[200,21,200,61,0],[204,17,204,123,0],[205,21,205,30,0],[208,17,208,79,0],[211,17,211,167,0],[212,17,212,18,0],[214,21,214,112,0],[217,21,217,52,0],[218,25,218,80,0],[219,17,219,18,0],[222,17,222,53,0],[223,21,223,86,0],[224,13,224,14,0],[227,13,227,42,0],[228,17,228,68,0],[229,9,229,10,0],[238,9,238,10,0],[239,20,239,115,0],[240,13,240,14,0],[241,17,241,49,0],[242,13,242,14,0],[243,9,243,10,0],[250,9,250,10,0],[251,13,251,34,0],[252,9,252,10,0],[259,9,259,10,0],[260,13,260,32,0],[261,9,261,10,0],[267,9,267,10,0],[268,13,268,54,0],[269,13,269,26,0],[270,13,270,45,0],[271,9,271,10,0],[279,9,279,10,0],[281,13,281,43,0],[281,43,283,71,0],[283,71,283,73,0],[281,13,283,73,0],[286,13,286,34,0],[287,17,287,24,0],[289,13,289,45,0],[290,13,290,64,0],[293,13,293,59,0],[294,13,294,75,0],[297,13,297,35,0],[298,13,298,109,0],[301,13,301,60,0],[302,13,302,72,0],[303,13,303,61,0],[304,13,304,72,0],[307,13,307,42,0],[308,13,308,78,0],[309,13,309,42,0],[310,13,310,78,0],[313,13,313,45,0],[314,13,314,48,0],[315,13,315,57,0],[316,13,316,144,0],[317,9,317,10,0],[322,9,322,10,0],[324,13,324,67,0],[325,13,325,20,0],[325,22,325,39,0],[325,40,325,42,0],[325,43,325,53,0],[326,13,326,14,0],[327,17,327,42,0],[328,21,328,39,0],[329,13,329,14,0],[331,13,331,36,0],[332,13,332,14,0],[334,17,334,30,0],[339,13,339,50,0],[342,13,342,63,0],[345,13,345,20,0],[345,22,345,39,0],[345,40,345,42,0],[345,43,345,50,0],[346,13,346,14,0],[347,17,347,70,0],[348,17,348,44,0],[349,17,349,113,0],[350,21,350,41,0],[351,17,351,48,0],[352,13,352,14,0],[354,13,354,24,0],[357,13,357,44,0],[358,13,358,25,0],[359,9,359,10,0],[364,9,364,10,0],[366,13,366,43,0],[366,43,368,71,0],[368,71,368,73,0],[366,13,368,73,0],[371,13,371,34,0],[372,17,372,24,0],[374,13,374,45,0],[377,13,377,62,0],[378,13,378,101,0],[381,13,381,56,0],[382,13,382,14,0],[383,17,383,59,0],[384,17,384,61,0],[385,17,385,139,0],[386,13,386,14,0],[387,18,387,65,0],[388,13,388,14,0],[390,17,390,45,0],[391,17,391,82,0],[392,17,392,45,0],[393,17,393,82,0],[394,17,394,69,0],[395,17,395,61,0],[396,17,396,143,0],[397,13,397,14,0],[398,18,398,67,0],[399,13,399,14,0],[401,17,401,45,0],[402,17,402,82,0],[403,17,403,45,0],[404,17,404,82,0],[405,17,405,48,0],[406,17,406,67,0],[407,17,407,65,0],[408,17,408,67,0],[409,17,409,116,0],[410,13,410,14,0],[411,9,411,10,0],[416,9,416,10,0],[418,13,418,67,0],[419,13,419,20,0],[419,22,419,39,0],[419,40,419,42,0],[419,43,419,53,0],[420,13,420,14,0],[421,17,421,42,0],[422,21,422,39,0],[423,13,423,14,0],[425,13,425,36,0],[426,13,426,14,0],[428,17,428,30,0],[432,13,432,50,0],[435,13,435,63,0],[438,13,438,20,0],[438,22,438,39,0],[438,40,438,42,0],[438,43,438,50,0],[439,13,439,14,0],[440,17,440,70,0],[441,17,441,44,0],[442,17,442,113,0],[443,21,443,41,0],[444,17,444,48,0],[445,13,445,14,0],[447,13,447,24,0],[450,13,450,44,0],[451,13,451,25,0],[452,9,452,10,0],[458,9,458,10,0],[460,13,460,43,0],[460,43,462,73,0],[462,73,462,75,0],[460,13,462,75,0],[465,13,465,34,0],[466,13,466,14,0],[467,17,467,66,0],[467,66,467,93,0],[467,93,467,95,0],[467,17,467,95,0],[468,17,468,42,0],[468,43,468,62,0],[469,17,469,34,0],[470,17,470,61,0],[471,17,471,59,0],[472,17,472,93,0],[473,21,473,71,0],[475,21,475,68,0],[476,17,476,24,0],[479,13,479,45,0],[480,13,480,72,0],[481,13,481,33,0],[484,13,484,32,0],[485,13,485,78,0],[486,17,486,67,0],[487,18,487,83,0],[488,17,488,64,0],[490,17,490,55,0],[493,13,493,64,0],[494,13,494,84,0],[495,17,495,71,0],[496,18,496,86,0],[497,17,497,68,0],[499,17,499,55,0],[502,13,502,130,0],[503,13,503,50,0],[505,13,505,97,0],[506,13,506,34,0],[507,13,507,33,0],[508,13,508,32,0],[510,13,510,40,0],[511,13,511,14,0],[512,17,512,63,0],[513,17,513,53,0],[514,17,514,38,0],[517,17,517,70,0],[518,22,518,33,0],[518,35,518,49,0],[518,51,518,54,0],[519,17,519,18,0],[521,21,521,62,0],[522,21,522,69,0],[523,21,523,74,0],[524,21,524,73,0],[525,21,525,48,0],[526,21,526,70,0],[529,21,529,67,0],[530,21,530,22,0],[531,25,531,75,0],[532,25,532,64,0],[533,21,533,22,0],[534,26,534,72,0],[535,21,535,22,0],[536,25,536,74,0],[537,25,537,62,0],[538,21,538,22,0],[539,26,539,70,0],[540,21,540,22,0],[541,25,541,78,0],[542,25,542,70,0],[543,21,543,22,0],[546,21,546,64,0],[547,25,547,67,0],[550,21,550,41,0],[551,21,551,61,0],[552,25,552,40,0],[553,26,553,40,0],[554,25,554,40,0],[555,26,555,53,0],[556,25,556,40,0],[557,26,557,54,0],[558,25,558,40,0],[559,21,559,59,0],[564,21,564,43,0],[565,21,565,41,0],[566,21,566,22,0],[567,25,567,83,0],[568,25,568,55,0],[569,25,569,82,0],[570,21,570,22,0],[573,21,573,65,0],[574,21,574,22,0],[575,25,575,39,0],[576,25,576,68,0],[577,21,577,22,0],[578,26,578,70,0],[579,25,579,68,0],[582,21,582,65,0],[583,21,583,22,0],[584,25,584,39,0],[586,25,586,39,0],[587,29,587,72,0],[589,29,589,72,0],[590,21,590,22,0],[591,26,591,70,0],[592,21,592,22,0],[593,25,593,41,0],[594,30,594,39,0],[594,41,594,50,0],[594,52,594,55,0],[595,25,595,26,0],[596,29,596,43,0],[597,33,597,77,0],[599,33,599,77,0],[600,25,600,26,0],[601,21,601,22,0],[604,21,604,123,0],[605,21,605,42,0],[606,17,606,18,0],[609,17,609,99,0],[610,17,610,42,0],[611,21,611,62,0],[613,17,613,80,0],[614,17,614,18,0],[615,21,615,40,0],[616,21,616,22,0],[617,32,617,113,0],[618,25,618,26,0],[619,29,619,66,0],[620,25,620,26,0],[621,21,621,22,0],[622,17,622,18,0],[623,13,623,14,0],[624,9,624,10,0],[630,9,630,10,0],[632,13,632,36,0],[633,13,633,35,0],[634,13,634,39,0],[635,13,635,37,0],[637,13,637,37,0],[638,13,638,34,0],[639,13,639,35,0],[640,13,640,32,0],[642,13,642,35,0],[643,13,643,14,0],[644,17,644,75,0],[645,17,645,81,0],[646,13,646,14,0],[648,13,648,14,0],[649,17,649,85,0],[650,21,650,93,0],[651,17,651,91,0],[652,21,652,99,0],[653,13,653,14,0],[656,13,656,99,0],[657,13,657,97,0],[658,13,658,96,0],[659,13,659,100,0],[660,13,660,98,0],[662,13,662,20,0],[662,22,662,39,0],[662,40,662,42,0],[662,43,662,53,0],[663,13,663,14,0],[664,17,664,34,0],[667,25,667,55,0],[668,25,668,31,0],[670,25,670,53,0],[671,25,671,31,0],[673,25,673,52,0],[674,25,674,31,0],[676,25,676,56,0],[677,25,677,31,0],[679,25,679,54,0],[680,25,680,31,0],[682,13,682,14,0],[686,13,686,86,0],[687,17,687,96,0],[688,13,688,84,0],[689,17,689,94,0],[690,13,690,99,0],[691,17,691,118,0],[694,13,694,85,0],[695,17,695,58,0],[696,13,696,83,0],[697,17,697,57,0],[698,13,698,98,0],[699,17,699,68,0],[701,13,701,128,0],[702,13,702,14,0],[704,17,704,30,0],[708,13,708,100,0],[711,13,711,50,0],[714,13,714,65,0],[718,13,718,43,0],[719,13,719,138,0],[721,13,721,58,0],[723,13,723,55,0],[726,13,726,80,0],[727,13,727,75,0],[728,13,728,76,0],[729,13,729,74,0],[730,13,730,74,0],[731,13,731,78,0],[732,13,732,82,0],[733,13,733,76,0],[734,13,734,78,0],[737,13,737,41,0],[738,13,738,14,0],[739,17,739,63,0],[740,17,740,73,0],[741,13,741,14,0],[742,13,742,40,0],[743,13,743,14,0],[744,17,744,62,0],[745,17,745,72,0],[746,13,746,14,0],[747,13,747,44,0],[748,13,748,14,0],[749,17,749,66,0],[750,17,750,76,0],[751,13,751,14,0],[752,13,752,42,0],[753,13,753,14,0],[754,17,754,64,0],[755,17,755,74,0],[756,13,756,14,0],[758,13,758,42,0],[759,13,759,14,0],[760,17,760,64,0],[761,17,761,68,0],[762,13,762,14,0],[763,13,763,40,0],[764,13,764,14,0],[765,17,765,62,0],[766,17,766,66,0],[767,13,767,14,0],[769,13,769,24,0],[772,13,772,44,0],[773,13,773,25,0],[774,9,774,10,0],[777,9,777,10,0],[778,13,778,97,0],[781,13,781,72,0],[782,13,782,20,0],[782,22,782,39,0],[782,40,782,42,0],[782,43,782,53,0],[783,17,783,51,0],[784,21,784,46,0],[786,13,786,52,0],[787,17,787,60,0],[790,13,790,93,0],[791,13,791,49,0],[792,13,792,82,0],[794,13,794,43,0],[796,13,796,66,0],[798,13,798,42,0],[799,13,799,14,0],[800,17,800,59,0],[801,17,801,71,0],[803,17,803,42,0],[806,17,813,56,0],[814,17,814,18,0],[816,21,816,47,0],[817,21,817,30,0],[819,22,819,57,0],[820,17,820,18,0],[821,21,821,45,0],[823,21,823,107,0],[824,25,824,79,0],[826,25,826,45,0],[827,17,827,18,0],[830,17,830,66,0],[832,17,832,67,0],[834,17,834,66,0],[836,17,836,44,0],[837,17,839,66,0],[840,17,840,18,0],[841,21,841,34,0],[842,21,842,45,0],[842,46,842,55,0],[843,21,843,48,0],[845,26,845,35,0],[845,37,845,42,0],[845,44,845,47,0],[846,25,846,61,0],[847,17,847,18,0],[851,17,851,70,0],[852,21,852,58,0],[853,22,853,75,0],[854,21,854,57,0],[855,22,855,73,0],[856,21,856,61,0],[857,22,857,73,0],[858,21,858,59,0],[859,22,859,73,0],[860,21,860,57,0],[863,17,863,38,0],[864,17,864,18,0],[865,21,865,56,0],[866,26,866,45,0],[866,47,866,52,0],[866,54,866,57,0],[867,25,867,45,0],[868,17,868,18,0],[870,17,870,18,0],[872,21,872,92,0],[874,21,874,58,0],[875,21,875,71,0],[877,26,877,35,0],[877,37,877,56,0],[877,58,877,61,0],[878,25,878,48,0],[879,21,879,56,0],[880,21,880,66,0],[882,21,882,78,0],[883,21,883,73,0],[884,17,884,18,0],[885,13,885,14,0],[888,13,888,39,0],[889,17,889,55,0],[890,13,890,59,0],[893,13,893,63,0],[896,13,896,38,0],[897,13,897,14,0],[898,17,898,39,0],[899,17,899,18,0],[900,21,900,58,0],[901,21,901,40,0],[902,21,902,32,0],[903,21,903,49,0],[904,21,904,77,0],[905,21,905,57,0],[906,21,906,58,0],[907,21,907,34,0],[908,17,908,18,0],[910,17,910,18,0],[911,21,911,42,0],[912,21,912,40,0],[913,17,913,18,0],[914,13,914,14,0],[915,9,915,10,0]]);
    </script>
  </body>
</html>