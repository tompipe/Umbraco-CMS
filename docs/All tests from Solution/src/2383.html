<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\umbraco.cms\businesslogic\workflow\Diff.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Text;
using System.Text.RegularExpressions;


namespace umbraco.cms.businesslogic.workflow
{
    /// &lt;summary&gt;    
    /// This Class implements the Difference Algorithm published in
    /// &quot;An O(ND) Difference Algorithm and its Variations&quot; by Eugene Myers
    /// Algorithmica Vol. 1 No. 2, 1986, p 251.  
    /// 
    /// The algorithm itself is comparing 2 arrays of numbers so when comparing 2 text documents
    /// each line is converted into a (hash) number. See DiffText().     
    /// 
    /// diff.cs: A port of the algorithm to C#
    /// Copyright (c) by Matthias Hertel, http://www.mathertel.de
    /// This work is licensed under a BSD style license. See http://www.mathertel.de/License.aspx    
    /// &lt;/summary&gt;    
    [Obsolete(&quot;This class will be removed from the codebase in the future&quot;)]
    public class Diff
    {

        /// &lt;summary&gt;details of one difference.&lt;/summary&gt;
        public struct Item
        {
            /// &lt;summary&gt;Start Line number in Data A.&lt;/summary&gt;
            public int StartA;
            /// &lt;summary&gt;Start Line number in Data B.&lt;/summary&gt;
            public int StartB;

            /// &lt;summary&gt;Number of changes in Data A.&lt;/summary&gt;
            public int deletedA;
            /// &lt;summary&gt;Number of changes in Data B.&lt;/summary&gt;
            public int insertedB;
        } // Item

        /// &lt;summary&gt;
        /// Shortest Middle Snake Return Data
        /// &lt;/summary&gt;
        private struct SMSRD
        {
            internal int x, y;
            // internal int u, v;  // 2002.09.20: no need for 2 points 
        }

        /// &lt;summary&gt;
        /// Find the difference in 2 texts, comparing by textlines.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;TextA&quot;&gt;A-version of the text (usualy the old one)&lt;/param&gt;
        /// &lt;param name=&quot;TextB&quot;&gt;B-version of the text (usualy the new one)&lt;/param&gt;
        /// &lt;returns&gt;Returns a array of Items that describe the differences.&lt;/returns&gt;
        public static Item[] DiffText(string TextA, string TextB)
        {
            return (DiffText(TextA, TextB, false, false, false));
        } // DiffText

        /// &lt;summary&gt;
        /// Find the difference in 2 texts, comparing by textlines. 
        /// This method uses the DiffInt internally by 1st converting the string into char codes
        /// then uses the diff int method
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;TextA&quot;&gt;A-version of the text (usualy the old one)&lt;/param&gt;
        /// &lt;param name=&quot;TextB&quot;&gt;B-version of the text (usualy the new one)&lt;/param&gt;
        /// &lt;returns&gt;Returns a array of Items that describe the differences.&lt;/returns&gt;
        public static Item[] DiffText1(string TextA, string TextB)
        {
            return DiffInt(DiffCharCodes(TextA, false), DiffCharCodes(TextB, false));
        }


        /// &lt;summary&gt;
        /// Find the difference in 2 text documents, comparing by textlines.
        /// The algorithm itself is comparing 2 arrays of numbers so when comparing 2 text documents
        /// each line is converted into a (hash) number. This hash-value is computed by storing all
        /// textlines into a common hashtable so i can find dublicates in there, and generating a 
        /// new number each time a new textline is inserted.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;TextA&quot;&gt;A-version of the text (usualy the old one)&lt;/param&gt;
        /// &lt;param name=&quot;TextB&quot;&gt;B-version of the text (usualy the new one)&lt;/param&gt;
        /// &lt;param name=&quot;trimSpace&quot;&gt;When set to true, all leading and trailing whitespace characters are stripped out before the comparation is done.&lt;/param&gt;
        /// &lt;param name=&quot;ignoreSpace&quot;&gt;When set to true, all whitespace characters are converted to a single space character before the comparation is done.&lt;/param&gt;
        /// &lt;param name=&quot;ignoreCase&quot;&gt;When set to true, all characters are converted to their lowercase equivivalence before the comparation is done.&lt;/param&gt;
        /// &lt;returns&gt;Returns a array of Items that describe the differences.&lt;/returns&gt;
        public static Item[] DiffText(string TextA, string TextB, bool trimSpace, bool ignoreSpace, bool ignoreCase)
        {
            // prepare the input-text and convert to comparable numbers.
            Hashtable h = new Hashtable(TextA.Length + TextB.Length);

            // The A-Version of the data (original data) to be compared.
            DiffData DataA = new DiffData(DiffCodes(TextA, h, trimSpace, ignoreSpace, ignoreCase));

            // The B-Version of the data (modified data) to be compared.
            DiffData DataB = new DiffData(DiffCodes(TextB, h, trimSpace, ignoreSpace, ignoreCase));

            h = null; // free up hashtable memory (maybe)

            int MAX = DataA.Length + DataB.Length + 1;
            /// vector for the (0,0) to (x,y) search
            int[] DownVector = new int[2 * MAX + 2];
            /// vector for the (u,v) to (N,M) search
            int[] UpVector = new int[2 * MAX + 2];

            LCS(DataA, 0, DataA.Length, DataB, 0, DataB.Length, DownVector, UpVector);

            Optimize(DataA);
            Optimize(DataB);
            return CreateDiffs(DataA, DataB);
        } // DiffText


        /// &lt;summary&gt;
        /// Diffs the char codes.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;aText&quot;&gt;A text.&lt;/param&gt;
        /// &lt;param name=&quot;ignoreCase&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; [ignore case].&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private static int[] DiffCharCodes(string aText, bool ignoreCase)
        {
            int[] Codes;

            if (ignoreCase)
                aText = aText.ToUpperInvariant();

            Codes = new int[aText.Length];

            for (int n = 0; n &lt; aText.Length; n++)
                Codes[n] = (int)aText[n];

            return (Codes);
        } // DiffCharCodes

        /// &lt;summary&gt;
        /// If a sequence of modified lines starts with a line that contains the same content
        /// as the line that appends the changes, the difference sequence is modified so that the
        /// appended line and not the starting line is marked as modified.
        /// This leads to more readable diff sequences when comparing text files.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Data&quot;&gt;A Diff data buffer containing the identified changes.&lt;/param&gt;
        private static void Optimize(DiffData Data)
        {
            int StartPos, EndPos;

            StartPos = 0;
            while (StartPos &lt; Data.Length)
            {
                while ((StartPos &lt; Data.Length) &amp;&amp; (Data.modified[StartPos] == false))
                    StartPos++;
                EndPos = StartPos;
                while ((EndPos &lt; Data.Length) &amp;&amp; (Data.modified[EndPos] == true))
                    EndPos++;

                if ((EndPos &lt; Data.Length) &amp;&amp; (Data.data[StartPos] == Data.data[EndPos]))
                {
                    Data.modified[StartPos] = false;
                    Data.modified[EndPos] = true;
                }
                else
                {
                    StartPos = EndPos;
                } // if
            } // while
        } // Optimize


        /// &lt;summary&gt;
        /// Find the difference in 2 arrays of integers.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;ArrayA&quot;&gt;A-version of the numbers (usualy the old one)&lt;/param&gt;
        /// &lt;param name=&quot;ArrayB&quot;&gt;B-version of the numbers (usualy the new one)&lt;/param&gt;
        /// &lt;returns&gt;Returns a array of Items that describe the differences.&lt;/returns&gt;
        public static Item[] DiffInt(int[] ArrayA, int[] ArrayB)
        {
            // The A-Version of the data (original data) to be compared.
            DiffData DataA = new DiffData(ArrayA);

            // The B-Version of the data (modified data) to be compared.
            DiffData DataB = new DiffData(ArrayB);

            int MAX = DataA.Length + DataB.Length + 1;
            /// vector for the (0,0) to (x,y) search
            int[] DownVector = new int[2 * MAX + 2];
            /// vector for the (u,v) to (N,M) search
            int[] UpVector = new int[2 * MAX + 2];

            LCS(DataA, 0, DataA.Length, DataB, 0, DataB.Length, DownVector, UpVector);
            return CreateDiffs(DataA, DataB);
        } // Diff


        /// &lt;summary&gt;
        /// This function converts all textlines of the text into unique numbers for every unique textline
        /// so further work can work only with simple numbers.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;aText&quot;&gt;the input text&lt;/param&gt;
        /// &lt;param name=&quot;h&quot;&gt;This extern initialized hashtable is used for storing all ever used textlines.&lt;/param&gt;
        /// &lt;param name=&quot;trimSpace&quot;&gt;ignore leading and trailing space characters&lt;/param&gt;
        /// &lt;returns&gt;a array of integers.&lt;/returns&gt;
        private static int[] DiffCodes(string aText, Hashtable h, bool trimSpace, bool ignoreSpace, bool ignoreCase)
        {
            // get all codes of the text
            string[] Lines;
            int[] Codes;
            int lastUsedCode = h.Count;
            object aCode;
            string s;

            // strip off all cr, only use lf as textline separator.
            aText = aText.Replace(&quot;\r&quot;, &quot;&quot;);
            Lines = aText.Split(&#39;\n&#39;);

            Codes = new int[Lines.Length];

            for (int i = 0; i &lt; Lines.Length; ++i)
            {
                s = Lines[i];
                if (trimSpace)
                    s = s.Trim();

                if (ignoreSpace)
                {
                    s = Regex.Replace(s, &quot;\\s+&quot;, &quot; &quot;);            // TODO: optimization: faster blank removal.
                }

                if (ignoreCase)
                    s = s.ToLower();

                aCode = h[s];
                if (aCode == null)
                {
                    lastUsedCode++;
                    h[s] = lastUsedCode;
                    Codes[i] = lastUsedCode;
                }
                else
                {
                    Codes[i] = (int)aCode;
                } // if
            } // for
            return (Codes);
        } // DiffCodes


        /// &lt;summary&gt;
        /// This is the algorithm to find the Shortest Middle Snake (SMS).
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;DataA&quot;&gt;sequence A&lt;/param&gt;
        /// &lt;param name=&quot;LowerA&quot;&gt;lower bound of the actual range in DataA&lt;/param&gt;
        /// &lt;param name=&quot;UpperA&quot;&gt;upper bound of the actual range in DataA (exclusive)&lt;/param&gt;
        /// &lt;param name=&quot;DataB&quot;&gt;sequence B&lt;/param&gt;
        /// &lt;param name=&quot;LowerB&quot;&gt;lower bound of the actual range in DataB&lt;/param&gt;
        /// &lt;param name=&quot;UpperB&quot;&gt;upper bound of the actual range in DataB (exclusive)&lt;/param&gt;
        /// &lt;param name=&quot;DownVector&quot;&gt;a vector for the (0,0) to (x,y) search. Passed as a parameter for speed reasons.&lt;/param&gt;
        /// &lt;param name=&quot;UpVector&quot;&gt;a vector for the (u,v) to (N,M) search. Passed as a parameter for speed reasons.&lt;/param&gt;
        /// &lt;returns&gt;a MiddleSnakeData record containing x,y and u,v&lt;/returns&gt;
        private static SMSRD SMS(DiffData DataA, int LowerA, int UpperA, DiffData DataB, int LowerB, int UpperB,
          int[] DownVector, int[] UpVector)
        {

            SMSRD ret;
            int MAX = DataA.Length + DataB.Length + 1;

            int DownK = LowerA - LowerB; // the k-line to start the forward search
            int UpK = UpperA - UpperB; // the k-line to start the reverse search

            int Delta = (UpperA - LowerA) - (UpperB - LowerB);
            bool oddDelta = (Delta &amp; 1) != 0;

            // The vectors in the publication accepts negative indexes. the vectors implemented here are 0-based
            // and are access using a specific offset: UpOffset UpVector and DownOffset for DownVektor
            int DownOffset = MAX - DownK;
            int UpOffset = MAX - UpK;

            int MaxD = ((UpperA - LowerA + UpperB - LowerB) / 2) + 1;

            // Debug.Write(2, &quot;SMS&quot;, String.Format(&quot;Search the box: A[{0}-{1}] to B[{2}-{3}]&quot;, LowerA, UpperA, LowerB, UpperB));

            // init vectors
            DownVector[DownOffset + DownK + 1] = LowerA;
            UpVector[UpOffset + UpK - 1] = UpperA;

            for (int D = 0; D &lt;= MaxD; D++)
            {

                // Extend the forward path.
                for (int k = DownK - D; k &lt;= DownK + D; k += 2)
                {
                    // Debug.Write(0, &quot;SMS&quot;, &quot;extend forward path &quot; + k.ToString());

                    // find the only or better starting point
                    int x, y;
                    if (k == DownK - D)
                    {
                        x = DownVector[DownOffset + k + 1]; // down
                    }
                    else
                    {
                        x = DownVector[DownOffset + k - 1] + 1; // a step to the right
                        if ((k &lt; DownK + D) &amp;&amp; (DownVector[DownOffset + k + 1] &gt;= x))
                            x = DownVector[DownOffset + k + 1]; // down
                    }
                    y = x - k;

                    // find the end of the furthest reaching forward D-path in diagonal k.
                    while ((x &lt; UpperA) &amp;&amp; (y &lt; UpperB) &amp;&amp; (DataA.data[x] == DataB.data[y]))
                    {
                        x++; y++;
                    }
                    DownVector[DownOffset + k] = x;

                    // overlap ?
                    if (oddDelta &amp;&amp; (UpK - D &lt; k) &amp;&amp; (k &lt; UpK + D))
                    {
                        if (UpVector[UpOffset + k] &lt;= DownVector[DownOffset + k])
                        {
                            ret.x = DownVector[DownOffset + k];
                            ret.y = DownVector[DownOffset + k] - k;
                            // ret.u = UpVector[UpOffset + k];      // 2002.09.20: no need for 2 points 
                            // ret.v = UpVector[UpOffset + k] - k;
                            return (ret);
                        } // if
                    } // if

                } // for k

                // Extend the reverse path.
                for (int k = UpK - D; k &lt;= UpK + D; k += 2)
                {
                    // Debug.Write(0, &quot;SMS&quot;, &quot;extend reverse path &quot; + k.ToString());

                    // find the only or better starting point
                    int x, y;
                    if (k == UpK + D)
                    {
                        x = UpVector[UpOffset + k - 1]; // up
                    }
                    else
                    {
                        x = UpVector[UpOffset + k + 1] - 1; // left
                        if ((k &gt; UpK - D) &amp;&amp; (UpVector[UpOffset + k - 1] &lt; x))
                            x = UpVector[UpOffset + k - 1]; // up
                    } // if
                    y = x - k;

                    while ((x &gt; LowerA) &amp;&amp; (y &gt; LowerB) &amp;&amp; (DataA.data[x - 1] == DataB.data[y - 1]))
                    {
                        x--; y--; // diagonal
                    }
                    UpVector[UpOffset + k] = x;

                    // overlap ?
                    if (!oddDelta &amp;&amp; (DownK - D &lt;= k) &amp;&amp; (k &lt;= DownK + D))
                    {
                        if (UpVector[UpOffset + k] &lt;= DownVector[DownOffset + k])
                        {
                            ret.x = DownVector[DownOffset + k];
                            ret.y = DownVector[DownOffset + k] - k;
                            // ret.u = UpVector[UpOffset + k];     // 2002.09.20: no need for 2 points 
                            // ret.v = UpVector[UpOffset + k] - k;
                            return (ret);
                        } // if
                    } // if

                } // for k

            } // for D

            throw new ApplicationException(&quot;the algorithm should never come here.&quot;);
        } // SMS


        /// &lt;summary&gt;
        /// This is the divide-and-conquer implementation of the longes common-subsequence (LCS) 
        /// algorithm.
        /// The published algorithm passes recursively parts of the A and B sequences.
        /// To avoid copying these arrays the lower and upper bounds are passed while the sequences stay constant.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;DataA&quot;&gt;sequence A&lt;/param&gt;
        /// &lt;param name=&quot;LowerA&quot;&gt;lower bound of the actual range in DataA&lt;/param&gt;
        /// &lt;param name=&quot;UpperA&quot;&gt;upper bound of the actual range in DataA (exclusive)&lt;/param&gt;
        /// &lt;param name=&quot;DataB&quot;&gt;sequence B&lt;/param&gt;
        /// &lt;param name=&quot;LowerB&quot;&gt;lower bound of the actual range in DataB&lt;/param&gt;
        /// &lt;param name=&quot;UpperB&quot;&gt;upper bound of the actual range in DataB (exclusive)&lt;/param&gt;
        /// &lt;param name=&quot;DownVector&quot;&gt;a vector for the (0,0) to (x,y) search. Passed as a parameter for speed reasons.&lt;/param&gt;
        /// &lt;param name=&quot;UpVector&quot;&gt;a vector for the (u,v) to (N,M) search. Passed as a parameter for speed reasons.&lt;/param&gt;
        private static void LCS(DiffData DataA, int LowerA, int UpperA, DiffData DataB, int LowerB, int UpperB, int[] DownVector, int[] UpVector)
        {
            // Debug.Write(2, &quot;LCS&quot;, String.Format(&quot;Analyse the box: A[{0}-{1}] to B[{2}-{3}]&quot;, LowerA, UpperA, LowerB, UpperB));

            // Fast walkthrough equal lines at the start
            while (LowerA &lt; UpperA &amp;&amp; LowerB &lt; UpperB &amp;&amp; DataA.data[LowerA] == DataB.data[LowerB])
            {
                LowerA++; LowerB++;
            }

            // Fast walkthrough equal lines at the end
            while (LowerA &lt; UpperA &amp;&amp; LowerB &lt; UpperB &amp;&amp; DataA.data[UpperA - 1] == DataB.data[UpperB - 1])
            {
                --UpperA; --UpperB;
            }

            if (LowerA == UpperA)
            {
                // mark as inserted lines.
                while (LowerB &lt; UpperB)
                    DataB.modified[LowerB++] = true;

            }
            else if (LowerB == UpperB)
            {
                // mark as deleted lines.
                while (LowerA &lt; UpperA)
                    DataA.modified[LowerA++] = true;

            }
            else
            {
                // Find the middle snakea and length of an optimal path for A and B
                SMSRD smsrd = SMS(DataA, LowerA, UpperA, DataB, LowerB, UpperB, DownVector, UpVector);
                // Debug.Write(2, &quot;MiddleSnakeData&quot;, String.Format(&quot;{0},{1}&quot;, smsrd.x, smsrd.y));

                // The path is from LowerX to (x,y) and (x,y) to UpperX
                LCS(DataA, LowerA, smsrd.x, DataB, LowerB, smsrd.y, DownVector, UpVector);
                LCS(DataA, smsrd.x, UpperA, DataB, smsrd.y, UpperB, DownVector, UpVector);  // 2002.09.20: no need for 2 points 
            }
        } // LCS()


        /// &lt;summary&gt;Scan the tables of which lines are inserted and deleted,
        /// producing an edit script in forward order.  
        /// &lt;/summary&gt;
        /// dynamic array
        private static Item[] CreateDiffs(DiffData DataA, DiffData DataB)
        {
            ArrayList a = new ArrayList();
            Item aItem;
            Item[] result;

            int StartA, StartB;
            int LineA, LineB;

            LineA = 0;
            LineB = 0;
            while (LineA &lt; DataA.Length || LineB &lt; DataB.Length)
            {
                if ((LineA &lt; DataA.Length) &amp;&amp; (!DataA.modified[LineA])
                  &amp;&amp; (LineB &lt; DataB.Length) &amp;&amp; (!DataB.modified[LineB]))
                {
                    // equal lines
                    LineA++;
                    LineB++;

                }
                else
                {
                    // maybe deleted and/or inserted lines
                    StartA = LineA;
                    StartB = LineB;

                    while (LineA &lt; DataA.Length &amp;&amp; (LineB &gt;= DataB.Length || DataA.modified[LineA]))
                        // while (LineA &lt; DataA.Length &amp;&amp; DataA.modified[LineA])
                        LineA++;

                    while (LineB &lt; DataB.Length &amp;&amp; (LineA &gt;= DataA.Length || DataB.modified[LineB]))
                        // while (LineB &lt; DataB.Length &amp;&amp; DataB.modified[LineB])
                        LineB++;

                    if ((StartA &lt; LineA) || (StartB &lt; LineB))
                    {
                        // store a new difference-item
                        aItem = new Item();
                        aItem.StartA = StartA;
                        aItem.StartB = StartB;
                        aItem.deletedA = LineA - StartA;
                        aItem.insertedB = LineB - StartB;
                        a.Add(aItem);
                    } // if
                } // if
            } // while

            result = new Item[a.Count];
            a.CopyTo(result);

            return (result);
        }

    } // class Diff

    /// &lt;summary&gt;Data on one input file being compared.  
    /// &lt;/summary&gt;
    [Obsolete(&quot;This class will be removed from the codebase in the future, logic has moved to the Core project&quot;)]
    internal class DiffData
    {

        /// &lt;summary&gt;Number of elements (lines).&lt;/summary&gt;
        internal int Length;

        /// &lt;summary&gt;Buffer of numbers that will be compared.&lt;/summary&gt;
        internal int[] data;

        /// &lt;summary&gt;
        /// Array of booleans that flag for modified data.
        /// This is the result of the diff.
        /// This means deletedA in the first Data or inserted in the second Data.
        /// &lt;/summary&gt;
        internal bool[] modified;

        /// &lt;summary&gt;
        /// Initialize the Diff-Data buffer.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;data&quot;&gt;reference to the buffer&lt;/param&gt;
        internal DiffData(int[] initData)
        {
            data = initData;
            Length = initData.Length;
            modified = new bool[Length + 2];
        } // DiffData

    } // class DiffData

} // namespace
    </pre>
    <script type="text/javascript">
      highlightRanges([[55,9,55,10,0],[56,13,56,66,0],[57,9,57,10,0],[68,9,68,10,0],[69,13,69,86,0],[70,9,70,10,0],[87,9,87,10,0],[89,13,89,70,0],[92,13,92,100,0],[95,13,95,100,0],[97,13,97,22,0],[99,13,99,55,0],[101,13,101,53,0],[103,13,103,51,0],[105,13,105,87,0],[107,13,107,29,0],[108,13,108,29,0],[109,13,109,46,0],[110,9,110,10,0],[120,9,120,10,0],[123,13,123,28,0],[124,17,124,50,0],[126,13,126,43,0],[128,18,128,27,0],[128,29,128,45,0],[128,47,128,50,0],[129,17,129,42,0],[131,13,131,28,0],[132,9,132,10,0],[142,9,142,10,0],[145,13,145,26,0],[146,13,146,43,0],[147,13,147,14,0],[148,17,148,87,0],[149,21,149,32,0],[150,17,150,35,0],[151,17,151,82,0],[152,21,152,30,0],[154,17,154,90,0],[155,17,155,18,0],[156,21,156,53,0],[157,21,157,50,0],[158,17,158,18,0],[160,17,160,18,0],[161,21,161,39,0],[162,17,162,18,0],[163,13,163,14,0],[164,9,164,10,0],[174,9,174,10,0],[176,13,176,51,0],[179,13,179,51,0],[181,13,181,55,0],[183,13,183,53,0],[185,13,185,51,0],[187,13,187,87,0],[188,13,188,46,0],[189,9,189,10,0],[201,9,201,10,0],[205,13,205,40,0],[210,13,210,45,0],[211,13,211,39,0],[213,13,213,43,0],[215,18,215,27,0],[215,29,215,45,0],[215,47,215,50,0],[216,13,216,14,0],[217,17,217,30,0],[218,17,218,31,0],[219,21,219,34,0],[221,17,221,33,0],[222,17,222,18,0],[223,21,223,55,0],[224,17,224,18,0],[226,17,226,32,0],[227,21,227,37,0],[229,17,229,30,0],[230,17,230,35,0],[231,17,231,18,0],[232,21,232,36,0],[233,21,233,41,0],[234,21,234,45,0],[235,17,235,18,0],[237,17,237,18,0],[238,21,238,43,0],[239,17,239,18,0],[240,13,240,14,0],[241,13,241,28,0],[242,9,242,10,0],[259,9,259,10,0],[262,13,262,55,0],[264,13,264,41,0],[265,13,265,39,0],[267,13,267,63,0],[268,13,268,46,0],[272,13,272,42,0],[273,13,273,38,0],[275,13,275,70,0],[280,13,280,57,0],[281,13,281,51,0],[283,18,283,27,0],[283,29,283,38,0],[283,40,283,43,0],[284,13,284,14,0],[287,22,287,39,0],[287,41,287,55,0],[287,57,287,63,0],[288,17,288,18,0],[293,21,293,40,0],[294,21,294,22,0],[295,25,295,60,0],[296,21,296,22,0],[298,21,298,22,0],[299,25,299,64,0],[300,25,300,86,0],[301,29,301,64,0],[302,21,302,22,0],[303,21,303,31,0],[306,21,306,93,0],[307,21,307,22,0],[308,25,308,29,0],[308,30,308,34,0],[309,21,309,22,0],[310,21,310,52,0],[313,21,313,68,0],[314,21,314,22,0],[315,25,315,82,0],[316,25,316,26,0],[317,29,317,64,0],[318,29,318,68,0],[321,29,321,42,0],[323,21,323,22,0],[325,17,325,18,0],[328,22,328,37,0],[328,39,328,51,0],[328,53,328,59,0],[329,17,329,18,0],[334,21,334,38,0],[335,21,335,22,0],[336,25,336,56,0],[337,21,337,22,0],[339,21,339,22,0],[340,25,340,60,0],[341,25,341,79,0],[342,29,342,60,0],[343,21,343,22,0],[344,21,344,31,0],[346,21,346,101,0],[347,21,347,22,0],[348,25,348,29,0],[348,30,348,34,0],[349,21,349,22,0],[350,21,350,48,0],[353,21,353,75,0],[354,21,354,22,0],[355,25,355,82,0],[356,25,356,26,0],[357,29,357,64,0],[358,29,358,68,0],[361,29,361,42,0],[363,21,363,22,0],[365,17,365,18,0],[367,13,367,14,0],[369,13,369,85,0],[370,9,370,10,0],[388,9,388,10,0],[392,13,392,99,0],[393,13,393,14,0],[394,17,394,26,0],[394,27,394,36,0],[395,13,395,14,0],[398,13,398,107,0],[399,13,399,14,0],[400,17,400,26,0],[400,27,400,36,0],[401,13,401,14,0],[403,13,403,34,0],[404,13,404,14,0],[406,17,406,40,0],[407,21,407,53,0],[409,13,409,14,0],[410,18,410,39,0],[411,13,411,14,0],[413,17,413,40,0],[414,21,414,53,0],[416,13,416,14,0],[418,13,418,14,0],[420,17,420,103,0],[424,17,424,91,0],[425,17,425,91,0],[426,13,426,14,0],[427,9,427,10,0],[435,9,435,10,0],[436,13,436,43,0],[443,13,443,23,0],[444,13,444,23,0],[445,13,445,65,0],[446,13,446,14,0],[447,17,448,73,0],[449,17,449,18,0],[451,21,451,29,0],[452,21,452,29,0],[454,17,454,18,0],[456,17,456,18,0],[458,21,458,36,0],[459,21,459,36,0],[461,21,461,101,0],[463,25,463,33,0],[465,21,465,101,0],[467,25,467,33,0],[469,21,469,62,0],[470,21,470,22,0],[472,25,472,44,0],[473,25,473,47,0],[474,25,474,47,0],[475,25,475,57,0],[476,25,476,58,0],[477,25,477,38,0],[478,21,478,22,0],[479,17,479,18,0],[480,13,480,14,0],[482,13,482,40,0],[483,13,483,30,0],[485,13,485,29,0],[486,9,486,10,0],[513,9,513,42,0],[514,9,514,10,0],[515,13,515,29,0],[516,13,516,38,0],[517,13,517,45,0],[518,9,518,10,0]]);
    </script>
  </body>
</html>