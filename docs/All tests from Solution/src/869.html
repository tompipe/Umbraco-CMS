<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\PublishedCache\XmlPublishedCache\XmlPublishedProperty.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Xml;
using System.Xml.Serialization;
using Umbraco.Core;
using Umbraco.Core.Models.PublishedContent;

namespace Umbraco.Web.PublishedCache.XmlPublishedCache
{

	/// &lt;summary&gt;
	/// Represents an IDocumentProperty which is created based on an Xml structure.
	/// &lt;/summary&gt;
	[Serializable]
	[XmlType(Namespace = &quot;http://umbraco.org/webservices/&quot;)]
	internal class XmlPublishedProperty : PublishedPropertyBase
	{
		private readonly string _xmlValue; // the raw, xml node value

        // in v7 we&#39;re not using XPath value so don&#39;t allocate that Lazy.
        // as for the rest... we&#39;re single threaded here, keep it simple
        //private readonly Lazy&lt;object&gt; _sourceValue;
        //private readonly Lazy&lt;object&gt; _objectValue;
        //private readonly Lazy&lt;object&gt; _xpathValue;
        private object _objectValue;
        private bool _objectValueComputed;
        private readonly bool _isPreviewing;

        /// &lt;summary&gt;
        /// Gets the raw value of the property.
        /// &lt;/summary&gt;
        public override object DataValue { get { return _xmlValue; } }

        // in the Xml cache, everything is a string, and to have a value
        // you want to have a non-null, non-empty string.
	    public override bool HasValue 
        {
	        get { return _xmlValue.Trim().Length &gt; 0; }
	    }

	    public override object Value
	    {
	        get
	        {
                // NOT caching the source (intermediate) value since we&#39;ll never need it
                // everything in Xml cache in v7 is per-request anyways
                // also, properties should not be shared between requests and therefore
                // are single threaded, so the following code should be safe &amp; fast

                if (_objectValueComputed) return _objectValue;
                var sourceValue = PropertyType.ConvertDataToSource(_xmlValue, _isPreviewing);
                _objectValue = PropertyType.ConvertSourceToObject(sourceValue, _isPreviewing);
                _objectValueComputed = true;
                return _objectValue;
            }
        }

        public override object XPathValue { get { throw new NotImplementedException(); } }

        public XmlPublishedProperty(PublishedPropertyType propertyType, bool isPreviewing, XmlNode propertyXmlData)
            : this(propertyType, isPreviewing)
		{
		    if (propertyXmlData == null)
		        throw new ArgumentNullException(&quot;propertyXmlData&quot;, &quot;Property xml source is null&quot;);
		    _xmlValue = XmlHelper.GetNodeValue(propertyXmlData);
        }

        public XmlPublishedProperty(PublishedPropertyType propertyType, bool isPreviewing, string propertyData)
            : this(propertyType, isPreviewing)
        {
            if (propertyData == null)
                throw new ArgumentNullException(&quot;propertyData&quot;);
            _xmlValue = propertyData;
        }

        public XmlPublishedProperty(PublishedPropertyType propertyType, bool isPreviewing)
            : base(propertyType)
        {
            _xmlValue = string.Empty;
            _isPreviewing = isPreviewing;

            //_sourceValue = new Lazy&lt;object&gt;(() =&gt; PropertyType.ConvertDataToSource(_xmlValue, _isPreviewing));
            //_objectValue = new Lazy&lt;object&gt;(() =&gt; PropertyType.ConvertSourceToObject(_sourceValue.Value, _isPreviewing));
            //_xpathValue = new Lazy&lt;object&gt;(() =&gt; PropertyType.ConvertSourceToXPath(_sourceValue.Value, _isPreviewing));
        }
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[31,48,31,49,0],[31,50,31,67,0],[31,68,31,69,0],[37,14,37,15,1],[37,16,37,51,1],[37,52,37,53,1],[43,10,43,11,1],[49,17,49,42,1],[49,43,49,63,1],[50,17,50,94,1],[51,17,51,95,1],[52,17,52,45,1],[53,17,53,37,1],[54,13,54,14,1],[57,49,57,50,0],[57,51,57,87,0],[60,15,60,47,1],[61,3,61,4,1],[62,7,62,35,1],[63,11,63,93,0],[64,7,64,59,1],[65,9,65,10,1],[68,15,68,47,1],[69,9,69,10,1],[70,13,70,38,1],[71,17,71,65,0],[72,13,72,38,1],[73,9,73,10,1],[76,15,76,33,1],[77,9,77,10,1],[78,13,78,38,1],[79,13,79,42,1],[84,9,84,10,1]]);
    </script>
  </body>
</html>