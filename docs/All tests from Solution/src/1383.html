<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\AsyncLock.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;

namespace Umbraco.Core
{
    // http://blogs.msdn.com/b/pfxteam/archive/2012/02/12/10266988.aspx
    //
    // notes:
    // - this is NOT a reader/writer lock
    // - this is NOT a recursive lock
    //
    // using a named Semaphore here and not a Mutex because mutexes have thread
    // affinity which does not work with async situations
    //
    // it is important that managed code properly release the Semaphore before
    // going down else it will maintain the lock - however note that when the
    // whole process (w3wp.exe) goes down and all handles to the Semaphore have
    // been closed, the Semaphore system object is destroyed - so in any case
    // an iisreset should clean up everything
    //
    internal class AsyncLock
    {
        private readonly SemaphoreSlim _semaphore;
        private readonly Semaphore _semaphore2;
        private readonly IDisposable _releaser;
        private readonly Task&lt;IDisposable&gt; _releaserTask;

        public AsyncLock()
            : this (null)
        { }

        public AsyncLock(string name)
        {
            // WaitOne() waits until count &gt; 0 then decrements count
            // Release() increments count
            // initial count: the initial count value
            // maximum count: the max value of count, and then Release() throws

            if (string.IsNullOrWhiteSpace(name))
            {
                // anonymous semaphore
                // use one unique releaser, that will not release the semaphore when finalized
                // because the semaphore is destroyed anyway if the app goes down

                _semaphore = new SemaphoreSlim(1, 1); // create a local (to the app domain) semaphore
                _releaser = new SemaphoreSlimReleaser(_semaphore);
                _releaserTask = Task.FromResult(_releaser);
            }
            else
            {
                // named semaphore
                // use dedicated releasers, that will release the semaphore when finalized
                // because the semaphore is system-wide and we cannot leak counts

                _semaphore2 = new Semaphore(1, 1, name); // create a system-wide named semaphore
            }
        }

        private IDisposable CreateReleaser()
        {
            // for anonymous semaphore, use the unique releaser, else create a new one
            return _semaphore != null
                ? _releaser // (IDisposable)new SemaphoreSlimReleaser(_semaphore)
                : new NamedSemaphoreReleaser(_semaphore2);
        }

        public Task&lt;IDisposable&gt; LockAsync()
        {
            var wait = _semaphore != null 
                ? _semaphore.WaitAsync()
                : _semaphore2.WaitOneAsync();

            return wait.IsCompleted 
                ? _releaserTask ?? Task.FromResult(CreateReleaser()) // anonymous vs named
                : wait.ContinueWith((_, state) =&gt; (((AsyncLock) state).CreateReleaser()),
                    this, CancellationToken.None,
                    TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);
        }

        public Task&lt;IDisposable&gt; LockAsync(int millisecondsTimeout)
        {
            var wait = _semaphore != null
                ? _semaphore.WaitAsync(millisecondsTimeout)
                : _semaphore2.WaitOneAsync(millisecondsTimeout);

            return wait.IsCompleted
                ? _releaserTask ?? Task.FromResult(CreateReleaser()) // anonymous vs named
                : wait.ContinueWith((_, state) =&gt; (((AsyncLock)state).CreateReleaser()),
                    this, CancellationToken.None,
                    TaskContinuationOptions.ExecuteSynchronously, TaskScheduler.Default);
        }

        public IDisposable Lock()
        {
            if (_semaphore != null)
                _semaphore.Wait();
            else
                _semaphore2.WaitOne();
            return _releaser ?? CreateReleaser(); // anonymous vs named
        }

        public IDisposable Lock(int millisecondsTimeout)
        {
            var entered = _semaphore != null
                ? _semaphore.Wait(millisecondsTimeout)
                : _semaphore2.WaitOne(millisecondsTimeout);
            if (entered == false)
                throw new TimeoutException(&quot;Failed to enter the lock within timeout.&quot;);
            return _releaser ?? CreateReleaser(); // anonymous vs named
        }

        // note - before making those classes some structs, read 
        // about &quot;impure methods&quot; and mutating readonly structs...

        private class NamedSemaphoreReleaser : CriticalFinalizerObject, IDisposable
        {
            private readonly Semaphore _semaphore;
            private GCHandle _handle;

            internal NamedSemaphoreReleaser(Semaphore semaphore)
            {
                _semaphore = semaphore;
                _handle = GCHandle.Alloc(_semaphore);
            }

            public void Dispose()
            {
                Dispose(true);
                GC.SuppressFinalize(this); // finalize will not run
            }

            private void Dispose(bool disposing)
            {
                // critical
                _handle.Free();
                _semaphore.Release();
                _semaphore.Dispose();
            }

            // we WANT to release the semaphore because it&#39;s a system object, ie a critical 
            // non-managed resource - and if it is not released then noone else can acquire
            // the lock - so we inherit from CriticalFinalizerObject which means that the 
            // finalizer &quot;should&quot; run in all situations - there is always a chance that it
            // does not run and the semaphore remains &quot;acquired&quot; but then chances are the
            // whole process (w3wp.exe...) is going down, at which point the semaphore will
            // be destroyed by Windows.

            // however, the semaphore is a managed object, and so when the finalizer runs it
            // might have been finalized already, and then we get a, ObjectDisposedException
            // in the finalizer - which is bad.

            // in order to prevent this we do two things
            // - use a GCHandler to ensure the semaphore is still there when the finalizer
            //   runs, so we can actually release it
            // - wrap the finalizer code in a try...catch to make sure it never throws

            ~NamedSemaphoreReleaser()
            {
                try
                {
                    Dispose(false);
                }
                catch
                {
                    // we do NOT want the finalizer to throw - never ever
                }
            }
        }

        private class SemaphoreSlimReleaser : IDisposable
        {
            private readonly SemaphoreSlim _semaphore;

            internal SemaphoreSlimReleaser(SemaphoreSlim semaphore)
            {
                _semaphore = semaphore;
            }

            public void Dispose()
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }

            private void Dispose(bool disposing)
            {
                if (disposing)
                {
                    // normal
                    _semaphore.Release();
                }
            }

            ~SemaphoreSlimReleaser()
            {
                Dispose(false);
            }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[32,15,32,26,0],[33,9,33,10,0],[33,11,33,12,0],[35,9,35,38,1],[36,9,36,10,1],[42,13,42,49,1],[43,13,43,14,0],[48,17,48,54,0],[49,17,49,67,0],[50,17,50,60,0],[51,13,51,14,0],[53,13,53,14,1],[58,17,58,57,1],[59,13,59,14,1],[60,9,60,10,1],[63,9,63,10,1],[65,13,67,59,1],[68,9,68,10,1],[71,9,71,10,0],[72,13,74,46,0],[76,13,78,51,0],[78,51,78,89,0],[78,89,80,90,0],[76,13,80,90,0],[81,9,81,10,0],[84,9,84,10,0],[85,13,87,65,0],[89,13,91,51,0],[91,51,91,88,0],[91,88,93,90,0],[89,13,93,90,0],[94,9,94,10,0],[97,9,97,10,0],[98,13,98,36,0],[99,17,99,35,0],[101,17,101,39,0],[102,13,102,50,0],[103,9,103,10,0],[106,9,106,10,1],[107,13,109,60,1],[110,13,110,34,1],[111,17,111,88,0],[112,13,112,50,1],[113,9,113,10,1],[123,13,123,65,1],[124,13,124,14,1],[125,17,125,40,1],[126,17,126,54,1],[127,13,127,14,1],[130,13,130,14,1],[131,17,131,31,1],[132,17,132,43,1],[133,13,133,14,1],[136,13,136,14,1],[138,17,138,32,1],[139,17,139,38,1],[140,17,140,38,1],[141,13,141,14,1],[161,13,161,14,0],[161,13,161,14,0],[163,17,163,18,0],[164,21,164,36,0],[165,17,165,18,0],[166,17,166,22,0],[167,17,167,18,0],[169,17,169,18,0],[170,13,170,14,0],[170,13,170,14,0],[177,13,177,68,0],[178,13,178,14,0],[179,17,179,40,0],[180,13,180,14,0],[183,13,183,14,0],[184,17,184,31,0],[185,17,185,43,0],[186,13,186,14,0],[189,13,189,14,0],[190,17,190,31,0],[191,17,191,18,0],[193,21,193,42,0],[194,17,194,18,0],[195,13,195,14,0],[198,13,198,14,0],[198,13,198,14,0],[199,17,199,32,0],[200,13,200,14,0],[200,13,200,14,0]]);
    </script>
  </body>
</html>