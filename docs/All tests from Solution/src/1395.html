<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\DictionaryExtensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.Web;

namespace Umbraco.Core
{
	///&lt;summary&gt;
	/// Extension methods for dictionary &amp; concurrentdictionary
	///&lt;/summary&gt;
	internal static class DictionaryExtensions
	{

        /// &lt;summary&gt;
        /// Method to Get a value by the key. If the key doesn&#39;t exist it will create a new TVal object for the key and return it.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TKey&quot;&gt;&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TVal&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;dict&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
	    public static TVal GetOrCreate&lt;TKey, TVal&gt;(this IDictionary&lt;TKey, TVal&gt; dict, TKey key)
            where TVal : class, new()
	    {
	        if (dict.ContainsKey(key) == false)
	        {
                dict.Add(key, new TVal());
	        }
            return dict[key];
	    }

        /// &lt;summary&gt;
        /// Updates an item with the specified key with the specified value
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TKey&quot;&gt;&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TValue&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;dict&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;updateFactory&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// Taken from: http://stackoverflow.com/questions/12240219/is-there-a-way-to-use-concurrentdictionary-tryupdate-with-a-lambda-expression
        /// 
        /// If there is an item in the dictionary with the key, it will keep trying to update it until it can
        /// &lt;/remarks&gt;
        public static bool TryUpdate&lt;TKey, TValue&gt;(this ConcurrentDictionary&lt;TKey, TValue&gt; dict, TKey key, Func&lt;TValue, TValue&gt; updateFactory)
        {
            TValue curValue;
            while (dict.TryGetValue(key, out curValue))
            {
                if (dict.TryUpdate(key, updateFactory(curValue), curValue))
                    return true;
                //if we&#39;re looping either the key was removed by another thread, or another thread
                //changed the value, so we start again.
            }
            return false;
        }

        /// &lt;summary&gt;
        /// Updates an item with the specified key with the specified value
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TKey&quot;&gt;&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TValue&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;dict&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;updateFactory&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// Taken from: http://stackoverflow.com/questions/12240219/is-there-a-way-to-use-concurrentdictionary-tryupdate-with-a-lambda-expression
        /// 
        /// WARNING: If the value changes after we&#39;ve retreived it, then the item will not be updated
        /// &lt;/remarks&gt;
        public static bool TryUpdateOptimisitic&lt;TKey, TValue&gt;(this ConcurrentDictionary&lt;TKey, TValue&gt; dict, TKey key, Func&lt;TValue, TValue&gt; updateFactory)
        {
            TValue curValue;
            if (!dict.TryGetValue(key, out curValue))
                return false;
            dict.TryUpdate(key, updateFactory(curValue), curValue);
            return true;//note we return true whether we succeed or not, see explanation below.
        }

		/// &lt;summary&gt;
		/// Converts a dictionary to another type by only using direct casting
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;TKeyOut&quot;&gt;&lt;/typeparam&gt;
		/// &lt;typeparam name=&quot;TValOut&quot;&gt;&lt;/typeparam&gt;
		/// &lt;param name=&quot;d&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static IDictionary&lt;TKeyOut, TValOut&gt; ConvertTo&lt;TKeyOut, TValOut&gt;(this IDictionary d)
		{
			var result = new Dictionary&lt;TKeyOut, TValOut&gt;();
			foreach (DictionaryEntry v in d)
			{
				result.Add((TKeyOut)v.Key, (TValOut)v.Value);
			}
			return result;
		}

		/// &lt;summary&gt;
		/// Converts a dictionary to another type using the specified converters
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;TKeyOut&quot;&gt;&lt;/typeparam&gt;
		/// &lt;typeparam name=&quot;TValOut&quot;&gt;&lt;/typeparam&gt;
		/// &lt;param name=&quot;d&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;keyConverter&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;valConverter&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static IDictionary&lt;TKeyOut, TValOut&gt; ConvertTo&lt;TKeyOut, TValOut&gt;(this IDictionary d, Func&lt;object, TKeyOut&gt; keyConverter, Func&lt;object, TValOut&gt; valConverter)
		{
			var result = new Dictionary&lt;TKeyOut, TValOut&gt;();
			foreach (DictionaryEntry v in d)
			{
				result.Add(keyConverter(v.Key), valConverter(v.Value));
			}
			return result;
		}

		/// &lt;summary&gt;
		/// Converts a dictionary to a NameValueCollection
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;d&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static NameValueCollection ToNameValueCollection(this IDictionary&lt;string, string&gt; d)
		{
			var n = new NameValueCollection();
			foreach (var i in d)
			{
				n.Add(i.Key, i.Value);
			}
			return n;
		}


	    /// &lt;summary&gt;
	    /// Merges all key/values from the sources dictionaries into the destination dictionary
	    /// &lt;/summary&gt;
	    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
	    /// &lt;typeparam name=&quot;TK&quot;&gt;&lt;/typeparam&gt;
	    /// &lt;typeparam name=&quot;TV&quot;&gt;&lt;/typeparam&gt;
	    /// &lt;param name=&quot;destination&quot;&gt;The source dictionary to merge other dictionaries into&lt;/param&gt;
	    /// &lt;param name=&quot;overwrite&quot;&gt;
	    /// By default all values will be retained in the destination if the same keys exist in the sources but 
	    /// this can changed if overwrite = true, then any key/value found in any of the sources will overwritten in the destination. Note that
	    /// it will just use the last found key/value if this is true.
	    /// &lt;/param&gt;
	    /// &lt;param name=&quot;sources&quot;&gt;The other dictionaries to merge values from&lt;/param&gt;
        public static void MergeLeft&lt;T, TK, TV&gt;(this T destination, IEnumerable&lt;IDictionary&lt;TK, TV&gt;&gt; sources, bool overwrite = false)
			where T : IDictionary&lt;TK, TV&gt;
	    {
	        foreach (var p in sources.SelectMany(src =&gt; src).Where(p =&gt; overwrite || destination.ContainsKey(p.Key) == false))
	        {
	            destination[p.Key] = p.Value;
	        }
	    }

        /// &lt;summary&gt;
        /// Merges all key/values from the sources dictionaries into the destination dictionary
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TK&quot;&gt;&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TV&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;destination&quot;&gt;The source dictionary to merge other dictionaries into&lt;/param&gt;
        /// &lt;param name=&quot;overwrite&quot;&gt;
        /// By default all values will be retained in the destination if the same keys exist in the sources but 
        /// this can changed if overwrite = true, then any key/value found in any of the sources will overwritten in the destination. Note that
        /// it will just use the last found key/value if this is true.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;source&quot;&gt;The other dictionary to merge values from&lt;/param&gt;
        public static void MergeLeft&lt;T, TK, TV&gt;(this T destination, IDictionary&lt;TK, TV&gt; source, bool overwrite = false)
            where T : IDictionary&lt;TK, TV&gt;
        {
            destination.MergeLeft(new[] {source}, overwrite);
        }

	    /// &lt;summary&gt;
		/// Returns the value of the key value based on the key, if the key is not found, a null value is returned
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;TKey&quot;&gt;The type of the key.&lt;/typeparam&gt;
		/// &lt;typeparam name=&quot;TVal&quot;&gt;The type of the val.&lt;/typeparam&gt;
		/// &lt;param name=&quot;d&quot;&gt;The d.&lt;/param&gt;
		/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
		/// &lt;param name=&quot;defaultValue&quot;&gt;The default value.&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static TVal GetValue&lt;TKey, TVal&gt;(this IDictionary&lt;TKey, TVal&gt; d, TKey key, TVal defaultValue = default(TVal))
		{
			if (d.ContainsKey(key))
			{
				return d[key];
			}
			return defaultValue;
		}

		/// &lt;summary&gt;
		/// Returns the value of the key value based on the key as it&#39;s string value, if the key is not found, then an empty string is returned
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;d&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static string GetValueAsString&lt;TKey, TVal&gt;(this IDictionary&lt;TKey, TVal&gt; d, TKey key)
		{
			if (d.ContainsKey(key))
			{
				return d[key].ToString();
			}
			return String.Empty;
		}

	    /// &lt;summary&gt;
	    /// Returns the value of the key value based on the key as it&#39;s string value, if the key is not found or is an empty string, then the provided default value is returned
	    /// &lt;/summary&gt;
	    /// &lt;param name=&quot;d&quot;&gt;&lt;/param&gt;
	    /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt;
	    /// &lt;param name=&quot;defaultValue&quot;&gt;&lt;/param&gt;
	    /// &lt;returns&gt;&lt;/returns&gt;
	    public static string GetValueAsString&lt;TKey, TVal&gt;(this IDictionary&lt;TKey, TVal&gt; d, TKey key, string defaultValue)
		{
			if (d.ContainsKey(key))
			{
				var value = d[key].ToString();
			    if (value != string.Empty)
                    return value;
			}
			
            return defaultValue;
		}

		/// &lt;summary&gt;contains key ignore case.&lt;/summary&gt;
		/// &lt;param name=&quot;dictionary&quot;&gt;The dictionary.&lt;/param&gt;
		/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
		/// &lt;typeparam name=&quot;TValue&quot;&gt;Value Type&lt;/typeparam&gt;
		/// &lt;returns&gt;The contains key ignore case.&lt;/returns&gt;
		public static bool ContainsKeyIgnoreCase&lt;TValue&gt;(this IDictionary&lt;string, TValue&gt; dictionary, string key)
		{
		    return dictionary.Keys.InvariantContains(key);
		}

		/// &lt;summary&gt;
		/// Converts a dictionary object to a query string representation such as:
		/// firstname=shannon&amp;lastname=deminick
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;d&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static string ToQueryString(this IDictionary&lt;string, object&gt; d)
		{
			if (!d.Any()) return &quot;&quot;;

			var builder = new StringBuilder();
			foreach (var i in d)
			{
				builder.Append(String.Format(&quot;{0}={1}&amp;&quot;, HttpUtility.UrlEncode(i.Key), i.Value == null ? string.Empty : HttpUtility.UrlEncode(i.Value.ToString())));
			}
			return builder.ToString().TrimEnd(&#39;&amp;&#39;);
		}

		/// &lt;summary&gt;The get entry ignore case.&lt;/summary&gt;
		/// &lt;param name=&quot;dictionary&quot;&gt;The dictionary.&lt;/param&gt;
		/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
		/// &lt;typeparam name=&quot;TValue&quot;&gt;The type&lt;/typeparam&gt;
		/// &lt;returns&gt;The entry&lt;/returns&gt;
		public static TValue GetValueIgnoreCase&lt;TValue&gt;(this IDictionary&lt;string, TValue&gt; dictionary, string key)
		{
			return dictionary.GetValueIgnoreCase(key, default(TValue));
		}

		/// &lt;summary&gt;The get entry ignore case.&lt;/summary&gt;
		/// &lt;param name=&quot;dictionary&quot;&gt;The dictionary.&lt;/param&gt;
		/// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
		/// &lt;param name=&quot;defaultValue&quot;&gt;The default value.&lt;/param&gt;
		/// &lt;typeparam name=&quot;TValue&quot;&gt;The type&lt;/typeparam&gt;
		/// &lt;returns&gt;The entry&lt;/returns&gt;
		public static TValue GetValueIgnoreCase&lt;TValue&gt;(this IDictionary&lt;string, TValue&gt; dictionary, string key, TValue defaultValue)
		{
			key = dictionary.Keys.FirstOrDefault(i =&gt; i.InvariantEquals(key));

			return key.IsNullOrWhiteSpace() == false
			       	? dictionary[key]
			       	: defaultValue;
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[28,6,28,7,0],[29,10,29,45,0],[30,10,30,11,0],[31,17,31,43,0],[32,10,32,11,0],[33,13,33,30,0],[34,6,34,7,0],[51,9,51,10,0],[53,13,53,56,0],[54,13,54,14,0],[55,17,55,76,0],[56,21,56,33,0],[59,13,59,14,0],[60,13,60,26,0],[61,9,61,10,0],[78,9,78,10,0],[80,13,80,54,0],[81,17,81,30,0],[82,13,82,68,0],[83,13,83,25,0],[84,9,84,10,0],[94,3,94,4,0],[95,4,95,52,0],[96,4,96,11,0],[96,13,96,30,0],[96,31,96,33,0],[96,34,96,35,0],[97,4,97,5,0],[98,5,98,50,0],[99,4,99,5,0],[100,4,100,18,0],[101,3,101,4,0],[113,3,113,4,0],[114,4,114,52,0],[115,4,115,11,0],[115,13,115,30,0],[115,31,115,33,0],[115,34,115,35,0],[116,4,116,5,0],[117,5,117,60,0],[118,4,118,5,0],[119,4,119,18,0],[120,3,120,4,0],[128,3,128,4,0],[129,4,129,38,0],[130,4,130,11,0],[130,13,130,18,0],[130,19,130,21,0],[130,22,130,23,0],[131,4,131,5,0],[132,5,132,27,0],[133,4,133,5,0],[134,4,134,13,0],[135,3,135,4,0],[153,6,153,7,1],[154,10,154,17,1],[154,19,154,24,1],[154,25,154,27,1],[154,28,154,54,1],[154,54,154,57,1],[154,57,154,70,1],[154,70,154,122,1],[154,122,154,123,1],[154,28,154,123,1],[155,10,155,11,1],[156,14,156,43,1],[157,10,157,11,1],[158,6,158,7,1],[175,9,175,10,1],[176,13,176,62,1],[177,9,177,10,1],[189,3,189,4,0],[190,4,190,27,0],[191,4,191,5,0],[192,5,192,19,0],[194,4,194,24,0],[195,3,195,4,0],[204,3,204,4,0],[205,4,205,27,0],[206,4,206,5,0],[207,5,207,30,0],[209,4,209,24,0],[210,3,210,4,0],[220,3,220,4,0],[221,4,221,27,0],[222,4,222,5,0],[223,5,223,35,0],[224,8,224,34,0],[225,21,225,34,0],[226,4,226,5,0],[228,13,228,33,0],[229,3,229,4,0],[237,3,237,4,0],[238,7,238,53,0],[239,3,239,4,0],[248,3,248,4,1],[249,4,249,17,1],[249,18,249,28,0],[251,4,251,38,1],[252,4,252,11,1],[252,13,252,18,1],[252,19,252,21,1],[252,22,252,23,1],[253,4,253,5,1],[254,5,254,153,1],[255,4,255,5,1],[256,4,256,43,1],[257,3,257,4,1],[265,3,265,4,0],[266,4,266,63,0],[267,3,267,4,0],[276,3,276,4,0],[277,4,277,46,0],[277,46,277,68,0],[277,68,277,70,0],[277,4,277,70,0],[279,4,281,27,0],[282,3,282,4,0]]);
    </script>
  </body>
</html>