<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Xml\XPath\NavigableNavigator.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Xml;
using System.Xml.XPath;

namespace Umbraco.Core.Xml.XPath
{
    /// &lt;summary&gt;
    /// Provides a cursor model for navigating Umbraco data as if it were XML.
    /// &lt;/summary&gt;
    class NavigableNavigator : XPathNavigator
    {
        // &quot;The XmlNameTable stores atomized strings of any local name, namespace URI,
        // and prefix used by the XPathNavigator. This means that when the same Name is
        // returned multiple times (like &quot;book&quot;), the same String object is returned for
        // that Name. This makes it possible to write efficient code that does object
        // comparisons on these strings, instead of expensive string comparisons.&quot;
        //
        // &quot;When an element or attribute name occurs multiple times in an XML document,
        // it is stored only once in the NameTable. The names are stored as common
        // language runtime (CLR) object types. This enables you to do object comparisons
        // on these strings rather than a more expensive string comparison. These 
        // string objects are referred to as atomized strings.&quot;
        //
        // But... &quot;Any instance members are not guaranteed to be thread safe.&quot;
        //
        // see http://msdn.microsoft.com/en-us/library/aa735772%28v=vs.71%29.aspx
        // see http://www.hanselman.com/blog/XmlAndTheNametable.aspx
        // see http://blogs.msdn.com/b/mfussell/archive/2004/04/30/123673.aspx
        //
        // &quot;Additionally, all LocalName, NameSpaceUri and Prefix strings must be added to
        // a NameTable, given by the NameTable property. When the LocalName, NamespaceURI,
        // and Prefix properties are returned, the string returned should come from the
        // NameTable. Comparisons between names are done by object comparisons rather
        // than by string comparisons, which are significantly slower.&quot;&quot;
        //
        // So what shall we do? Well, here we have no namespace, no prefix, and all
        // local names come from cached instances of INavigableContentType or
        // INavigableFieldType and are already unique. So... create a one nametable
        // because we need one, and share it amongst all clones.

        private readonly XmlNameTable _nameTable;
        private readonly INavigableSource _source;
        private readonly int _lastAttributeIndex; // last index of attributes in the fields collection
        private State _state;

        #region Constructor

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;NavigableNavigator&quot;/&gt; class with a content source.
        /// &lt;/summary&gt;
        private NavigableNavigator(INavigableSource source)
        {
            _source = source;
            _lastAttributeIndex = source.LastAttributeIndex;
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;NavigableNavigator&quot;/&gt; class with a content source,
        /// and an optional root content.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;source&quot;&gt;The content source.&lt;/param&gt;
        /// &lt;param name=&quot;content&quot;&gt;The root content.&lt;/param&gt;
        /// &lt;remarks&gt;When no root content is supplied then the root of the source is used.&lt;/remarks&gt;
        public NavigableNavigator(INavigableSource source, INavigableContent content = null)
            : this(source)
        {
            _nameTable = new NameTable();
            _lastAttributeIndex = source.LastAttributeIndex;
            _state = new State(content ?? source.Root, null, null, 0, StatePosition.Root);
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;NavigableNavigator&quot;/&gt; class with a content source, a name table and a state.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;source&quot;&gt;The content source.&lt;/param&gt;
        /// &lt;param name=&quot;nameTable&quot;&gt;The name table.&lt;/param&gt;
        /// &lt;param name=&quot;state&quot;&gt;The state.&lt;/param&gt;
        /// &lt;remarks&gt;Privately used for cloning a navigator.&lt;/remarks&gt;
        private NavigableNavigator(INavigableSource source, XmlNameTable nameTable, State state)
            : this(source)
        {
            _nameTable = nameTable;
            _state = state;
        }

        #endregion

        #region Diagnostics

        // diagnostics code will not be compiled nor called into Release configuration.
        // in Debug configuration, uncomment lines in Debug() to write to console or to log.

#if DEBUG
        private const string Tabs = &quot;                    &quot;;
        private int _tabs;
        private readonly int _uid = GetUid();
        private static int _uidg;
        private readonly static object Uidl = new object();
        private static int GetUid()
        {
            lock (Uidl)
            {
                return _uidg++;
            }
        }
#endif

        [Conditional(&quot;DEBUG&quot;)]
        void DebugEnter(string name)
        {
#if DEBUG
            Debug(&quot;&quot;);
            DebugState(&quot;:&quot;);
            Debug(name);
            _tabs = Math.Min(Tabs.Length, _tabs + 2);
#endif
        }

        [Conditional(&quot;DEBUG&quot;)]
        void DebugCreate(NavigableNavigator nav)
        {
#if DEBUG
            Debug(&quot;Create: [NavigableNavigator::{0}]&quot;, nav._uid);
#endif
        }

        [Conditional(&quot;DEBUG&quot;)]
        private void DebugReturn()
        {
#if DEBUG
// ReSharper disable IntroduceOptionalParameters.Local
            DebugReturn(&quot;(void)&quot;);
// ReSharper restore IntroduceOptionalParameters.Local
#endif
        }

        [Conditional(&quot;DEBUG&quot;)]
        private void DebugReturn(bool value)
        {
#if DEBUG
            DebugReturn(value ? &quot;true&quot; : &quot;false&quot;);
#endif
        }

        [Conditional(&quot;DEBUG&quot;)]
        void DebugReturn(string format, params object[] args)
        {
#if DEBUG
            Debug(&quot;=&gt; &quot; + format, args);
            if (_tabs &gt; 0) _tabs -= 2;
#endif
        }

        [Conditional(&quot;DEBUG&quot;)]
        void DebugState(string s = &quot; =&gt;&quot;)
        {
#if DEBUG
            string position;

            switch (_state.Position)
            {
                case StatePosition.Attribute:
                    position = string.Format(&quot;At attribute &#39;{0}/@{1}&#39;.&quot;,
                        _state.Content.Type.Name,
                        _state.FieldIndex &lt; 0 ? &quot;id&quot; : _state.CurrentFieldType.Name);
                    break;
                case StatePosition.Element:
                    position = string.Format(&quot;At element &#39;{0}&#39;.&quot;,
                        _state.Content.Type.Name);
                    break;
                case StatePosition.PropertyElement:
                    position = string.Format(&quot;At property &#39;{0}/{1}&#39;.&quot;,
                        _state.Content.Type.Name, _state.Content.Type.FieldTypes[this._state.FieldIndex].Name);
                    break;
                case StatePosition.PropertyText:
                    position = string.Format(&quot;At property &#39;{0}/{1}&#39; text.&quot;,
                        _state.Content.Type.Name, _state.CurrentFieldType.Name);
                    break;
                case StatePosition.PropertyXml:
                    position = string.Format(&quot;In property &#39;{0}/{1}&#39; xml fragment.&quot;,
                        _state.Content.Type.Name, _state.CurrentFieldType.Name);
                    break;
                case StatePosition.Root:
                    position = &quot;At root.&quot;;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            Debug(&quot;State{0} {1}&quot;, s, position);
#endif
        }

#if DEBUG
        void Debug(string format, params object[] args)
        {
            // remove comments to write

            format = &quot;[&quot; + _uid.ToString(&quot;00000&quot;) + &quot;] &quot; + Tabs.Substring(0, _tabs) + format;
#pragma warning disable 168
            var msg = string.Format(format, args); // unused if not writing, hence #pragma
#pragma warning restore 168
            //LogHelper.Debug&lt;NavigableNavigator&gt;(msg); // beware! this can quicky overflow log4net
            //Console.WriteLine(msg);
        }
#endif

        #endregion

        /// &lt;summary&gt;
        /// Gets the underlying content object.
        /// &lt;/summary&gt;
        public override object UnderlyingObject
        {
            get { return _state.Content; }
        }

        /// &lt;summary&gt;
        /// Creates a new XPathNavigator positioned at the same node as this XPathNavigator.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A new XPathNavigator positioned at the same node as this XPathNavigator.&lt;/returns&gt;
        public override XPathNavigator Clone()
        {
            DebugEnter(&quot;Clone&quot;);
            var nav = new NavigableNavigator(_source, _nameTable, _state.Clone());
            DebugCreate(nav);
            DebugReturn(&quot;[XPathNavigator]&quot;);
            return nav;
        }

        /// &lt;summary&gt;
        /// Creates a new XPathNavigator using the same source but positioned at a new root.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A new XPathNavigator using the same source and positioned at a new root.&lt;/returns&gt;
        /// &lt;remarks&gt;The new root can be above this navigator&#39;s root.&lt;/remarks&gt;
        public XPathNavigator CloneWithNewRoot(string id)
        {
            DebugEnter(&quot;CloneWithNewRoot&quot;);

            int contentId;
            State state = null;

            if (id != null &amp;&amp; id.Trim() == &quot;-1&quot;)
            {
                state = new State(_source.Root, null, null, 0, StatePosition.Root);
            }
            else if (int.TryParse(id, out contentId))
            {
                var content = _source.Get(contentId);
                if (content != null)
                {
                    state = new State(content, null, null, 0, StatePosition.Root);
                }
            }

            NavigableNavigator clone = null;

            if (state != null)
            {
                clone = new NavigableNavigator(_source, _nameTable, state);
                DebugCreate(clone);
                DebugReturn(&quot;[XPathNavigator]&quot;);
            }
            else
            {
                DebugReturn(&quot;[null]&quot;);                
            }

            return clone;
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether the current node is an empty element without an end element tag.
        /// &lt;/summary&gt;
        public override bool IsEmptyElement
        {
            get 
            {
                DebugEnter(&quot;IsEmptyElement&quot;);
                bool isEmpty;

                switch (_state.Position)
                {
                    case StatePosition.Element:
                        isEmpty = (_state.Content.ChildIds == null || _state.Content.ChildIds.Count == 0) // no content child
                            &amp;&amp; _state.FieldsCount - 1 == _lastAttributeIndex; // no property element child
                        break;
                    case StatePosition.PropertyElement:
                        // value should be
                        // - an XPathNavigator over a non-empty XML fragment
                        // - a non-Xml-whitespace string
                        // - null
                        isEmpty = _state.Content.Value(_state.FieldIndex) == null;
                        break;
                    case StatePosition.PropertyXml:
                        isEmpty = _state.XmlFragmentNavigator.IsEmptyElement;
                        break;
                    case StatePosition.Attribute:
                    case StatePosition.PropertyText:
                    case StatePosition.Root:
                        throw new InvalidOperationException(&quot;Not an element.&quot;);
                    default:
                        throw new InvalidOperationException(&quot;Invalid position.&quot;);
                }

                DebugReturn(isEmpty);
                return isEmpty;
            }
        }

        /// &lt;summary&gt;
        /// Determines whether the current XPathNavigator is at the same position as the specified XPathNavigator.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;nav&quot;&gt;The XPathNavigator to compare to this XPathNavigator.&lt;/param&gt;
        /// &lt;returns&gt;true if the two XPathNavigator objects have the same position; otherwise, false.&lt;/returns&gt;
        public override bool IsSamePosition(XPathNavigator nav)
        {
            DebugEnter(&quot;IsSamePosition&quot;);
            bool isSame;

            switch (_state.Position)
            {
                case StatePosition.PropertyXml:
                    isSame = _state.XmlFragmentNavigator.IsSamePosition(nav);
                    break;
                case StatePosition.Attribute:
                case StatePosition.Element:
                case StatePosition.PropertyElement:
                case StatePosition.PropertyText:
                case StatePosition.Root:
                    var other = nav as NavigableNavigator;
                    isSame = other != null &amp;&amp; other._source == _source &amp;&amp; _state.IsSamePosition(other._state);
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(isSame);
            return isSame;
        }

        /// &lt;summary&gt;
        /// Gets the qualified name of the current node.
        /// &lt;/summary&gt;
        public override string Name
        {
            get
            {
                DebugEnter(&quot;Name&quot;);
                string name;

                switch (_state.Position)
                {
                    case StatePosition.PropertyXml:
                        name = _state.XmlFragmentNavigator.Name;
                        break;
                    case StatePosition.Attribute:
                    case StatePosition.PropertyElement:
                        name = _state.FieldIndex == -1 ? &quot;id&quot; : _state.CurrentFieldType.Name;
                        break;
                    case StatePosition.Element:
                        name = _state.Content.Type.Name;
                        break;
                    case StatePosition.PropertyText:
                        name = string.Empty;
                        break;
                    case StatePosition.Root:
                        name = string.Empty;
                        break;
                    default:
                        throw new InvalidOperationException(&quot;Invalid position.&quot;);
                }

                DebugReturn(&quot;\&quot;{0}\&quot;&quot;, name);
                return name;
            }
        }

        /// &lt;summary&gt;
        /// Gets the Name of the current node without any namespace prefix.
        /// &lt;/summary&gt;
        public override string LocalName
        {
            get
            {
                DebugEnter(&quot;LocalName&quot;);
                var name = Name;
                DebugReturn(&quot;\&quot;{0}\&quot;&quot;, name);
                return name;
            }
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the same position as the specified XPathNavigator.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;nav&quot;&gt;The XPathNavigator positioned on the node that you want to move to. &lt;/param&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the same position as the specified XPathNavigator;
        /// otherwise, false. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveTo(XPathNavigator nav)
        {
            DebugEnter(&quot;MoveTo&quot;);

            var other = nav as NavigableNavigator;
            var succ = false;

            if (other != null &amp;&amp; other._source == _source)
            {
                _state = other._state.Clone();
                DebugState();
                succ = true;
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the first attribute of the current node.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the first attribute of the current node;
        /// otherwise, false. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToFirstAttribute()
        {
            DebugEnter(&quot;MoveToFirstAttribute&quot;);
            bool succ;

            switch (_state.Position)
            {
                case StatePosition.PropertyXml:
                    succ = _state.XmlFragmentNavigator.MoveToFirstAttribute();
                    break;
                case StatePosition.Element:
                    _state.FieldIndex = -1;
                    _state.Position = StatePosition.Attribute;
                    DebugState();
                    succ = true;
                    break;
                case StatePosition.Attribute:
                case StatePosition.PropertyElement:
                case StatePosition.PropertyText:
                case StatePosition.Root:
                    succ = false;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the first child node of the current node.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the first child node of the current node;
        /// otherwise, false. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToFirstChild()
        {
            DebugEnter(&quot;MoveToFirstChild&quot;);
            bool succ;

            switch (_state.Position)
            {
                case StatePosition.PropertyXml:
                    succ = _state.XmlFragmentNavigator.MoveToFirstChild();
                    break;
                case StatePosition.Attribute:
                case StatePosition.PropertyText:
                    succ = false;
                    break;
                case StatePosition.Element:
                    var firstPropertyIndex = _lastAttributeIndex + 1;
                    if (_state.FieldsCount &gt; firstPropertyIndex)
                    {
                        _state.Position = StatePosition.PropertyElement;
                        _state.FieldIndex = firstPropertyIndex;
                        DebugState();
                        succ = true;
                    }
                    else succ = MoveToFirstChildElement();
                    break;
                case StatePosition.PropertyElement:
                    succ = MoveToFirstChildProperty();
                    break;
                case StatePosition.Root:
                    _state.Position = StatePosition.Element;
                    DebugState();
                    succ = true;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(succ);
            return succ;
        }

        private bool MoveToFirstChildElement()
        {
            var children = _state.Content.ChildIds;

            if (children != null &amp;&amp; children.Count &gt; 0)
            {
                // children may contain IDs that does not correspond to some content in source
                // because children contains all child IDs including unpublished children - and
                // then if we&#39;re not previewing, the source will return null.
                var child = children.Select(id =&gt; _source.Get(id)).FirstOrDefault(c =&gt; c != null);
                if (child != null)
                {
                    _state.Position = StatePosition.Element;
                    _state.FieldIndex = -1;
                    _state = new State(child, _state, children, 0, StatePosition.Element);
                    DebugState();
                    return true;
                }
            }

            return false;
        }

        private bool MoveToFirstChildProperty()
        {
            var valueForXPath = _state.Content.Value(_state.FieldIndex);

            // value should be
            // - an XPathNavigator over a non-empty XML fragment
            // - a non-Xml-whitespace string
            // - null

            var nav = valueForXPath as XPathNavigator;
            if (nav != null)
            {
                nav = nav.Clone(); // never use the one we got
                nav.MoveToFirstChild();
                _state.XmlFragmentNavigator = nav;
                _state.Position = StatePosition.PropertyXml;
                DebugState();
                return true;
            }

            if (valueForXPath == null)
                return false;
            
            if (valueForXPath is string)
            {
                _state.Position = StatePosition.PropertyText;
                DebugState();
                return true;
            }

            throw new InvalidOperationException(&quot;XPathValue must be an XPathNavigator or a string.&quot;);
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the first namespace node that matches the XPathNamespaceScope specified.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;namespaceScope&quot;&gt;An XPathNamespaceScope value describing the namespace scope. &lt;/param&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the first namespace node;
        /// otherwise, false. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope)
        {
            DebugEnter(&quot;MoveToFirstNamespace&quot;);
            DebugReturn(false);
            return false;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the next namespace node matching the XPathNamespaceScope specified.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;namespaceScope&quot;&gt;An XPathNamespaceScope value describing the namespace scope. &lt;/param&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the next namespace node;
        /// otherwise, false. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToNextNamespace(XPathNamespaceScope namespaceScope)
        {
            DebugEnter(&quot;MoveToNextNamespace&quot;);
            DebugReturn(false);
            return false;
        }

        /// &lt;summary&gt;
        /// Moves to the node that has an attribute of type ID whose value matches the specified String.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;id&quot;&gt;A String representing the ID value of the node to which you want to move.&lt;/param&gt;
        /// &lt;returns&gt;true if the XPathNavigator is successful moving; otherwise, false.
        /// If false, the position of the navigator is unchanged.&lt;/returns&gt;
        public override bool MoveToId(string id)
        {
            DebugEnter(&quot;MoveToId&quot;);
            var succ = false;

            // don&#39;t look into fragments, just look for element identifiers
            // not sure we actually need to implement it... think of it as
            // as exercise of style, always better than throwing NotImplemented.

            int contentId;
            if (/*id != null &amp;&amp;*/ id.Trim() == &quot;-1&quot;) // id cannot be null
            {
                _state = new State(_source.Root, null, _source.Root.ChildIds, 0, StatePosition.Element);
                succ = true;
            }
            else if (int.TryParse(id, out contentId))
            {
                var content = _source.Get(contentId);
                if (content != null)
                {
                    var state = _state;
                    while (state.Parent != null)
                        state = state.Parent;
                    var navRootId = state.Content.Id; // navigator may be rooted below source root

                    var s = new Stack&lt;INavigableContent&gt;();
                    while (content != null &amp;&amp; content.ParentId != navRootId)
                    {
                        s.Push(content);
                        content = _source.Get(content.ParentId);
                    }
                    if (content != null)
                    {
                        _state = new State(_source.Root, null, _source.Root.ChildIds, _source.Root.ChildIds.IndexOf(content.Id), StatePosition.Element);
                        while (content != null)
                        {
                            _state = new State(content, _state, content.ChildIds, _state.Content.ChildIds.IndexOf(content.Id), StatePosition.Element);
                            content = s.Count == 0 ? null : s.Pop();
                        }
                        DebugState();
                        succ = true;
                    }
                }
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the next sibling node of the current node.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;true if the XPathNavigator is successful moving to the next sibling node;
        /// otherwise, false if there are no more siblings or if the XPathNavigator is currently
        /// positioned on an attribute node. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToNext()
        {
            DebugEnter(&quot;MoveToNext&quot;);
            bool succ;

            switch (_state.Position)
            {
                case StatePosition.PropertyXml:
                    succ = _state.XmlFragmentNavigator.MoveToNext();
                    break;
                case StatePosition.Element:
                    succ = false;
                    while (_state.Siblings != null &amp;&amp; _state.SiblingIndex &lt; _state.Siblings.Count - 1)
                    {
                        // Siblings may contain IDs that does not correspond to some content in source
                        // because children contains all child IDs including unpublished children - and
                        // then if we&#39;re not previewing, the source will return null.
                        var node = _source.Get(_state.Siblings[++_state.SiblingIndex]);
                        if (node == null) continue;

                        _state.Content = node;
                        DebugState();
                        succ = true;
                        break;
                    }
                    break;
                case StatePosition.PropertyElement:
                    if (_state.FieldIndex == _state.FieldsCount - 1)
                    {
                        // after property elements may come some children elements
                        // if successful, will push a new state
                        succ = MoveToFirstChildElement();
                    }
                    else
                    {
                        ++_state.FieldIndex;
                        DebugState();
                        succ = true;
                    }
                    break;
                case StatePosition.PropertyText:
                case StatePosition.Attribute:
                case StatePosition.Root:
                    succ = false;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the previous sibling node of the current node.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the previous sibling node;
        /// otherwise, false if there is no previous sibling node or if the XPathNavigator is currently
        /// positioned on an attribute node. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToPrevious()
        {
            DebugEnter(&quot;MoveToPrevious&quot;);
            bool succ;

            switch (_state.Position)
            {
                case StatePosition.PropertyXml:
                    succ = _state.XmlFragmentNavigator.MoveToPrevious();
                    break;
                case StatePosition.Element:
                    succ = false;
                    while (_state.Siblings != null &amp;&amp; _state.SiblingIndex &gt; 0)
                    {
                        // children may contain IDs that does not correspond to some content in source
                        // because children contains all child IDs including unpublished children - and
                        // then if we&#39;re not previewing, the source will return null.
                        var content = _source.Get(_state.Siblings[--_state.SiblingIndex]);
                        if (content == null) continue;

                        _state.Content = content;
                        DebugState();
                        succ = true;
                        break;
                    }
                    if (succ == false &amp;&amp; _state.SiblingIndex == 0 &amp;&amp; _state.FieldsCount - 1 &gt; _lastAttributeIndex)
                    {
                        // before children elements may come some property elements
                        if (MoveToParentElement()) // pops the state
                        {
                            _state.FieldIndex = _state.FieldsCount - 1;
                            DebugState();
                            succ = true;
                        }
                    }                    
                    break;
                case StatePosition.PropertyElement:
                    succ = false;
                    if (_state.FieldIndex &gt; _lastAttributeIndex)
                    {
                        --_state.FieldIndex;
                        DebugState();
                        succ = true;
                    }
                    break;
                case StatePosition.Attribute:
                case StatePosition.PropertyText:
                case StatePosition.Root:
                    succ = false;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the next attribute.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the next attribute;
        /// false if there are no more attributes. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToNextAttribute()
        {
            DebugEnter(&quot;MoveToNextAttribute&quot;);
            bool succ;

            switch (_state.Position)
            {
                case StatePosition.PropertyXml:
                    succ = _state.XmlFragmentNavigator.MoveToNextAttribute();
                    break;
                case StatePosition.Attribute:
                    if (_state.FieldIndex == _lastAttributeIndex)
                        succ = false;
                    else
                    {
                        ++_state.FieldIndex;
                        DebugState();
                        succ = true;
                    }
                    break;
                case StatePosition.Element:
                case StatePosition.PropertyElement:
                case StatePosition.PropertyText:
                case StatePosition.Root:
                    succ = false;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(succ);
            return succ;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the parent node of the current node.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Returns true if the XPathNavigator is successful moving to the parent node of the current node;
        /// otherwise, false. If false, the position of the XPathNavigator is unchanged.&lt;/returns&gt;
        public override bool MoveToParent()
        {
            DebugEnter(&quot;MoveToParent&quot;);
            bool succ;

            switch (_state.Position)
            {
                case StatePosition.Attribute:
                case StatePosition.PropertyElement:
                    _state.Position = StatePosition.Element;
                    _state.FieldIndex = -1;
                    DebugState();
                    succ = true;
                    break;
                case StatePosition.Element:
                    succ = MoveToParentElement();
                    if (!succ)
                    {
                        _state.Position = StatePosition.Root;
                        succ = true;
                    }
                    break;
                case StatePosition.PropertyText:
                    _state.Position = StatePosition.PropertyElement;
                    DebugState();
                    succ = true;
                    break;
                case StatePosition.PropertyXml:
                    if (!_state.XmlFragmentNavigator.MoveToParent())
                        throw new InvalidOperationException(&quot;Could not move to parent in fragment.&quot;);
                    if (_state.XmlFragmentNavigator.NodeType == XPathNodeType.Root)
                    {
                        _state.XmlFragmentNavigator = null;
                        _state.Position = StatePosition.PropertyElement;
                        DebugState();
                    }
                    succ = true;
                    break;
                case StatePosition.Root:
                    succ = false;
                    break;
                default:
                    throw new InvalidOperationException(&quot;Invalid position.&quot;);
            }

            DebugReturn(succ);
            return succ;
        }

        private bool MoveToParentElement()
        {
            var p = _state.Parent;
            if (p != null)
            {
                _state = p;
                DebugState();
                return true;
            }

            return false;
        }

        /// &lt;summary&gt;
        /// Moves the XPathNavigator to the root node that the current node belongs to.
        /// &lt;/summary&gt;
        public override void MoveToRoot()
        {
            DebugEnter(&quot;MoveToRoot&quot;);

            while (_state.Parent != null)
                _state = _state.Parent;
            DebugState();

            DebugReturn();
        }

        /// &lt;summary&gt;
        /// Gets the base URI for the current node.
        /// &lt;/summary&gt;
        public override string BaseURI
        {
            get { return string.Empty; }
        }

        /// &lt;summary&gt;
        /// Gets the XmlNameTable of the XPathNavigator.
        /// &lt;/summary&gt;
        public override XmlNameTable NameTable
        {
            get { return _nameTable; }
        }

        /// &lt;summary&gt;
        /// Gets the namespace URI of the current node.
        /// &lt;/summary&gt;
        public override string NamespaceURI
        {
            get { return string.Empty; }
        }

        /// &lt;summary&gt;
        /// Gets the XPathNodeType of the current node.
        /// &lt;/summary&gt;
        public override XPathNodeType NodeType
        {
            get
            {
                DebugEnter(&quot;NodeType&quot;);
                XPathNodeType type;

                switch (_state.Position)
                {
                    case StatePosition.PropertyXml:
                        type = _state.XmlFragmentNavigator.NodeType;
                        break;
                    case StatePosition.Attribute:
                        type = XPathNodeType.Attribute;
                        break;
                    case StatePosition.Element:
                    case StatePosition.PropertyElement:
                        type = XPathNodeType.Element;
                        break;
                    case StatePosition.PropertyText:
                        type = XPathNodeType.Text;
                        break;
                    case StatePosition.Root:
                        type = XPathNodeType.Root;
                        break;
                    default:
                        throw new InvalidOperationException(&quot;Invalid position.&quot;);
                }

                DebugReturn(&quot;\&#39;{0}\&#39;&quot;, type);
                return type;
            }
        }

        /// &lt;summary&gt;
        /// Gets the namespace prefix associated with the current node.
        /// &lt;/summary&gt;
        public override string Prefix
        {
            get { return string.Empty; }
        }

        /// &lt;summary&gt;
        /// Gets the string value of the item.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Does not fully behave as per the specs, as we report empty value on content elements, and we start
        /// reporting values only on property elements. This is because, otherwise, we would dump the whole database
        /// and it probably does not make sense at Umbraco level.&lt;/remarks&gt;
        public override string Value
        {
            get
            {
                DebugEnter(&quot;Value&quot;);
                string value;

                switch (_state.Position)
                {
                    case StatePosition.PropertyXml:
                        value = _state.XmlFragmentNavigator.Value;
                        break;
                    case StatePosition.Attribute:
                    case StatePosition.PropertyText:
                    case StatePosition.PropertyElement:
                        if (_state.FieldIndex == -1)
                        {
                            value = _state.Content.Id.ToString(CultureInfo.InvariantCulture);
                        }
                        else
                        {
                            var valueForXPath = _state.Content.Value(_state.FieldIndex);

                            // value should be
                            // - an XPathNavigator over a non-empty XML fragment
                            // - a non-Xml-whitespace string
                            // - null
                            
                            var nav = valueForXPath as XPathNavigator;
                            var s = valueForXPath as string;
                            if (valueForXPath == null)
                            {
                                value = string.Empty;
                            }
                            else if (nav != null)
                            {
                                nav = nav.Clone(); // never use the one we got
                                value = nav.Value;
                            }
                            else if (s != null)
                            {
                                value = s;
                            }
                            else
                            {
                                throw new InvalidOperationException(&quot;XPathValue must be an XPathNavigator or a string.&quot;);
                            }
                        }
                        break;
                    case StatePosition.Element:
                    case StatePosition.Root:
                        value = string.Empty;
                        break;
                    default:
                        throw new InvalidOperationException(&quot;Invalid position.&quot;);
                }

                DebugReturn(&quot;\&quot;{0}\&quot;&quot;, value);
                return value;
            }
        }

        #region State management

        // the possible state positions
        internal enum StatePosition
        {
            Root,
            Element,
            Attribute,
            PropertyElement,
            PropertyText,
            PropertyXml
        };

        // gets the state
        // for unit tests only
        internal State InternalState { get { return _state; } }

        // represents the XPathNavigator state
        internal class State
        {
            public StatePosition Position { get; set; }

            // initialize a new state
            private State(StatePosition position)
            {
                Position = position;
                FieldIndex = -1;
            }

            // initialize a new state
            // used for creating the very first state
            // and also when moving to a child element
            public State(INavigableContent content, State parent, IList&lt;int&gt; siblings, int siblingIndex, StatePosition position)
                : this(position)
            {
                Content = content;
                Parent = parent;
                Siblings = siblings;
                SiblingIndex = siblingIndex;
            }

            // initialize a clone state
            private State(State other, bool recurse = false)
            {
                Position = other.Position;

                _content = other._content;
                SiblingIndex = other.SiblingIndex;
                Siblings = other.Siblings;
                FieldsCount = other.FieldsCount;
                FieldIndex = other.FieldIndex;

                if (Position == StatePosition.PropertyXml)
                    XmlFragmentNavigator = other.XmlFragmentNavigator.Clone();

                // NielsK did
                //Parent = other.Parent;
                // but that creates corrupted stacks of states when cloning
                // because clones share the parents : have to clone the whole
                // stack of states. Avoid recursion.

                if (recurse) return;

                var clone = this;
                while (other.Parent != null)
                {
                    clone.Parent = new State(other.Parent, true);
                    clone = clone.Parent;
                    other = other.Parent;
                }
            }

            public State Clone()
            {
                return new State(this);
            }

            // the parent state
            public State Parent { get; private set; }

            // the current content
            private INavigableContent _content;

            // the current content
            public INavigableContent Content
            {
                get
                {
                    return _content;
                }
                set
                {
                    FieldsCount = value == null ? 0 : value.Type.FieldTypes.Length;
                    _content = value;
                }
            }

            // the index of the current content within Siblings
            public int SiblingIndex { get; set; }

            // the list of content identifiers for all children of the current content&#39;s parent
            public IList&lt;int&gt; Siblings { get; set; }

            // the number of fields of the current content
            // properties include attributes and properties
            public int FieldsCount { get; private set; }

            // the index of the current field
            // index -1 means special attribute &quot;id&quot;
            public int FieldIndex { get; set; }

            // the current field type
            // beware, no check on the index
            public INavigableFieldType CurrentFieldType { get { return Content.Type.FieldTypes[FieldIndex];  } }

            // gets or sets the xml fragment navigator
            public XPathNavigator XmlFragmentNavigator { get; set; }

            // gets a value indicating whether this state is at the same position as another one.
            public bool IsSamePosition(State other)
            {
                return other.Position == Position 
                    &amp;&amp; (Position != StatePosition.PropertyXml || other.XmlFragmentNavigator.IsSamePosition(XmlFragmentNavigator))
                    &amp;&amp; other.Content == Content 
                    &amp;&amp; other.FieldIndex == FieldIndex;
            }
        }

        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[55,9,55,60,1],[56,9,56,10,1],[57,13,57,30,1],[58,13,58,61,1],[59,9,59,10,1],[69,15,69,27,1],[70,9,70,10,1],[71,13,71,42,1],[72,13,72,61,1],[73,13,73,91,1],[74,9,74,10,1],[84,15,84,27,1],[85,9,85,10,1],[86,13,86,36,1],[87,13,87,28,1],[88,9,88,10,1],[100,9,100,46,1],[102,9,102,60,1],[104,9,104,10,1],[105,13,105,24,1],[106,13,106,14,1],[107,17,107,32,1],[109,9,109,10,1],[114,9,114,10,1],[116,13,116,23,1],[117,13,117,29,1],[118,13,118,25,1],[119,13,119,54,1],[121,9,121,10,1],[125,9,125,10,1],[127,13,127,66,1],[129,9,129,10,1],[133,9,133,10,1],[136,13,136,35,1],[139,9,139,10,1],[143,9,143,10,1],[145,13,145,51,1],[147,9,147,10,1],[151,9,151,10,1],[153,13,153,41,1],[154,13,154,27,1],[154,28,154,39,1],[156,9,156,10,1],[160,9,160,10,1],[164,13,164,37,1],[167,21,169,86,1],[170,21,170,27,1],[172,21,173,51,1],[174,21,174,27,1],[176,21,177,112,1],[178,21,178,27,1],[180,21,181,81,1],[182,21,182,27,1],[184,21,185,81,1],[186,21,186,27,1],[188,21,188,43,1],[189,21,189,27,1],[191,21,191,78,0],[194,13,194,48,1],[196,9,196,10,1],[200,9,200,10,1],[203,13,203,94,1],[205,13,205,51,1],[209,9,209,10,1],[219,17,219,18,1],[219,19,219,41,1],[219,42,219,43,1],[227,9,227,10,1],[228,13,228,33,1],[229,13,229,83,1],[230,13,230,30,1],[231,13,231,45,1],[232,13,232,24,1],[233,9,233,10,1],[241,9,241,10,0],[242,13,242,44,0],[245,13,245,32,0],[247,13,247,49,0],[248,13,248,14,0],[249,17,249,84,0],[250,13,250,14,0],[251,18,251,54,0],[252,13,252,14,0],[253,17,253,54,0],[254,17,254,37,0],[255,17,255,18,0],[256,21,256,83,0],[257,17,257,18,0],[258,13,258,14,0],[260,13,260,45,0],[262,13,262,31,0],[263,13,263,14,0],[264,17,264,76,0],[265,17,265,36,0],[266,17,266,49,0],[267,13,267,14,0],[269,13,269,14,0],[270,17,270,39,0],[271,13,271,14,0],[273,13,273,26,0],[274,9,274,10,0],[282,13,282,14,1],[283,17,283,46,1],[286,17,286,41,1],[289,25,290,78,1],[291,25,291,31,1],[297,25,297,83,1],[298,25,298,31,1],[300,25,300,78,1],[301,25,301,31,1],[305,25,305,80,0],[307,25,307,82,0],[310,17,310,38,1],[311,17,311,32,1],[312,13,312,14,1],[321,9,321,10,0],[322,13,322,42,0],[325,13,325,37,0],[328,21,328,78,0],[329,21,329,27,0],[335,21,335,59,0],[336,21,336,111,0],[337,21,337,27,0],[339,21,339,78,0],[342,13,342,33,0],[343,13,343,27,0],[344,9,344,10,0],[352,13,352,14,1],[353,17,353,36,1],[356,17,356,41,1],[359,25,359,65,1],[360,25,360,31,1],[363,25,363,94,1],[364,25,364,31,1],[366,25,366,57,1],[367,25,367,31,1],[369,25,369,45,1],[370,25,370,31,1],[372,25,372,45,1],[373,25,373,31,1],[375,25,375,82,0],[378,17,378,46,1],[379,17,379,29,1],[380,13,380,14,1],[389,13,389,14,1],[390,17,390,41,1],[391,17,391,33,1],[392,17,392,46,1],[393,17,393,29,1],[394,13,394,14,1],[404,9,404,10,1],[405,13,405,34,1],[407,13,407,51,1],[408,13,408,30,1],[410,13,410,59,1],[411,13,411,14,1],[412,17,412,47,1],[413,17,413,30,1],[414,17,414,29,1],[415,13,415,14,1],[417,13,417,31,1],[418,13,418,25,1],[419,9,419,10,1],[427,9,427,10,1],[428,13,428,48,1],[431,13,431,37,1],[434,21,434,79,1],[435,21,435,27,1],[437,21,437,44,1],[438,21,438,63,1],[439,21,439,34,1],[440,21,440,33,1],[441,21,441,27,1],[446,21,446,34,1],[447,21,447,27,1],[449,21,449,78,0],[452,13,452,31,1],[453,13,453,25,1],[454,9,454,10,1],[462,9,462,10,1],[463,13,463,44,1],[466,13,466,37,1],[469,21,469,75,1],[470,21,470,27,1],[473,21,473,34,1],[474,21,474,27,1],[476,21,476,70,1],[477,21,477,65,1],[478,21,478,22,1],[479,25,479,73,1],[480,25,480,64,1],[481,25,481,38,1],[482,25,482,37,1],[483,21,483,22,1],[484,26,484,59,1],[485,21,485,27,1],[487,21,487,55,1],[488,21,488,27,1],[490,21,490,61,1],[491,21,491,34,1],[492,21,492,33,1],[493,21,493,27,1],[495,21,495,78,0],[498,13,498,31,1],[499,13,499,25,1],[500,9,500,10,1],[503,9,503,10,1],[504,13,504,52,1],[506,13,506,56,1],[507,13,507,14,1],[511,17,511,51,1],[511,51,511,66,1],[511,66,511,88,1],[511,88,511,97,1],[511,97,511,99,1],[511,17,511,99,1],[512,17,512,35,1],[513,17,513,18,1],[514,21,514,61,1],[515,21,515,44,1],[516,21,516,91,1],[517,21,517,34,1],[518,21,518,33,1],[520,13,520,14,0],[522,13,522,26,1],[523,9,523,10,1],[526,9,526,10,1],[527,13,527,73,1],[534,13,534,55,1],[535,13,535,29,1],[536,13,536,14,1],[537,17,537,35,1],[538,17,538,40,1],[539,17,539,51,1],[540,17,540,61,1],[541,17,541,30,1],[542,17,542,29,1],[545,13,545,39,1],[546,17,546,30,1],[548,13,548,41,1],[549,13,549,14,1],[550,17,550,62,1],[551,17,551,30,1],[552,17,552,29,1],[555,13,555,102,0],[556,9,556,10,1],[565,9,565,10,1],[566,13,566,48,1],[567,13,567,32,1],[568,13,568,26,1],[569,9,569,10,1],[578,9,578,10,0],[579,13,579,47,0],[580,13,580,32,0],[581,13,581,26,0],[582,9,582,10,0],[591,9,591,10,1],[592,13,592,36,1],[593,13,593,30,1],[600,13,600,53,1],[601,13,601,14,1],[602,17,602,105,1],[603,17,603,29,1],[604,13,604,14,1],[605,18,605,54,1],[606,13,606,14,1],[607,17,607,54,1],[608,17,608,37,1],[609,17,609,18,1],[610,21,610,40,1],[611,21,611,49,1],[612,25,612,46,0],[613,21,613,54,1],[615,21,615,60,1],[616,21,616,77,1],[617,21,617,22,1],[618,25,618,41,1],[619,25,619,65,1],[620,21,620,22,1],[621,21,621,41,1],[622,21,622,22,1],[623,25,623,153,1],[624,25,624,48,1],[625,25,625,26,1],[626,29,626,151,1],[627,29,627,69,1],[628,25,628,26,1],[629,25,629,38,1],[630,25,630,37,1],[631,21,631,22,1],[632,17,632,18,1],[633,13,633,14,1],[635,13,635,31,1],[636,13,636,25,1],[637,9,637,10,1],[646,9,646,10,1],[647,13,647,38,1],[650,13,650,37,1],[653,21,653,69,1],[654,21,654,27,1],[656,21,656,34,1],[657,21,657,103,1],[658,21,658,22,1],[662,25,662,88,1],[663,25,663,42,1],[663,43,663,52,0],[665,25,665,47,1],[666,25,666,38,1],[667,25,667,37,1],[668,25,668,31,1],[670,21,670,27,1],[672,21,672,69,1],[673,21,673,22,1],[676,25,676,58,1],[677,21,677,22,1],[679,21,679,22,1],[680,25,680,45,1],[681,25,681,38,1],[682,25,682,37,1],[683,21,683,22,1],[684,21,684,27,1],[688,21,688,34,1],[689,21,689,27,1],[691,21,691,78,0],[694,13,694,31,1],[695,13,695,25,1],[696,9,696,10,1],[705,9,705,10,0],[706,13,706,42,0],[709,13,709,37,0],[712,21,712,73,0],[713,21,713,27,0],[715,21,715,34,0],[716,21,716,79,0],[717,21,717,22,0],[721,25,721,91,0],[722,25,722,45,0],[722,46,722,55,0],[724,25,724,50,0],[725,25,725,38,0],[726,25,726,37,0],[727,25,727,31,0],[729,21,729,115,0],[730,21,730,22,0],[732,25,732,51,0],[733,25,733,26,0],[734,29,734,72,0],[735,29,735,42,0],[736,29,736,41,0],[737,25,737,26,0],[738,21,738,22,0],[739,21,739,27,0],[741,21,741,34,0],[742,21,742,65,0],[743,21,743,22,0],[744,25,744,45,0],[745,25,745,38,0],[746,25,746,37,0],[747,21,747,22,0],[748,21,748,27,0],[752,21,752,34,0],[753,21,753,27,0],[755,21,755,78,0],[758,13,758,31,0],[759,13,759,25,0],[760,9,760,10,0],[768,9,768,10,1],[769,13,769,47,1],[772,13,772,37,1],[775,21,775,78,1],[776,21,776,27,1],[778,21,778,66,1],[779,25,779,38,1],[781,21,781,22,1],[782,25,782,45,1],[783,25,783,38,1],[784,25,784,37,1],[785,21,785,22,1],[786,21,786,27,1],[791,21,791,34,0],[792,21,792,27,0],[794,21,794,78,0],[797,13,797,31,1],[798,13,798,25,1],[799,9,799,10,1],[807,9,807,10,1],[808,13,808,40,1],[811,13,811,37,1],[815,21,815,61,1],[816,21,816,44,1],[817,21,817,34,1],[818,21,818,33,1],[819,21,819,27,1],[821,21,821,50,1],[822,21,822,31,1],[823,21,823,22,1],[824,25,824,62,1],[825,25,825,37,1],[826,21,826,22,1],[827,21,827,27,1],[829,21,829,69,1],[830,21,830,34,1],[831,21,831,33,1],[832,21,832,27,1],[834,21,834,69,1],[835,25,835,102,0],[836,21,836,84,1],[837,21,837,22,1],[838,25,838,60,1],[839,25,839,73,1],[840,25,840,38,1],[841,21,841,22,1],[842,21,842,33,1],[843,21,843,27,1],[845,21,845,34,1],[846,21,846,27,1],[848,21,848,78,0],[851,13,851,31,1],[852,13,852,25,1],[853,9,853,10,1],[856,9,856,10,1],[857,13,857,35,1],[858,13,858,27,1],[859,13,859,14,1],[860,17,860,28,1],[861,17,861,30,1],[862,17,862,29,1],[865,13,865,26,1],[866,9,866,10,1],[872,9,872,10,1],[873,13,873,38,1],[875,13,875,42,1],[876,17,876,40,1],[877,13,877,26,1],[879,13,879,27,1],[880,9,880,10,1],[887,17,887,18,0],[887,19,887,39,0],[887,40,887,41,0],[895,17,895,18,0],[895,19,895,37,0],[895,38,895,39,0],[903,17,903,18,1],[903,19,903,39,1],[903,40,903,41,1],[912,13,912,14,1],[913,17,913,40,1],[916,17,916,41,1],[919,25,919,69,1],[920,25,920,31,1],[922,25,922,56,1],[923,25,923,31,1],[926,25,926,54,1],[927,25,927,31,1],[929,25,929,51,1],[930,25,930,31,1],[932,25,932,51,1],[933,25,933,31,1],[935,25,935,82,0],[938,17,938,46,1],[939,17,939,29,1],[940,13,940,14,1],[948,17,948,18,1],[948,19,948,39,1],[948,40,948,41,1],[960,13,960,14,1],[961,17,961,37,1],[964,17,964,41,1],[967,25,967,67,1],[968,25,968,31,1],[972,25,972,53,1],[973,25,973,26,1],[974,29,974,94,1],[975,25,975,26,1],[977,25,977,26,1],[978,29,978,89,1],[985,29,985,71,1],[986,29,986,61,1],[987,29,987,55,1],[988,29,988,30,1],[989,33,989,54,1],[990,29,990,30,1],[991,34,991,50,1],[992,29,992,30,1],[993,33,993,51,1],[994,33,994,51,1],[995,29,995,30,1],[996,34,996,48,1],[997,29,997,30,1],[998,33,998,43,1],[999,29,999,30,1],[1001,29,1001,30,0],[1002,33,1002,122,0],[1004,25,1004,26,1],[1005,25,1005,31,1],[1008,25,1008,46,1],[1009,25,1009,31,1],[1011,25,1011,82,0],[1014,17,1014,47,1],[1015,17,1015,30,1],[1016,13,1016,14,1],[1034,44,1034,45,1],[1034,46,1034,60,1],[1034,61,1034,62,1],[1039,45,1039,49,1],[1039,50,1039,54,1],[1042,13,1042,50,1],[1043,13,1043,14,1],[1044,17,1044,37,1],[1045,17,1045,33,1],[1046,13,1046,14,1],[1052,19,1052,33,1],[1053,13,1053,14,1],[1054,17,1054,35,1],[1055,17,1055,33,1],[1056,17,1056,37,1],[1057,17,1057,45,1],[1058,13,1058,14,1],[1061,13,1061,61,1],[1062,13,1062,14,1],[1063,17,1063,43,1],[1065,17,1065,43,1],[1066,17,1066,51,1],[1067,17,1067,43,1],[1068,17,1068,49,1],[1069,17,1069,47,1],[1071,17,1071,59,1],[1072,21,1072,79,1],[1080,17,1080,29,1],[1080,30,1080,37,1],[1082,17,1082,34,1],[1083,17,1083,45,1],[1084,17,1084,18,1],[1085,21,1085,66,1],[1086,21,1086,42,1],[1087,21,1087,42,1],[1088,17,1088,18,1],[1089,13,1089,14,1],[1092,13,1092,14,1],[1093,17,1093,40,1],[1094,13,1094,14,1],[1097,35,1097,39,1],[1097,40,1097,52,1],[1106,17,1106,18,1],[1107,21,1107,37,1],[1108,17,1108,18,1],[1110,17,1110,18,1],[1111,21,1111,84,1],[1112,21,1112,38,1],[1113,17,1113,18,1],[1117,39,1117,43,1],[1117,44,1117,48,1],[1120,42,1120,46,1],[1120,47,1120,51,1],[1124,38,1124,42,1],[1124,43,1124,55,1],[1128,37,1128,41,1],[1128,42,1128,46,1],[1132,63,1132,64,1],[1132,65,1132,108,1],[1132,110,1132,111,1],[1135,58,1135,62,1],[1135,63,1135,67,1],[1139,13,1139,14,0],[1140,17,1143,55,0],[1144,13,1144,14,0]]);
    </script>
  </body>
</html>