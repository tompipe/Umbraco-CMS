<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Tests\Plugins\PluginManagerTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using Moq;
using NUnit.Framework;
using SqlCE4Umbraco;
using umbraco;
using umbraco.businesslogic;
using umbraco.cms.businesslogic;
using Umbraco.Core;
using Umbraco.Core.Cache;
using Umbraco.Core.IO;
using Umbraco.Core.Logging;
using Umbraco.Core.Profiling;
using Umbraco.Core.PropertyEditors;
using umbraco.DataLayer;
using umbraco.editorControls;
using umbraco.MacroEngines;
using umbraco.uicontrols;
using Umbraco.Web;
using Umbraco.Web.PropertyEditors;

namespace Umbraco.Tests.Plugins
{

    [TestFixture]
    public class PluginManagerTests
    {
        private PluginManager _manager;
        [SetUp]
        public void Initialize()
        {
            //this ensures its reset
            _manager = new PluginManager(new ActivatorServiceProvider(), new NullCacheProvider(), 
                new ProfilingLogger(Mock.Of&lt;ILogger&gt;(), Mock.Of&lt;IProfiler&gt;()));

            //for testing, we&#39;ll specify which assemblies are scanned for the PluginTypeResolver
            //TODO: Should probably update this so it only searches this assembly and add custom types to be found
            _manager.AssembliesToScan = new[]
			    {
			        this.GetType().Assembly, 
			        typeof(ApplicationStartupHandler).Assembly,
			        typeof(SqlCEHelper).Assembly,
			        typeof(CMSNode).Assembly,
			        typeof(System.Guid).Assembly,
			        typeof(NUnit.Framework.Assert).Assembly,
			        typeof(Microsoft.CSharp.CSharpCodeProvider).Assembly,
			        typeof(System.Xml.NameTable).Assembly,
			        typeof(System.Configuration.GenericEnumConverter).Assembly,
			        typeof(System.Web.SiteMap).Assembly,
			        typeof(TabPage).Assembly,
			        typeof(System.Web.Mvc.ActionResult).Assembly,
			        typeof(TypeFinder).Assembly,
			        typeof(ISqlHelper).Assembly,
			        typeof(ICultureDictionary).Assembly,
					typeof(UmbracoContext).Assembly,
					typeof(BaseDataType).Assembly
			    };
        }

        [TearDown]
        public void TearDown()
        {
            _manager = null;
        }

        private DirectoryInfo PrepareFolder()
        {
            var assDir = new FileInfo(Assembly.GetExecutingAssembly().Location).Directory;
            var dir = Directory.CreateDirectory(Path.Combine(assDir.FullName, &quot;PluginManager&quot;, Guid.NewGuid().ToString(&quot;N&quot;)));
            foreach (var f in dir.GetFiles())
            {
                f.Delete();
            }
            return dir;
        }

        //[Test]
        //public void Scan_Vs_Load_Benchmark()
        //{
        //	var pluginManager = new PluginManager(false);
        //	var watch = new Stopwatch();
        //	watch.Start();
        //	for (var i = 0; i &lt; 1000; i++)
        //	{
        //		var type2 = Type.GetType(&quot;umbraco.macroCacheRefresh, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;);
        //		var type3 = Type.GetType(&quot;umbraco.templateCacheRefresh, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;);
        //		var type4 = Type.GetType(&quot;umbraco.presentation.cache.MediaLibraryRefreshers, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;);
        //		var type5 = Type.GetType(&quot;umbraco.presentation.cache.pageRefresher, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;);
        //	}
        //	watch.Stop();
        //	Debug.WriteLine(&quot;TOTAL TIME (1st round): &quot; + watch.ElapsedMilliseconds);
        //	watch.Start();
        //	for (var i = 0; i &lt; 1000; i++)
        //	{
        //		var type2 = BuildManager.GetType(&quot;umbraco.macroCacheRefresh, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;, true);
        //		var type3 = BuildManager.GetType(&quot;umbraco.templateCacheRefresh, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;, true);
        //		var type4 = BuildManager.GetType(&quot;umbraco.presentation.cache.MediaLibraryRefreshers, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;, true);
        //		var type5 = BuildManager.GetType(&quot;umbraco.presentation.cache.pageRefresher, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;, true);
        //	}
        //	watch.Stop();
        //	Debug.WriteLine(&quot;TOTAL TIME (1st round): &quot; + watch.ElapsedMilliseconds);
        //	watch.Reset();
        //	watch.Start();
        //	for (var i = 0; i &lt; 1000; i++)
        //	{
        //		var refreshers = pluginManager.ResolveTypes&lt;ICacheRefresher&gt;(false);
        //	}
        //	watch.Stop();
        //	Debug.WriteLine(&quot;TOTAL TIME (2nd round): &quot; + watch.ElapsedMilliseconds);
        //}

        ////NOTE: This test shows that Type.GetType is 100% faster than Assembly.Load(..).GetType(...) so we&#39;ll use that :)
        //[Test]
        //public void Load_Type_Benchmark()
        //{
        //	var watch = new Stopwatch();
        //	watch.Start();
        //	for (var i = 0; i &lt; 1000; i++)
        //	{
        //		var type2 = Type.GetType(&quot;umbraco.macroCacheRefresh, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;);
        //		var type3 = Type.GetType(&quot;umbraco.templateCacheRefresh, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;);
        //		var type4 = Type.GetType(&quot;umbraco.presentation.cache.MediaLibraryRefreshers, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;);
        //		var type5 = Type.GetType(&quot;umbraco.presentation.cache.pageRefresher, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;);
        //	}
        //	watch.Stop();
        //	Debug.WriteLine(&quot;TOTAL TIME (1st round): &quot; + watch.ElapsedMilliseconds);
        //	watch.Reset();
        //	watch.Start();
        //	for (var i = 0; i &lt; 1000; i++)
        //	{
        //		var type2 = Assembly.Load(&quot;umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;)
        //			.GetType(&quot;umbraco.macroCacheRefresh&quot;);
        //		var type3 = Assembly.Load(&quot;umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;)
        //			.GetType(&quot;umbraco.templateCacheRefresh&quot;);
        //		var type4 = Assembly.Load(&quot;umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;)
        //			.GetType(&quot;umbraco.presentation.cache.MediaLibraryRefreshers&quot;);
        //		var type5 = Assembly.Load(&quot;umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;)
        //			.GetType(&quot;umbraco.presentation.cache.pageRefresher&quot;);
        //	}
        //	watch.Stop();
        //	Debug.WriteLine(&quot;TOTAL TIME (2nd round): &quot; + watch.ElapsedMilliseconds);
        //	watch.Reset();
        //	watch.Start();
        //	for (var i = 0; i &lt; 1000; i++)
        //	{
        //		var type2 = BuildManager.GetType(&quot;umbraco.macroCacheRefresh, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;, true);
        //		var type3 = BuildManager.GetType(&quot;umbraco.templateCacheRefresh, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;, true);
        //		var type4 = BuildManager.GetType(&quot;umbraco.presentation.cache.MediaLibraryRefreshers, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;, true);
        //		var type5 = BuildManager.GetType(&quot;umbraco.presentation.cache.pageRefresher, umbraco, Version=1.0.4698.259, Culture=neutral, PublicKeyToken=null&quot;, true);
        //	}
        //	watch.Stop();
        //	Debug.WriteLine(&quot;TOTAL TIME (1st round): &quot; + watch.ElapsedMilliseconds);
        //}

        [Test]
        public void Detect_Legacy_Plugin_File_List()
        {
            var tempFolder = IOHelper.MapPath(&quot;~/App_Data/TEMP/PluginCache&quot;);
            
            var filePath= Path.Combine(tempFolder, string.Format(&quot;umbraco-plugins.{0}.list&quot;, NetworkHelper.FileSafeMachineName));

            File.WriteAllText(filePath, @&quot;&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;utf-8&quot;&quot;?&gt;
&lt;plugins&gt;
&lt;baseType type=&quot;&quot;umbraco.interfaces.ICacheRefresher&quot;&quot;&gt;
&lt;add type=&quot;&quot;umbraco.macroCacheRefresh, umbraco, Version=6.0.0.0, Culture=neutral, PublicKeyToken=null&quot;&quot; /&gt;
&lt;/baseType&gt;
&lt;/plugins&gt;&quot;);
            
            Assert.IsTrue(_manager.DetectLegacyPluginListFile());

            File.Delete(filePath);

            //now create a valid one
            File.WriteAllText(filePath, @&quot;&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;utf-8&quot;&quot;?&gt;
&lt;plugins&gt;
&lt;baseType type=&quot;&quot;umbraco.interfaces.ICacheRefresher&quot;&quot; resolutionType=&quot;&quot;FindAllTypes&quot;&quot;&gt;
&lt;add type=&quot;&quot;umbraco.macroCacheRefresh, umbraco, Version=6.0.0.0, Culture=neutral, PublicKeyToken=null&quot;&quot; /&gt;
&lt;/baseType&gt;
&lt;/plugins&gt;&quot;);

            Assert.IsFalse(_manager.DetectLegacyPluginListFile());
        }

        [Test]
        public void Create_Cached_Plugin_File()
        {
            var types = new[] { typeof(PluginManager), typeof(PluginManagerTests), typeof(UmbracoContext) };

            //yes this is silly, none of these types inherit from string, but this is just to test the xml file format
            _manager.UpdateCachedPluginsFile&lt;string&gt;(types, PluginManager.TypeResolutionKind.FindAllTypes);

            var plugins = _manager.TryGetCachedPluginsFromFile&lt;string&gt;(PluginManager.TypeResolutionKind.FindAllTypes);
            var diffType = _manager.TryGetCachedPluginsFromFile&lt;string&gt;(PluginManager.TypeResolutionKind.FindAttributedTypes);

            Assert.IsTrue(plugins.Success);
            //this will be false since there is no cache of that type resolution kind
            Assert.IsFalse(diffType.Success);

            Assert.AreEqual(3, plugins.Result.Count());
            var shouldContain = types.Select(x =&gt; x.AssemblyQualifiedName);
            //ensure they are all found
            Assert.IsTrue(plugins.Result.ContainsAll(shouldContain));
        }

        [Test]
        public void PluginHash_From_String()
        {
            var s = &quot;hello my name is someone&quot;.GetHashCode().ToString(&quot;x&quot;, CultureInfo.InvariantCulture);
            var output = PluginManager.ConvertPluginsHashFromHex(s);
            Assert.AreNotEqual(0, output);
        }

        [Test]
        public void Get_Plugins_Hash()
        {
            //Arrange
            var dir = PrepareFolder();
            var d1 = dir.CreateSubdirectory(&quot;1&quot;);
            var d2 = dir.CreateSubdirectory(&quot;2&quot;);
            var d3 = dir.CreateSubdirectory(&quot;3&quot;);
            var d4 = dir.CreateSubdirectory(&quot;4&quot;);
            var f1 = new FileInfo(Path.Combine(d1.FullName, &quot;test1.dll&quot;));
            var f2 = new FileInfo(Path.Combine(d1.FullName, &quot;test2.dll&quot;));
            var f3 = new FileInfo(Path.Combine(d2.FullName, &quot;test1.dll&quot;));
            var f4 = new FileInfo(Path.Combine(d2.FullName, &quot;test2.dll&quot;));
            var f5 = new FileInfo(Path.Combine(d3.FullName, &quot;test1.dll&quot;));
            var f6 = new FileInfo(Path.Combine(d3.FullName, &quot;test2.dll&quot;));
            var f7 = new FileInfo(Path.Combine(d4.FullName, &quot;test1.dll&quot;));
            f1.CreateText().Close();
            f2.CreateText().Close();
            f3.CreateText().Close();
            f4.CreateText().Close();
            f5.CreateText().Close();
            f6.CreateText().Close();
            f7.CreateText().Close();
            var list1 = new[] { f1, f2, f3, f4, f5, f6 };
            var list2 = new[] { f1, f3, f5 };
            var list3 = new[] { f1, f3, f5, f7 };
            
            //Act
            var hash1 = PluginManager.GetFileHash(list1, new ProfilingLogger(Mock.Of&lt;ILogger&gt;(), Mock.Of&lt;IProfiler&gt;()));
            var hash2 = PluginManager.GetFileHash(list2, new ProfilingLogger(Mock.Of&lt;ILogger&gt;(), Mock.Of&lt;IProfiler&gt;()));
            var hash3 = PluginManager.GetFileHash(list3, new ProfilingLogger(Mock.Of&lt;ILogger&gt;(), Mock.Of&lt;IProfiler&gt;()));

            //Assert
            Assert.AreNotEqual(hash1, hash2);
            Assert.AreNotEqual(hash1, hash3);
            Assert.AreNotEqual(hash2, hash3);

            Assert.AreEqual(hash1, PluginManager.GetFileHash(list1, new ProfilingLogger(Mock.Of&lt;ILogger&gt;(), Mock.Of&lt;IProfiler&gt;())));
        }

        [Test]
        public void Ensure_Only_One_Type_List_Created()
        {
            var foundTypes1 = _manager.ResolveFindMeTypes();
            var foundTypes2 = _manager.ResolveFindMeTypes();
            Assert.AreEqual(1,
                            _manager.GetTypeLists()
                                .Count(x =&gt; x.IsTypeList&lt;IFindMe&gt;(PluginManager.TypeResolutionKind.FindAllTypes)));
        }

        [Test]
        public void Resolves_Assigned_Mappers()
        {
            var foundTypes1 = _manager.ResolveAssignedMapperTypes();
            Assert.AreEqual(28, foundTypes1.Count());
        }

        [Test]
        public void Resolves_Types()
        {
            var foundTypes1 = _manager.ResolveFindMeTypes();
            Assert.AreEqual(2, foundTypes1.Count());
        }

        [Test]
        public void Resolves_Attributed_Trees()
        {
            var trees = _manager.ResolveAttributedTrees();
            // commit 6c5e35ec2cbfa31be6790d1228e0c2faf5f55bc8 brings the count down to 14
            Assert.AreEqual(12, trees.Count());
        }

        [Test]
        public void Resolves_Actions()
        {
            var actions = _manager.ResolveActions();
            Assert.AreEqual(37, actions.Count());
        }

        [Test]
        public void Resolves_Trees()
        {
            var trees = _manager.ResolveTrees();
            Assert.AreEqual(39, trees.Count());
        }

        [Test]
        public void Resolves_Applications()
        {
            var apps = _manager.ResolveApplications();
            Assert.AreEqual(7, apps.Count());
        }

        [Test]
        public void Resolves_DataTypes()
        {
            var types = _manager.ResolveDataTypes();
            Assert.AreEqual(35, types.Count());
        }

        [Test]
        public void Resolves_RazorDataTypeModels()
        {
            var types = _manager.ResolveRazorDataTypeModels();
            Assert.AreEqual(2, types.Count());
        }

        [Test]
        public void Resolves_RestExtensions()
        {
            var types = _manager.ResolveRestExtensions();
            Assert.AreEqual(3, types.Count());
        }

        [Test]
        public void Resolves_XsltExtensions()
        {
            var types = _manager.ResolveXsltExtensions();
            Assert.AreEqual(3, types.Count());
        }

        /// &lt;summary&gt;
        /// This demonstrates this issue: http://issues.umbraco.org/issue/U4-3505 - the TypeList was returning a list of assignable types
        /// not explicit types which is sort of ideal but is confusing so we&#39;ll do it the less confusing way.
        /// &lt;/summary&gt;
        [Test]
        public void TypeList_Resolves_Explicit_Types()
        {
            var types = new HashSet&lt;PluginManager.TypeList&gt;();

            var propEditors = new PluginManager.TypeList&lt;PropertyEditor&gt;(PluginManager.TypeResolutionKind.FindAllTypes);
            propEditors.AddType(typeof(LabelPropertyEditor));
            types.Add(propEditors);

            var found = types.SingleOrDefault(x =&gt; x.IsTypeList&lt;PropertyEditor&gt;(PluginManager.TypeResolutionKind.FindAllTypes));

            Assert.IsNotNull(found);

            //This should not find a type list of this type
            var shouldNotFind = types.SingleOrDefault(x =&gt; x.IsTypeList&lt;IParameterEditor&gt;(PluginManager.TypeResolutionKind.FindAllTypes));

            Assert.IsNull(shouldNotFind);
        }
     
        [XsltExtension(&quot;Blah.Blah&quot;)]
        public class MyXsltExtension
        {

        }


        [Umbraco.Web.BaseRest.RestExtension(&quot;Blah&quot;)]
        public class MyRestExtesion
        {

        }

        public interface IFindMe
        {

        }

        public class FindMe1 : IFindMe
        {

        }

        public class FindMe2 : IFindMe
        {

        }

    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[35,9,35,10,1],[37,13,38,80,1],[42,13,61,10,1],[62,9,62,10,1],[66,9,66,10,1],[67,13,67,29,1],[68,9,68,10,1],[71,9,71,10,1],[72,13,72,91,1],[73,13,73,127,1],[74,13,74,20,1],[74,22,74,27,0],[74,28,74,30,1],[74,31,74,45,1],[75,13,75,14,0],[76,17,76,28,0],[77,13,77,14,0],[78,13,78,24,1],[79,9,79,10,1],[161,9,161,10,1],[162,13,162,78,1],[164,13,164,130,1],[166,13,171,14,1],[173,13,173,66,1],[175,13,175,35,1],[178,13,183,14,1],[185,13,185,67,1],[186,9,186,10,1],[190,9,190,10,1],[191,13,191,109,1],[194,13,194,108,1],[196,13,196,119,1],[197,13,197,127,1],[199,13,199,44,1],[201,13,201,46,1],[203,13,203,56,1],[204,13,204,51,1],[204,51,204,74,1],[204,74,204,76,1],[204,13,204,76,1],[206,13,206,70,1],[207,9,207,10,1],[211,9,211,10,1],[212,13,212,106,1],[213,13,213,69,1],[214,13,214,43,1],[215,9,215,10,1],[219,9,219,10,1],[221,13,221,39,1],[222,13,222,50,1],[223,13,223,50,1],[224,13,224,50,1],[225,13,225,50,1],[226,13,226,75,1],[227,13,227,75,1],[228,13,228,75,1],[229,13,229,75,1],[230,13,230,75,1],[231,13,231,75,1],[232,13,232,75,1],[233,13,233,37,1],[234,13,234,37,1],[235,13,235,37,1],[236,13,236,37,1],[237,13,237,37,1],[238,13,238,37,1],[239,13,239,37,1],[240,13,240,58,1],[241,13,241,46,1],[242,13,242,50,1],[245,13,245,121,1],[246,13,246,121,1],[247,13,247,121,1],[250,13,250,46,1],[251,13,251,46,1],[252,13,252,46,1],[254,13,254,133,1],[255,9,255,10,1],[259,9,259,10,1],[260,13,260,61,1],[261,13,261,61,1],[262,13,264,45,1],[264,45,264,113,1],[264,113,264,116,1],[262,13,264,116,1],[265,9,265,10,1],[269,9,269,10,1],[270,13,270,69,1],[271,13,271,54,1],[272,9,272,10,1],[276,9,276,10,1],[277,13,277,61,1],[278,13,278,53,1],[279,9,279,10,1],[283,9,283,10,1],[284,13,284,59,1],[286,13,286,48,1],[287,9,287,10,1],[291,9,291,10,1],[292,13,292,53,1],[293,13,293,50,1],[294,9,294,10,1],[298,9,298,10,1],[299,13,299,49,1],[300,13,300,48,1],[301,9,301,10,1],[305,9,305,10,1],[306,13,306,55,1],[307,13,307,46,1],[308,9,308,10,1],[312,9,312,10,1],[313,13,313,53,1],[314,13,314,48,1],[315,9,315,10,1],[319,9,319,10,1],[320,13,320,63,1],[321,13,321,47,1],[322,9,322,10,1],[326,9,326,10,1],[327,13,327,58,1],[328,13,328,47,1],[329,9,329,10,1],[333,9,333,10,1],[334,13,334,58,1],[335,13,335,47,1],[336,9,336,10,1],[344,9,344,10,1],[345,13,345,63,1],[347,13,347,121,1],[348,13,348,62,1],[349,13,349,36,1],[351,13,351,52,1],[351,52,351,127,1],[351,127,351,129,1],[351,13,351,129,1],[353,13,353,37,1],[356,13,356,60,1],[356,60,356,137,1],[356,137,356,139,1],[356,13,356,139,1],[358,13,358,42,1],[359,9,359,10,1]]);
    </script>
  </body>
</html>