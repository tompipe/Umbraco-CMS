<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Tests\Plugins\TypeFinderTests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Compilation;
using NUnit.Framework;
using SqlCE4Umbraco;
using umbraco;
using umbraco.businesslogic;
using umbraco.cms.businesslogic;
using Umbraco.Core;
using Umbraco.Core.IO;
using umbraco.DataLayer;
using umbraco.editorControls.tags;
using umbraco.interfaces;
using umbraco.MacroEngines;
using umbraco.uicontrols;
using Umbraco.Web.BaseRest;

namespace Umbraco.Tests.Plugins
{
    
    /// &lt;summary&gt;
	/// Tests for typefinder
	/// &lt;/summary&gt;
	[TestFixture]	
	public class TypeFinderTests
	{
		/// &lt;summary&gt;
		/// List of assemblies to scan
		/// &lt;/summary&gt;
		private Assembly[] _assemblies;

		[SetUp]
		public void Initialize()
		{
		    _assemblies = new[]
			    {
			        this.GetType().Assembly, 
			        typeof(ApplicationStartupHandler).Assembly,
			        typeof(SqlCEHelper).Assembly,
			        typeof(CMSNode).Assembly,
			        typeof(System.Guid).Assembly,
			        typeof(NUnit.Framework.Assert).Assembly,
			        typeof(Microsoft.CSharp.CSharpCodeProvider).Assembly,
			        typeof(System.Xml.NameTable).Assembly,
			        typeof(System.Configuration.GenericEnumConverter).Assembly,
			        typeof(System.Web.SiteMap).Assembly,
			        typeof(TabPage).Assembly,
			        typeof(System.Web.Mvc.ActionResult).Assembly,
			        typeof(TypeFinder).Assembly,
			        typeof(ISqlHelper).Assembly,
			        typeof(ICultureDictionary).Assembly,
                    typeof(Tag).Assembly,
                    typeof(global::UmbracoExamine.BaseUmbracoIndexer).Assembly
			    };

		}

        [Test]
		public void Find_Class_Of_Type_With_Attribute()
		{

			var typesFound = TypeFinder.FindClassesOfTypeWithAttribute&lt;TestEditor, MyTestAttribute&gt;(_assemblies);
			Assert.AreEqual(2, typesFound.Count());
		}

        [Test]
        public void Find_Classes_Of_Type()
        {
            var typesFound = TypeFinder.FindClassesOfType&lt;IApplicationStartupHandler&gt;(_assemblies);            
            var originalTypesFound = TypeFinderOriginal.FindClassesOfType&lt;IApplicationStartupHandler&gt;(_assemblies);

            Assert.AreEqual(originalTypesFound.Count(), typesFound.Count());
            Assert.AreEqual(9, typesFound.Count());
            Assert.AreEqual(9, originalTypesFound.Count());
        }

        [Test]
        public void Find_Classes_With_Attribute()
        {
            var typesFound = TypeFinder.FindClassesWithAttribute&lt;RestExtensionAttribute&gt;(_assemblies);
            Assert.AreEqual(1, typesFound.Count());
        }

        [Ignore]
        [Test]
        public void Benchmark_Original_Finder()
        {
            using (DisposableTimer.TraceDuration&lt;TypeFinderTests&gt;(&quot;Starting test&quot;, &quot;Finished test&quot;))
            {
                using (DisposableTimer.TraceDuration&lt;TypeFinderTests&gt;(&quot;Starting FindClassesOfType&quot;, &quot;Finished FindClassesOfType&quot;))
                {
                    for (var i = 0; i &lt; 1000; i++)
                    {
                        Assert.Greater(TypeFinderOriginal.FindClassesOfType&lt;DisposableObject&gt;(_assemblies).Count(), 0);
                    }
                }
                using (DisposableTimer.TraceDuration&lt;TypeFinderTests&gt;(&quot;Starting FindClassesOfTypeWithAttribute&quot;, &quot;Finished FindClassesOfTypeWithAttribute&quot;))
                {
                    for (var i = 0; i &lt; 1000; i++)
                    {
                        Assert.Greater(TypeFinderOriginal.FindClassesOfTypeWithAttribute&lt;TestEditor, MyTestAttribute&gt;(_assemblies).Count(), 0);
                    }
                }
                using (DisposableTimer.TraceDuration&lt;TypeFinderTests&gt;(&quot;Starting FindClassesWithAttribute&quot;, &quot;Finished FindClassesWithAttribute&quot;))
                {
                    for (var i = 0; i &lt; 1000; i++)
                    {
                        Assert.Greater(TypeFinderOriginal.FindClassesWithAttribute&lt;XsltExtensionAttribute&gt;(_assemblies).Count(), 0);
                    }
                }
            }
            
        }

        [Ignore]
        [Test]
        public void Benchmark_New_Finder()
        {
            using (DisposableTimer.TraceDuration&lt;TypeFinderTests&gt;(&quot;Starting test&quot;, &quot;Finished test&quot;))
            {
                using (DisposableTimer.TraceDuration&lt;TypeFinderTests&gt;(&quot;Starting FindClassesOfType&quot;, &quot;Finished FindClassesOfType&quot;))
                {
                    for (var i = 0; i &lt; 1000; i++)
                    {
                        Assert.Greater(TypeFinder.FindClassesOfType&lt;DisposableObject&gt;(_assemblies).Count(), 0);
                    }
                }
                using (DisposableTimer.TraceDuration&lt;TypeFinderTests&gt;(&quot;Starting FindClassesOfTypeWithAttribute&quot;, &quot;Finished FindClassesOfTypeWithAttribute&quot;))
                {
                    for (var i = 0; i &lt; 1000; i++)
                    {
                        Assert.Greater(TypeFinder.FindClassesOfTypeWithAttribute&lt;TestEditor, MyTestAttribute&gt;(_assemblies).Count(), 0);
                    }
                }
                using (DisposableTimer.TraceDuration&lt;TypeFinderTests&gt;(&quot;Starting FindClassesWithAttribute&quot;, &quot;Finished FindClassesWithAttribute&quot;))
                {
                    for (var i = 0; i &lt; 1000; i++)
                    {
                        Assert.Greater(TypeFinder.FindClassesWithAttribute&lt;XsltExtensionAttribute&gt;(_assemblies).Count(), 0);
                    }
                }
            }
            
        }

        public class MyTag : ITag
        {
            public int Id { get; private set; }
            public string TagCaption { get; private set; }
            public string Group { get; private set; }
        }

        public class MySuperTag : MyTag
        {
            
        }

        [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
        public class MyTestAttribute : Attribute
        {

        }

        public abstract class TestEditor
        {

        }

        [MyTest]
        public class BenchmarkTestEditor : TestEditor
        {

        }

        [MyTest]
        public class MyOtherTestEditor : TestEditor
        {

        }

        //USED FOR THE ABOVE TESTS
        // see this issue for details: http://issues.umbraco.org/issue/U4-1187
        internal static class TypeFinderOriginal
        {

            private static readonly ConcurrentBag&lt;Assembly&gt; LocalFilteredAssemblyCache = new ConcurrentBag&lt;Assembly&gt;();
            private static readonly ReaderWriterLockSlim LocalFilteredAssemblyCacheLocker = new ReaderWriterLockSlim();
            private static ReadOnlyCollection&lt;Assembly&gt; _allAssemblies = null;
            private static ReadOnlyCollection&lt;Assembly&gt; _binFolderAssemblies = null;
            private static readonly ReaderWriterLockSlim Locker = new ReaderWriterLockSlim();

            /// &lt;summary&gt;
            /// lazily load a reference to all assemblies and only local assemblies.
            /// This is a modified version of: http://www.dominicpettifer.co.uk/Blog/44/how-to-get-a-reference-to-all-assemblies-in-the--bin-folder
            /// &lt;/summary&gt;
            /// &lt;remarks&gt;
            /// We do this because we cannot use AppDomain.Current.GetAssemblies() as this will return only assemblies that have been 
            /// loaded in the CLR, not all assemblies.
            /// See these threads:
            /// http://issues.umbraco.org/issue/U5-198
            /// http://stackoverflow.com/questions/3552223/asp-net-appdomain-currentdomain-getassemblies-assemblies-missing-after-app
            /// http://stackoverflow.com/questions/2477787/difference-between-appdomain-getassemblies-and-buildmanager-getreferencedassembl
            /// &lt;/remarks&gt;
            internal static IEnumerable&lt;Assembly&gt; GetAllAssemblies()
            {
                if (_allAssemblies == null)
                {
                    using (new WriteLock(Locker))
                    {
                        List&lt;Assembly&gt; assemblies = null;
                        try
                        {
                            var isHosted = HttpContext.Current != null;

                            try
                            {
                                if (isHosted)
                                {
                                    assemblies = new List&lt;Assembly&gt;(BuildManager.GetReferencedAssemblies().Cast&lt;Assembly&gt;());
                                }
                            }
                            catch (InvalidOperationException e)
                            {
                                if (!(e.InnerException is SecurityException))
                                    throw;
                            }


                            if (assemblies == null)
                            {
                                //NOTE: we cannot use AppDomain.CurrentDomain.GetAssemblies() because this only returns assemblies that have
                                // already been loaded in to the app domain, instead we will look directly into the bin folder and load each one.
                                var binFolder = Assembly.GetExecutingAssembly().GetAssemblyFile().Directory;
                                var binAssemblyFiles = Directory.GetFiles(binFolder.FullName, &quot;*.dll&quot;, SearchOption.TopDirectoryOnly).ToList();
                                assemblies = new List&lt;Assembly&gt;();
                                foreach (var a in binAssemblyFiles)
                                {
                                    try
                                    {
                                        var assName = AssemblyName.GetAssemblyName(a);
                                        var ass = Assembly.Load(assName);
                                        assemblies.Add(ass);
                                    }
                                    catch (Exception e)
                                    {
                                        if (e is SecurityException || e is BadImageFormatException)
                                        {
                                            //swallow these exceptions
                                        }
                                        else
                                        {
                                            throw;
                                        }
                                    }
                                }
                            }

                            //if for some reason they are still no assemblies, then use the AppDomain to load in already loaded assemblies.
                            if (!assemblies.Any())
                            {
                                assemblies.AddRange(AppDomain.CurrentDomain.GetAssemblies().ToList());
                            }

                            //here we are trying to get the App_Code assembly
                            var fileExtensions = new[] { &quot;.cs&quot;, &quot;.vb&quot; }; //only vb and cs files are supported
                            var appCodeFolder = new DirectoryInfo(IOHelper.MapPath(IOHelper.ResolveUrl(&quot;~/App_code&quot;)));
                            //check if the folder exists and if there are any files in it with the supported file extensions
                            if (appCodeFolder.Exists &amp;&amp; (fileExtensions.Any(x =&gt; appCodeFolder.GetFiles(&quot;*&quot; + x).Any())))
                            {
                                var appCodeAssembly = Assembly.Load(&quot;App_Code&quot;);
                                if (!assemblies.Contains(appCodeAssembly)) // BuildManager will find App_Code already
                                    assemblies.Add(appCodeAssembly);
                            }

                            //now set the _allAssemblies
                            _allAssemblies = new ReadOnlyCollection&lt;Assembly&gt;(assemblies);

                        }
                        catch (InvalidOperationException e)
                        {
                            if (!(e.InnerException is SecurityException))
                                throw;

                            _binFolderAssemblies = _allAssemblies;
                        }
                    }
                }

                return _allAssemblies;
            }

            /// &lt;summary&gt;
            /// Returns only assemblies found in the bin folder that have been loaded into the app domain.
            /// &lt;/summary&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            /// &lt;remarks&gt;
            /// This will be used if we implement App_Plugins from Umbraco v5 but currently it is not used.
            /// &lt;/remarks&gt;
            internal static IEnumerable&lt;Assembly&gt; GetBinAssemblies()
            {

                if (_binFolderAssemblies == null)
                {
                    using (new WriteLock(Locker))
                    {
                        var assemblies = GetAssembliesWithKnownExclusions().ToArray();
                        var binFolder = Assembly.GetExecutingAssembly().GetAssemblyFile().Directory;
                        var binAssemblyFiles = Directory.GetFiles(binFolder.FullName, &quot;*.dll&quot;, SearchOption.TopDirectoryOnly).ToList();
                        var domainAssemblyNames = binAssemblyFiles.Select(AssemblyName.GetAssemblyName);
                        var safeDomainAssemblies = new List&lt;Assembly&gt;();
                        var binFolderAssemblies = new List&lt;Assembly&gt;();

                        foreach (var a in assemblies)
                        {
                            try
                            {
                                //do a test to see if its queryable in med trust
                                var assemblyFile = a.GetAssemblyFile();
                                safeDomainAssemblies.Add(a);
                            }
                            catch (SecurityException)
                            {
                                //we will just ignore this because this will fail 
                                //in medium trust for system assemblies, we get an exception but we just want to continue until we get to 
                                //an assembly that is ok.
                            }
                        }

                        foreach (var assemblyName in domainAssemblyNames)
                        {
                            try
                            {
                                var foundAssembly = safeDomainAssemblies.FirstOrDefault(a =&gt; a.GetAssemblyFile() == assemblyName.GetAssemblyFile());
                                if (foundAssembly != null)
                                {
                                    binFolderAssemblies.Add(foundAssembly);
                                }
                            }
                            catch (SecurityException)
                            {
                                //we will just ignore this because if we are trying to do a call to: 
                                // AssemblyName.ReferenceMatchesDefinition(a.GetName(), assemblyName)))
                                //in medium trust for system assemblies, we get an exception but we just want to continue until we get to 
                                //an assembly that is ok.
                            }
                        }

                        _binFolderAssemblies = new ReadOnlyCollection&lt;Assembly&gt;(binFolderAssemblies);
                    }
                }
                return _binFolderAssemblies;
            }

            /// &lt;summary&gt;
            /// Return a list of found local Assemblies excluding the known assemblies we don&#39;t want to scan 
            /// and exluding the ones passed in and excluding the exclusion list filter, the results of this are
            /// cached for perforance reasons.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;excludeFromResults&quot;&gt;&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            internal static IEnumerable&lt;Assembly&gt; GetAssembliesWithKnownExclusions(
                IEnumerable&lt;Assembly&gt; excludeFromResults = null)
            {
                if (LocalFilteredAssemblyCache.Any()) return LocalFilteredAssemblyCache;
                using (new WriteLock(LocalFilteredAssemblyCacheLocker))
                {
                    var assemblies = GetFilteredAssemblies(excludeFromResults, KnownAssemblyExclusionFilter);
                    assemblies.ForEach(LocalFilteredAssemblyCache.Add);
                }
                return LocalFilteredAssemblyCache;
            }

            /// &lt;summary&gt;
            /// Return a list of found local Assemblies and exluding the ones passed in and excluding the exclusion list filter
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;excludeFromResults&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;exclusionFilter&quot;&gt;&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            private static IEnumerable&lt;Assembly&gt; GetFilteredAssemblies(
                IEnumerable&lt;Assembly&gt; excludeFromResults = null,
                string[] exclusionFilter = null)
            {
                if (excludeFromResults == null)
                    excludeFromResults = new List&lt;Assembly&gt;();
                if (exclusionFilter == null)
                    exclusionFilter = new string[] { };

                return GetAllAssemblies()
                    .Where(x =&gt; !excludeFromResults.Contains(x)
                                &amp;&amp; !x.GlobalAssemblyCache
                                &amp;&amp; !exclusionFilter.Any(f =&gt; x.FullName.StartsWith(f)));
            }

            /// &lt;summary&gt;
            /// this is our assembly filter to filter out known types that def dont contain types we&#39;d like to find or plugins
            /// &lt;/summary&gt;
            /// &lt;remarks&gt;
            /// NOTE the comma vs period... comma delimits the name in an Assembly FullName property so if it ends with comma then its an exact name match
            /// &lt;/remarks&gt;
            internal static readonly string[] KnownAssemblyExclusionFilter = new[]
                {
                    &quot;mscorlib,&quot;,
					&quot;System.&quot;,
                    &quot;Antlr3.&quot;,
                    &quot;Autofac.&quot;,
                    &quot;Autofac,&quot;,
                    &quot;Castle.&quot;,
                    &quot;ClientDependency.&quot;,
                    &quot;DataAnnotationsExtensions.&quot;,
                    &quot;DataAnnotationsExtensions,&quot;,
                    &quot;Dynamic,&quot;,
                    &quot;HtmlDiff,&quot;,
                    &quot;Iesi.Collections,&quot;,
                    &quot;log4net,&quot;,
                    &quot;Microsoft.&quot;,
                    &quot;Newtonsoft.&quot;,
                    &quot;NHibernate.&quot;,
                    &quot;NHibernate,&quot;,
                    &quot;NuGet.&quot;,
                    &quot;RouteDebugger,&quot;,
                    &quot;SqlCE4Umbraco,&quot;,
                    &quot;umbraco.datalayer,&quot;,
                    &quot;umbraco.interfaces,&quot;,										
					&quot;umbraco.providers,&quot;,
					&quot;Umbraco.Web.UI,&quot;,
                    &quot;umbraco.webservices&quot;,
                    &quot;Lucene.&quot;,
                    &quot;Examine,&quot;,
                    &quot;Examine.&quot;,
                    &quot;ServiceStack.&quot;,
                    &quot;MySql.&quot;,
                    &quot;HtmlAgilityPack.&quot;,
                    &quot;TidyNet.&quot;,
                    &quot;ICSharpCode.&quot;,
                    &quot;CookComputing.&quot;,
                    /* Mono */
                    &quot;MonoDevelop.NUnit&quot;
                };

            public static IEnumerable&lt;Type&gt; FindClassesOfTypeWithAttribute&lt;T, TAttribute&gt;()
                where TAttribute : Attribute
            {
                return FindClassesOfTypeWithAttribute&lt;T, TAttribute&gt;(GetAssembliesWithKnownExclusions(), true);
            }

            public static IEnumerable&lt;Type&gt; FindClassesOfTypeWithAttribute&lt;T, TAttribute&gt;(IEnumerable&lt;Assembly&gt; assemblies)
                where TAttribute : Attribute
            {
                return FindClassesOfTypeWithAttribute&lt;T, TAttribute&gt;(assemblies, true);
            }

            public static IEnumerable&lt;Type&gt; FindClassesOfTypeWithAttribute&lt;T, TAttribute&gt;(IEnumerable&lt;Assembly&gt; assemblies, bool onlyConcreteClasses)
                where TAttribute : Attribute
            {
                if (assemblies == null) throw new ArgumentNullException(&quot;assemblies&quot;);

                var l = new List&lt;Type&gt;();
                foreach (var a in assemblies)
                {
                    var types = from t in GetTypesWithFormattedException(a)
                                where !t.IsInterface
                                      &amp;&amp; typeof(T).IsAssignableFrom(t)
                                      &amp;&amp; t.GetCustomAttributes&lt;TAttribute&gt;(false).Any()
                                      &amp;&amp; (!onlyConcreteClasses || (t.IsClass &amp;&amp; !t.IsAbstract))
                                select t;
                    l.AddRange(types);
                }

                return l;
            }

            /// &lt;summary&gt;
            /// Searches all filtered local assemblies specified for classes of the type passed in.
            /// &lt;/summary&gt;
            /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public static IEnumerable&lt;Type&gt; FindClassesOfType&lt;T&gt;()
            {
                return FindClassesOfType&lt;T&gt;(GetAssembliesWithKnownExclusions(), true);
            }

            /// &lt;summary&gt;
            /// Returns all types found of in the assemblies specified of type T
            /// &lt;/summary&gt;
            /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
            /// &lt;param name=&quot;assemblies&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;onlyConcreteClasses&quot;&gt;&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public static IEnumerable&lt;Type&gt; FindClassesOfType&lt;T&gt;(IEnumerable&lt;Assembly&gt; assemblies, bool onlyConcreteClasses)
            {
                if (assemblies == null) throw new ArgumentNullException(&quot;assemblies&quot;);

                return GetAssignablesFromType&lt;T&gt;(assemblies, onlyConcreteClasses);
            }

            /// &lt;summary&gt;
            /// Returns all types found of in the assemblies specified of type T
            /// &lt;/summary&gt;
            /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
            /// &lt;param name=&quot;assemblies&quot;&gt;&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public static IEnumerable&lt;Type&gt; FindClassesOfType&lt;T&gt;(IEnumerable&lt;Assembly&gt; assemblies)
            {
                return FindClassesOfType&lt;T&gt;(assemblies, true);
            }

            /// &lt;summary&gt;
            /// Finds the classes with attribute.
            /// &lt;/summary&gt;
            /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
            /// &lt;param name=&quot;assemblies&quot;&gt;The assemblies.&lt;/param&gt;
            /// &lt;param name=&quot;onlyConcreteClasses&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; only concrete classes.&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public static IEnumerable&lt;Type&gt; FindClassesWithAttribute&lt;T&gt;(IEnumerable&lt;Assembly&gt; assemblies, bool onlyConcreteClasses)
                where T : Attribute
            {
                return FindClassesWithAttribute(typeof(T), assemblies, onlyConcreteClasses);
            }

            /// &lt;summary&gt;
            /// Finds the classes with attribute.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;type&quot;&gt;The attribute type &lt;/param&gt;
            /// &lt;param name=&quot;assemblies&quot;&gt;The assemblies.&lt;/param&gt;
            /// &lt;param name=&quot;onlyConcreteClasses&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; only concrete classes.&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public static IEnumerable&lt;Type&gt; FindClassesWithAttribute(Type type, IEnumerable&lt;Assembly&gt; assemblies, bool onlyConcreteClasses)
            {
                if (assemblies == null) throw new ArgumentNullException(&quot;assemblies&quot;);
                if (!TypeHelper.IsTypeAssignableFrom&lt;Attribute&gt;(type))
                    throw new ArgumentException(&quot;The type specified: &quot; + type + &quot; is not an Attribute type&quot;);

                var l = new List&lt;Type&gt;();
                foreach (var a in assemblies)
                {
                    var types = from t in GetTypesWithFormattedException(a)
                                where !t.IsInterface &amp;&amp; t.GetCustomAttributes(type, false).Any() &amp;&amp; (!onlyConcreteClasses || (t.IsClass &amp;&amp; !t.IsAbstract))
                                select t;
                    l.AddRange(types);
                }

                return l;
            }

            /// &lt;summary&gt;
            /// Finds the classes with attribute.
            /// &lt;/summary&gt;
            /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
            /// &lt;param name=&quot;assemblies&quot;&gt;The assemblies.&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public static IEnumerable&lt;Type&gt; FindClassesWithAttribute&lt;T&gt;(IEnumerable&lt;Assembly&gt; assemblies)
                where T : Attribute
            {
                return FindClassesWithAttribute&lt;T&gt;(assemblies, true);
            }

            /// &lt;summary&gt;
            /// Finds the classes with attribute in filtered local assemblies
            /// &lt;/summary&gt;
            /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public static IEnumerable&lt;Type&gt; FindClassesWithAttribute&lt;T&gt;()
                where T : Attribute
            {
                return FindClassesWithAttribute&lt;T&gt;(GetAssembliesWithKnownExclusions());
            }


            #region Private methods

            /// &lt;summary&gt;
            /// Gets a collection of assignables of type T from a collection of assemblies
            /// &lt;/summary&gt;
            /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
            /// &lt;param name=&quot;assemblies&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;onlyConcreteClasses&quot;&gt;&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            private static IEnumerable&lt;Type&gt; GetAssignablesFromType&lt;T&gt;(IEnumerable&lt;Assembly&gt; assemblies, bool onlyConcreteClasses)
            {
                return GetTypes(typeof(T), assemblies, onlyConcreteClasses);
            }

            private static IEnumerable&lt;Type&gt; GetTypes(Type assignTypeFrom, IEnumerable&lt;Assembly&gt; assemblies, bool onlyConcreteClasses)
            {
                var l = new List&lt;Type&gt;();
                foreach (var a in assemblies)
                {
                    var types = from t in GetTypesWithFormattedException(a)
                                where !t.IsInterface &amp;&amp; assignTypeFrom.IsAssignableFrom(t) &amp;&amp; (!onlyConcreteClasses || (t.IsClass &amp;&amp; !t.IsAbstract))
                                select t;
                    l.AddRange(types);
                }
                return l;
            }

            private static IEnumerable&lt;Type&gt; GetTypesWithFormattedException(Assembly a)
            {
                //if the assembly is dynamic, do not try to scan it
                if (a.IsDynamic)
                    return Enumerable.Empty&lt;Type&gt;();

                try
                {
                    return a.GetExportedTypes();
                }
                catch (ReflectionTypeLoadException ex)
                {
                    var sb = new StringBuilder();
                    sb.AppendLine(&quot;Could not load types from assembly &quot; + a.FullName + &quot;, errors:&quot;);
                    foreach (var loaderException in ex.LoaderExceptions.WhereNotNull())
                    {
                        sb.AppendLine(&quot;Exception: &quot; + loaderException.ToString());
                    }
                    throw new ReflectionTypeLoadException(ex.Types, ex.LoaderExceptions, sb.ToString());
                }
            }

            #endregion



        }
	}

    
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[43,3,43,4,1],[44,7,63,10,1],[65,3,65,4,1],[69,3,69,4,1],[71,4,71,105,1],[72,4,72,43,1],[73,3,73,4,1],[77,9,77,10,1],[78,13,78,100,1],[79,13,79,116,1],[81,13,81,77,1],[82,13,82,52,1],[83,13,83,60,1],[84,9,84,10,1],[88,9,88,10,1],[89,13,89,103,1],[90,13,90,52,1],[91,9,91,10,1],[96,9,96,10,0],[97,13,97,101,0],[98,13,98,14,0],[99,17,99,131,0],[100,17,100,18,0],[101,26,101,35,0],[101,37,101,45,0],[101,47,101,50,0],[102,21,102,22,0],[103,25,103,120,0],[104,21,104,22,0],[105,17,105,18,0],[106,17,106,157,0],[107,17,107,18,0],[108,26,108,35,0],[108,37,108,45,0],[108,47,108,50,0],[109,21,109,22,0],[110,25,110,144,0],[111,21,111,22,0],[112,17,112,18,0],[113,17,113,145,0],[114,17,114,18,0],[115,26,115,35,0],[115,37,115,45,0],[115,47,115,50,0],[116,21,116,22,0],[117,25,117,133,0],[118,21,118,22,0],[119,17,119,18,0],[120,13,120,14,0],[122,9,122,10,0],[127,9,127,10,0],[128,13,128,101,0],[129,13,129,14,0],[130,17,130,131,0],[131,17,131,18,0],[132,26,132,35,0],[132,37,132,45,0],[132,47,132,50,0],[133,21,133,22,0],[134,25,134,112,0],[135,21,135,22,0],[136,17,136,18,0],[137,17,137,157,0],[138,17,138,18,0],[139,26,139,35,0],[139,37,139,45,0],[139,47,139,50,0],[140,21,140,22,0],[141,25,141,136,0],[142,21,142,22,0],[143,17,143,18,0],[144,17,144,145,0],[145,17,145,18,0],[146,26,146,35,0],[146,37,146,45,0],[146,47,146,50,0],[147,21,147,22,0],[148,25,148,125,0],[149,21,149,22,0],[150,17,150,18,0],[151,13,151,14,0],[153,9,153,10,0],[157,29,157,33,0],[157,34,157,46,0],[158,40,158,44,0],[158,45,158,57,0],[159,35,159,39,0],[159,40,159,52,0],[195,13,195,120,1],[196,13,196,120,1],[197,13,197,79,1],[198,13,198,85,1],[199,13,199,94,1],[214,13,214,14,0],[215,17,215,44,0],[216,17,216,18,0],[217,21,217,50,0],[218,21,218,22,0],[219,25,219,58,0],[221,25,221,26,0],[222,29,222,72,0],[225,29,225,30,0],[226,33,226,46,0],[227,33,227,34,0],[228,37,228,126,0],[229,33,229,34,0],[230,29,230,30,0],[231,29,231,64,0],[232,29,232,30,0],[233,33,233,78,0],[234,37,234,43,0],[235,29,235,30,0],[238,29,238,52,0],[239,29,239,30,0],[242,33,242,109,0],[243,33,243,144,0],[244,33,244,67,0],[245,33,245,40,0],[245,42,245,47,0],[245,48,245,50,0],[245,51,245,67,0],[246,33,246,34,0],[248,37,248,38,0],[249,41,249,87,0],[250,41,250,74,0],[251,41,251,61,0],[252,37,252,38,0],[253,37,253,56,0],[254,37,254,38,0],[255,41,255,100,0],[256,41,256,42,0],[258,41,258,42,0],[260,41,260,42,0],[261,45,261,51,0],[263,37,263,38,0],[264,33,264,34,0],[265,29,265,30,0],[268,29,268,51,0],[269,29,269,30,0],[270,33,270,103,0],[271,29,271,30,0],[274,29,274,73,0],[275,29,275,120,0],[277,29,277,82,0],[277,82,277,119,0],[277,119,277,122,0],[277,29,277,122,0],[278,29,278,30,0],[279,33,279,81,0],[280,33,280,75,0],[281,37,281,69,0],[282,29,282,30,0],[285,29,285,91,0],[287,25,287,26,0],[288,25,288,60,0],[289,25,289,26,0],[290,29,290,74,0],[291,33,291,39,0],[293,29,293,67,0],[294,25,294,26,0],[295,21,295,22,0],[296,17,296,18,0],[298,17,298,39,0],[299,13,299,14,0],[309,13,309,14,0],[311,17,311,50,0],[312,17,312,18,0],[313,21,313,50,0],[314,21,314,22,0],[315,25,315,87,0],[316,25,316,101,0],[317,25,317,136,0],[318,25,318,105,0],[319,25,319,73,0],[320,25,320,72,0],[322,25,322,32,0],[322,34,322,39,0],[322,40,322,42,0],[322,43,322,53,0],[323,25,323,26,0],[325,29,325,30,0],[327,33,327,72,0],[328,33,328,61,0],[329,29,329,30,0],[330,29,330,54,0],[331,29,331,30,0],[335,29,335,30,0],[336,25,336,26,0],[338,25,338,32,0],[338,34,338,50,0],[338,51,338,53,0],[338,54,338,73,0],[339,25,339,26,0],[341,29,341,30,0],[342,33,342,94,0],[342,94,342,147,0],[342,147,342,149,0],[342,33,342,149,0],[343,33,343,59,0],[344,33,344,34,0],[345,37,345,76,0],[346,33,346,34,0],[347,29,347,30,0],[348,29,348,54,0],[349,29,349,30,0],[354,29,354,30,0],[355,25,355,26,0],[357,25,357,102,0],[358,21,358,22,0],[359,17,359,18,0],[360,17,360,45,0],[361,13,361,14,0],[372,13,372,14,0],[373,17,373,54,0],[373,55,373,89,0],[374,17,374,72,0],[375,17,375,18,0],[376,21,376,110,0],[377,21,377,72,0],[378,17,378,18,0],[379,17,379,51,0],[380,13,380,14,0],[391,13,391,14,0],[392,17,392,48,0],[393,21,393,63,0],[394,17,394,45,0],[395,21,395,56,0],[397,17,398,33,0],[398,33,400,62,0],[400,62,400,86,0],[400,86,400,87,0],[398,33,400,87,0],[400,87,400,89,0],[397,17,400,89,0],[401,13,401,14,0],[409,13,447,19,1],[451,13,451,14,0],[452,17,452,112,0],[453,13,453,14,0],[457,13,457,14,0],[458,17,458,88,0],[459,13,459,14,0],[463,13,463,14,0],[464,17,464,40,0],[464,41,464,87,0],[466,17,466,42,0],[467,17,467,24,0],[467,26,467,31,0],[467,32,467,34,0],[467,35,467,45,0],[468,17,468,18,0],[469,21,470,39,0],[470,39,473,96,0],[473,96,474,42,0],[469,21,474,42,0],[475,21,475,39,0],[476,17,476,18,0],[478,17,478,26,0],[479,13,479,14,0],[487,13,487,14,0],[488,17,488,87,0],[489,13,489,14,0],[499,13,499,14,1],[500,17,500,40,1],[500,41,500,87,0],[502,17,502,83,1],[503,13,503,14,1],[512,13,512,14,1],[513,17,513,63,1],[514,13,514,14,1],[525,13,525,14,0],[526,17,526,93,0],[527,13,527,14,0],[537,13,537,14,0],[538,17,538,40,0],[538,41,538,87,0],[539,17,539,71,0],[540,21,540,110,0],[542,17,542,42,0],[543,17,543,24,0],[543,26,543,31,0],[543,32,543,34,0],[543,35,543,45,0],[544,17,544,18,0],[545,21,546,39,0],[546,39,546,155,0],[546,155,547,42,0],[545,21,547,42,0],[548,21,548,39,0],[549,17,549,18,0],[551,17,551,26,0],[552,13,552,14,0],[562,13,562,14,0],[563,17,563,70,0],[564,13,564,14,0],[573,13,573,14,0],[574,17,574,88,0],[575,13,575,14,0],[588,13,588,14,1],[589,17,589,77,1],[590,13,590,14,1],[593,13,593,14,1],[594,17,594,42,1],[595,17,595,24,1],[595,26,595,31,1],[595,32,595,34,1],[595,35,595,45,1],[596,17,596,18,1],[597,21,598,39,1],[598,39,598,149,1],[598,149,599,42,1],[597,21,599,42,1],[600,21,600,39,1],[601,17,601,18,1],[602,17,602,26,1],[603,13,603,14,1],[606,13,606,14,1],[608,17,608,33,1],[609,21,609,53,0],[612,17,612,18,1],[613,21,613,49,1],[615,17,615,55,0],[616,17,616,18,0],[617,21,617,50,0],[618,21,618,101,0],[619,21,619,28,0],[619,30,619,49,0],[619,50,619,52,0],[619,53,619,87,0],[620,21,620,22,0],[621,25,621,83,0],[622,21,622,22,0],[623,21,623,105,0],[625,13,625,14,1]]);
    </script>
  </body>
</html>