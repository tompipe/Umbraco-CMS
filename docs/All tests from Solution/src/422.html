<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\umbraco.presentation\umbraco\uQuery\uQuery-Nodes.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Xml.XPath;
using umbraco.NodeFactory;
using Umbraco.Core;

namespace umbraco
{
	/// &lt;summary&gt;
	/// uQuery sub-class for Nodes
	/// &lt;/summary&gt;
	public static partial class uQuery
	{
		/// &lt;summary&gt;
		/// Gets the Root Node Id (-1)
		/// &lt;/summary&gt;
		public static readonly int RootNodeId = -1;

		/// &lt;summary&gt;
		/// Get a collection of Umbraco Nodes from an XPath expression
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;xpath&quot;&gt;XPath expression to get Nodes, can use $ancestorOrSelf which will use the current Node if published, else it&#39;ll use the nearest published parent
		/// $currentPage will be depreciated&lt;/param&gt;
		/// &lt;returns&gt;an empty collection or a collection of nodes&lt;/returns&gt;
		public static IEnumerable&lt;Node&gt; GetNodesByXPath(string xpath)
		{
			var nodes = new List&lt;Node&gt;();

			// resolve the XPath expression with any Umbraco-specific parameters
			xpath = uQuery.ResolveXPath(xpath);

			// Get Umbraco Xml
			var xPathNavigator = content.Instance.XmlContent.CreateNavigator();
			XPathExpression xPathExpression;

			// Check to see if XPathExpression is in the cache
            if (HttpRuntime.Cache[xpath] == null)
            {
				// Build Compiled XPath expression
				xPathExpression = xPathNavigator.Compile(xpath);

				// Store in Cache
				HttpRuntime.Cache[xpath] = xPathExpression;
			}
			else // Get from Cache
			{
				xPathExpression = (XPathExpression)HttpRuntime.Cache[xpath];
			}

			// [LK] Interested in exploring options to call custom extension methods in XPath expressions.
			// http://msdn.microsoft.com/en-us/library/ms950806.aspx
			// http://msdn.microsoft.com/en-us/library/dd567715.aspx
			// Alternative is to render a Clean.xslt with the desired XPath, returning nodeIds

			var xPathNodeIterator = xPathNavigator.Select(xPathExpression);

			while (xPathNodeIterator.MoveNext())
			{
				var node = uQuery.GetNode(xPathNodeIterator.Current.GetAttribute(&quot;id&quot;, string.Empty));
				if (node != null)
				{
					nodes.Add(node);
				}
			}

			return nodes;
		}

		/// &lt;summary&gt;
		/// Returns a collection of Nodes, from a delimited list of Ids (as per the format used with UltimatePicker)
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;csv&quot;&gt;string csv of Ids&lt;/param&gt;
		/// &lt;returns&gt;an empty collection or a collection or Nodes&lt;/returns&gt;
		public static IEnumerable&lt;Node&gt; GetNodesByCsv(string csv)
		{
			var nodes = new List&lt;Node&gt;();
			var ids = uQuery.GetCsvIds(csv);

			if (ids != null)
			{
				foreach (string id in ids)
				{
					var node = uQuery.GetNode(id);
					if (node != null)
					{
						nodes.Add(node);
					}
				}
			}

			return nodes;
		}

		/// &lt;summary&gt;
		/// Builds a node collection from an XML snippet
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;xml&quot;&gt;
		/// the expected Xml snippet is that stored by the Multi-Node Tree Picker (and XPathCheckBoxList when storing Ids)
		/// &quot;&lt;MultiNodePicker&gt;
		///     &lt;nodeId&gt;1065&lt;/nodeId&gt;
		///     &lt;nodeId&gt;1068&lt;/nodeId&gt;
		///     &lt;nodeId&gt;1066&lt;/nodeId&gt;
		///  &lt;/MultiNodePicker&gt;&quot;
		/// &lt;/param&gt;
		/// &lt;returns&gt;an empty list or a list of nodes&lt;/returns&gt;
		public static IEnumerable&lt;Node&gt; GetNodesByXml(string xml)
		{
			var nodes = new List&lt;Node&gt;();
			var ids = uQuery.GetXmlIds(xml);

			if (ids != null)
			{
				foreach (int id in ids)
				{
					var node = uQuery.GetNode(id);
					if (node != null)
					{
						nodes.Add(node);
					}
				}
			}

			return nodes;
		}

		/// &lt;summary&gt;
		/// Get nodes by name
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;name&quot;&gt;name of node to look for&lt;/param&gt;
		/// &lt;returns&gt;list of nodes, or empty list&lt;/returns&gt;
		public static IEnumerable&lt;Node&gt; GetNodesByName(string name)
		{
			return uQuery.GetNodesByXPath(string.Concat(&quot;descendant::*[@nodeName=&#39;&quot;, name, &quot;&#39;]&quot;));
		}

		/// &lt;summary&gt;
		/// Get nodes by document type alias
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;documentTypeAlias&quot;&gt;The document type alias&lt;/param&gt;
		/// &lt;returns&gt;list of nodes, or empty list&lt;/returns&gt;
		public static IEnumerable&lt;Node&gt; GetNodesByType(string documentTypeAlias)
		{
			if (uQuery.IsLegacyXmlSchema())
			{
				return uQuery.GetNodesByXPath(string.Concat(&quot;descendant::*[@nodeTypeAlias=&#39;&quot;, documentTypeAlias, &quot;&#39;]&quot;));
			}
			else
			{
				return uQuery.GetNodesByXPath(string.Concat(&quot;descendant::&quot;, documentTypeAlias, &quot;[@isDoc]&quot;));
			}
		}

		/// &lt;summary&gt;
		/// Get nodes by document type id
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;documentTypeId&quot;&gt;The document type id.&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static IEnumerable&lt;Node&gt; GetNodesByType(int documentTypeId)
		{
			return uQuery.GetNodesByXPath(string.Concat(&quot;descendant::*[@nodeType=&#39;&quot;, documentTypeId, &quot;&#39;]&quot;));
		}

		/// &lt;summary&gt;
		/// Gets the node by URL.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;url&quot;&gt;url to search for&lt;/param&gt;
		/// &lt;returns&gt;null or node matching supplied url&lt;/returns&gt;
		public static Node GetNodeByUrl(string url)
		{
			return uQuery.GetNode(uQuery.GetNodeIdByUrl(url));
		}

		/// &lt;summary&gt;
		/// Gets the node id by path level.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;path&quot;&gt;The path.&lt;/param&gt;
		/// &lt;param name=&quot;level&quot;&gt;The level.&lt;/param&gt;
		/// &lt;returns&gt;Returns the node id for a given path level.&lt;/returns&gt;
		public static string GetNodeIdByPathLevel(string path, int level)
		{
			// TODO: [LK] use uQuery.GetNodeIdByPathLevel
			var nodeIds = path.Split(&#39;,&#39;).ToList();

			if (nodeIds.Count &gt; level)
			{
				return nodeIds[level];
			}

			return uQuery.RootNodeId.ToString();
		}

		/// &lt;summary&gt;
		/// Gets the node Id by URL.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;url&quot;&gt;The URL to get the XML node from.&lt;/param&gt;
		/// &lt;returns&gt;Returns the node Id.&lt;/returns&gt;
		/// &lt;remarks&gt;
		/// &lt;para&gt;Thanks to Jonas Eriksson http://our.umbraco.org/member/4853 &lt;/para&gt;
		/// &lt;para&gt;Just runs lookups to find the document, does not follow internal redirects, 404 handlers,
		/// page access verification, wildcard domains -- nothing.&lt;/para&gt;
		/// &lt;/remarks&gt;
		public static int GetNodeIdByUrl(string url)
		{
			var uri = new Uri(url, UriKind.RelativeOrAbsolute);
			if (!uri.IsAbsoluteUri)
				uri = uri.MakeAbsolute(Umbraco.Web.UmbracoContext.Current.CleanedUmbracoUrl);
			uri = Umbraco.Web.UriUtility.UriToUmbraco(uri);

			var pcr = new Umbraco.Web.Routing.PublishedContentRequest(uri, Umbraco.Web.UmbracoContext.Current.RoutingContext);
			// partially prepare the request: do _not_ follow redirects, handle 404, nothing - just find a content
			pcr.Engine.FindDomain();
			pcr.Engine.FindPublishedContent();
			return pcr.HasPublishedContent ? pcr.PublishedContent.Id : uQuery.RootNodeId;
		}

		/// &lt;summary&gt;
		/// Get top level content node
		/// &lt;/summary&gt;
		/// &lt;returns&gt;the top level content node&lt;/returns&gt;
		public static Node GetRootNode()
		{
			return new Node(RootNodeId);
		}

		/// &lt;summary&gt;
		/// checks to see if the current node can be got via the nodeFactory, if not then 
		/// checks to see if the current node can be got via an id on the QueryString
		/// &lt;/summary&gt;
		/// &lt;returns&gt;the current node or null if not found&lt;/returns&gt;
		public static Node GetCurrentNode()
		{
			Node currentNode = null;

			try
			{
				currentNode = Node.GetCurrent();
			}
			catch // if current node can&#39;t be found via the nodeFactory then Umbraco throws an exception
			{
				// look on QueryString for an id parameter (this is used in the backoffice)
				currentNode = uQuery.GetNode(uQuery.GetIdFromQueryString());
			}

			return currentNode;
		}

		/// &lt;summary&gt;
		/// Checks the supplied string can be cast to an integer, and returns the node with that Id
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;nodeId&quot;&gt;string representing the nodeId to return&lt;/param&gt;
		/// &lt;returns&gt;Node or null&lt;/returns&gt;
		public static Node GetNode(string nodeId)
		{
			int id;
			Node node = null;

			if (int.TryParse(nodeId, out id))
			{
				node = uQuery.GetNode(id);
			}

			return node;
		}

		/// &lt;summary&gt;
		/// Wrapper for Node constructor
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;id&quot;&gt;id of Node to get&lt;/param&gt;
		/// &lt;returns&gt;Node or null&lt;/returns&gt;
		public static Node GetNode(int id)
		{
			Node node;

			try
			{
				node = new Node(id);

				if (node.Id == 0)
				{
					node = null;
				}
			}
			catch
			{
				node = null;
			}

			return node;
		}

		/// &lt;summary&gt;
		/// Resolves the XPath expression with any Umbraco-specific parameters.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;xpath&quot;&gt;The xpath expression.&lt;/param&gt;
		/// &lt;returns&gt;Returns an XPath expression with the Umbraco-specific parameters resolved.&lt;/returns&gt;
		public static string ResolveXPath(string xpath)
		{
			if (!string.IsNullOrWhiteSpace(xpath))
			{
				var parameters = new[] { &quot;$currentPage&quot;, &quot;$ancestorOrSelf&quot;, &quot;$parentPage&quot; };

				if (parameters.Any(xpath.Contains))
				{
					var ancestorOrSelfId = RootNodeId;
					var parentPageId = RootNodeId;

					var currentNode = uQuery.GetCurrentNode();
					if (currentNode != null)
					{
						ancestorOrSelfId = currentNode.Id;
						parentPageId = (currentNode.Parent != null) ? currentNode.Parent.Id : currentNode.Id;
					}
					else
					{
						// current node is unpublished or can&#39;t be found, so try via the Document API
						var currentDocument = uQuery.GetCurrentDocument();
						if (currentDocument != null)
						{
							// need to find first published parent
							var publishedDocument = currentDocument.GetAncestorOrSelfDocuments().Where(document =&gt; document.Published == true).FirstOrDefault();
							if (publishedDocument != null)
							{
								// found the nearest published document
								ancestorOrSelfId = publishedDocument.Id;
								parentPageId = (publishedDocument.Id == currentDocument.Id) ? currentDocument.ParentId : publishedDocument.Id;
							}
						}
					}

					// replace the parameters with corresponding XPath expression
					xpath = xpath.Replace(&quot;$parentPage&quot;, string.Concat(&quot;/descendant::*[@id=&#39;&quot;, parentPageId, &quot;&#39;]&quot;));
					xpath = xpath.Replace(&quot;$currentPage&quot;, &quot;$ancestorOrSelf&quot;);
					xpath = xpath.Replace(&quot;$ancestorOrSelf&quot;, string.Concat(&quot;/descendant::*[@id=&#39;&quot;, ancestorOrSelfId, &quot;&#39;]&quot;));
				}
			}

			return xpath;
		}

		/// &lt;summary&gt;
		/// Extension method on Node collection to return key value pairs of: node.Id / node.Name
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;nodes&quot;&gt;generic list of node objects&lt;/param&gt;
		/// &lt;returns&gt;a collection of nodeIDs and their names&lt;/returns&gt;
		public static Dictionary&lt;int, string&gt; ToNameIds(this IEnumerable&lt;Node&gt; nodes)
		{
			var dictionary = new Dictionary&lt;int, string&gt;();

			foreach (var node in nodes)
			{
				dictionary.Add(node.Id, node.Name);
			}

			return dictionary;
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[19,3,19,46,1],[28,3,28,4,0],[29,4,29,33,0],[32,4,32,39,0],[35,4,35,71,0],[39,13,39,50,0],[40,13,40,14,0],[42,5,42,53,0],[45,5,45,48,0],[46,4,46,5,0],[48,4,48,5,0],[49,5,49,65,0],[50,4,50,5,0],[57,4,57,67,0],[59,4,59,40,0],[60,4,60,5,0],[61,5,61,91,0],[62,5,62,22,0],[63,5,63,6,0],[64,6,64,22,0],[65,5,65,6,0],[66,4,66,5,0],[68,4,68,17,0],[69,3,69,4,0],[77,3,77,4,0],[78,4,78,33,0],[79,4,79,36,0],[81,4,81,20,0],[82,4,82,5,0],[83,5,83,12,0],[83,14,83,23,0],[83,24,83,26,0],[83,27,83,30,0],[84,5,84,6,0],[85,6,85,36,0],[86,6,86,23,0],[87,6,87,7,0],[88,7,88,23,0],[89,6,89,7,0],[90,5,90,6,0],[91,4,91,5,0],[93,4,93,17,0],[94,3,94,4,0],[109,3,109,4,0],[110,4,110,33,0],[111,4,111,36,0],[113,4,113,20,0],[114,4,114,5,0],[115,5,115,12,0],[115,14,115,20,0],[115,21,115,23,0],[115,24,115,27,0],[116,5,116,6,0],[117,6,117,36,0],[118,6,118,23,0],[119,6,119,7,0],[120,7,120,23,0],[121,6,121,7,0],[122,5,122,6,0],[123,4,123,5,0],[125,4,125,17,0],[126,3,126,4,0],[134,3,134,4,0],[135,4,135,90,0],[136,3,136,4,0],[144,3,144,4,0],[145,4,145,35,0],[146,4,146,5,0],[147,5,147,109,0],[150,4,150,5,0],[151,5,151,97,0],[153,3,153,4,0],[161,3,161,4,0],[162,4,162,100,0],[163,3,163,4,0],[171,3,171,4,0],[172,4,172,54,0],[173,3,173,4,0],[182,3,182,4,0],[184,4,184,43,0],[186,4,186,30,0],[187,4,187,5,0],[188,5,188,27,0],[191,4,191,40,0],[192,3,192,4,0],[205,3,205,4,1],[206,4,206,55,1],[207,4,207,27,1],[208,5,208,82,1],[209,4,209,51,1],[211,4,211,118,1],[213,4,213,28,1],[214,4,214,38,1],[215,4,215,81,1],[216,3,216,4,1],[223,3,223,4,0],[224,4,224,32,0],[225,3,225,4,0],[233,3,233,4,0],[234,4,234,28,0],[237,4,237,5,0],[238,5,238,37,0],[239,4,239,5,0],[240,4,240,9,0],[241,4,241,5,0],[243,5,243,65,0],[244,4,244,5,0],[246,4,246,23,0],[247,3,247,4,0],[255,3,255,4,0],[257,4,257,21,0],[259,4,259,37,0],[260,4,260,5,0],[261,5,261,31,0],[262,4,262,5,0],[264,4,264,16,0],[265,3,265,4,0],[273,3,273,4,0],[277,4,277,5,0],[278,5,278,25,0],[280,5,280,22,0],[281,5,281,6,0],[282,6,282,18,0],[283,5,283,6,0],[284,4,284,5,0],[285,4,285,9,0],[286,4,286,5,0],[287,5,287,17,0],[288,4,288,5,0],[290,4,290,16,0],[291,3,291,4,0],[299,3,299,4,0],[300,4,300,42,0],[301,4,301,5,0],[302,5,302,81,0],[304,5,304,40,0],[305,5,305,6,0],[306,6,306,40,0],[307,6,307,36,0],[309,6,309,48,0],[310,6,310,30,0],[311,6,311,7,0],[312,7,312,41,0],[313,7,313,92,0],[314,6,314,7,0],[316,6,316,7,0],[318,7,318,57,0],[319,7,319,35,0],[320,7,320,8,0],[322,8,322,95,0],[322,95,322,121,0],[322,121,322,140,0],[322,8,322,140,0],[323,8,323,38,0],[324,8,324,9,0],[326,9,326,49,0],[327,9,327,119,0],[328,8,328,9,0],[329,7,329,8,0],[330,6,330,7,0],[333,6,333,102,0],[334,6,334,63,0],[335,6,335,110,0],[336,5,336,6,0],[337,4,337,5,0],[339,4,339,17,0],[340,3,340,4,0],[348,3,348,4,0],[349,4,349,51,0],[351,4,351,11,0],[351,13,351,21,0],[351,22,351,24,0],[351,25,351,30,0],[352,4,352,5,0],[353,5,353,40,0],[354,4,354,5,0],[356,4,356,22,0],[357,3,357,4,0]]);
    </script>
  </body>
</html>