<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Tests\Logging\AsyncRollingFileAppenderTest.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;
using log4net;
using log4net.Config;
using log4net.Core;
using log4net.Layout;
using log4net.Repository;
using NUnit.Framework;
using Umbraco.Core;
using Umbraco.Core.Logging;

namespace Umbraco.Tests.Logging
{
    [TestFixture]
    public class AsyncRollingFileAppenderTest
    {
        private const string ErrorMessage = &quot;TEST ERROR MESSAGE&quot;;
        private const string FileFolderPath = @&quot;c:\LogTesting\&quot;;
        private readonly Level ErrorLevel = Level.Error;
        private AsynchronousRollingFileAppender appender;
        private ILoggerRepository rep;
        private Guid fileGuid;

        private string GetFilePath()
        {
            return string.Format(&quot;{0}{1}.log&quot;, FileFolderPath, fileGuid);
        }

        [SetUp]
        public void SetUp()
        {
            fileGuid = Guid.NewGuid();
            if (File.Exists(GetFilePath()))
            {
                File.Delete(GetFilePath());
            }

            appender = new AsynchronousRollingFileAppender();
            appender.Threshold = ErrorLevel;
            appender.File = GetFilePath();
            appender.Layout = new PatternLayout(&quot;%d|%-5level|%logger| %message %exception%n&quot;);
            appender.StaticLogFileName = true;
            appender.AppendToFile = true;
            appender.ActivateOptions();

            rep = LogManager.CreateRepository(Guid.NewGuid().ToString());
            BasicConfigurator.Configure(rep, appender);
        }

        [TearDown]
        public void TearDown()
        {
            rep.Shutdown();
            if (File.Exists(GetFilePath()))
            {
                File.Delete(GetFilePath());
            }
        }

        [TestFixtureTearDown]
        public void FixtureTearDown()
        {
            foreach (string file in Directory.GetFiles(FileFolderPath))
            {
                try
                {
                    File.Delete(file);
                }
                catch { }
            }
        }

        private void ReleaseFileLocks()
        {
            rep.Shutdown();
            appender.Close();
        }

        [Test]
        public void CanWriteToFile()
        {
            // Arrange
            ILog log = LogManager.GetLogger(rep.Name, &quot;CanWriteToDatabase&quot;);

            // Act
            log.Error(ErrorMessage);
            Thread.Sleep(200); // let background thread finish

            // Assert
            ReleaseFileLocks();
            Assert.That(File.Exists(GetFilePath()), Is.True);
            IEnumerable&lt;string&gt; readLines = File.ReadLines(GetFilePath());
            Assert.That(readLines.Count(), Is.GreaterThanOrEqualTo(1));
        }

        [Test]
        public void ReturnsQuicklyAfterLogging100Messages()
        {
            // Arrange
            ILog log = LogManager.GetLogger(rep.Name, &quot;ReturnsQuicklyAfterLogging100Messages&quot;);

            // Act
            DateTime startTime = DateTime.UtcNow;
            100.Times(i =&gt; log.Error(ErrorMessage));
            DateTime endTime = DateTime.UtcNow;

            // Give background thread time to finish
            Thread.Sleep(500);

            // Assert
            ReleaseFileLocks();
            Assert.That(endTime - startTime, Is.LessThan(TimeSpan.FromMilliseconds(100)));
            Assert.That(File.Exists(GetFilePath()), Is.True);
            IEnumerable&lt;string&gt; readLines = File.ReadLines(GetFilePath());
            Assert.That(readLines.Count(), Is.GreaterThanOrEqualTo(100));
        }

        [Test]
        [Ignore]
        public void CanLogAtleast1000MessagesASecond()
        {
            // Arrange
            ILog log = LogManager.GetLogger(rep.Name, &quot;CanLogAtLeast1000MessagesASecond&quot;);

            int logCount = 0;
            bool logging = true;
            bool logsCounted = false;

            var logTimer = new Timer(s =&gt;
            {
                logging = false;

                if (File.Exists(GetFilePath()))
                {
                    ReleaseFileLocks();
                    IEnumerable&lt;string&gt; readLines = File.ReadLines(GetFilePath());
                    logCount = readLines.Count();
                }
                logsCounted = true;
            }, null, TimeSpan.FromSeconds(3), TimeSpan.FromMilliseconds(-1));

            // Act
            DateTime startTime = DateTime.UtcNow;
            while (logging)
            {
                log.Error(ErrorMessage);
            }
            TimeSpan testDuration = DateTime.UtcNow - startTime;

            while (!logsCounted)
            {
                Thread.Sleep(1);
            }

            logTimer.Dispose();

            // Assert
            var logsPerSecond = logCount / testDuration.TotalSeconds;

            Debug.Print(&quot;{0} messages logged in {1}s =&gt; {2}/s&quot;, logCount, testDuration.TotalSeconds, logsPerSecond);
            Assert.That(logsPerSecond, Is.GreaterThan(1000), &quot;Must log at least 1000 messages per second&quot;);
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[23,9,23,57,1],[29,9,29,10,1],[30,13,30,74,1],[31,9,31,10,1],[35,9,35,10,1],[36,13,36,39,1],[37,13,37,44,1],[38,13,38,14,0],[39,17,39,44,0],[40,13,40,14,0],[42,13,42,62,1],[43,13,43,45,1],[44,13,44,43,1],[45,13,45,95,1],[46,13,46,47,1],[47,13,47,42,1],[48,13,48,40,1],[50,13,50,74,1],[51,13,51,56,1],[52,9,52,10,1],[56,9,56,10,1],[57,13,57,28,1],[58,13,58,44,1],[59,13,59,14,1],[60,17,60,44,1],[61,13,61,14,1],[62,9,62,10,1],[66,9,66,10,1],[67,13,67,20,1],[67,22,67,33,0],[67,34,67,36,1],[67,37,67,71,1],[68,13,68,14,0],[70,17,70,18,0],[71,21,71,39,0],[72,17,72,18,0],[73,17,73,22,0],[73,23,73,24,0],[73,25,73,26,0],[74,13,74,14,0],[75,9,75,10,1],[78,9,78,10,1],[79,13,79,28,1],[80,13,80,30,1],[81,9,81,10,1],[85,9,85,10,1],[87,13,87,77,1],[90,13,90,37,1],[91,13,91,31,1],[94,13,94,32,1],[95,13,95,62,1],[96,13,96,75,1],[97,13,97,72,1],[98,9,98,10,1],[102,9,102,10,1],[104,13,104,96,1],[107,13,107,50,1],[108,13,108,28,1],[108,28,108,51,1],[108,51,108,53,1],[108,13,108,53,1],[109,13,109,48,1],[112,13,112,31,1],[115,13,115,32,1],[116,13,116,91,1],[117,13,117,62,1],[118,13,118,75,1],[119,13,119,74,1],[120,9,120,10,1],[125,9,125,10,0],[127,13,127,91,0],[129,13,129,30,0],[130,13,130,33,0],[131,13,131,38,0],[133,13,134,13,0],[134,13,134,14,0],[134,14,135,17,0],[135,17,135,33,0],[135,33,137,17,0],[137,17,137,48,0],[137,48,138,17,0],[138,17,138,18,0],[138,18,139,21,0],[139,21,139,40,0],[139,40,140,21,0],[140,21,140,83,0],[140,83,141,21,0],[141,21,141,50,0],[141,50,142,17,0],[142,17,142,18,0],[142,18,143,17,0],[143,17,143,36,0],[143,36,144,13,0],[144,13,144,14,0],[144,14,144,78,0],[133,13,144,78,0],[147,13,147,50,0],[148,13,148,28,0],[149,13,149,14,0],[150,17,150,41,0],[151,13,151,14,0],[152,13,152,65,0],[154,13,154,33,0],[155,13,155,14,0],[156,17,156,33,0],[157,13,157,14,0],[159,13,159,32,0],[162,13,162,70,0],[164,13,164,117,0],[165,13,165,108,0],[166,9,166,10,0]]);
    </script>
  </body>
</html>