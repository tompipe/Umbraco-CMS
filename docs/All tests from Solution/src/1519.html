<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Services\ContentTypeServiceBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Collections.Generic;
using System.Linq;
using Umbraco.Core.Events;
using Umbraco.Core.Logging;
using Umbraco.Core.Models;
using Umbraco.Core.Models.EntityBase;
using Umbraco.Core.Persistence;
using Umbraco.Core.Persistence.Repositories;
using Umbraco.Core.Persistence.UnitOfWork;

namespace Umbraco.Core.Services
{
    public class ContentTypeServiceBase : RepositoryService
    {
        public ContentTypeServiceBase(IDatabaseUnitOfWorkProvider provider, RepositoryFactory repositoryFactory, ILogger logger, IEventMessagesFactory eventMessagesFactory)
            : base(provider, repositoryFactory, logger, eventMessagesFactory)
        {
        }
        
        /// &lt;summary&gt;
        /// This is called after an content type is saved and is used to update the content xml structures in the database
        /// if they are required to be updated.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;contentTypes&quot;&gt;&lt;/param&gt;
        internal IEnumerable&lt;IContentTypeBase&gt; GetContentTypesForXmlUpdates(params IContentTypeBase[] contentTypes)
        {

            var toUpdate = new List&lt;IContentTypeBase&gt;();

            foreach (var contentType in contentTypes)
            {
                //we need to determine if we need to refresh the xml content in the database. This is to be done when:
                // - the item is not new (already existed in the db) AND
                //      - a content type changes it&#39;s alias OR
                //      - if a content type has it&#39;s property removed OR
                //      - if a content type has a property whose alias has changed
                //here we need to check if the alias of the content type changed or if one of the properties was removed.                    
                var dirty = contentType as IRememberBeingDirty;
                if (dirty == null) continue;

                //check if any property types have changed their aliases (and not new property types)
                var hasAnyPropertiesChangedAlias = contentType.PropertyTypes.Any(propType =&gt;
                    {
                        var dirtyProperty = propType as IRememberBeingDirty;
                        if (dirtyProperty == null) return false;
                        return dirtyProperty.WasPropertyDirty(&quot;HasIdentity&quot;) == false   //ensure it&#39;s not &#39;new&#39;
                               &amp;&amp; dirtyProperty.WasPropertyDirty(&quot;Alias&quot;);              //alias has changed
                    });

                if (dirty.WasPropertyDirty(&quot;HasIdentity&quot;) == false //ensure it&#39;s not &#39;new&#39;
                    &amp;&amp; (dirty.WasPropertyDirty(&quot;Alias&quot;) || dirty.WasPropertyDirty(&quot;HasPropertyTypeBeenRemoved&quot;) || hasAnyPropertiesChangedAlias))
                {
                    //If the alias was changed then we only need to update the xml structures for content of the current content type.
                    //If a property was deleted or a property alias was changed then we need to update the xml structures for any 
                    // content of the current content type and any of the content type&#39;s child content types.
                    if (dirty.WasPropertyDirty(&quot;Alias&quot;)
                        &amp;&amp; dirty.WasPropertyDirty(&quot;HasPropertyTypeBeenRemoved&quot;) == false &amp;&amp; hasAnyPropertiesChangedAlias == false)
                    {
                        //if only the alias changed then only update the current content type                        
                        toUpdate.Add(contentType);
                    }
                    else
                    {
                        //if a property was deleted or alias changed, then update all content of the current content type
                        // and all of it&#39;s desscendant doc types.     
                        toUpdate.AddRange(contentType.DescendantsAndSelf());
                    }
                }
            }

            return toUpdate;

        }

        /// &lt;summary&gt;
        /// Given the path of a content item, this will return true if the content item exists underneath a list view content item
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;contentPath&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool HasContainerInPath(string contentPath)
        {
            using (var uow = UowProvider.GetUnitOfWork())
            {
                // can use same repo for both content and media
                var repository = RepositoryFactory.CreateContentTypeRepository(uow);
                return repository.HasContainerInPath(contentPath);
            }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[16,15,16,78,1],[17,9,17,10,1],[18,9,18,10,1],[26,9,26,10,1],[28,13,28,57,1],[30,13,30,20,1],[30,22,30,37,1],[30,38,30,40,1],[30,41,30,53,1],[31,13,31,14,1],[38,17,38,64,1],[39,17,39,35,1],[39,36,39,45,0],[42,17,43,21,1],[43,21,43,22,1],[43,22,44,25,1],[44,25,44,77,1],[44,77,45,25,1],[45,25,45,51,1],[45,51,45,52,1],[45,52,45,65,0],[45,65,46,25,1],[46,25,47,75,1],[47,75,48,21,1],[48,21,48,22,1],[48,22,48,24,1],[42,17,48,24,1],[50,17,51,146,1],[52,17,52,18,1],[56,21,57,131,1],[58,21,58,22,1],[60,25,60,51,1],[61,21,61,22,1],[63,21,63,22,1],[66,25,66,77,1],[67,21,67,22,1],[68,17,68,18,1],[69,13,69,14,1],[71,13,71,29,1],[73,9,73,10,1],[81,9,81,10,0],[82,20,82,57,0],[83,13,83,14,0],[85,17,85,85,0],[86,17,86,67,0],[88,9,88,10,0]]);
    </script>
  </body>
</html>