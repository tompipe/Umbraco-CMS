<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Media\Exif\ImageFileDirectoryEntry.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;

namespace Umbraco.Core.Media.Exif
{
    /// &lt;summary&gt;
    /// Represents an entry in the image file directory.
    /// &lt;/summary&gt;
    internal struct ImageFileDirectoryEntry
    {
        /// &lt;summary&gt;
        /// The tag that identifies the field.
        /// &lt;/summary&gt;
        public ushort Tag;
        /// &lt;summary&gt;
        /// Field type identifier.
        /// &lt;/summary&gt;
        public ushort Type;
        /// &lt;summary&gt;
        /// Count of Type.
        /// &lt;/summary&gt;
        public uint Count;
        /// &lt;summary&gt;
        /// Field data.
        /// &lt;/summary&gt;
        public byte[] Data;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;ImageFileDirectoryEntry&quot;/&gt; struct.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;tag&quot;&gt;The tag that identifies the field.&lt;/param&gt;
        /// &lt;param name=&quot;type&quot;&gt;Field type identifier.&lt;/param&gt;
        /// &lt;param name=&quot;count&quot;&gt;Count of Type.&lt;/param&gt;
        /// &lt;param name=&quot;data&quot;&gt;Field data.&lt;/param&gt;
        public ImageFileDirectoryEntry(ushort tag, ushort type, uint count, byte[] data)
        {
            Tag = tag;
            Type = type;
            Count = count;
            Data = data;
        }

        /// &lt;summary&gt;
        /// Returns a &lt;see cref=&quot;ImageFileDirectoryEntry&quot;/&gt; initialized from the given byte data.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;data&quot;&gt;The data.&lt;/param&gt;
        /// &lt;param name=&quot;offset&quot;&gt;The offset into &lt;paramref name=&quot;data&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;byteOrder&quot;&gt;The byte order of &lt;paramref name=&quot;data&quot;/&gt;.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;ImageFileDirectoryEntry&quot;/&gt; initialized from the given byte data.&lt;/returns&gt;
        public static ImageFileDirectoryEntry FromBytes(byte[] data, uint offset, BitConverterEx.ByteOrder byteOrder)
        {
            // Tag ID
            ushort tag = BitConverterEx.ToUInt16(data, offset, byteOrder, BitConverterEx.SystemByteOrder);

            // Tag Type
            ushort type = BitConverterEx.ToUInt16(data, offset + 2, byteOrder, BitConverterEx.SystemByteOrder);

            // Count of Type
            uint count = BitConverterEx.ToUInt32(data, offset + 4, byteOrder, BitConverterEx.SystemByteOrder);

            // Field value or offset to field data
            byte[] value = new byte[4];
            Array.Copy(data, offset + 8, value, 0, 4);

            // Calculate the bytes we need to read
            uint baselength = GetBaseLength(type);
            uint totallength = count * baselength;

            // If field value does not fit in 4 bytes
            // the value field is an offset to the actual
            // field value
            if (totallength &gt; 4)
            {
                uint dataoffset = BitConverterEx.ToUInt32(value, 0, byteOrder, BitConverterEx.SystemByteOrder);
                value = new byte[totallength];
                Array.Copy(data, dataoffset, value, 0, totallength);
            }

            // Reverse array order if byte orders are different
            if (byteOrder != BitConverterEx.SystemByteOrder)
            {
                for (uint i = 0; i &lt; count; i++)
                {
                    byte[] val = new byte[baselength];
                    Array.Copy(value, i * baselength, val, 0, baselength);
                    Array.Reverse(val);
                    Array.Copy(val, 0, value, i * baselength, baselength);
                }
            }

            return new ImageFileDirectoryEntry(tag, type, count, value);
        }

        /// &lt;summary&gt;
        /// Gets the base byte length for the given type.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;Type identifier.&lt;/param&gt;
        private static uint GetBaseLength(ushort type)
        {
            if (type == 1 || type == 6) // BYTE and SBYTE
                return 1;
            else if (type == 2 || type == 7) // ASCII and UNDEFINED
                return 1;
            else if (type == 3 || type == 8) // SHORT and SSHORT
                return 2;
            else if (type == 4 || type == 9) // LONG and SLONG
                return 4;
            else if (type == 5 || type == 10) // RATIONAL (2xLONG) and SRATIONAL (2xSLONG)
                return 8;
            else if (type == 11) // FLOAT
                return 4;
            else if (type == 12) // DOUBLE
                return 8;

            throw new ArgumentException(&quot;Unknown type identifier.&quot;, &quot;type&quot;);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[35,9,35,10,0],[36,13,36,23,0],[37,13,37,25,0],[38,13,38,27,0],[39,13,39,25,0],[40,9,40,10,0],[50,9,50,10,0],[52,13,52,107,0],[55,13,55,112,0],[58,13,58,111,0],[61,13,61,40,0],[62,13,62,55,0],[65,13,65,51,0],[66,13,66,51,0],[71,13,71,33,0],[72,13,72,14,0],[73,17,73,112,0],[74,17,74,47,0],[75,17,75,69,0],[76,13,76,14,0],[79,13,79,61,0],[80,13,80,14,0],[81,22,81,32,0],[81,34,81,43,0],[81,45,81,48,0],[82,17,82,18,0],[83,21,83,55,0],[84,21,84,75,0],[85,21,85,40,0],[86,21,86,75,0],[87,17,87,18,0],[88,13,88,14,0],[90,13,90,73,0],[91,9,91,10,0],[98,9,98,10,0],[99,13,99,40,0],[100,17,100,26,0],[101,18,101,45,0],[102,17,102,26,0],[103,18,103,45,0],[104,17,104,26,0],[105,18,105,45,0],[106,17,106,26,0],[107,18,107,46,0],[108,17,108,26,0],[109,18,109,33,0],[110,17,110,26,0],[111,18,111,33,0],[112,17,112,26,0],[114,13,114,77,0],[115,9,115,10,0]]);
    </script>
  </body>
</html>