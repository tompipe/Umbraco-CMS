<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Strings\LegacyShortStringHelper.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using Umbraco.Core.Configuration;

namespace Umbraco.Core.Strings
{
    /// &lt;summary&gt;
    /// Legacy implementation of string functions for short strings such as aliases or url segments.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// &lt;para&gt;Not necessarily optimized to work on large bodies of text.&lt;/para&gt;
    /// &lt;para&gt;Can expose surprising or bogus behavior.&lt;/para&gt;
    /// &lt;para&gt;Uses invariant culture everywhere.&lt;/para&gt;
    /// &lt;/remarks&gt;
    internal class LegacyShortStringHelper : IShortStringHelper
    {
        #region Ctor and vars

        /// &lt;summary&gt;
        /// Freezes the helper so it can prevents its configuration from being modified.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Will be called by &lt;c&gt;ShortStringHelperResolver&lt;/c&gt; when resolution freezes.&lt;/remarks&gt;
        public void Freeze()
        {
            // we have nothing to protect.
        }

        const string UmbracoValidAliasCharacters = &quot;_-abcdefghijklmnopqrstuvwxyz1234567890&quot;;
        const string UmbracoInvalidFirstCharacters = &quot;0123456789&quot;;

        #endregion

        #region Short string services JavaScript

        const string SssjsValidCharacters = &quot;_-abcdefghijklmnopqrstuvwxyz1234567890&quot;;
        const string SssjsInvalidFirstCharacters = &quot;0123456789&quot;;

        private const string SssjsFormat = @&quot;
var UMBRACO_FORCE_SAFE_ALIAS = {0};
var UMBRACO_FORCE_SAFE_ALIAS_VALIDCHARS = &#39;{1}&#39;;
var UMBRACO_FORCE_SAFE_ALIAS_INVALID_FIRST_CHARS = &#39;{2}&#39;;

function safeAlias(alias) {{
    if (UMBRACO_FORCE_SAFE_ALIAS) {{
        var safeAlias = &#39;&#39;;
        var aliasLength = alias.length;
        for (var i = 0; i &lt; aliasLength; i++) {{
            currentChar = alias.substring(i, i + 1);
            if (UMBRACO_FORCE_SAFE_ALIAS_VALIDCHARS.indexOf(currentChar.toLowerCase()) &gt; -1) {{
                // check for camel (if previous character is a space, we&#39;ll upper case the current one
                if (safeAlias == &#39;&#39; &amp;&amp; UMBRACO_FORCE_SAFE_ALIAS_INVALID_FIRST_CHARS.indexOf(currentChar.toLowerCase()) &gt; 0) {{ 
                    currentChar = &#39;&#39;;
                }} else {{
                    // first char should always be lowercase (camel style)
                    if (safeAlias.length == 0)
                        currentChar = currentChar.toLowerCase();

                    if (i &lt; aliasLength - 1 &amp;&amp; safeAlias != &#39;&#39; &amp;&amp; alias.substring(i - 1, i) == &#39; &#39;)
                        currentChar = currentChar.toUpperCase();

                    safeAlias += currentChar;
                }}
            }}
        }}

        alias = safeAlias;
    }}
    return alias;
}}

function getSafeAlias(input, value, immediate, callback) {{
    callback(safeAlias(value));
}}

function validateSafeAlias(input, value, immediate, callback) {{
    callback(value == safeAlias(value));
}}

// legacy backward compatibility requires that one
function isValidAlias(alias) {{
    return alias == safeAlias(alias);
}}
&quot;;

        /// &lt;summary&gt;
        /// Gets the JavaScript code defining client-side short string services.
        /// &lt;/summary&gt;
        public string GetShortStringServicesJavaScript(string controllerPath)
        {
            return string.Format(SssjsFormat,
                UmbracoConfig.For.UmbracoSettings().Content.ForceSafeAliases ? &quot;true&quot; : &quot;false&quot;, SssjsValidCharacters, SssjsInvalidFirstCharacters);
        }

        #endregion

        #region IShortStringHelper CleanFor...

        /// &lt;summary&gt;
        /// Cleans a string to produce a string that can safely be used in an alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe alias.&lt;/returns&gt;
        /// &lt;remarks&gt;The string will be cleaned in the context of invariant culture.&lt;/remarks&gt;
        public string CleanStringForSafeAlias(string text)
        {
            // ported from StringExtensions.ToSafeAlias()

            const string validAliasCharacters = UmbracoValidAliasCharacters;
            const string invalidFirstCharacters = UmbracoInvalidFirstCharacters;
            var safeString = new StringBuilder();
            int aliasLength = text.Length;
            for (var i = 0; i &lt; aliasLength; i++)
            {
                var currentChar = text.Substring(i, 1);
                if (validAliasCharacters.Contains(currentChar.ToLowerInvariant()))
                {
                    // check for camel (if previous character is a space, we&#39;ll upper case the current one
                    if (safeString.Length == 0 &amp;&amp; invalidFirstCharacters.Contains(currentChar.ToLowerInvariant()))
                    {
                        //currentChar = &quot;&quot;;
                    }
                    else
                    {
                        if (i &lt; aliasLength - 1 &amp;&amp; i &gt; 0 &amp;&amp; text.Substring(i - 1, 1) == &quot; &quot;)
                            currentChar = currentChar.ToUpperInvariant();

                        safeString.Append(currentChar);
                    }
                }
            }

            return safeString.ToString();
        }

        /// &lt;summary&gt;
        /// Cleans a string, in the context of the invariant culture, to produce a string that can safely be used in an alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The safe alias.&lt;/returns&gt;
        /// &lt;remarks&gt;Legacy does not support culture contexts.&lt;/remarks&gt;
        public string CleanStringForSafeAlias(string text, CultureInfo culture)
        {
            return CleanStringForSafeAlias(text);
        }

        /// &lt;summary&gt;
        /// Cleans a string to produce a string that can safely be used in an url segment, in the context of the invariant culture.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe url segment.&lt;/returns&gt;
        public string CleanStringForUrlSegment(string text)
        {
            return LegacyFormatUrl(text);
        }

        /// &lt;summary&gt;
        /// Cleans a string, in the context of the invariant culture, to produce a string that can safely be used in an url segment.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The safe url segment.&lt;/returns&gt;
        /// &lt;remarks&gt;Legacy does not support culture contexts.&lt;/remarks&gt;
        public string CleanStringForUrlSegment(string text, CultureInfo culture)
        {
            return CleanStringForUrlSegment(text);
        }

        /// &lt;summary&gt;
        /// Cleans a string, in the context of the invariant culture, to produce a string that can safely be used as a filename,
        /// both internally (on disk) and externally (as a url).
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe filename.&lt;/returns&gt;
        /// &lt;remarks&gt;Legacy says this was used to &quot;overcome an issue when Umbraco is used in IE in an intranet environment&quot; but that issue is not documented.&lt;/remarks&gt;
        public string CleanStringForSafeFileName(string text)
        {
            var filePath = text;

            // ported from Core.IO.IOHelper.SafeFileName()

            if (String.IsNullOrEmpty(filePath))
                return String.Empty;

            if (!String.IsNullOrWhiteSpace(filePath))
            {
                foreach (var character in Path.GetInvalidFileNameChars())
                {
                    filePath = filePath.Replace(character, &#39;-&#39;);
                }
            }
            else
            {
                filePath = String.Empty;
            }

            //Break up the file in name and extension before applying the UrlReplaceCharacters
            var fileNamePart = filePath.Substring(0, filePath.LastIndexOf(&#39;.&#39;));
            var ext = filePath.Substring(filePath.LastIndexOf(&#39;.&#39;));

            //Because the file usually is downloadable as well we check characters against &#39;UmbracoSettings.UrlReplaceCharacters&#39;
            foreach (var n in UmbracoConfig.For.UmbracoSettings().RequestHandler.CharCollection)
            {
                if (n.Char.IsNullOrWhiteSpace() == false)
                    fileNamePart = fileNamePart.Replace(n.Char, n.Replacement);
            }

            filePath = string.Concat(fileNamePart, ext);

            // Adapted from: http://stackoverflow.com/a/4827510/5018
            // Combined both Reserved Characters and Character Data 
            // from http://en.wikipedia.org/wiki/Percent-encoding
            var stringBuilder = new StringBuilder();

            const string reservedCharacters = &quot;!*&#39;();:@&amp;=+$,/?%#[]-~{}\&quot;&lt;&gt;\\^`| &quot;;

            foreach (var character in filePath)
            {
                if (reservedCharacters.IndexOf(character) == -1)
                    stringBuilder.Append(character);
                else
                    stringBuilder.Append(&quot;-&quot;);
            }

            // Remove repeating dashes
            // From: http://stackoverflow.com/questions/5111967/regex-to-remove-a-specific-repeated-character
            var reducedString = Regex.Replace(stringBuilder.ToString(), &quot;-+&quot;, &quot;-&quot;);

            return reducedString;
        }

        /// &lt;summary&gt;
        /// Cleans a string, in the context of the invariant culture, to produce a string that can safely be used as a filename,
        /// both internally (on disk) and externally (as a url).
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The safe filename.&lt;/returns&gt;
        /// &lt;remarks&gt;Legacy does not support culture contexts.&lt;/remarks&gt;
        public string CleanStringForSafeFileName(string text, CultureInfo culture)
        {
            return CleanStringForSafeFileName(text);
        }

        #endregion

        #region CleanString

        // legacy does not implement these

        public string CleanString(string text, CleanStringType stringType)
        {
            return text;
        }

        public string CleanString(string text, CleanStringType stringType, char separator)
        {
            return text;
        }

        public string CleanString(string text, CleanStringType stringType, CultureInfo culture)
        {
            return text;
        }

        public string CleanString(string text, CleanStringType stringType, char separator, CultureInfo culture)
        {
            return text;
        }
        
        #endregion

        #region SplitPascalCasing

        /// &lt;summary&gt;
        /// Splits a pascal-cased string by inserting a separator in between each term.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to split.&lt;/param&gt;
        /// &lt;param name=&quot;separator&quot;&gt;The separator.&lt;/param&gt;
        /// &lt;returns&gt;The splitted string.&lt;/returns&gt;
        /// &lt;remarks&gt;Probably only supports Ascii strings.&lt;/remarks&gt;
        public string SplitPascalCasing(string text, char separator)
        {
            // ported from StringExtensions.SplitPascalCasing()

            var replacement = &quot;$1&quot; + separator;
            var result = Regex.Replace(text, &quot;([a-z](?=[A-Z])|[A-Z](?=[A-Z][a-z]))&quot;, replacement);
            return result;
        }
        
        #endregion

        #region Legacy

        /// &lt;summary&gt;
        /// Cleans a string to produce a string that can safely be used in an alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe alias.&lt;/returns&gt;
        /// &lt;remarks&gt;The string will be cleaned in the context of invariant culture.&lt;/remarks&gt;
        public string LegacyCleanStringForUmbracoAlias(string text)
        {
            // ported from StringExtensions.ToUmbracoAlias()
            // kept here for reference, not used anymore

            if (string.IsNullOrEmpty(text)) return string.Empty;

            //convert case first
            //var tmp = text.ConvertCase(caseType);
            // note: always Camel anyway
            var tmp = LegacyConvertStringCase(text, CleanStringType.CamelCase);

            //remove non-alphanumeric chars
            var result = Regex.Replace(tmp, @&quot;[^a-zA-Z0-9\s\.-]+&quot;, &quot;&quot;, RegexOptions.Compiled);

            // note: spaces are always removed anyway
            //if (removeSpaces)
            //    result = result.Replace(&quot; &quot;, &quot;&quot;);

            return result;
        }

        /// &lt;summary&gt;
        /// Filters a string to convert case, and more.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;phrase&quot;&gt;the text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;cases&quot;&gt;The string case type.&lt;/param&gt;
        /// &lt;returns&gt;The filtered text.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is the legacy method, so we can&#39;t really change it, although it has issues (see unit tests).&lt;/para&gt;
        /// &lt;para&gt;It does more than &quot;converting the case&quot;, and also remove spaces, etc.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public string LegacyConvertStringCase(string phrase, CleanStringType cases)
        {
            // ported from StringExtensions.ConvertCase

            cases &amp;= CleanStringType.CaseMask;

            var splittedPhrase = Regex.Split(phrase, @&quot;[^a-zA-Z0-9\&#39;]&quot;, RegexOptions.Compiled);

            if (cases == CleanStringType.Unchanged)
                return string.Join(&quot;&quot;, splittedPhrase);

            //var splittedPhrase = phrase.Split(&#39; &#39;, &#39;-&#39;, &#39;.&#39;);
            var sb = new StringBuilder();

            foreach (var splittedPhraseChars in splittedPhrase.Select(s =&gt; s.ToCharArray()))
            {
                if (splittedPhraseChars.Length &gt; 0)
                {
                    splittedPhraseChars[0] = ((new String(splittedPhraseChars[0], 1)).ToUpperInvariant().ToCharArray())[0];
                }
                sb.Append(new String(splittedPhraseChars));
            }

            var result = sb.ToString();

            if (cases == CleanStringType.CamelCase)
            {
                if (result.Length &gt; 1)
                {
                    var pattern = new Regex(&quot;^([A-Z]*)([A-Z].*)$&quot;, RegexOptions.Singleline | RegexOptions.Compiled);
                    var match = pattern.Match(result);
                    if (match.Success)
                    {
                        result = match.Groups[1].Value.ToLowerInvariant() + match.Groups[2].Value;

                        return result.Substring(0, 1).ToLowerInvariant() + result.Substring(1);
                    }

                    return result;
                }

                return result.ToLowerInvariant();
            }

            return result;
        }

        /// &lt;summary&gt;
        /// Converts string to a URL alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
        /// &lt;param name=&quot;charReplacements&quot;&gt;The char replacements.&lt;/param&gt;
        /// &lt;param name=&quot;replaceDoubleDashes&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; replace double dashes.&lt;/param&gt;
        /// &lt;param name=&quot;stripNonAscii&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; strip non ASCII.&lt;/param&gt;
        /// &lt;param name=&quot;urlEncode&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; URL encode.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// This ensures that ONLY ascii chars are allowed and of those ascii chars, only digits and lowercase chars, all
        /// punctuation, etc... are stripped out, however this method allows you to pass in string&#39;s to replace with the
        /// specified replacement character before the string is converted to ascii and it has invalid characters stripped out.
        /// This allows you to replace strings like &amp;amp; , etc.. with your replacement character before the automatic
        /// reduction.
        /// &lt;/remarks&gt;
        public string LegacyToUrlAlias(string value, IDictionary&lt;string, string&gt; charReplacements, bool replaceDoubleDashes, bool stripNonAscii, bool urlEncode)
        {
            // to lower case invariant
            // replace chars one by one using charReplacements
            // (opt) convert to ASCII then remove anything that&#39;s not ASCII
            // trim - and _ then (opt) remove double -
            // (opt) url-encode

            // charReplacement is actually *string* replacement ie it can replace &quot;&amp;nbsp;&quot; by a non-breaking space
            // so it&#39;s kind of a pre-filter actually...
            // we need pre-filters, and post-filters, within each token...
            // not so... we may want to replace &amp;nbsp; with a space BEFORE cutting into tokens...

            //first to lower case
            value = value.ToLowerInvariant();

            //then replacement chars
            value = charReplacements.Aggregate(value, (current, kvp) =&gt; current.Replace(kvp.Key, kvp.Value));

            //then convert to only ascii, this will remove the rest of any invalid chars
            if (stripNonAscii)
            {
                value = Encoding.ASCII.GetString(
                    Encoding.Convert(
                        Encoding.UTF8,
                        Encoding.GetEncoding(
                            Encoding.ASCII.EncodingName,
                            new EncoderReplacementFallback(String.Empty),
                            new DecoderExceptionFallback()),
                        Encoding.UTF8.GetBytes(value)));

                //remove all characters that do not fall into the following categories (apart from the replacement val)
                var validCodeRanges =
                    //digits
                    Enumerable.Range(48, 10).Concat(
                    //lowercase chars
                        Enumerable.Range(97, 26));

                var sb = new StringBuilder();
                foreach (var c in value.Where(c =&gt; charReplacements.Values.Contains(c.ToString(CultureInfo.InvariantCulture)) || validCodeRanges.Contains(c)))
                {
                    sb.Append(c);
                }

                value = sb.ToString();
            }

            //trim dashes from end
            value = value.Trim(&#39;-&#39;, &#39;_&#39;);

            //replace double occurances of - or _
            value = replaceDoubleDashes ? Regex.Replace(value, @&quot;([-_]){2,}&quot;, &quot;$1&quot;, RegexOptions.Compiled) : value;

            //url encode result
            return urlEncode ? System.Web.HttpUtility.UrlEncode(value) : value;
        }

        /// &lt;summary&gt;
        /// Cleans a string to produce a string that can safely be used in an url segment.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;url&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe url segment.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Uses &lt;c&gt;UmbracoSettings.UrlReplaceCharacters&lt;/c&gt;
        ///  and &lt;c&gt;UmbracoSettings.RemoveDoubleDashesFromUrlReplacing&lt;/c&gt;.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public string LegacyFormatUrl(string url)
        {
            var newUrl = url.ToLowerInvariant();
            foreach (var n in UmbracoConfig.For.UmbracoSettings().RequestHandler.CharCollection)
            {
                if (n.Char != &quot;&quot;)
                    newUrl = newUrl.Replace(n.Char, n.Replacement);
            }

            // check for double dashes
            if (UmbracoConfig.For.UmbracoSettings().RequestHandler.RemoveDoubleDashes)
            {
                newUrl = Regex.Replace(newUrl, @&quot;[-]{2,}&quot;, &quot;-&quot;);
            }

            return newUrl;
        }

        #endregion

        #region ReplaceMany

        /// &lt;summary&gt;
        /// Returns a new string in which all occurences of specified strings are replaced by other specified strings.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The string to filter.&lt;/param&gt;
        /// &lt;param name=&quot;replacements&quot;&gt;The replacements definition.&lt;/param&gt;
        /// &lt;returns&gt;The filtered string.&lt;/returns&gt;
        public string ReplaceMany(string text, IDictionary&lt;string, string&gt; replacements)
        {
            // Have done various tests, implementing my own &quot;super fast&quot; state machine to handle 
            // replacement of many items, or via regexes, but on short strings and not too
            // many replacements (which prob. is going to be our case) nothing can beat this...
            // (at least with safe and checked code -- we don&#39;t want unsafe/unchecked here)

            // Note that it will do chained-replacements ie replaced items can be replaced
            // in turn by another replacement (ie the order of replacements is important)

            return replacements.Aggregate(text, (current, kvp) =&gt; current.Replace(kvp.Key, kvp.Value));
        }

        /// &lt;summary&gt;
        /// Returns a new string in which all occurences of specified characters are replaced by a specified character.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The string to filter.&lt;/param&gt;
        /// &lt;param name=&quot;chars&quot;&gt;The characters to replace.&lt;/param&gt;
        /// &lt;param name=&quot;replacement&quot;&gt;The replacement character.&lt;/param&gt;
        /// &lt;returns&gt;The filtered string.&lt;/returns&gt;
        public string ReplaceMany(string text, char[] chars, char replacement)
        {
            // be safe
            if (text == null)
                throw new ArgumentNullException(&quot;text&quot;);
            if (chars == null)
                throw new ArgumentNullException(&quot;chars&quot;);

            // see note above

            return chars.Aggregate(text, (current, c) =&gt; current.Replace(c, replacement));
        }

        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[30,9,30,10,1],[32,9,32,10,1],[95,9,95,10,0],[96,13,97,149,0],[98,9,98,10,0],[111,9,111,10,1],[116,13,116,50,1],[117,13,117,43,1],[118,18,118,27,1],[118,29,118,44,1],[118,46,118,49,1],[119,13,119,14,1],[120,17,120,56,1],[121,17,121,83,1],[122,17,122,18,1],[124,21,124,115,1],[125,21,125,22,1],[127,21,127,22,1],[129,21,129,22,1],[130,25,130,93,1],[131,29,131,74,1],[133,25,133,56,1],[134,21,134,22,1],[135,17,135,18,1],[136,13,136,14,1],[138,13,138,42,1],[139,9,139,10,1],[149,9,149,10,0],[150,13,150,50,0],[151,9,151,10,0],[159,9,159,10,0],[160,13,160,42,0],[161,9,161,10,0],[171,9,171,10,0],[172,13,172,51,0],[173,9,173,10,0],[183,9,183,10,1],[184,13,184,33,1],[188,13,188,48,1],[189,17,189,37,0],[191,13,191,54,1],[192,13,192,14,1],[193,17,193,24,1],[193,26,193,39,1],[193,40,193,42,1],[193,43,193,73,1],[194,17,194,18,1],[195,21,195,65,1],[196,17,196,18,1],[197,13,197,14,1],[199,13,199,14,0],[200,17,200,41,0],[201,13,201,14,0],[204,13,204,81,1],[205,13,205,69,1],[208,13,208,20,1],[208,22,208,27,1],[208,28,208,30,1],[208,31,208,96,1],[209,13,209,14,1],[210,17,210,58,1],[211,21,211,80,1],[212,13,212,14,1],[214,13,214,57,1],[219,13,219,53,1],[223,13,223,20,1],[223,22,223,35,1],[223,36,223,38,1],[223,39,223,47,1],[224,13,224,14,1],[225,17,225,65,1],[226,21,226,53,1],[228,21,228,47,1],[229,13,229,14,1],[233,13,233,84,1],[235,13,235,34,1],[236,9,236,10,1],[247,9,247,10,0],[248,13,248,53,0],[249,9,249,10,0],[258,9,258,10,1],[259,13,259,25,1],[260,9,260,10,1],[263,9,263,10,1],[264,13,264,25,1],[265,9,265,10,1],[268,9,268,10,0],[269,13,269,25,0],[270,9,270,10,0],[273,9,273,10,0],[274,13,274,25,0],[275,9,275,10,0],[289,9,289,10,1],[292,13,292,48,1],[293,13,293,99,1],[294,13,294,27,1],[295,9,295,10,1],[308,9,308,10,1],[312,13,312,44,1],[312,45,312,65,0],[317,13,317,80,1],[320,13,320,95,1],[326,13,326,27,1],[327,9,327,10,1],[340,9,340,10,1],[343,13,343,47,1],[345,13,345,96,1],[347,13,347,52,1],[348,17,348,56,1],[351,13,351,42,1],[353,13,353,20,1],[353,22,353,45,1],[353,46,353,48,1],[353,49,353,76,1],[353,76,353,91,1],[353,91,353,92,1],[353,49,353,92,1],[354,13,354,14,1],[355,17,355,52,1],[356,17,356,18,1],[357,21,357,124,1],[358,17,358,18,1],[359,17,359,60,1],[360,13,360,14,1],[362,13,362,40,1],[364,13,364,52,1],[365,13,365,14,1],[366,17,366,39,1],[367,17,367,18,1],[368,21,368,117,1],[369,21,369,55,1],[370,21,370,39,1],[371,21,371,22,1],[372,25,372,99,1],[374,25,374,96,1],[377,21,377,35,0],[380,17,380,50,0],[383,13,383,27,1],[384,9,384,10,1],[403,9,403,10,1],[416,13,416,46,1],[419,13,419,73,1],[419,73,419,108,1],[419,108,419,110,1],[419,13,419,110,1],[422,13,422,31,1],[423,13,423,14,1],[424,17,431,57,1],[434,17,438,51,1],[440,17,440,46,1],[441,17,441,24,1],[441,26,441,31,1],[441,32,441,34,1],[441,35,441,52,1],[441,52,441,157,1],[441,157,441,158,1],[441,35,441,158,1],[442,17,442,18,1],[443,21,443,34,1],[444,17,444,18,1],[446,17,446,39,1],[447,13,447,14,1],[450,13,450,42,1],[453,13,453,116,1],[456,13,456,80,1],[457,9,457,10,1],[469,9,469,10,1],[470,13,470,49,1],[471,13,471,20,1],[471,22,471,27,1],[471,28,471,30,1],[471,31,471,96,1],[472,13,472,14,1],[473,17,473,34,1],[474,21,474,68,1],[475,13,475,14,1],[478,13,478,87,1],[479,13,479,14,1],[480,17,480,65,1],[481,13,481,14,1],[483,13,483,27,1],[484,9,484,10,1],[497,9,497,10,1],[506,13,506,67,1],[506,67,506,102,1],[506,102,506,104,1],[506,13,506,104,1],[507,9,507,10,1],[517,9,517,10,1],[519,13,519,30,1],[520,17,520,57,0],[521,13,521,31,1],[522,17,522,58,0],[526,13,526,58,1],[526,58,526,89,1],[526,89,526,91,1],[526,13,526,91,1],[527,9,527,10,1]]);
    </script>
  </body>
</html>