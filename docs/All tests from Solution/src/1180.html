<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Models\PublishedContentBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Umbraco.Core;
using Umbraco.Core.Models;
using Umbraco.Core.Models.PublishedContent;

namespace Umbraco.Web.Models
{
    /// &lt;summary&gt;
    /// Provide an abstract base class for &lt;c&gt;IPublishedContent&lt;/c&gt; implementations.
	/// &lt;/summary&gt;
	/// &lt;remarks&gt;This base class does which (a) consitently resolves and caches the Url, (b) provides an implementation
    /// for this[alias], and (c) provides basic content set management.&lt;/remarks&gt;
    [DebuggerDisplay(&quot;Content Id: {Id}, Name: {Name}&quot;)]
    public abstract class PublishedContentBase : IPublishedContent
    {
        #region Content

        private string _url;

	    /// &lt;summary&gt;
		/// Gets the url of the content.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// If this content is Content, the url that is returned is the one computed by the NiceUrlProvider, otherwise if 
		/// this content is Media, the url returned is the value found in the &#39;umbracoFile&#39; property.
		/// &lt;/remarks&gt;
		public virtual string Url
		{
	        get
	        {
	            // should be thread-safe although it won&#39;t prevent url from being resolved more than once
	            if (_url != null)
	                return _url;

	            switch (ItemType)
	            {
	                case PublishedItemType.Content:
	                    if (UmbracoContext.Current == null)
	                        throw new InvalidOperationException(
	                            &quot;Cannot resolve a Url for a content item when UmbracoContext.Current is null.&quot;);
	                    if (UmbracoContext.Current.UrlProvider == null)
	                        throw new InvalidOperationException(
	                            &quot;Cannot resolve a Url for a content item when UmbracoContext.Current.UrlProvider is null.&quot;);
	                    _url = UmbracoContext.Current.UrlProvider.GetUrl(Id);
	                    break;
	                case PublishedItemType.Media:
	                    var prop = GetProperty(Constants.Conventions.Media.File);
	                    if (prop == null || prop.Value == null)
	                    {
	                        _url = string.Empty;
	                        return _url;
	                    }

	                    var propType = ContentType.GetPropertyType(Constants.Conventions.Media.File);

	                    //This is a hack - since we now have 2 properties that support a URL: upload and cropper, we need to detect this since we always
	                    // want to return the normal URL and the cropper stores data as json
	                    switch (propType.PropertyEditorAlias)
	                    {
	                        case Constants.PropertyEditors.UploadFieldAlias:
	                            _url = prop.Value.ToString();
	                            break;
	                        case Constants.PropertyEditors.ImageCropperAlias:
	                            //get the url from the json format

	                            var stronglyTyped = prop.Value as ImageCropDataSet;
	                            if (stronglyTyped != null)
	                            {
                                    _url = stronglyTyped.Src;
                                    break;
                                }

                                var json = prop.Value as JObject;
	                            if (json != null)
	                            {
                                    _url = json.ToObject&lt;ImageCropDataSet&gt;(new JsonSerializer { Culture = CultureInfo.InvariantCulture, FloatParseHandling = FloatParseHandling.Decimal }).Src;
	                                break;
	                            }
                                
	                            _url = prop.Value.ToString();
	                            break;
	                    }
	                    break;
	                default:
	                    throw new NotSupportedException();
	            }

	            return _url;
	        }
		}

		public abstract PublishedItemType ItemType { get; }
		public abstract int Id { get; }
		public abstract int TemplateId { get; }
		public abstract int SortOrder { get; }
		public abstract string Name { get; }
		public abstract string UrlName { get; }
		public abstract string DocumentTypeAlias { get; }
		public abstract int DocumentTypeId { get; }
		public abstract string WriterName { get; }
		public abstract string CreatorName { get; }
		public abstract int WriterId { get; }
		public abstract int CreatorId { get; }
		public abstract string Path { get; }
		public abstract DateTime CreateDate { get; }
		public abstract DateTime UpdateDate { get; }
		public abstract Guid Version { get; }
		public abstract int Level { get; }

        public abstract bool IsDraft { get; }
        
        public int GetIndex()
        {
            var index = this.Siblings().FindIndex(x =&gt; x.Id == Id);
            if (index &lt; 0)
                throw new IndexOutOfRangeException(&quot;Could not find content in the content set.&quot;);
            return index;
        }

        #endregion

        #region Tree

        /// &lt;summary&gt;
        /// Gets the parent of the content.
        /// &lt;/summary&gt;
        public abstract IPublishedContent Parent { get; }

        /// &lt;summary&gt;
        /// Gets the children of the content.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Children are sorted by their sortOrder.&lt;/remarks&gt;
        public abstract IEnumerable&lt;IPublishedContent&gt; Children { get; }

        #endregion

        #region ContentSet

        public virtual IEnumerable&lt;IPublishedContent&gt; ContentSet
        {
            // the default content set of a content is its siblings
            get { return this.Siblings(); }
        }

        #endregion

        #region ContentType

        public abstract PublishedContentType ContentType { get; }

        #endregion

        #region Properties

        /// &lt;summary&gt;
        /// Gets the properties of the content.
        /// &lt;/summary&gt;
        public abstract ICollection&lt;IPublishedProperty&gt; Properties { get; }

        /// &lt;summary&gt;
        /// Gets the value of a property identified by its alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;returns&gt;The value of the property identified by the alias.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;If &lt;c&gt;GetProperty(alias)&lt;/c&gt; is &lt;c&gt;null&lt;/c&gt; then returns &lt;c&gt;null&lt;/c&gt; else return &lt;c&gt;GetProperty(alias).Value&lt;/c&gt;.&lt;/para&gt;
        /// &lt;para&gt;So if the property has no value, returns the default value for that property type.&lt;/para&gt;
        /// &lt;para&gt;This one is defined here really because we cannot define index extension methods, but all it should do is:
        /// &lt;code&gt;var p = GetProperty(alias); return p == null ? null : p.Value;&lt;/code&gt; and nothing else.&lt;/para&gt;
        /// &lt;para&gt;The recursive syntax (eg &quot;_title&quot;) is _not_ supported here.&lt;/para&gt;
        /// &lt;para&gt;The alias is case-insensitive.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public virtual object this[string alias]
		{
			get
			{
                // no cache here: GetProperty should be fast, and .Value cache should be managed by the property.              
                var property = GetProperty(alias);
			    return property == null ? null : property.Value;
			}
		}

        /// &lt;summary&gt;
        /// Gets a property identified by its alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;returns&gt;The property identified by the alias.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;If no property with the specified alias exists, returns &lt;c&gt;null&lt;/c&gt;.&lt;/para&gt;
        /// &lt;para&gt;The returned property may have no value (ie &lt;c&gt;HasValue&lt;/c&gt; is &lt;c&gt;false&lt;/c&gt;).&lt;/para&gt;
        /// &lt;para&gt;The alias is case-insensitive.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public abstract IPublishedProperty GetProperty(string alias);

        /// &lt;summary&gt;
        /// Gets a property identified by its alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The property alias.&lt;/param&gt;
        /// &lt;param name=&quot;recurse&quot;&gt;A value indicating whether to navigate the tree upwards until a property with a value is found.&lt;/param&gt;
        /// &lt;returns&gt;The property identified by the alias.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Navigate the tree upwards and look for a property with that alias and with a value (ie &lt;c&gt;HasValue&lt;/c&gt; is &lt;c&gt;true&lt;/c&gt;).
        /// If found, return the property. If no property with that alias is found, having a value or not, return &lt;c&gt;null&lt;/c&gt;. Otherwise
        /// return the first property that was found with the alias but had no value (ie &lt;c&gt;HasValue&lt;/c&gt; is &lt;c&gt;false&lt;/c&gt;).&lt;/para&gt;
        /// &lt;para&gt;The alias is case-insensitive.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public virtual IPublishedProperty GetProperty(string alias, bool recurse)
        {
            var property = GetProperty(alias);
            if (recurse == false) return property;

            IPublishedContent content = this;
            var firstNonNullProperty = property;
            while (content != null &amp;&amp; (property == null || property.HasValue == false))
            {
                content = content.Parent;
                property = content == null ? null : content.GetProperty(alias);
                if (firstNonNullProperty == null &amp;&amp; property != null) firstNonNullProperty = property;
            }

            // if we find a content with the property with a value, return that property
            // if we find no content with the property, return null
            // if we find a content with the property without a value, return that property
            //   have to save that first property while we look further up, hence firstNonNullProperty

            return property != null &amp;&amp; property.HasValue ? property : firstNonNullProperty;
        }

        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[35,10,35,11,0],[37,14,37,31,0],[38,18,38,30,0],[40,14,40,31,0],[43,22,43,57,0],[44,26,45,110,0],[46,22,46,69,0],[47,26,48,122,0],[49,22,49,75,0],[50,22,50,28,0],[52,22,52,79,0],[53,22,53,61,0],[54,22,54,23,0],[55,26,55,46,0],[56,26,56,38,0],[59,22,59,99,0],[63,22,63,59,0],[66,30,66,59,0],[67,30,67,36,0],[71,30,71,81,0],[72,30,72,56,0],[73,30,73,31,0],[74,37,74,62,0],[75,37,75,43,0],[78,33,78,66,0],[79,30,79,47,0],[80,30,80,31,0],[81,37,81,192,0],[82,34,82,40,0],[85,30,85,59,0],[86,30,86,36,0],[88,22,88,28,0],[90,22,90,56,0],[93,14,93,26,0],[94,10,94,11,0],[118,9,118,10,1],[119,13,119,56,1],[119,56,119,66,1],[119,66,119,68,1],[119,13,119,68,1],[120,13,120,27,1],[121,17,121,98,0],[122,13,122,26,1],[123,9,123,10,1],[147,17,147,18,1],[147,19,147,42,1],[147,43,147,44,1],[181,4,181,5,0],[183,17,183,51,0],[184,8,184,56,0],[185,4,185,5,0],[213,9,213,10,1],[214,13,214,47,1],[215,13,215,34,1],[215,35,215,51,0],[217,13,217,46,1],[218,13,218,49,1],[219,13,219,88,1],[220,13,220,14,1],[221,17,221,42,1],[222,17,222,80,1],[223,17,223,70,1],[223,71,223,103,0],[224,13,224,14,1],[231,13,231,92,1],[232,9,232,10,1]]);
    </script>
  </body>
</html>