<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Routing\NotFoundHandlerHelper.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Web;
using System.Xml;
using System.Reflection;
using umbraco.cms.businesslogic.web;
using Umbraco.Core;
using Umbraco.Core.Logging;
using umbraco.interfaces;
using Umbraco.Core.Configuration;
using Umbraco.Core.Configuration.UmbracoSettings;
using Umbraco.Core.Models;
using Umbraco.Core.Services;
using Umbraco.Core.Xml;

namespace Umbraco.Web.Routing
{
    // provides internal access to legacy url -- should get rid of it eventually
    internal class NotFoundHandlerHelper
    {
        const string ContextKey = &quot;Umbraco.Web.Routing.NotFoundHandlerHelper.Url&quot;;

        static NotFoundHandlerHelper()
        {
            InitializeNotFoundHandlers();
        }

        public static string GetLegacyUrlForNotFoundHandlers()
        {
            // that&#39;s not backward-compatible because when requesting &quot;/foo.aspx&quot;
            // 4.9  : url = &quot;foo.aspx&quot;
            // 4.10 : url = &quot;/foo&quot;
            //return pcr.Uri.AbsolutePath;

            // so we have to run the legacy code for url preparation :-(

            var httpContext = HttpContext.Current;

            if (httpContext == null)
                return &quot;&quot;;

            var url = httpContext.Items[ContextKey] as string;
            if (url != null)
                return url;

            // code from requestModule.UmbracoRewrite
            var tmp = httpContext.Request.Path.ToLower();

            // note: requestModule.UmbracoRewrite also did some stripping of &amp;umbPage
            // from the querystring... that was in v3.x to fix some issues with pre-forms
            // auth. Paul Sterling confirmed in jan. 2013 that we can get rid of it.

            // code from requestHandler.cleanUrl
            var root = Core.IO.SystemDirectories.Root.ToLower();
            if (!string.IsNullOrEmpty(root) &amp;&amp; tmp.StartsWith(root))
                tmp = tmp.Substring(root.Length);
            tmp = tmp.TrimEnd(&#39;/&#39;);
            if (tmp == &quot;/default.aspx&quot;)
                tmp = string.Empty;
            else if (tmp == root)
                tmp = string.Empty;

            // code from UmbracoDefault.Page_PreInit
            if (tmp != &quot;&quot; &amp;&amp; httpContext.Request[&quot;umbPageID&quot;] == null)
            {
                var tryIntParse = tmp.Replace(&quot;/&quot;, &quot;&quot;).Replace(&quot;.aspx&quot;, string.Empty);
                int result;
                if (int.TryParse(tryIntParse, out result))
                    tmp = tmp.Replace(&quot;.aspx&quot;, string.Empty);
            }
            else if (!string.IsNullOrEmpty(httpContext.Request[&quot;umbPageID&quot;]))
            {
                int result;
                if (int.TryParse(httpContext.Request[&quot;umbPageID&quot;], out result))
                {
                    tmp = httpContext.Request[&quot;umbPageID&quot;];
                }
            }

            // code from requestHandler.ctor
            if (tmp != &quot;&quot;)
                tmp = tmp.Substring(1);

            httpContext.Items[ContextKey] = tmp;
            return tmp;
        }

        private static IEnumerable&lt;Type&gt; _customHandlerTypes;
        private static Type _customLastChanceHandlerType;

        static void InitializeNotFoundHandlers()
        {
            // initialize handlers
            // create the definition cache

            LogHelper.Debug&lt;NotFoundHandlerHelper&gt;(&quot;Registering custom handlers.&quot;);

            var customHandlerTypes = new List&lt;Type&gt;();
            Type customHandlerType = null;

            var customHandlers = new XmlDocument();
            customHandlers.Load(Core.IO.IOHelper.MapPath(Core.IO.SystemFiles.NotFoundhandlersConfig));

            foreach (XmlNode n in customHandlers.DocumentElement.SelectNodes(&quot;notFound&quot;))
            {
                if (customHandlerType != null)
                {
                    LogHelper.Debug&lt;NotFoundHandlerHelper&gt;(&quot;Registering &#39;{0}&#39;.&quot;, () =&gt; customHandlerType.FullName);
                    customHandlerTypes.Add(customHandlerType);
                }

                var assemblyName = n.Attributes.GetNamedItem(&quot;assembly&quot;).Value;
                var typeName = n.Attributes.GetNamedItem(&quot;type&quot;).Value;

                var ns = assemblyName;
                var nsAttr = n.Attributes.GetNamedItem(&quot;namespace&quot;);
                if (nsAttr != null &amp;&amp; string.IsNullOrWhiteSpace(nsAttr.Value) == false)
                    ns = nsAttr.Value;

                LogHelper.Debug&lt;NotFoundHandlerHelper&gt;(&quot;Configured: &#39;{0}.{1},{2}&#39;.&quot;, () =&gt; ns, () =&gt; typeName, () =&gt; assemblyName);

                customHandlerType = null;
                try
                {
                    var assembly = Assembly.Load(new AssemblyName(assemblyName));
                    customHandlerType = assembly.GetType(ns + &quot;.&quot; + typeName);
                }
                catch (Exception e)
                {
                    LogHelper.Error&lt;NotFoundHandlerHelper&gt;(&quot;Error: could not load handler, ignoring.&quot;, e);
                }
            }

            // what shall we do with the last one, assuming it&#39;s not null?
            // if the last chance finder wants a handler, then use the last one as the last chance handler
            // else assume that the last one is a normal handler since noone else wants it, and add it to the list
            if (customHandlerType != null)
            {
                var lastChanceFinder = ContentLastChanceFinderResolver.Current.Finder; // can be null
                var finderWantsHandler = lastChanceFinder != null &amp;&amp;
                    lastChanceFinder.GetType() == typeof(ContentLastChanceFinderByNotFoundHandlers);

                if (finderWantsHandler)
                {
                    LogHelper.Debug&lt;NotFoundHandlerHelper&gt;(&quot;Registering &#39;{0}&#39; as \&quot;last chance\&quot; handler.&quot;, () =&gt; customHandlerType.FullName);
                    _customLastChanceHandlerType = customHandlerType;
                }
                else
                {
                    LogHelper.Debug&lt;NotFoundHandlerHelper&gt;(&quot;Registering &#39;{0}&#39;.&quot;, () =&gt; customHandlerType.FullName);
                    customHandlerTypes.Add(customHandlerType);
                    _customLastChanceHandlerType = null;
                }
            }

            _customHandlerTypes = customHandlerTypes.ToArray();
        }

        public static IEnumerable&lt;INotFoundHandler&gt; GetNotFoundHandlers()
        {
            // instanciate new handlers
            // using definition cache

            var handlers = new List&lt;INotFoundHandler&gt;();

            foreach (var type in _customHandlerTypes)
            {
                try
                {
                    var handler = Activator.CreateInstance(type) as INotFoundHandler;
                    if (handler != null)
                        handlers.Add(handler);
                }
                catch (Exception e)
                {
                    LogHelper.Error&lt;ContentFinderByNotFoundHandlers&gt;(string.Format(&quot;Error instanciating handler {0}, ignoring.&quot;, type.FullName), e);
                }
            }

            return handlers;
        }

        public static bool IsNotFoundHandlerEnabled&lt;T&gt;()
        {
            return _customHandlerTypes.Contains(typeof(T));
        }

        public static INotFoundHandler GetNotFoundLastChanceHandler()
        {
            if (_customLastChanceHandlerType == null) return null;

            try
            {
                var handler = Activator.CreateInstance(_customLastChanceHandlerType) as INotFoundHandler;
                if (handler != null)
                    return handler;
            }
            catch (Exception e)
            {
                LogHelper.Error&lt;ContentFinderByNotFoundHandlers&gt;(string.Format(&quot;Error instanciating handler {0}, ignoring.&quot;, _customLastChanceHandlerType.FullName), e);
            }

            return null;
        }

        public static IContentFinder SubsituteFinder(INotFoundHandler handler)
        {
            IContentFinder finder = null;

            if (handler is global::umbraco.SearchForAlias)
                finder = new ContentFinderByUrlAlias();
            else if (handler is global::umbraco.SearchForProfile)
                finder = new ContentFinderByProfile();
            else if (handler is global::umbraco.SearchForTemplate)
                finder = new ContentFinderByNiceUrlAndTemplate();
            else if (handler is global::umbraco.handle404)
                finder = new ContentFinderByLegacy404();

            return finder;
        }

        /// &lt;summary&gt;
        /// Returns the Umbraco page id to use as the Not Found page based on the configured 404 pages and the current request
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;error404Collection&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;requestServerName&quot;&gt;
        /// The server name attached to the request, normally would be the source of HttpContext.Current.Request.ServerVariables[&quot;SERVER_NAME&quot;]
        /// &lt;/param&gt;
        /// &lt;param name=&quot;entityService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;publishedContentQuery&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;domainService&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal static int? GetCurrentNotFoundPageId(
            IContentErrorPage[] error404Collection,
            string requestServerName,
            IEntityService entityService,
            ITypedPublishedContentQuery publishedContentQuery,
            IDomainService domainService)
        {
            throw new NotImplementedException();
        }

        internal static int? GetCurrentNotFoundPageId(
            IContentErrorPage[] error404Collection, 
            IEntityService entityService,
            ITypedPublishedContentQuery publishedContentQuery,
            CultureInfo errorCulture)
        {
            if (error404Collection.Length &gt; 1)
            {
                // test if a 404 page exists with current culture thread
                var cultureErr = error404Collection.FirstOrDefault(x =&gt; x.Culture == errorCulture.Name)
                    ?? error404Collection.FirstOrDefault(x =&gt; x.Culture == &quot;default&quot;); // there should be a default one!

                if (cultureErr != null)
                    return GetContentIdFromErrorPageConfig(cultureErr, entityService, publishedContentQuery);
            }
            else
            {
                return GetContentIdFromErrorPageConfig(error404Collection.First(), entityService, publishedContentQuery);
            }

            return null;
        }

        /// &lt;summary&gt;
        /// Returns the content id based on the configured IContentErrorPage section
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;errorPage&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;entityService&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;publishedContentQuery&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal static int? GetContentIdFromErrorPageConfig(IContentErrorPage errorPage, IEntityService entityService, ITypedPublishedContentQuery publishedContentQuery)
        {
            if (errorPage.HasContentId) return errorPage.ContentId;

            if (errorPage.HasContentKey)
            {
                //need to get the Id for the GUID
                //TODO: When we start storing GUIDs into the IPublishedContent, then we won&#39;t have to look this up 
                // but until then we need to look it up in the db. For now we&#39;ve implemented a cached service for 
                // converting Int -&gt; Guid and vice versa.
                var found = entityService.GetIdForKey(errorPage.ContentKey, UmbracoObjectTypes.Document);
                if (found)
                {
                    return found.Result;
                }
                return null;
            }

            if (errorPage.ContentXPath.IsNullOrWhiteSpace() == false)
            {
                try
                {
                    //we have an xpath statement to execute
                    var xpathResult = UmbracoXPathPathSyntaxParser.ParseXPathQuery(
                        xpathExpression: errorPage.ContentXPath,
                        nodeContextId: null,
                        getPath: nodeid =&gt;
                        {
                            var ent = entityService.Get(nodeid);
                            return ent.Path.Split(&#39;,&#39;).Reverse();
                        },
                        publishedContentExists: i =&gt; publishedContentQuery.TypedContent(i) != null);

                    //now we&#39;ll try to execute the expression
                    var nodeResult = publishedContentQuery.TypedContentSingleAtXPath(xpathResult);
                    if (nodeResult != null) 
                        return nodeResult.Id;
                }
                catch (Exception ex)
                {
                    LogHelper.Error&lt;NotFoundHandlerHelper&gt;(&quot;Could not parse xpath expression: &quot; + errorPage.ContentXPath, ex);
                    return null;
                }
            }
            return null;
        }

    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[26,9,26,10,0],[27,13,27,42,0],[28,9,28,10,0],[31,9,31,10,0],[39,13,39,51,0],[41,13,41,37,0],[42,17,42,27,0],[44,13,44,63,0],[45,13,45,29,0],[46,17,46,28,0],[49,13,49,58,0],[56,13,56,65,0],[57,13,57,69,0],[58,17,58,50,0],[59,13,59,36,0],[60,13,60,40,0],[61,17,61,36,0],[62,18,62,34,0],[63,17,63,36,0],[66,13,66,71,0],[67,13,67,14,0],[68,17,68,87,0],[70,17,70,59,0],[71,21,71,62,0],[72,13,72,14,0],[73,18,73,78,0],[74,13,74,14,0],[76,17,76,80,0],[77,17,77,18,0],[78,21,78,60,0],[79,17,79,18,0],[80,13,80,14,0],[83,13,83,27,0],[84,17,84,40,0],[86,13,86,49,0],[87,13,87,24,0],[88,9,88,10,0],[94,9,94,10,0],[98,13,98,84,0],[100,13,100,55,0],[101,13,101,43,0],[103,13,103,52,0],[104,13,104,103,0],[106,13,106,20,0],[106,22,106,31,0],[106,32,106,34,0],[106,35,106,89,0],[107,13,107,14,0],[108,17,108,47,0],[109,17,109,18,0],[110,21,110,88,0],[110,88,110,114,0],[110,114,110,116,0],[110,21,110,116,0],[111,21,111,63,0],[112,17,112,18,0],[114,17,114,80,0],[115,17,115,72,0],[117,17,117,39,0],[118,17,118,69,0],[119,17,119,88,0],[120,21,120,39,0],[122,17,122,92,0],[122,92,122,94,0],[122,94,122,102,0],[122,102,122,110,0],[122,110,122,118,0],[122,118,122,130,0],[122,130,122,132,0],[122,17,122,132,0],[124,17,124,42,0],[126,17,126,18,0],[127,21,127,82,0],[128,21,128,79,0],[129,17,129,18,0],[130,17,130,36,0],[131,17,131,18,0],[132,21,132,107,0],[133,17,133,18,0],[134,13,134,14,0],[139,13,139,43,0],[140,13,140,14,0],[141,17,141,87,0],[142,17,143,101,0],[145,17,145,40,0],[146,17,146,18,0],[147,21,147,115,0],[147,115,147,141,0],[147,141,147,143,0],[147,21,147,143,0],[148,21,148,70,0],[149,17,149,18,0],[151,17,151,18,0],[152,21,152,88,0],[152,88,152,114,0],[152,114,152,116,0],[152,21,152,116,0],[153,21,153,63,0],[154,21,154,57,0],[155,17,155,18,0],[156,13,156,14,0],[158,13,158,64,0],[159,9,159,10,0],[162,9,162,10,0],[166,13,166,57,0],[168,13,168,20,0],[168,22,168,30,0],[168,31,168,33,0],[168,34,168,53,0],[169,13,169,14,0],[171,17,171,18,0],[172,21,172,86,0],[173,21,173,41,0],[174,25,174,47,0],[175,17,175,18,0],[176,17,176,36,0],[177,17,177,18,0],[178,21,178,149,0],[179,17,179,18,0],[180,13,180,14,0],[182,13,182,29,0],[183,9,183,10,0],[186,9,186,10,0],[187,13,187,60,0],[188,9,188,10,0],[191,9,191,10,0],[192,13,192,54,0],[192,55,192,67,0],[195,13,195,14,0],[196,17,196,106,0],[197,17,197,37,0],[198,21,198,36,0],[199,13,199,14,0],[200,13,200,32,0],[201,13,201,14,0],[202,17,202,169,0],[203,13,203,14,0],[205,13,205,25,0],[206,9,206,10,0],[209,9,209,10,0],[210,13,210,42,0],[212,13,212,59,0],[213,17,213,56,0],[214,18,214,66,0],[215,17,215,55,0],[216,18,216,67,0],[217,17,217,66,0],[218,18,218,59,0],[219,17,219,57,0],[221,13,221,27,0],[222,9,222,10,0],[241,9,241,10,0],[242,13,242,49,0],[250,9,250,10,0],[251,13,251,47,0],[252,13,252,14,0],[254,17,254,73,0],[254,73,254,103,0],[254,103,255,63,0],[255,63,255,85,0],[255,85,255,87,0],[254,17,255,87,0],[257,17,257,40,0],[258,21,258,110,0],[259,13,259,14,0],[261,13,261,14,0],[262,17,262,122,0],[265,13,265,25,0],[266,9,266,10,0],[276,9,276,10,0],[277,13,277,40,0],[277,41,277,68,0],[279,13,279,41,0],[280,13,280,14,0],[285,17,285,106,0],[286,17,286,27,0],[287,17,287,18,0],[288,21,288,41,0],[290,17,290,29,0],[293,13,293,70,0],[294,13,294,14,0],[296,17,296,18,0],[298,21,302,25,0],[302,25,302,26,0],[302,26,303,29,0],[303,29,303,65,0],[303,65,304,29,0],[304,29,304,66,0],[304,66,305,25,0],[305,25,305,26,0],[305,26,306,54,0],[306,54,306,99,0],[306,99,306,101,0],[298,21,306,101,0],[309,21,309,99,0],[310,21,310,44,0],[311,25,311,46,0],[312,17,312,18,0],[313,17,313,37,0],[314,17,314,18,0],[315,21,315,127,0],[316,21,316,33,0],[318,13,318,14,0],[319,13,319,25,0],[320,9,320,10,0]]);
    </script>
  </body>
</html>