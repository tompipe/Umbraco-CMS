<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Cache\HttpRuntimeCacheProvider.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Web.Caching;
using CacheItemPriority = System.Web.Caching.CacheItemPriority;

namespace Umbraco.Core.Cache
{
    /// &lt;summary&gt;
    /// A CacheProvider that wraps the logic of the HttpRuntime.Cache
    /// &lt;/summary&gt;
    internal class HttpRuntimeCacheProvider : DictionaryCacheProviderBase, IRuntimeCacheProvider
    {
        // locker object that supports upgradeable read locking
        // does not need to support recursion if we implement the cache correctly and ensure
        // that methods cannot be reentrant, ie we do NOT create values while holding a lock.
        private readonly ReaderWriterLockSlim _locker = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);

        private readonly System.Web.Caching.Cache _cache;

        /// &lt;summary&gt;
        /// Used for debugging
        /// &lt;/summary&gt;
        internal Guid InstanceId { get; private set; }

        public HttpRuntimeCacheProvider(System.Web.Caching.Cache cache)
        {
            _cache = cache;
            InstanceId = Guid.NewGuid();
        }

        protected override IEnumerable&lt;DictionaryEntry&gt; GetDictionaryEntries()
        {
            const string prefix = CacheItemPrefix + &quot;-&quot;;
            return _cache.Cast&lt;DictionaryEntry&gt;()
                .Where(x =&gt; x.Key is string &amp;&amp; ((string)x.Key).StartsWith(prefix));
        }

        protected override void RemoveEntry(string key)
        {
            _cache.Remove(key);
        }

        protected override object GetEntry(string key)
        {
            return _cache.Get(key);
        }

        #region Lock

        protected override IDisposable ReadLock
        {
            get { return new ReadLock(_locker); }
        }

        protected override IDisposable WriteLock
        {
            get { return new WriteLock(_locker); }
        }

        #endregion

        #region Get

        /// &lt;summary&gt;
        /// Gets (and adds if necessary) an item from the cache with all of the default parameters
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;cacheKey&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;getCacheItem&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public override object GetCacheItem(string cacheKey, Func&lt;object&gt; getCacheItem)
        {
            return GetCacheItem(cacheKey, getCacheItem, null, dependentFiles: null);
        }

        /// &lt;summary&gt;
        /// This overload is here for legacy purposes
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;cacheKey&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;getCacheItem&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;timeout&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;isSliding&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;priority&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;removedCallback&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dependency&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal object GetCacheItem(string cacheKey, Func&lt;object&gt; getCacheItem, TimeSpan? timeout, bool isSliding = false, CacheItemPriority priority = CacheItemPriority.Normal, CacheItemRemovedCallback removedCallback = null, CacheDependency dependency = null)
        {
            cacheKey = GetCacheKey(cacheKey);

            // NOTE - because we don&#39;t know what getCacheItem does, how long it will take and whether it will hang,
            // getCacheItem should run OUTSIDE of the global application lock else we run into lock contention and
            // nasty performance issues.

            // So.... we insert a Lazy&lt;object&gt; in the cache while holding the global application lock, and then rely
            // on the Lazy lock to ensure that getCacheItem runs once and everybody waits on it, while the global
            // application lock has been released.

            // NOTE 
            //   The Lazy value creation may produce a null value.
            //   Must make sure (for backward compatibility) that we pretend they are not in the cache.
            //   So if we find an entry in the cache that already has its value created and is null,
            //   pretend it was not there. If value is not already created, wait... and return null, that&#39;s
            //   what prior code did.

            // NOTE
            //   The Lazy value creation may throw.

            // So... the null value _will_ be in the cache but never returned

            Lazy&lt;object&gt; result;

            // Fast!
            // Only one thread can enter an UpgradeableReadLock at a time, but it does not prevent other
            // threads to enter a ReadLock in the meantime -- only upgrading to WriteLock will prevent all
            // reads. We first try with a normal ReadLock for maximum concurrency and take the penalty of
            // having to re-lock in case there&#39;s no value. Would need to benchmark to figure out whether
            // it&#39;s worth it, though...
            using (new ReadLock(_locker))
            {
                result = _cache.Get(cacheKey) as Lazy&lt;object&gt;; // null if key not found
            }
            var value = result == null ? null : GetSafeLazyValue(result);
            if (value != null) return value;

            using (var lck = new UpgradeableReadLock(_locker))
            {
                result = _cache.Get(cacheKey) as Lazy&lt;object&gt;; // null if key not found

                // cannot create value within the lock, so if result.IsValueCreated is false, just
                // do nothing here - means that if creation throws, a race condition could cause
                // more than one thread to reach the return statement below and throw - accepted.

                if (result == null || GetSafeLazyValue(result, true) == null) // get non-created as NonCreatedValue &amp; exceptions as null
                {
                    result = GetSafeLazy(getCacheItem);
                    var absolute = isSliding ? System.Web.Caching.Cache.NoAbsoluteExpiration : (timeout == null ? System.Web.Caching.Cache.NoAbsoluteExpiration : DateTime.Now.Add(timeout.Value));
                    var sliding = isSliding == false ? System.Web.Caching.Cache.NoSlidingExpiration : (timeout ?? System.Web.Caching.Cache.NoSlidingExpiration);

                    lck.UpgradeToWriteLock();
                    //NOTE: &#39;Insert&#39; on System.Web.Caching.Cache actually does an add or update!
                    _cache.Insert(cacheKey, result, dependency, absolute, sliding, priority, removedCallback);
                }
            }

            // using GetSafeLazy and GetSafeLazyValue ensures that we don&#39;t cache
            // exceptions (but try again and again) and silently eat them - however at
            // some point we have to report them - so need to re-throw here

            // this does not throw anymore
            //return result.Value;

            value = result.Value; // will not throw (safe lazy)
            var eh = value as ExceptionHolder;
            if (eh != null) throw eh.Exception; // throw once!
            return value;
        }

        public object GetCacheItem(string cacheKey, Func&lt;object&gt; getCacheItem, TimeSpan? timeout, bool isSliding = false, CacheItemPriority priority = CacheItemPriority.Normal, CacheItemRemovedCallback removedCallback = null, string[] dependentFiles = null)
        {
            CacheDependency dependency = null;
            if (dependentFiles != null &amp;&amp; dependentFiles.Any())
            {
                dependency = new CacheDependency(dependentFiles);
            }
            return GetCacheItem(cacheKey, getCacheItem, timeout, isSliding, priority, removedCallback, dependency);
        }

        #endregion

        #region Insert

        /// &lt;summary&gt;
        /// This overload is here for legacy purposes
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;cacheKey&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;getCacheItem&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;timeout&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;isSliding&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;priority&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;removedCallback&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;dependency&quot;&gt;&lt;/param&gt;
        internal void InsertCacheItem(string cacheKey, Func&lt;object&gt; getCacheItem, TimeSpan? timeout = null, bool isSliding = false, CacheItemPriority priority = CacheItemPriority.Normal, CacheItemRemovedCallback removedCallback = null, CacheDependency dependency = null)
        {
            // NOTE - here also we must insert a Lazy&lt;object&gt; but we can evaluate it right now
            // and make sure we don&#39;t store a null value.

            var result = GetSafeLazy(getCacheItem);
            var value = result.Value; // force evaluation now - this may throw if cacheItem throws, and then nothing goes into cache
            if (value == null) return; // do not store null values (backward compat)

            cacheKey = GetCacheKey(cacheKey);

            var absolute = isSliding ? System.Web.Caching.Cache.NoAbsoluteExpiration : (timeout == null ? System.Web.Caching.Cache.NoAbsoluteExpiration : DateTime.Now.Add(timeout.Value));
            var sliding = isSliding == false ? System.Web.Caching.Cache.NoSlidingExpiration : (timeout ?? System.Web.Caching.Cache.NoSlidingExpiration);

            using (new WriteLock(_locker))
            {
                //NOTE: &#39;Insert&#39; on System.Web.Caching.Cache actually does an add or update!
                _cache.Insert(cacheKey, result, dependency, absolute, sliding, priority, removedCallback);
            }
        }

        public void InsertCacheItem(string cacheKey, Func&lt;object&gt; getCacheItem, TimeSpan? timeout = null, bool isSliding = false, CacheItemPriority priority = CacheItemPriority.Normal, CacheItemRemovedCallback removedCallback = null, string[] dependentFiles = null)
        {
            CacheDependency dependency = null;
            if (dependentFiles != null &amp;&amp; dependentFiles.Any())
            {
                dependency = new CacheDependency(dependentFiles);
            }
            InsertCacheItem(cacheKey, getCacheItem, timeout, isSliding, priority, removedCallback, dependency);
        }

        #endregion
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[19,9,19,115,1],[26,36,26,40,0],[26,41,26,53,1],[28,9,28,72,1],[29,9,29,10,1],[30,13,30,28,1],[31,13,31,41,1],[32,9,32,10,1],[35,9,35,10,1],[37,13,38,29,1],[38,29,38,82,1],[38,82,38,84,1],[37,13,38,84,1],[39,9,39,10,1],[42,9,42,10,1],[43,13,43,32,1],[44,9,44,10,1],[47,9,47,10,1],[48,13,48,36,1],[49,9,49,10,1],[55,17,55,18,1],[55,19,55,48,1],[55,49,55,50,1],[60,17,60,18,1],[60,19,60,49,1],[60,50,60,51,1],[74,9,74,10,1],[75,13,75,85,1],[76,9,76,10,1],[90,9,90,10,1],[91,13,91,46,1],[121,13,121,42,1],[122,13,122,14,1],[123,17,123,63,1],[124,13,124,14,1],[125,13,125,74,1],[126,13,126,31,1],[126,32,126,45,1],[128,20,128,62,1],[129,13,129,14,1],[130,17,130,63,1],[136,17,136,78,1],[137,17,137,18,1],[138,21,138,56,1],[139,21,139,196,1],[140,21,140,161,1],[142,21,142,46,1],[144,21,144,111,1],[145,17,145,18,1],[146,13,146,14,1],[155,13,155,34,1],[156,13,156,47,1],[157,13,157,28,1],[157,29,157,48,1],[158,13,158,26,1],[159,9,159,10,1],[162,9,162,10,1],[163,13,163,47,1],[164,13,164,64,1],[165,13,165,14,0],[166,17,166,66,0],[167,13,167,14,0],[168,13,168,116,1],[169,9,169,10,1],[186,9,186,10,1],[190,13,190,52,1],[191,13,191,38,1],[192,13,192,31,1],[192,32,192,39,0],[194,13,194,46,1],[196,13,196,188,1],[197,13,197,153,1],[199,13,199,43,1],[200,13,200,14,1],[202,17,202,107,1],[203,13,203,14,1],[204,9,204,10,1],[207,9,207,10,1],[208,13,208,47,1],[209,13,209,64,1],[210,13,210,14,0],[211,17,211,66,0],[212,13,212,14,0],[213,13,213,112,1],[214,9,214,10,1]]);
    </script>
  </body>
</html>