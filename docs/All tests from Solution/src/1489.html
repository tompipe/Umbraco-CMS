<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Macros\MacroTagParser.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using HtmlAgilityPack;

namespace Umbraco.Core.Macros
{
	/// &lt;summary&gt;
	/// Parses the macro syntax in a string and renders out it&#39;s contents
	/// &lt;/summary&gt;
	internal class MacroTagParser
	{
	    private static readonly Regex MacroRteContent = new Regex(@&quot;(&lt;!--\s*?)(&lt;\?UMBRACO_MACRO.*?/&gt;)(\s*?--&gt;)&quot;,
	        RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.Singleline);

	    private static readonly Regex MacroPersistedFormat =
	        new Regex(@&quot;(&lt;\?UMBRACO_MACRO (?:.+?)??macroAlias=[&quot;&quot;&#39;]([^&quot;&quot;\&#39;\n\r]+?)[&quot;&quot;&#39;].+?)(?:/&gt;|&gt;.*?&lt;/\?UMBRACO_MACRO&gt;)&quot;,
	            RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.Singleline);

	    /// &lt;summary&gt;
	    /// This formats the persisted string to something useful for the rte so that the macro renders properly since we 
	    /// persist all macro formats like {?UMBRACO_MACRO macroAlias=\&quot;myMacro\&quot; /}
	    /// &lt;/summary&gt;
	    /// &lt;param name=&quot;persistedContent&quot;&gt;&lt;/param&gt;
	    /// &lt;param name=&quot;htmlAttributes&quot;&gt;The html attributes to be added to the div&lt;/param&gt;
	    /// &lt;returns&gt;&lt;/returns&gt;
	    /// &lt;remarks&gt;
	    /// This converts the persisted macro format to this:
	    /// 
	    ///     {div class=&#39;umb-macro-holder&#39;}
	    ///         &lt;!-- &lt;?UMBRACO_MACRO macroAlias=\&quot;myMacro\&quot; /&gt; --&gt;
	    ///         {ins}Macro alias: {strong}My Macro{/strong}{/ins}
	    ///     {/div}
	    /// 
	    /// &lt;/remarks&gt;
	    internal static string FormatRichTextPersistedDataForEditor(string persistedContent, IDictionary&lt;string ,string&gt; htmlAttributes)
        {
            return MacroPersistedFormat.Replace(persistedContent, match =&gt;
            {
                if (match.Groups.Count &gt;= 3)
                {
                    //&lt;div class=&quot;umb-macro-holder myMacro mceNonEditable&quot;&gt;
                    var alias = match.Groups[2].Value;
                    var sb = new StringBuilder(&quot;&lt;div class=\&quot;umb-macro-holder &quot;);
                    //sb.Append(alias.ToSafeAlias());
                    sb.Append(&quot;mceNonEditable\&quot;&quot;);
                    foreach (var htmlAttribute in htmlAttributes)
                    {
                        sb.Append(&quot; &quot;);
                        sb.Append(htmlAttribute.Key);
                        sb.Append(&quot;=\&quot;&quot;);
                        sb.Append(htmlAttribute.Value);
                        sb.Append(&quot;\&quot;&quot;);
                    }
                    sb.AppendLine(&quot;&gt;&quot;);
                    sb.Append(&quot;&lt;!-- &quot;);
                    sb.Append(match.Groups[1].Value.Trim());
                    sb.Append(&quot; /&gt;&quot;);
                    sb.AppendLine(&quot; --&gt;&quot;);
                    sb.Append(&quot;&lt;ins&gt;&quot;);
                    sb.Append(&quot;Macro alias: &quot;);
                    sb.Append(&quot;&lt;strong&gt;&quot;);
                    sb.Append(alias);
                    sb.Append(&quot;&lt;/strong&gt;&lt;/ins&gt;&lt;/div&gt;&quot;);
                    return sb.ToString();
                }
                //replace with nothing if we couldn&#39;t find the syntax for whatever reason
                return &quot;&quot;;
            });
        }

        /// &lt;summary&gt;
        /// This formats the string content posted from a rich text editor that contains macro contents to be persisted.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// 
        /// This is required because when editors are using the rte, the html that is contained in the editor might actually be displaying 
        /// the entire macro content, when the data is submitted the editor will clear most of this data out but we&#39;ll still need to parse it properly
        /// and ensure the correct sytnax is persisted to the db.
        /// 
        /// When a macro is inserted into the rte editor, the html will be:
        /// 
        ///     {div class=&#39;umb-macro-holder&#39;}
        ///         &lt;!-- &lt;?UMBRACO_MACRO macroAlias=\&quot;myMacro\&quot; /&gt; --&gt;
        ///         This could be some macro content
        ///     {/div}
        /// 
        /// What this method will do is remove the {div} and parse out the commented special macro syntax: {?UMBRACO_MACRO macroAlias=\&quot;myMacro\&quot; /}
        /// since this is exactly how we need to persist it to the db.
        /// 
        /// &lt;/remarks&gt;
        internal static string FormatRichTextContentForPersistence(string rteContent)
        {
            if (string.IsNullOrEmpty(rteContent))
            {
                return string.Empty;
            }

            var html = new HtmlDocument();
            html.LoadHtml(rteContent);

            //get all the comment nodes we want
            var commentNodes = html.DocumentNode.SelectNodes(&quot;//comment()[contains(., &#39;&lt;?UMBRACO_MACRO&#39;)]&quot;);
            if (commentNodes == null)
            {
                //There are no macros found, just return the normal content
                return rteContent;
            }

            //replace each containing parent &lt;div&gt; with the comment node itself. 
            foreach (var c in commentNodes)
            {
                var div = c.ParentNode;
                var divContainer = div.ParentNode;
                divContainer.ReplaceChild(c, div);
            }

            var parsed = html.DocumentNode.OuterHtml;

            //now replace all the &lt;!-- and --&gt; with nothing
            return MacroRteContent.Replace(parsed, match =&gt;
                {
                    if (match.Groups.Count &gt;= 3)
                    {
                        //get the 3rd group which is the macro syntax
                        return match.Groups[2].Value;
                    }
                    //replace with nothing if we couldn&#39;t find the syntax for whatever reason
                    return string.Empty;
                });
        }

		/// &lt;summary&gt;
		/// This will accept a text block and seach/parse it for macro markup.
		/// When either a text block or a a macro is found, it will call the callback method.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;text&quot;&gt; &lt;/param&gt;
		/// &lt;param name=&quot;textFoundCallback&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;macroFoundCallback&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		/// &lt;remarks&gt;
		/// This method  simply parses the macro contents, it does not create a string or result, 
		/// this is up to the developer calling this method to implement this with the callbacks.
		/// &lt;/remarks&gt;
		internal static void ParseMacros(
			string text,
			Action&lt;string&gt; textFoundCallback, 
			Action&lt;string, Dictionary&lt;string, string&gt;&gt; macroFoundCallback )
		{
			if (textFoundCallback == null) throw new ArgumentNullException(&quot;textFoundCallback&quot;);
			if (macroFoundCallback == null) throw new ArgumentNullException(&quot;macroFoundCallback&quot;);

			string elementText = text;

			var fieldResult = new StringBuilder(elementText);

			//NOTE: This is legacy code, this is definitely not the correct way to do a while loop! :)
			var stop = false;
			while (!stop)
			{
				var tagIndex = fieldResult.ToString().ToLower().IndexOf(&quot;&lt;?umbraco&quot;);
				if (tagIndex &lt; 0)
					tagIndex = fieldResult.ToString().ToLower().IndexOf(&quot;&lt;umbraco:macro&quot;);
				if (tagIndex &gt; -1)
				{
					var tempElementContent = &quot;&quot;;

					//text block found, call the call back method
					textFoundCallback(fieldResult.ToString().Substring(0, tagIndex));

					fieldResult.Remove(0, tagIndex);

					var tag = fieldResult.ToString().Substring(0, fieldResult.ToString().IndexOf(&quot;&gt;&quot;) + 1);
					var attributes = XmlHelper.GetAttributesFromElement(tag);

					// Check whether it&#39;s a single tag (&lt;?.../&gt;) or a tag with children (&lt;?..&gt;...&lt;/?...&gt;)
					if (tag.Substring(tag.Length - 2, 1) != &quot;/&quot; &amp;&amp; tag.IndexOf(&quot; &quot;) &gt; -1)
					{
						String closingTag = &quot;&lt;/&quot; + (tag.Substring(1, tag.IndexOf(&quot; &quot;) - 1)) + &quot;&gt;&quot;;
						// Tag with children are only used when a macro is inserted by the umbraco-editor, in the
						// following format: &quot;&lt;?UMBRACO_MACRO ...&gt;&lt;IMG SRC=&quot;...&quot;..&gt;&lt;/?UMBRACO_MACRO&gt;&quot;, so we
						// need to delete extra information inserted which is the image-tag and the closing
						// umbraco_macro tag
						if (fieldResult.ToString().IndexOf(closingTag) &gt; -1)
						{
							fieldResult.Remove(0, fieldResult.ToString().IndexOf(closingTag));
						}
					}

				    var macroAlias = attributes.ContainsKey(&quot;macroalias&quot;) ? attributes[&quot;macroalias&quot;] : attributes[&quot;alias&quot;];

					//call the callback now that we have the macro parsed
					macroFoundCallback(macroAlias, attributes);

					fieldResult.Remove(0, fieldResult.ToString().IndexOf(&quot;&gt;&quot;) + 1);
					fieldResult.Insert(0, tempElementContent);
				}
				else
				{
					//text block found, call the call back method
					textFoundCallback(fieldResult.ToString());

					stop = true; //break;
				}
			}
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[14,6,15,117,1],[17,6,19,121,1],[38,9,38,10,1],[39,13,40,13,1],[40,13,40,14,1],[40,14,41,17,1],[41,17,41,45,1],[41,45,42,17,1],[42,17,42,18,1],[42,18,44,21,1],[44,21,44,55,1],[44,55,45,21,1],[45,21,45,82,1],[45,82,47,21,1],[47,21,47,51,1],[47,51,48,21,1],[48,21,48,28,1],[48,28,48,30,1],[48,30,48,47,1],[48,47,48,48,1],[48,48,48,50,1],[48,50,48,51,1],[48,51,48,65,1],[48,65,49,21,1],[49,21,49,22,1],[49,22,50,25,1],[50,25,50,40,1],[50,40,51,25,1],[51,25,51,54,1],[51,54,52,25,1],[52,25,52,42,1],[52,42,53,25,1],[53,25,53,56,1],[53,56,54,25,1],[54,25,54,41,1],[54,41,55,21,1],[55,21,55,22,1],[55,22,56,21,1],[56,21,56,40,1],[56,40,57,21,1],[57,21,57,40,1],[57,40,58,21,1],[58,21,58,61,1],[58,61,59,21,1],[59,21,59,38,1],[59,38,60,21,1],[60,21,60,43,1],[60,43,61,21,1],[61,21,61,40,1],[61,40,62,21,1],[62,21,62,48,1],[62,48,63,21,1],[63,21,63,43,1],[63,43,64,21,1],[64,21,64,38,1],[64,38,65,21,1],[65,21,65,56,1],[65,56,66,21,1],[66,21,66,42,1],[66,42,69,17,1],[69,17,69,27,0],[69,27,70,13,1],[70,13,70,14,1],[70,14,70,16,1],[39,13,70,16,1],[71,9,71,10,1],[95,9,95,10,1],[96,13,96,50,1],[97,13,97,14,0],[98,17,98,37,0],[101,13,101,43,1],[102,13,102,39,1],[105,13,105,109,1],[106,13,106,38,1],[107,13,107,14,1],[109,17,109,35,1],[113,13,113,20,1],[113,22,113,27,1],[113,28,113,30,1],[113,31,113,43,1],[114,13,114,14,1],[115,17,115,40,1],[116,17,116,51,1],[117,17,117,51,1],[118,13,118,14,1],[120,13,120,54,1],[123,13,124,17,1],[124,17,124,18,1],[124,18,125,21,1],[125,21,125,49,1],[125,49,126,21,1],[126,21,126,22,1],[126,22,128,25,1],[128,25,128,54,1],[128,54,131,21,1],[131,21,131,41,0],[131,41,132,17,1],[132,17,132,18,1],[132,18,132,20,1],[123,13,132,20,1],[133,9,133,10,1],[151,3,151,4,1],[152,4,152,34,1],[152,35,152,88,0],[153,4,153,35,1],[153,36,153,90,0],[155,4,155,30,1],[157,4,157,53,1],[160,4,160,21,1],[161,4,161,17,1],[162,4,162,5,1],[163,5,163,74,1],[164,5,164,22,1],[165,6,165,76,1],[166,5,166,23,1],[167,5,167,6,0],[168,6,168,34,0],[171,6,171,71,0],[173,6,173,38,0],[175,6,175,93,0],[176,6,176,63,0],[179,6,179,75,0],[180,6,180,7,0],[181,7,181,81,0],[186,7,186,59,0],[187,7,187,8,0],[188,8,188,74,0],[189,7,189,8,0],[190,6,190,7,0],[192,9,192,112,0],[195,6,195,49,0],[197,6,197,69,0],[198,6,198,48,0],[199,5,199,6,0],[201,5,201,6,1],[203,6,203,48,1],[205,6,205,18,1],[206,5,206,6,1],[207,4,207,5,1],[208,3,208,4,1]]);
    </script>
  </body>
</html>