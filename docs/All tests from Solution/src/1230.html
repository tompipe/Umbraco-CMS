<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Models\ContentEditing\ContentTypeSave.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Runtime.Serialization;
using Umbraco.Core;

namespace Umbraco.Web.Models.ContentEditing
{
    /// &lt;summary&gt;
    /// Abstract model used to save content types
    /// &lt;/summary&gt;
    [DataContract(Name = &quot;contentType&quot;, Namespace = &quot;&quot;)]
    public abstract class ContentTypeSave : ContentTypeBasic, IValidatableObject
    {
        protected ContentTypeSave()
        {
            AllowedContentTypes = new List&lt;int&gt;();
            CompositeContentTypes = new List&lt;string&gt;();
        }

        //Compositions
        [DataMember(Name = &quot;compositeContentTypes&quot;)]
        public IEnumerable&lt;string&gt; CompositeContentTypes { get; set; }

        [DataMember(Name = &quot;isContainer&quot;)]
        public bool IsContainer { get; set; }

        [DataMember(Name = &quot;allowAsRoot&quot;)]
        public bool AllowAsRoot { get; set; }

        //Allowed child types
        [DataMember(Name = &quot;allowedContentTypes&quot;)]
        public IEnumerable&lt;int&gt; AllowedContentTypes { get; set; }

        /// &lt;summary&gt;
        /// Custom validation
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;validationContext&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public virtual IEnumerable&lt;ValidationResult&gt; Validate(ValidationContext validationContext)
        {
            if (CompositeContentTypes.Any(x =&gt; x.IsNullOrWhiteSpace()))
                yield return new ValidationResult(&quot;Composite Content Type value cannot be null&quot;, new[] {&quot;CompositeContentTypes&quot;});
        }
    }

    /// &lt;summary&gt;
    /// Abstract model used to save content types
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TPropertyType&quot;&gt;&lt;/typeparam&gt;
    [DataContract(Name = &quot;contentType&quot;, Namespace = &quot;&quot;)]
    public abstract class ContentTypeSave&lt;TPropertyType&gt; : ContentTypeSave
        where TPropertyType : PropertyTypeBasic
    {
        protected ContentTypeSave()
        {
            Groups = new List&lt;PropertyGroupBasic&lt;TPropertyType&gt;&gt;();
        }
        
        //Tabs
        [DataMember(Name = &quot;groups&quot;)]
        public IEnumerable&lt;PropertyGroupBasic&lt;TPropertyType&gt;&gt; Groups { get; set; }

        /// &lt;summary&gt;
        /// Custom validation
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;validationContext&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public override IEnumerable&lt;ValidationResult&gt; Validate(ValidationContext validationContext)
        {
            foreach (var validationResult in base.Validate(validationContext))
            {
                yield return validationResult;
            }

            var duplicateGroups = Groups.GroupBy(x =&gt; x.Name).Where(x =&gt; x.Count() &gt; 1).ToArray();
            if (duplicateGroups.Any())
            {
                //we need to return the field name with an index so it&#39;s wired up correctly
                var lastIndex = Groups.IndexOf(duplicateGroups.Last().Last());
                yield return new ValidationResult(&quot;Duplicate group names not allowed&quot;, new[]
                {
                    string.Format(&quot;Groups[{0}].Name&quot;, lastIndex)
                });
            }

            var duplicateProperties = Groups.SelectMany(x =&gt; x.Properties).Where(x =&gt; x.Inherited == false).GroupBy(x =&gt; x.Alias).Where(x =&gt; x.Count() &gt; 1).ToArray();
            if (duplicateProperties.Any())
            {
                //we need to return the field name with an index so it&#39;s wired up correctly
                var lastProperty = duplicateProperties.Last().Last();
                var propertyGroup = Groups.Single(x =&gt; x.Properties.Contains(lastProperty));                

                yield return new ValidationResult(&quot;Duplicate property aliases not allowed: &quot; + lastProperty.Alias, new[]
                {
                    string.Format(&quot;Groups[{0}].Properties[{1}].Alias&quot;, propertyGroup.SortOrder, lastProperty.SortOrder)
                });
            }

        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[15,9,15,36,1],[16,9,16,10,1],[17,13,17,51,1],[18,13,18,56,1],[19,9,19,10,1],[23,60,23,64,1],[23,65,23,69,1],[26,35,26,39,1],[26,40,26,44,1],[29,35,29,39,1],[29,40,29,44,1],[33,55,33,59,1],[33,60,33,64,1],[55,9,55,36,1],[56,9,56,10,1],[57,13,57,68,1],[58,9,58,10,1],[62,72,62,76,1],[62,77,62,81,1]]);
    </script>
  </body>
</html>