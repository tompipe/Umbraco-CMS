<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Mvc\ValidateMvcAngularAntiForgeryTokenAttribute.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Security.Claims;
using System.Web.Mvc;
using Umbraco.Web.WebApi.Filters;

namespace Umbraco.Web.Mvc
{
    /// &lt;summary&gt;
    /// A filter to check for the csrf token based on Angular&#39;s standard approach
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// Code derived from http://ericpanorel.net/2013/07/28/spa-authentication-and-csrf-mvc4-antiforgery-implementation/
    /// 
    /// If the authentication type is cookie based, then this filter will execute, otherwise it will be disabled
    /// &lt;/remarks&gt;
    public sealed class ValidateMvcAngularAntiForgeryTokenAttribute : ActionFilterAttribute
    {
        public override void OnActionExecuting(ActionExecutingContext filterContext)
        {
            var userIdentity = filterContext.HttpContext.User.Identity as ClaimsIdentity;
            if (userIdentity != null)
            {
                //if there is not CookiePath claim, then exist
                if (userIdentity.HasClaim(x =&gt; x.Type == ClaimTypes.CookiePath) == false)
                {
                    base.OnActionExecuting(filterContext);
                    return;
                }
            }

            string failedReason;
            var headers = new List&lt;KeyValuePair&lt;string, List&lt;string&gt;&gt;&gt;();
            foreach (var key in filterContext.HttpContext.Request.Headers.AllKeys)
            {
                if (headers.Any(x =&gt; x.Key == key))
                {
                    var found = headers.First(x =&gt; x.Key == key);
                    found.Value.Add(filterContext.HttpContext.Request.Headers[key]);
                }
                else
                {
                    headers.Add(new KeyValuePair&lt;string, List&lt;string&gt;&gt;(key, new List&lt;string&gt; { filterContext.HttpContext.Request.Headers[key] }));
                }
            }
            var cookie = filterContext.HttpContext.Request.Cookies[AngularAntiForgeryHelper.CsrfValidationCookieName];
            if (AngularAntiForgeryHelper.ValidateHeaders(
                headers.Select(x =&gt; new KeyValuePair&lt;string, IEnumerable&lt;string&gt;&gt;(x.Key, x.Value)).ToArray(),
                cookie == null ? &quot;&quot; : cookie.Value,
                out failedReason) == false)
            {
                var result = new HttpStatusCodeResult(HttpStatusCode.ExpectationFailed);
                filterContext.Result = result;
                return;
            }

            base.OnActionExecuting(filterContext);
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[21,9,21,10,0],[22,13,22,90,0],[23,13,23,38,0],[24,13,24,14,0],[26,17,26,48,0],[26,48,26,79,0],[26,79,26,90,0],[26,17,26,90,0],[27,17,27,18,0],[28,21,28,59,0],[29,21,29,28,0],[31,13,31,14,0],[34,13,34,74,0],[35,13,35,20,0],[35,22,35,29,0],[35,30,35,32,0],[35,33,35,82,0],[36,13,36,14,0],[37,17,37,38,0],[37,38,37,50,0],[37,50,37,52,0],[37,17,37,52,0],[38,17,38,18,0],[39,21,39,52,0],[39,52,39,64,0],[39,64,39,66,0],[39,21,39,66,0],[40,21,40,85,0],[41,17,41,18,0],[43,17,43,18,0],[44,21,44,147,0],[45,17,45,18,0],[46,13,46,14,0],[47,13,47,119,0],[48,13,49,37,0],[49,37,49,98,0],[49,98,51,44,0],[48,13,51,44,0],[52,13,52,14,0],[53,17,53,89,0],[54,17,54,47,0],[55,17,55,24,0],[58,13,58,51,0],[59,9,59,10,0]]);
    </script>
  </body>
</html>