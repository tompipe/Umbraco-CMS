<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Media\ImageHelper.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.Linq;
using Umbraco.Core.IO;
using Umbraco.Core.Media.Exif;

namespace Umbraco.Core.Media
{
    /// &lt;summary&gt;
    /// A helper class used for imaging
    /// &lt;/summary&gt;
    internal static class ImageHelper
    {
        /// &lt;summary&gt;
        /// Gets the dimensions of an image based on a stream
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;imageStream&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// First try with EXIF, this is because it is insanely faster and doesn&#39;t use any memory to read exif data than to load in the entire
        /// image via GDI. Otherwise loading an image into GDI consumes a crazy amount of memory on large images.
        /// 
        /// Of course EXIF data might not exist in every file and can only exist in JPGs
        /// &lt;/remarks&gt;
        public static Size GetDimensions(Stream imageStream)
        {
            //Try to load with exif 
            try
            {
                var jpgInfo = ImageFile.FromStream(imageStream);

                if (jpgInfo.Format != ImageFileFormat.Unknown
                    &amp;&amp; jpgInfo.Properties.ContainsKey(ExifTag.PixelYDimension)
                    &amp;&amp; jpgInfo.Properties.ContainsKey(ExifTag.PixelXDimension))
                {
                    var height = Convert.ToInt32(jpgInfo.Properties[ExifTag.PixelYDimension].Value);
                    var width = Convert.ToInt32(jpgInfo.Properties[ExifTag.PixelXDimension].Value);
                    if (height &gt; 0 &amp;&amp; width &gt; 0)
                    {
                        return new Size(width, height);
                    }
                }
            }
            catch (Exception)
            {
                //We will just swallow, just means we can&#39;t read exif data, we don&#39;t want to log an error either
            }

            //we have no choice but to try to read in via GDI
            using (var image = Image.FromStream(imageStream))
            {

                var fileWidth = image.Width;
                var fileHeight = image.Height;
                return new Size(fileWidth, fileHeight);
            }

        }

        public static string GetMimeType(this Image image)
        {
            var format = image.RawFormat;
            var codec = ImageCodecInfo.GetImageDecoders().First(c =&gt; c.FormatID == format.Guid);
            return codec.MimeType;
        }

        /// &lt;summary&gt;
        /// Creates the thumbnails if the image is larger than all of the specified ones.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fs&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;fileName&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;extension&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;originalImage&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;additionalThumbSizes&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal static IEnumerable&lt;ResizedImage&gt; GenerateMediaThumbnails(
            IFileSystem fs,
            string fileName,
            string extension,
            Image originalImage,
            IEnumerable&lt;int&gt; additionalThumbSizes)
        {

            var result = new List&lt;ResizedImage&gt;();

            var allSizesDictionary = new Dictionary&lt;int, string&gt; { { 100, &quot;thumb&quot; }, { 500, &quot;big-thumb&quot; } };

            //combine the static dictionary with the additional sizes with only unique values
            var allSizes = allSizesDictionary.Select(kv =&gt; kv.Key)
                .Union(additionalThumbSizes.Where(x =&gt; x &gt; 0).Distinct());

            var sizesDictionary = allSizes.ToDictionary(s =&gt; s, s =&gt; allSizesDictionary.ContainsKey(s) ? allSizesDictionary[s] : &quot;&quot;);

            foreach (var s in sizesDictionary)
            {
                var size = s.Key;
                var name = s.Value;
                if (originalImage.Width &gt;= size &amp;&amp; originalImage.Height &gt;= size)
                {
                    result.Add(Resize(fs, fileName, extension, size, name, originalImage));
                }
            }

            return result;
        }

        /// &lt;summary&gt;
        /// Performs an image resize
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fileSystem&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;extension&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;maxWidthHeight&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;fileNameAddition&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;originalImage&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private static ResizedImage Resize(IFileSystem fileSystem, string path, string extension, int maxWidthHeight, string fileNameAddition, Image originalImage)
        {
            var fileNameThumb = string.IsNullOrWhiteSpace(fileNameAddition)
                                            ? string.Format(&quot;{0}_UMBRACOSYSTHUMBNAIL.&quot; + extension, path.Substring(0, path.LastIndexOf(&quot;.&quot;, StringComparison.Ordinal)))
                                            : string.Format(&quot;{0}_{1}.&quot; + extension, path.Substring(0, path.LastIndexOf(&quot;.&quot;, StringComparison.Ordinal)), fileNameAddition);

            var thumb = GenerateThumbnail(
                originalImage,
                maxWidthHeight,
                fileNameThumb,
                extension,
                fileSystem);

            return thumb;
        }

        internal static ResizedImage GenerateThumbnail(Image image, int maxWidthHeight, string thumbnailFileName, string extension, IFileSystem fs)
        {
            return GenerateThumbnail(image, maxWidthHeight, -1, -1, thumbnailFileName, extension, fs);
        }

        internal static ResizedImage GenerateThumbnail(Image image, int fixedWidth, int fixedHeight, string thumbnailFileName, string extension, IFileSystem fs)
        {
            return GenerateThumbnail(image, -1, fixedWidth, fixedHeight, thumbnailFileName, extension, fs);
        }

        private static ResizedImage GenerateThumbnail(Image image, int maxWidthHeight, int fixedWidth, int fixedHeight, string thumbnailFileName, string extension, IFileSystem fs)
        {
            // Generate thumbnail
            float f = 1;
            if (maxWidthHeight &gt;= 0)
            {
                var fx = (float)image.Size.Width / maxWidthHeight;
                var fy = (float)image.Size.Height / maxWidthHeight;

                // must fit in thumbnail size
                f = Math.Max(fx, fy);
            }

            //depending on if we are doing fixed width resizing or not.
            fixedWidth = (maxWidthHeight &gt; 0) ? image.Width : fixedWidth;
            fixedHeight = (maxWidthHeight &gt; 0) ? image.Height : fixedHeight;

            var widthTh = (int)Math.Round(fixedWidth / f);
            var heightTh = (int)Math.Round(fixedHeight / f);

            // fixes for empty width or height
            if (widthTh == 0)
                widthTh = 1;
            if (heightTh == 0)
                heightTh = 1;

            // Create new image with best quality settings
            using (var bp = new Bitmap(widthTh, heightTh))
            {
                using (var g = Graphics.FromImage(bp))
                {
                    //if the image size is rather large we cannot use the best quality interpolation mode
                    // because we&#39;ll get out of mem exceptions. So we&#39;ll detect how big the image is and use
                    // the mid quality interpolation mode when the image size exceeds our max limit.

                    if (image.Width &gt; 5000 || image.Height &gt; 5000)
                    {
                        //use mid quality
                        g.InterpolationMode = InterpolationMode.Bilinear;
                    }
                    else
                    {
                        //use best quality
                        g.InterpolationMode = InterpolationMode.HighQualityBicubic;
                    }


                    g.SmoothingMode = SmoothingMode.HighQuality;
                    g.PixelOffsetMode = PixelOffsetMode.HighQuality;
                    g.CompositingQuality = CompositingQuality.HighQuality;

                    // Copy the old image to the new and resized
                    var rect = new Rectangle(0, 0, widthTh, heightTh);
                    g.DrawImage(image, rect, 0, 0, image.Width, image.Height, GraphicsUnit.Pixel);

                    // Copy metadata
                    var imageEncoders = ImageCodecInfo.GetImageEncoders();
                    ImageCodecInfo codec;
                    switch (extension.ToLower())
                    {
                        case &quot;png&quot;:
                            codec = imageEncoders.Single(t =&gt; t.MimeType.Equals(&quot;image/png&quot;));
                            break;
                        case &quot;gif&quot;:
                            codec = imageEncoders.Single(t =&gt; t.MimeType.Equals(&quot;image/gif&quot;));
                            break;
                        case &quot;tif&quot;:
                        case &quot;tiff&quot;:
                            codec = imageEncoders.Single(t =&gt; t.MimeType.Equals(&quot;image/tiff&quot;));
                            break;
                        case &quot;bmp&quot;:
                            codec = imageEncoders.Single(t =&gt; t.MimeType.Equals(&quot;image/bmp&quot;));
                            break;
                        // TODO: this is dirty, defaulting to jpg but the return value of this thing is used all over the
                        // place so left it here, but it needs to not set a codec if it doesn&#39;t know which one to pick 
                        // Note: when fixing this: both .jpg and .jpeg should be handled as extensions
                        default:
                            codec = imageEncoders.Single(t =&gt; t.MimeType.Equals(&quot;image/jpeg&quot;));
                            break;
                    }

                    // Set compresion ratio to 90%
                    var ep = new EncoderParameters();
                    ep.Param[0] = new EncoderParameter(Encoder.Quality, 90L);

                    // Save the new image using the dimensions of the image
                    var predictableThumbnailName = thumbnailFileName.Replace(&quot;UMBRACOSYSTHUMBNAIL&quot;, maxWidthHeight.ToString(CultureInfo.InvariantCulture));
                    var predictableThumbnailNameJpg = predictableThumbnailName.Substring(0, predictableThumbnailName.LastIndexOf(&quot;.&quot;, StringComparison.Ordinal)) + &quot;.jpg&quot;;
                    using (var ms = new MemoryStream())
                    {
                        bp.Save(ms, codec, ep);
                        ms.Seek(0, 0);

                        fs.AddFile(predictableThumbnailName, ms);
                        fs.AddFile(predictableThumbnailNameJpg, ms);
                    }

                    // TODO: Remove this, this is ONLY here for backwards compatibility but it is essentially completely unusable see U4-5385
                    var newFileName = thumbnailFileName.Replace(&quot;UMBRACOSYSTHUMBNAIL&quot;, string.Format(&quot;{0}x{1}&quot;, widthTh, heightTh));
                    using (var ms = new MemoryStream())
                    {
                        bp.Save(ms, codec, ep);
                        ms.Seek(0, 0);

                        fs.AddFile(newFileName, ms);
                    }

                    return new ResizedImage(widthTh, heightTh, newFileName);
                }
            }
        }

    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[31,9,31,10,0],[34,13,34,14,0],[35,17,35,65,0],[37,17,39,80,0],[40,17,40,18,0],[41,21,41,101,0],[42,21,42,100,0],[43,21,43,49,0],[44,21,44,22,0],[45,25,45,56,0],[47,17,47,18,0],[48,13,48,14,0],[49,13,49,30,0],[50,13,50,14,0],[52,13,52,14,0],[55,20,55,61,0],[56,13,56,14,0],[58,17,58,45,0],[59,17,59,47,0],[60,17,60,56,0],[63,9,63,10,0],[66,9,66,10,0],[67,13,67,42,0],[68,13,68,70,0],[68,70,68,95,0],[68,95,68,97,0],[68,13,68,97,0],[69,13,69,35,0],[70,9,70,10,0],[87,9,87,10,0],[89,13,89,51,0],[91,13,91,109,0],[94,13,94,60,0],[94,60,94,66,0],[94,66,95,56,0],[95,56,95,61,0],[95,61,95,75,0],[94,13,95,75,0],[97,13,97,62,0],[97,62,97,63,0],[97,63,97,70,0],[97,70,97,132,0],[97,132,97,134,0],[97,13,97,134,0],[99,13,99,20,0],[99,22,99,27,0],[99,28,99,30,0],[99,31,99,46,0],[100,13,100,14,0],[101,17,101,34,0],[102,17,102,36,0],[103,17,103,81,0],[104,17,104,18,0],[105,21,105,92,0],[106,17,106,18,0],[107,13,107,14,0],[109,13,109,27,0],[110,9,110,10,0],[123,9,123,10,0],[124,13,126,171,0],[128,13,133,29,0],[135,13,135,26,0],[136,9,136,10,0],[139,9,139,10,0],[140,13,140,103,0],[141,9,141,10,0],[144,9,144,10,0],[145,13,145,108,0],[146,9,146,10,0],[149,9,149,10,0],[151,13,151,25,0],[152,13,152,37,0],[153,13,153,14,0],[154,17,154,67,0],[155,17,155,68,0],[158,17,158,38,0],[159,13,159,14,0],[162,13,162,74,0],[163,13,163,77,0],[165,13,165,59,0],[166,13,166,61,0],[169,13,169,30,0],[170,17,170,29,0],[171,13,171,31,0],[172,17,172,30,0],[175,20,175,58,0],[176,13,176,14,0],[177,24,177,54,0],[178,17,178,18,0],[183,21,183,67,0],[184,21,184,22,0],[186,25,186,74,0],[187,21,187,22,0],[189,21,189,22,0],[191,25,191,84,0],[192,21,192,22,0],[195,21,195,65,0],[196,21,196,69,0],[197,21,197,75,0],[200,21,200,71,0],[201,21,201,99,0],[204,21,204,75,0],[206,21,206,49,0],[209,29,209,63,0],[209,63,209,93,0],[209,93,209,95,0],[209,29,209,95,0],[210,29,210,35,0],[212,29,212,63,0],[212,63,212,93,0],[212,93,212,95,0],[212,29,212,95,0],[213,29,213,35,0],[216,29,216,63,0],[216,63,216,94,0],[216,94,216,96,0],[216,29,216,96,0],[217,29,217,35,0],[219,29,219,63,0],[219,63,219,93,0],[219,93,219,95,0],[219,29,219,95,0],[220,29,220,35,0],[225,29,225,63,0],[225,63,225,94,0],[225,94,225,96,0],[225,29,225,96,0],[226,29,226,35,0],[230,21,230,54,0],[231,21,231,78,0],[234,21,234,156,0],[235,21,235,171,0],[236,28,236,55,0],[237,21,237,22,0],[238,25,238,48,0],[239,25,239,39,0],[241,25,241,66,0],[242,25,242,69,0],[243,21,243,22,0],[246,21,246,133,0],[247,28,247,55,0],[248,21,248,22,0],[249,25,249,48,0],[250,25,250,39,0],[252,25,252,53,0],[253,21,253,22,0],[255,21,255,77,0],[258,9,258,10,0]]);
    </script>
  </body>
</html>