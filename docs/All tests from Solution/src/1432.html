<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\StringExtensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using System.Xml;
using Newtonsoft.Json;
using Umbraco.Core.Configuration;
using System.Web.Security;
using Umbraco.Core.Strings;
using Umbraco.Core.CodeAnnotations;
using Umbraco.Core.IO;

namespace Umbraco.Core
{

    ///&lt;summary&gt;
    /// String extension methods
    ///&lt;/summary&gt;
    public static class StringExtensions
    {
        [UmbracoWillObsolete(&quot;Do not use this constants. See IShortStringHelper.CleanStringForSafeAliasJavaScriptCode.&quot;)]
        public const string UmbracoValidAliasCharacters = &quot;_-abcdefghijklmnopqrstuvwxyz1234567890&quot;;
        [UmbracoWillObsolete(&quot;Do not use this constants. See IShortStringHelper.CleanStringForSafeAliasJavaScriptCode.&quot;)]
        public const string UmbracoInvalidFirstCharacters = &quot;01234567890&quot;;

        private static readonly char[] ToCSharpHexDigitLower = &quot;0123456789abcdef&quot;.ToCharArray();
        private static readonly char[] ToCSharpEscapeChars;

        static StringExtensions()
        {
            var escapes = new[] { &quot;\aa&quot;, &quot;\bb&quot;, &quot;\ff&quot;, &quot;\nn&quot;, &quot;\rr&quot;, &quot;\tt&quot;, &quot;\vv&quot;, &quot;\&quot;\&quot;&quot;, &quot;\\\\&quot;, &quot;??&quot;, &quot;\00&quot; };
            ToCSharpEscapeChars = new char[escapes.Max(e =&gt; e[0]) + 1];
            foreach (var escape in escapes)
                ToCSharpEscapeChars[escape[0]] = escape[1];
        }

        /// &lt;summary&gt;
        /// Removes new lines and tabs
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;txt&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal static string StripWhitespace(this string txt)
        {
            return Regex.Replace(txt, @&quot;\s&quot;, string.Empty);
        }

        internal static string StripFileExtension(this string fileName)
        {
            //filenames cannot contain line breaks
            if (fileName.Contains(Environment.NewLine) || fileName.Contains(&quot;\r&quot;) || fileName.Contains(&quot;\n&quot;)) return fileName;

            var lastIndex = fileName.LastIndexOf(&#39;.&#39;);
            if (lastIndex &gt; 0)
            {
                var ext = fileName.Substring(lastIndex);
                //file extensions cannot contain whitespace
                if (ext.Contains(&quot; &quot;)) return fileName;

                return string.Format(&quot;{0}&quot;, fileName.Substring(0, fileName.IndexOf(ext, StringComparison.Ordinal)));
            }
            return fileName;


        }

        /// &lt;summary&gt;
        /// Based on the input string, this will detect if the strnig is a JS path or a JS snippet.
        /// If a path cannot be determined, then it is assumed to be a snippet the original text is returned
        /// with an invalid attempt, otherwise a valid attempt is returned with the resolved path
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// This is only used for legacy purposes for the Action.JsSource stuff and shouldn&#39;t be needed in v8
        /// &lt;/remarks&gt;
        internal static Attempt&lt;string&gt; DetectIsJavaScriptPath(this string input)
        {
            //validate that this is a url, if it is not, we&#39;ll assume that it is a text block and render it as a text
            //block instead.
            var isValid = true;

            if (Uri.IsWellFormedUriString(input, UriKind.RelativeOrAbsolute))
            {
                //ok it validates, but so does alert(&#39;hello&#39;); ! so we need to do more checks

                //here are the valid chars in a url without escaping
                if (Regex.IsMatch(input, @&quot;[^a-zA-Z0-9-._~:/?#\[\]@!$&amp;&#39;\(\)*\+,%;=]&quot;))
                    isValid = false;

                //we&#39;ll have to be smarter and just check for certain js patterns now too!
                var jsPatterns = new[] { @&quot;\+\s*\=&quot;, @&quot;\);&quot;, @&quot;function\s*\(&quot;, @&quot;!=&quot;, @&quot;==&quot; };
                if (jsPatterns.Any(p =&gt; Regex.IsMatch(input, p)))
                    isValid = false;

                if (isValid)
                {
                    var resolvedUrlResult = IOHelper.TryResolveUrl(input);
                    //if the resolution was success, return it, otherwise just return the path, we&#39;ve detected
                    // it&#39;s a path but maybe it&#39;s relative and resolution has failed, etc... in which case we&#39;re just
                    // returning what was given to us.
                    return resolvedUrlResult.Success 
                        ? resolvedUrlResult 
                        : Attempt.Succeed(input);
                }
            }

            return Attempt.Fail(input);
        }

        /// &lt;summary&gt;
        /// This tries to detect a json string, this is not a fail safe way but it is quicker than doing 
        /// a try/catch when deserializing when it is not json.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal static bool DetectIsJson(this string input)
        {
            input = input.Trim();
            return (input.StartsWith(&quot;{&quot;) &amp;&amp; input.EndsWith(&quot;}&quot;))
                   || (input.StartsWith(&quot;[&quot;) &amp;&amp; input.EndsWith(&quot;]&quot;));
        }

        internal static readonly Regex Whitespace = new Regex(@&quot;\s+&quot;, RegexOptions.Compiled);
        internal static readonly string[] JsonEmpties = new [] { &quot;[]&quot;, &quot;{}&quot; };
        internal static bool DetectIsEmptyJson(this string input)
        {
            return JsonEmpties.Contains(Whitespace.Replace(input, string.Empty));
        }

        /// &lt;summary&gt;
        /// Returns a JObject/JArray instance if the string can be converted to json, otherwise returns the string
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal static object ConvertToJsonIfPossible(this string input)
        {
            if (input.DetectIsJson() == false)
            {
                return input;
            }
            try
            {
                var obj = JsonConvert.DeserializeObject(input);
                return obj;
            }
            catch (Exception ex)
            {
                return input;
            }
        }

        internal static string ReplaceNonAlphanumericChars(this string input, string replacement)
        {
            //any character that is not alphanumeric, convert to a hyphen
            var mName = input;
            foreach (var c in mName.ToCharArray().Where(c =&gt; !char.IsLetterOrDigit(c)))
            {
                mName = mName.Replace(c.ToString(CultureInfo.InvariantCulture), replacement);
            }
            return mName;
        }

        internal static string ReplaceNonAlphanumericChars(this string input, char replacement)
        {
            var inputArray = input.ToCharArray();
            var outputArray = new char[input.Length];
            for (var i = 0; i &lt; inputArray.Length; i++)
                outputArray[i] = char.IsLetterOrDigit(inputArray[i]) ? inputArray[i] : replacement;
            return new string(outputArray);
        }

        private static readonly char[] CleanForXssChars = &quot;*?(){}[];:%&lt;&gt;/\\|&amp;&#39;\&quot;&quot;.ToCharArray();

        /// &lt;summary&gt;
        /// Cleans string to aid in preventing xss attacks.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;ignoreFromClean&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string CleanForXss(this string input, params char[] ignoreFromClean)
        {
            //remove any html
            input = input.StripHtml();
            //strip out any potential chars involved with XSS
            return input.ExceptChars(new HashSet&lt;char&gt;(CleanForXssChars.Except(ignoreFromClean)));
        }

        public static string ExceptChars(this string str, HashSet&lt;char&gt; toExclude)
        {
            var sb = new StringBuilder(str.Length);
            foreach (var c in str.Where(c =&gt; toExclude.Contains(c) == false))
            {
                sb.Append(c);
            }
            return sb.ToString();
        }

        /// &lt;summary&gt;
        /// Returns a stream from a string
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;s&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal static Stream GenerateStreamFromString(this string s)
        {
            var stream = new MemoryStream();
            var writer = new StreamWriter(stream);
            writer.Write(s);
            writer.Flush();
            stream.Position = 0;
            return stream;
        }

        /// &lt;summary&gt;
        /// This will append the query string to the URL
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;url&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;queryStrings&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// This methods ensures that the resulting URL is structured correctly, that there&#39;s only one &#39;?&#39; and that things are
        /// delimited properly with &#39;&amp;&#39; 
        /// &lt;/remarks&gt;
        internal static string AppendQueryStringToUrl(this string url, params string[] queryStrings)
        {
            //remove any prefixed &#39;&amp;&#39; or &#39;?&#39;
            for (var i = 0; i &lt; queryStrings.Length; i++)
            {
                queryStrings[i] = queryStrings[i].TrimStart(&#39;?&#39;, &#39;&amp;&#39;).TrimEnd(&#39;&amp;&#39;);
            }

            var nonEmpty = queryStrings.Where(x =&gt; !x.IsNullOrWhiteSpace()).ToArray();

            if (url.Contains(&quot;?&quot;))
            {
                return url + string.Join(&quot;&amp;&quot;, nonEmpty).EnsureStartsWith(&#39;&amp;&#39;);
            }
            return url + string.Join(&quot;&amp;&quot;, nonEmpty).EnsureStartsWith(&#39;?&#39;);
        }

        /// &lt;summary&gt;
        /// Encrypt the string using the MachineKey in medium trust
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;The string value to be encrypted.&lt;/param&gt;
        /// &lt;returns&gt;The encrypted string.&lt;/returns&gt;
        public static string EncryptWithMachineKey(this string value)
        {
            if (value == null)
                return null;

            string valueToEncrypt = value;
            List&lt;string&gt; parts = new List&lt;string&gt;();

            const int EncrpytBlockSize = 500;

            while (valueToEncrypt.Length &gt; EncrpytBlockSize)
            {
                parts.Add(valueToEncrypt.Substring(0, EncrpytBlockSize));
                valueToEncrypt = valueToEncrypt.Remove(0, EncrpytBlockSize);
            }

            if (valueToEncrypt.Length &gt; 0)
            {
                parts.Add(valueToEncrypt);
            }

            StringBuilder encrpytedValue = new StringBuilder();

            foreach (var part in parts)
            {
                var encrpytedBlock = FormsAuthentication.Encrypt(new FormsAuthenticationTicket(0, string.Empty, DateTime.Now, DateTime.MaxValue, false, part));
                encrpytedValue.AppendLine(encrpytedBlock);
            }

            return encrpytedValue.ToString().TrimEnd();
        }

        /// &lt;summary&gt;
        /// Decrypt the encrypted string using the Machine key in medium trust
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;The string value to be decrypted&lt;/param&gt;
        /// &lt;returns&gt;The decrypted string.&lt;/returns&gt;
        public static string DecryptWithMachineKey(this string value)
        {
            if (value == null)
                return null;

            string[] parts = value.Split(&#39;\n&#39;);

            StringBuilder decryptedValue = new StringBuilder();

            foreach (var part in parts)
            {
                decryptedValue.Append(FormsAuthentication.Decrypt(part.TrimEnd()).UserData);
            }

            return decryptedValue.ToString();
        }

        //this is from SqlMetal and just makes it a bit of fun to allow pluralisation
        public static string MakePluralName(this string name)
        {
            if ((name.EndsWith(&quot;x&quot;, StringComparison.OrdinalIgnoreCase) || name.EndsWith(&quot;ch&quot;, StringComparison.OrdinalIgnoreCase)) || (name.EndsWith(&quot;s&quot;, StringComparison.OrdinalIgnoreCase) || name.EndsWith(&quot;sh&quot;, StringComparison.OrdinalIgnoreCase)))
            {
                name = name + &quot;es&quot;;
                return name;
            }
            if ((name.EndsWith(&quot;y&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; (name.Length &gt; 1)) &amp;&amp; !IsVowel(name[name.Length - 2]))
            {
                name = name.Remove(name.Length - 1, 1);
                name = name + &quot;ies&quot;;
                return name;
            }
            if (!name.EndsWith(&quot;s&quot;, StringComparison.OrdinalIgnoreCase))
            {
                name = name + &quot;s&quot;;
            }
            return name;
        }

        public static bool IsVowel(this char c)
        {
            switch (c)
            {
                case &#39;O&#39;:
                case &#39;U&#39;:
                case &#39;Y&#39;:
                case &#39;A&#39;:
                case &#39;E&#39;:
                case &#39;I&#39;:
                case &#39;o&#39;:
                case &#39;u&#39;:
                case &#39;y&#39;:
                case &#39;a&#39;:
                case &#39;e&#39;:
                case &#39;i&#39;:
                    return true;
            }
            return false;
        }

        /// &lt;summary&gt;
        /// Trims the specified value from a string; accepts a string input whereas the in-built implementation only accepts char or char[].
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
        /// &lt;param name=&quot;forRemoving&quot;&gt;For removing.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string Trim(this string value, string forRemoving)
        {
            if (string.IsNullOrEmpty(value)) return value;
            return value.TrimEnd(forRemoving).TrimStart(forRemoving);
        }

        public static string EncodeJsString(this string s)
        {
            var sb = new StringBuilder();
            foreach (var c in s)
            {
                switch (c)
                {
                    case &#39;\&quot;&#39;:
                        sb.Append(&quot;\\\&quot;&quot;);
                        break;
                    case &#39;\\&#39;:
                        sb.Append(&quot;\\\\&quot;);
                        break;
                    case &#39;\b&#39;:
                        sb.Append(&quot;\\b&quot;);
                        break;
                    case &#39;\f&#39;:
                        sb.Append(&quot;\\f&quot;);
                        break;
                    case &#39;\n&#39;:
                        sb.Append(&quot;\\n&quot;);
                        break;
                    case &#39;\r&#39;:
                        sb.Append(&quot;\\r&quot;);
                        break;
                    case &#39;\t&#39;:
                        sb.Append(&quot;\\t&quot;);
                        break;
                    default:
                        int i = (int)c;
                        if (i &lt; 32 || i &gt; 127)
                        {
                            sb.AppendFormat(&quot;\\u{0:X04}&quot;, i);
                        }
                        else
                        {
                            sb.Append(c);
                        }
                        break;
                }
            }
            return sb.ToString();
        }

        public static string TrimEnd(this string value, string forRemoving)
        {
            if (string.IsNullOrEmpty(value)) return value;
            if (string.IsNullOrEmpty(forRemoving)) return value;

            while (value.EndsWith(forRemoving, StringComparison.InvariantCultureIgnoreCase))
            {
                value = value.Remove(value.LastIndexOf(forRemoving, StringComparison.InvariantCultureIgnoreCase));
            }
            return value;
        }

        public static string TrimStart(this string value, string forRemoving)
        {
            if (string.IsNullOrEmpty(value)) return value;
            if (string.IsNullOrEmpty(forRemoving)) return value;

            while (value.StartsWith(forRemoving, StringComparison.InvariantCultureIgnoreCase))
            {
                value = value.Substring(forRemoving.Length);
            }
            return value;
        }

        public static string EnsureStartsWith(this string input, string toStartWith)
        {
            if (input.StartsWith(toStartWith)) return input;
            return toStartWith + input.TrimStart(toStartWith);
        }

        public static string EnsureStartsWith(this string input, char value)
        {
            return input.StartsWith(value.ToString(CultureInfo.InvariantCulture)) ? input : value + input;
        }

        public static string EnsureEndsWith(this string input, char value)
        {
            return input.EndsWith(value.ToString(CultureInfo.InvariantCulture)) ? input : input + value;
        }

        public static string EnsureEndsWith(this string input, string toEndWith)
        {
            return input.EndsWith(toEndWith.ToString(CultureInfo.InvariantCulture)) ? input : input + toEndWith;
        }

        public static bool IsLowerCase(this char ch)
        {
            return ch.ToString(CultureInfo.InvariantCulture) == ch.ToString(CultureInfo.InvariantCulture).ToLowerInvariant();
        }

        public static bool IsUpperCase(this char ch)
        {
            return ch.ToString(CultureInfo.InvariantCulture) == ch.ToString(CultureInfo.InvariantCulture).ToUpperInvariant();
        }

        /// &lt;summary&gt;Is null or white space.&lt;/summary&gt;
        /// &lt;param name=&quot;str&quot;&gt;The str.&lt;/param&gt;
        /// &lt;returns&gt;The is null or white space.&lt;/returns&gt;
        public static bool IsNullOrWhiteSpace(this string str)
        {
            return (str == null) || (str.Trim().Length == 0);
        }

        public static string IfNullOrWhiteSpace(this string str, string defaultValue)
        {
            return str.IsNullOrWhiteSpace() ? defaultValue : str;
        }

        /// &lt;summary&gt;The to delimited list.&lt;/summary&gt;
        /// &lt;param name=&quot;list&quot;&gt;The list.&lt;/param&gt;
        /// &lt;param name=&quot;delimiter&quot;&gt;The delimiter.&lt;/param&gt;
        /// &lt;returns&gt;the list&lt;/returns&gt;
        [SuppressMessage(&quot;Microsoft.Design&quot;, &quot;CA1026:DefaultParametersShouldNotBeUsed&quot;, Justification = &quot;By design&quot;)]
        public static IList&lt;string&gt; ToDelimitedList(this string list, string delimiter = &quot;,&quot;)
        {
            var delimiters = new[] { delimiter };
            return !list.IsNullOrWhiteSpace()
                       ? list.Split(delimiters, StringSplitOptions.RemoveEmptyEntries)
                             .Select(i =&gt; i.Trim())
                             .ToList()
                       : new List&lt;string&gt;();
        }

        /// &lt;summary&gt;enum try parse.&lt;/summary&gt;
        /// &lt;param name=&quot;strType&quot;&gt;The str type.&lt;/param&gt;
        /// &lt;param name=&quot;ignoreCase&quot;&gt;The ignore case.&lt;/param&gt;
        /// &lt;param name=&quot;result&quot;&gt;The result.&lt;/param&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The type&lt;/typeparam&gt;
        /// &lt;returns&gt;The enum try parse.&lt;/returns&gt;
        [SuppressMessage(&quot;Microsoft.Design&quot;, &quot;CA1031:DoNotCatchGeneralExceptionTypes&quot;, Justification = &quot;By Design&quot;)]
        [SuppressMessage(&quot;Microsoft.Design&quot;, &quot;CA1021:AvoidOutParameters&quot;, MessageId = &quot;2#&quot;, Justification = &quot;By Design&quot;)]
        public static bool EnumTryParse&lt;T&gt;(this string strType, bool ignoreCase, out T result)
        {
            try
            {
                result = (T)Enum.Parse(typeof(T), strType, ignoreCase);
                return true;
            }
            catch
            {
                result = default(T);
                return false;
            }
        }

        /// &lt;summary&gt;
        /// Parse string to Enum
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The enum type&lt;/typeparam&gt;
        /// &lt;param name=&quot;strType&quot;&gt;The string to parse&lt;/param&gt;
        /// &lt;param name=&quot;ignoreCase&quot;&gt;The ignore case&lt;/param&gt;
        /// &lt;returns&gt;The parsed enum&lt;/returns&gt;
        [SuppressMessage(&quot;Microsoft.Design&quot;, &quot;CA1031:DoNotCatchGeneralExceptionTypes&quot;, Justification = &quot;By Design&quot;)]
        [SuppressMessage(&quot;Microsoft.Design&quot;, &quot;CA1021:AvoidOutParameters&quot;, MessageId = &quot;2#&quot;, Justification = &quot;By Design&quot;)]
        public static T EnumParse&lt;T&gt;(this string strType, bool ignoreCase)
        {
            return (T)Enum.Parse(typeof(T), strType, ignoreCase);
        }

        /// &lt;summary&gt;
        /// Strips all html from a string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text.&lt;/param&gt;
        /// &lt;returns&gt;Returns the string without any html tags.&lt;/returns&gt;
        public static string StripHtml(this string text)
        {
            const string pattern = @&quot;&lt;(.|\n)*?&gt;&quot;;
            return Regex.Replace(text, pattern, String.Empty);
        }

        /// &lt;summary&gt;
        /// Encodes as GUID.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;The input.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Guid EncodeAsGuid(this string input)
        {
            if (string.IsNullOrWhiteSpace(input)) throw new ArgumentNullException(&quot;input&quot;);

            var convertToHex = input.ConvertToHex();
            var hexLength = convertToHex.Length &lt; 32 ? convertToHex.Length : 32;
            var hex = convertToHex.Substring(0, hexLength).PadLeft(32, &#39;0&#39;);
            var output = Guid.Empty;
            return Guid.TryParse(hex, out output) ? output : Guid.Empty;
        }

        /// &lt;summary&gt;
        /// Converts to hex.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;The input.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string ConvertToHex(this string input)
        {
            if (string.IsNullOrEmpty(input)) return string.Empty;

            var sb = new StringBuilder(input.Length);
            foreach (var c in input)
            {
                sb.AppendFormat(&quot;{0:x2}&quot;, Convert.ToUInt32(c));
            }
            return sb.ToString();
        }

        public static string DecodeFromHex(this string hexValue)
        {
            var strValue = &quot;&quot;;
            while (hexValue.Length &gt; 0)
            {
                strValue += Convert.ToChar(Convert.ToUInt32(hexValue.Substring(0, 2), 16)).ToString();
                hexValue = hexValue.Substring(2, hexValue.Length - 2);
            }
            return strValue;
        }

        ///&lt;summary&gt;
        /// Encodes a string to a safe URL base64 string
        ///&lt;/summary&gt;
        ///&lt;param name=&quot;input&quot;&gt;&lt;/param&gt;
        ///&lt;returns&gt;&lt;/returns&gt;
        public static string ToUrlBase64(this string input)
        {
            if (input == null) throw new ArgumentNullException(&quot;input&quot;);

            if (String.IsNullOrEmpty(input)) return String.Empty;

            var bytes = Encoding.UTF8.GetBytes(input);
            return UrlTokenEncode(bytes);
            //return Convert.ToBase64String(bytes).Replace(&quot;.&quot;, &quot;-&quot;).Replace(&quot;/&quot;, &quot;_&quot;).Replace(&quot;=&quot;, &quot;,&quot;);
        }

        /// &lt;summary&gt;
        /// Decodes a URL safe base64 string back
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string FromUrlBase64(this string input)
        {
            if (input == null) throw new ArgumentNullException(&quot;input&quot;);

            //if (input.IsInvalidBase64()) return null;

            try
            {
                //var decodedBytes = Convert.FromBase64String(input.Replace(&quot;-&quot;, &quot;.&quot;).Replace(&quot;_&quot;, &quot;/&quot;).Replace(&quot;,&quot;, &quot;=&quot;));
                byte[] decodedBytes = UrlTokenDecode(input);
                return decodedBytes != null ? Encoding.UTF8.GetString(decodedBytes) : null;
            }
            catch (FormatException ex)
            {
                return null;
            }
        }

        /// &lt;summary&gt;
        /// formats the string with invariant culture
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;format&quot;&gt;The format.&lt;/param&gt;
        /// &lt;param name=&quot;args&quot;&gt;The args.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string InvariantFormat(this string format, params object[] args)
        {
            return String.Format(CultureInfo.InvariantCulture, format, args);
        }

        /// &lt;summary&gt;
        /// Converts an integer to an invariant formatted string
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;str&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string ToInvariantString(this int str)
        {
            return str.ToString(CultureInfo.InvariantCulture);
        }

        /// &lt;summary&gt;
        /// Compares 2 strings with invariant culture and case ignored
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;compare&quot;&gt;The compare.&lt;/param&gt;
        /// &lt;param name=&quot;compareTo&quot;&gt;The compare to.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static bool InvariantEquals(this string compare, string compareTo)
        {
            return String.Equals(compare, compareTo, StringComparison.InvariantCultureIgnoreCase);
        }

        public static bool InvariantStartsWith(this string compare, string compareTo)
        {
            return compare.StartsWith(compareTo, StringComparison.InvariantCultureIgnoreCase);
        }

        public static bool InvariantEndsWith(this string compare, string compareTo)
        {
            return compare.EndsWith(compareTo, StringComparison.InvariantCultureIgnoreCase);
        }

        public static bool InvariantContains(this string compare, string compareTo)
        {
            return compare.IndexOf(compareTo, StringComparison.OrdinalIgnoreCase) &gt;= 0;
        }

        public static bool InvariantContains(this IEnumerable&lt;string&gt; compare, string compareTo)
        {
            return compare.Contains(compareTo, StringComparer.InvariantCultureIgnoreCase);
        }

        [Obsolete(&quot;Use Guid.TryParse instead&quot;)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static bool IsGuid(this string str, bool withHyphens)
        {
            Guid g;
            return Guid.TryParse(str, out g);
        }

        /// &lt;summary&gt;
        /// Tries to parse a string into the supplied type by finding and using the Type&#39;s &quot;Parse&quot; method
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
        /// &lt;param name=&quot;val&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static T ParseInto&lt;T&gt;(this string val)
        {
            return (T)val.ParseInto(typeof(T));
        }

        /// &lt;summary&gt;
        /// Tries to parse a string into the supplied type by finding and using the Type&#39;s &quot;Parse&quot; method
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;val&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static object ParseInto(this string val, Type type)
        {
            if (string.IsNullOrEmpty(val) == false)
            {
                TypeConverter tc = TypeDescriptor.GetConverter(type);
                return tc.ConvertFrom(val);
            }
            return val;
        }

        /// &lt;summary&gt;
        /// Converts the string to MD5
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;stringToConvert&quot;&gt;referrs to itself&lt;/param&gt;
        /// &lt;returns&gt;the md5 hashed string&lt;/returns&gt;
        public static string ToMd5(this string stringToConvert)
        {
            //create an instance of the MD5CryptoServiceProvider
            var md5Provider = new MD5CryptoServiceProvider();

            //convert our string into byte array
            var byteArray = Encoding.UTF8.GetBytes(stringToConvert);

            //get the hashed values created by our MD5CryptoServiceProvider
            var hashedByteArray = md5Provider.ComputeHash(byteArray);

            //create a StringBuilder object
            var stringBuilder = new StringBuilder();

            //loop to each each byte
            foreach (var b in hashedByteArray)
            {
                //append it to our StringBuilder
                stringBuilder.Append(b.ToString(&quot;x2&quot;).ToLower());
            }

            //return the hashed value
            return stringBuilder.ToString();
        }

        /// &lt;summary&gt;
        /// Converts the string to SHA1
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;stringToConvert&quot;&gt;referrs to itself&lt;/param&gt;
        /// &lt;returns&gt;the md5 hashed string&lt;/returns&gt;
        public static string ToSHA1(this string stringToConvert)
        {
            //create an instance of the SHA1CryptoServiceProvider
            var md5Provider = new SHA1CryptoServiceProvider();

            //convert our string into byte array
            var byteArray = Encoding.UTF8.GetBytes(stringToConvert);

            //get the hashed values created by our SHA1CryptoServiceProvider
            var hashedByteArray = md5Provider.ComputeHash(byteArray);

            //create a StringBuilder object
            var stringBuilder = new StringBuilder();

            //loop to each each byte
            foreach (var b in hashedByteArray)
            {
                //append it to our StringBuilder
                stringBuilder.Append(b.ToString(&quot;x2&quot;).ToLower());
            }

            //return the hashed value
            return stringBuilder.ToString();
        }


        /// &lt;summary&gt;
        /// Decodes a string that was encoded with UrlTokenEncode
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal static byte[] UrlTokenDecode(string input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(&quot;input&quot;);
            }
            int length = input.Length;
            if (length &lt; 1)
            {
                return new byte[0];
            }
            int num2 = input[length - 1] - &#39;0&#39;;
            if ((num2 &lt; 0) || (num2 &gt; 10))
            {
                return null;
            }
            char[] inArray = new char[(length - 1) + num2];
            for (int i = 0; i &lt; (length - 1); i++)
            {
                char ch = input[i];
                switch (ch)
                {
                    case &#39;-&#39;:
                        inArray[i] = &#39;+&#39;;
                        break;

                    case &#39;_&#39;:
                        inArray[i] = &#39;/&#39;;
                        break;

                    default:
                        inArray[i] = ch;
                        break;
                }
            }
            for (int j = length - 1; j &lt; inArray.Length; j++)
            {
                inArray[j] = &#39;=&#39;;
            }
            return Convert.FromBase64CharArray(inArray, 0, inArray.Length);
        }

        /// &lt;summary&gt;
        /// Encodes a string so that it is &#39;safe&#39; for URLs, files, etc..
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal static string UrlTokenEncode(byte[] input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(&quot;input&quot;);
            }
            if (input.Length &lt; 1)
            {
                return String.Empty;
            }
            string str = null;
            int index = 0;
            char[] chArray = null;
            str = Convert.ToBase64String(input);
            if (str == null)
            {
                return null;
            }
            index = str.Length;
            while (index &gt; 0)
            {
                if (str[index - 1] != &#39;=&#39;)
                {
                    break;
                }
                index--;
            }
            chArray = new char[index + 1];
            chArray[index] = (char)((0x30 + str.Length) - index);
            for (int i = 0; i &lt; index; i++)
            {
                char ch = str[i];
                switch (ch)
                {
                    case &#39;+&#39;:
                        chArray[i] = &#39;-&#39;;
                        break;

                    case &#39;/&#39;:
                        chArray[i] = &#39;_&#39;;
                        break;

                    case &#39;=&#39;:
                        chArray[i] = ch;
                        break;

                    default:
                        chArray[i] = ch;
                        break;
                }
            }
            return new string(chArray);
        }

        /// &lt;summary&gt;
        /// Ensures that the folder path endds with a DirectorySeperatorChar
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;currentFolder&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string NormaliseDirectoryPath(this string currentFolder)
        {
            currentFolder = currentFolder
                                .IfNull(x =&gt; String.Empty)
                                .TrimEnd(Path.DirectorySeparatorChar) + Path.DirectorySeparatorChar;
            return currentFolder;
        }

        /// &lt;summary&gt;
        /// Truncates the specified text string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text.&lt;/param&gt;
        /// &lt;param name=&quot;maxLength&quot;&gt;Length of the max.&lt;/param&gt;
        /// &lt;param name=&quot;suffix&quot;&gt;The suffix.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string Truncate(this string text, int maxLength, string suffix = &quot;...&quot;)
        {
            // replaces the truncated string to a ...
            var truncatedString = text;

            if (maxLength &lt;= 0) return truncatedString;
            var strLength = maxLength - suffix.Length;

            if (strLength &lt;= 0) return truncatedString;

            if (text == null || text.Length &lt;= maxLength) return truncatedString;

            truncatedString = text.Substring(0, strLength);
            truncatedString = truncatedString.TrimEnd();
            truncatedString += suffix;

            return truncatedString;
        }

        /// &lt;summary&gt;
        /// Strips carrage returns and line feeds from the specified text.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;The input.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string StripNewLines(this string input)
        {
            return input.Replace(&quot;\r&quot;, &quot;&quot;).Replace(&quot;\n&quot;, &quot;&quot;);
        }

        public static string OrIfNullOrWhiteSpace(this string input, string alternative)
        {
            return !string.IsNullOrWhiteSpace(input)
                       ? input
                       : alternative;
        }

        /// &lt;summary&gt;
        /// Returns a copy of the string with the first character converted to uppercase.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;The string.&lt;/param&gt;
        /// &lt;returns&gt;The converted string.&lt;/returns&gt;
        public static string ToFirstUpper(this string input)
        {
            return string.IsNullOrWhiteSpace(input)
                ? input
                : input.Substring(0, 1).ToUpper() + input.Substring(1);
        }

        /// &lt;summary&gt;
        /// Returns a copy of the string with the first character converted to lowercase.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;The string.&lt;/param&gt;
        /// &lt;returns&gt;The converted string.&lt;/returns&gt;
        public static string ToFirstLower(this string input)
        {
            return string.IsNullOrWhiteSpace(input)
                ? input
                : input.Substring(0, 1).ToLower() + input.Substring(1);
        }

        /// &lt;summary&gt;
        /// Returns a copy of the string with the first character converted to uppercase using the casing rules of the specified culture.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;The string.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The converted string.&lt;/returns&gt;
        public static string ToFirstUpper(this string input, CultureInfo culture)
        {
            return string.IsNullOrWhiteSpace(input)
                ? input
                : input.Substring(0, 1).ToUpper(culture) + input.Substring(1);
        }

        /// &lt;summary&gt;
        /// Returns a copy of the string with the first character converted to lowercase using the casing rules of the specified culture.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;The string.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The converted string.&lt;/returns&gt;
        public static string ToFirstLower(this string input, CultureInfo culture)
        {
            return string.IsNullOrWhiteSpace(input)
                ? input
                : input.Substring(0, 1).ToLower(culture) + input.Substring(1);
        }

        /// &lt;summary&gt;
        /// Returns a copy of the string with the first character converted to uppercase using the casing rules of the invariant culture.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;The string.&lt;/param&gt;
        /// &lt;returns&gt;The converted string.&lt;/returns&gt;
        public static string ToFirstUpperInvariant(this string input)
        {
            return string.IsNullOrWhiteSpace(input)
                ? input
                : input.Substring(0, 1).ToUpperInvariant() + input.Substring(1);
        }

        /// &lt;summary&gt;
        /// Returns a copy of the string with the first character converted to lowercase using the casing rules of the invariant culture.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;input&quot;&gt;The string.&lt;/param&gt;
        /// &lt;returns&gt;The converted string.&lt;/returns&gt;
        public static string ToFirstLowerInvariant(this string input)
        {
            return string.IsNullOrWhiteSpace(input)
                ? input
                : input.Substring(0, 1).ToLowerInvariant() + input.Substring(1);
        }

        /// &lt;summary&gt;
        /// Gets the short string helper.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;This is so that unit tests that do not initialize the resolver do not
        /// fail and fall back to defaults. When running the whole Umbraco, CoreBootManager
        /// does initialise the resolver.&lt;/remarks&gt;
        private static IShortStringHelper ShortStringHelper
        {
            get
            {
                if (ShortStringHelperResolver.HasCurrent)
                    return ShortStringHelperResolver.Current.Helper;
                if (_helper != null)
                    return _helper;

                // we don&#39;t want Umbraco to die because the resolver hasn&#39;t been initialized
                // as the ShortStringHelper is too important, so as long as it&#39;s not there
                // already, we use a default one. That should never happen, but...
                Logging.LogHelper.Warn&lt;IShortStringHelper&gt;(&quot;ShortStringHelperResolver.HasCurrent == false, fallback to default.&quot;);
                _helper = new DefaultShortStringHelper(UmbracoConfig.For.UmbracoSettings()).WithDefaultConfig();
                _helper.Freeze();
                return _helper;
            }
        }
        private static IShortStringHelper _helper;

        /// &lt;summary&gt;
        /// Returns a new string in which all occurences of specified strings are replaced by other specified strings.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The string to filter.&lt;/param&gt;
        /// &lt;param name=&quot;replacements&quot;&gt;The replacements definition.&lt;/param&gt;
        /// &lt;returns&gt;The filtered string.&lt;/returns&gt;
        public static string ReplaceMany(this string text, IDictionary&lt;string, string&gt; replacements)
        {
            return ShortStringHelper.ReplaceMany(text, replacements);
        }

        /// &lt;summary&gt;
        /// Returns a new string in which all occurences of specified characters are replaced by a specified character.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The string to filter.&lt;/param&gt;
        /// &lt;param name=&quot;chars&quot;&gt;The characters to replace.&lt;/param&gt;
        /// &lt;param name=&quot;replacement&quot;&gt;The replacement character.&lt;/param&gt;
        /// &lt;returns&gt;The filtered string.&lt;/returns&gt;
        public static string ReplaceMany(this string text, char[] chars, char replacement)
        {
            return ShortStringHelper.ReplaceMany(text, chars, replacement);
        }

        // FORMAT STRINGS

        // note: LegacyShortStringHelper will produce a 100% backward-compatible output for ToUrlAlias.
        // this is the only reason why we keep the method, otherwise it should be removed, and with any other
        // helper we fallback to ToUrlSegment anyway.

        /// &lt;summary&gt;
        /// Converts string to a URL alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
        /// &lt;param name=&quot;charReplacements&quot;&gt;The char replacements.&lt;/param&gt;
        /// &lt;param name=&quot;replaceDoubleDashes&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; replace double dashes.&lt;/param&gt;
        /// &lt;param name=&quot;stripNonAscii&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; strip non ASCII.&lt;/param&gt;
        /// &lt;param name=&quot;urlEncode&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; URL encode.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// This ensures that ONLY ascii chars are allowed and of those ascii chars, only digits and lowercase chars, all
        /// punctuation, etc... are stripped out, however this method allows you to pass in string&#39;s to replace with the
        /// specified replacement character before the string is converted to ascii and it has invalid characters stripped out.
        /// This allows you to replace strings like &amp;amp; , etc.. with your replacement character before the automatic
        /// reduction.
        /// &lt;/remarks&gt;
        [Obsolete(&quot;This method should be removed. Use ToUrlSegment instead.&quot;)]
        public static string ToUrlAlias(this string value, IDictionary&lt;string, string&gt; charReplacements, bool replaceDoubleDashes, bool stripNonAscii, bool urlEncode)
        {
            var helper = ShortStringHelper;
            var legacy = helper as LegacyShortStringHelper;
            return legacy != null
                ? legacy.LegacyToUrlAlias(value, charReplacements, replaceDoubleDashes, stripNonAscii, urlEncode)
                : helper.CleanStringForUrlSegment(value);
        }

        // note: LegacyShortStringHelper will produce a 100% backward-compatible output for FormatUrl.
        // this is the only reason why we keep the method, otherwise it should be removed, and with any other
        // helper we fallback to ToUrlSegment anyway.

        /// &lt;summary&gt;
        /// Cleans a string to produce a string that can safely be used in an url segment.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;url&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe url segment.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;When using the legacy ShortStringHelper, uses &lt;c&gt;UmbracoSettings.UrlReplaceCharacters&lt;/c&gt;
        ///  and &lt;c&gt;UmbracoSettings.RemoveDoubleDashesFromUrlReplacing&lt;/c&gt;.&lt;/para&gt;
        /// &lt;para&gt;Other helpers may use different parameters.&lt;/para&gt;
        /// &lt;/remarks&gt;
        [Obsolete(&quot;This method should be removed. Use ToUrlSegment instead.&quot;)]
        public static string FormatUrl(this string url)
        {
            var helper = ShortStringHelper;
            var legacy = helper as LegacyShortStringHelper;
            return legacy != null ? legacy.LegacyFormatUrl(url) : helper.CleanStringForUrlSegment(url);
        }

        // note: LegacyShortStringHelper will produce a 100% backward-compatible output for ToSafeAlias
        // other helpers may not. DefaultShortStringHelper produces better, but non-compatible, results.

        /// &lt;summary&gt;
        /// Cleans a string to produce a string that can safely be used in an alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe alias.&lt;/returns&gt;
        public static string ToSafeAlias(this string alias)
        {
            return ShortStringHelper.CleanStringForSafeAlias(alias);
        }

        /// &lt;summary&gt;
        /// Cleans a string to produce a string that can safely be used in an alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;camel&quot;&gt;A value indicating that we want to camel-case the alias.&lt;/param&gt;
        /// &lt;returns&gt;The safe alias.&lt;/returns&gt;
        public static string ToSafeAlias(this string alias, bool camel)
        {
            var a = ShortStringHelper.CleanStringForSafeAlias(alias);
            if (string.IsNullOrWhiteSpace(a) || camel == false) return a;
            return char.ToLowerInvariant(a[0]) + a.Substring(1);
        }

        /// &lt;summary&gt;
        /// Cleans a string, in the context of a specified culture, to produce a string that can safely be used in an alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The safe alias.&lt;/returns&gt;
        public static string ToSafeAlias(this string alias, CultureInfo culture)
        {
            return ShortStringHelper.CleanStringForSafeAlias(alias, culture);
        }

        /// &lt;summary&gt;
        /// Cleans (but only if required) a string to produce a string that can safely be used in an alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe alias.&lt;/returns&gt;
        /// &lt;remarks&gt;Checks &lt;c&gt;UmbracoSettings.ForceSafeAliases&lt;/c&gt; to determine whether it should filter the text.&lt;/remarks&gt;
        public static string ToSafeAliasWithForcingCheck(this string alias)
        {
            return UmbracoConfig.For.UmbracoSettings().Content.ForceSafeAliases ? alias.ToSafeAlias() : alias;
        }

        /// &lt;summary&gt;
        /// Cleans (but only if required) a string, in the context of a specified culture, to produce a string that can safely be used in an alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The safe alias.&lt;/returns&gt;
        /// &lt;remarks&gt;Checks &lt;c&gt;UmbracoSettings.ForceSafeAliases&lt;/c&gt; to determine whether it should filter the text.&lt;/remarks&gt;
        public static string ToSafeAliasWithForcingCheck(this string alias, CultureInfo culture)
        {
            return UmbracoConfig.For.UmbracoSettings().Content.ForceSafeAliases ? alias.ToSafeAlias(culture) : alias;
        }

        // note: LegacyShortStringHelper will produce a 100% backward-compatible output for ToUmbracoAlias.
        // this is the only reason why we keep the method, otherwise it should be removed, and with any other
        // helper we fallback to ToSafeAlias anyway.

        /// &lt;summary&gt;
        /// Cleans a string to produce a string that can safely be used in an alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;phrase&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;caseType&quot;&gt;The case type. THIS PARAMETER IS IGNORED.&lt;/param&gt;
        /// &lt;param name=&quot;removeSpaces&quot;&gt;Indicates whether spaces should be removed. THIS PARAMETER IS IGNORED.&lt;/param&gt;
        /// &lt;returns&gt;The safe alias.&lt;/returns&gt;
        /// &lt;remarks&gt;CamelCase, and remove spaces, whatever the parameters.&lt;/remarks&gt;
        [Obsolete(&quot;This method should be removed. Use ToSafeAlias instead.&quot;)]
        public static string ToUmbracoAlias(this string phrase, StringAliasCaseType caseType = StringAliasCaseType.CamelCase, bool removeSpaces = false)
        {
            var helper = ShortStringHelper;
            var legacy = helper as LegacyShortStringHelper;
            return legacy != null ? legacy.LegacyCleanStringForUmbracoAlias(phrase) : helper.CleanStringForSafeAlias(phrase);
        }

        // the new methods to get a url segment

        /// &lt;summary&gt;
        /// Cleans a string to produce a string that can safely be used in an url segment.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe url segment.&lt;/returns&gt;
        public static string ToUrlSegment(this string text)
        {
            return ShortStringHelper.CleanStringForUrlSegment(text);
        }

        /// &lt;summary&gt;
        /// Cleans a string, in the context of a specified culture, to produce a string that can safely be used in an url segment.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The safe url segment.&lt;/returns&gt;
        public static string ToUrlSegment(this string text, CultureInfo culture)
        {
            return ShortStringHelper.CleanStringForUrlSegment(text, culture);
        }

        // note: LegacyShortStringHelper will produce 100% backward-compatible output for ConvertCase.
        // this is the only reason why we keep the method, otherwise it should be removed, and with any other
        // helper we fallback to CleanString(ascii, alias) anyway.

        /// &lt;summary&gt;
        /// Filters a string to convert case, and more.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;phrase&quot;&gt;the text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;cases&quot;&gt;The string case type.&lt;/param&gt;
        /// &lt;returns&gt;The filtered text.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is the legacy method, so we can&#39;t really change it, although it has issues (see unit tests).&lt;/para&gt;
        /// &lt;para&gt;It does more than &quot;converting the case&quot;, and also remove spaces, etc.&lt;/para&gt;
        /// &lt;/remarks&gt;
        [Obsolete(&quot;This method should be removed. Use ToCleanString instead.&quot;)]
        public static string ConvertCase(this string phrase, StringAliasCaseType cases)
        {
            var helper = ShortStringHelper;
            var legacy = helper as LegacyShortStringHelper;
            var cases2 = cases.ToCleanStringType() &amp; CleanStringType.CaseMask;
            return legacy != null
                       ? legacy.LegacyConvertStringCase(phrase, cases2)
                       : helper.CleanString(phrase, CleanStringType.Ascii | CleanStringType.ConvertCase | cases2);
        }

        // the new methods to clean a string (to alias, url segment...)

        /// &lt;summary&gt;
        /// Cleans a string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to clean.&lt;/param&gt;
        /// &lt;param name=&quot;stringType&quot;&gt;A flag indicating the target casing and encoding of the string. By default, 
        /// strings are cleaned up to camelCase and Ascii.&lt;/param&gt;
        /// &lt;returns&gt;The clean string.&lt;/returns&gt;
        /// &lt;remarks&gt;The string is cleaned in the context of the IShortStringHelper default culture.&lt;/remarks&gt;
        public static string ToCleanString(this string text, CleanStringType stringType)
        {
            return ShortStringHelper.CleanString(text, stringType);
        }

        /// &lt;summary&gt;
        /// Cleans a string, using a specified separator.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to clean.&lt;/param&gt;
        /// &lt;param name=&quot;stringType&quot;&gt;A flag indicating the target casing and encoding of the string. By default, 
        /// strings are cleaned up to camelCase and Ascii.&lt;/param&gt;
        /// &lt;param name=&quot;separator&quot;&gt;The separator.&lt;/param&gt;
        /// &lt;returns&gt;The clean string.&lt;/returns&gt;
        /// &lt;remarks&gt;The string is cleaned in the context of the IShortStringHelper default culture.&lt;/remarks&gt;
        public static string ToCleanString(this string text, CleanStringType stringType, char separator)
        {
            return ShortStringHelper.CleanString(text, stringType, separator);
        }

        /// &lt;summary&gt;
        /// Cleans a string in the context of a specified culture.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to clean.&lt;/param&gt;
        /// &lt;param name=&quot;stringType&quot;&gt;A flag indicating the target casing and encoding of the string. By default, 
        /// strings are cleaned up to camelCase and Ascii.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The clean string.&lt;/returns&gt;
        public static string ToCleanString(this string text, CleanStringType stringType, CultureInfo culture)
        {
            return ShortStringHelper.CleanString(text, stringType, culture);
        }

        /// &lt;summary&gt;
        /// Cleans a string in the context of a specified culture, using a specified separator.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to clean.&lt;/param&gt;
        /// &lt;param name=&quot;stringType&quot;&gt;A flag indicating the target casing and encoding of the string. By default, 
        /// strings are cleaned up to camelCase and Ascii.&lt;/param&gt;
        /// &lt;param name=&quot;separator&quot;&gt;The separator.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The clean string.&lt;/returns&gt;
        public static string ToCleanString(this string text, CleanStringType stringType, char separator, CultureInfo culture)
        {
            return ShortStringHelper.CleanString(text, stringType, separator, culture);
        }

        // note: LegacyShortStringHelper will produce 100% backward-compatible output for SplitPascalCasing.
        // other helpers may not. DefaultShortStringHelper produces better, but non-compatible, results.

        /// &lt;summary&gt;
        /// Splits a Pascal cased string into a phrase separated by spaces.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;phrase&quot;&gt;The text to split.&lt;/param&gt;
        /// &lt;returns&gt;The splitted text.&lt;/returns&gt;
        public static string SplitPascalCasing(this string phrase)
        {
            return ShortStringHelper.SplitPascalCasing(phrase, &#39; &#39;);
        }

        /// &lt;summary&gt;
        /// Cleans a string, in the context of the invariant culture, to produce a string that can safely be used as a filename,
        /// both internally (on disk) and externally (as a url).
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe filename.&lt;/returns&gt;
        public static string ToSafeFileName(this string text)
        {
            return ShortStringHelper.CleanStringForSafeFileName(text);
        }

        /// &lt;summary&gt;
        /// Cleans a string, in the context of the invariant culture, to produce a string that can safely be used as a filename,
        /// both internally (on disk) and externally (as a url).
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The safe filename.&lt;/returns&gt;
        public static string ToSafeFileName(this string text, CultureInfo culture)
        {
            return ShortStringHelper.CleanStringForSafeFileName(text, culture);
        }

        /// &lt;summary&gt;
        /// An extension method that returns a new string in which all occurrences of a 
        /// specified string in the current instance are replaced with another specified string.
        /// StringComparison specifies the type of search to use for the specified string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;source&quot;&gt;Current instance of the string&lt;/param&gt;
        /// &lt;param name=&quot;oldString&quot;&gt;Specified string to replace&lt;/param&gt;
        /// &lt;param name=&quot;newString&quot;&gt;Specified string to inject&lt;/param&gt;
        /// &lt;param name=&quot;stringComparison&quot;&gt;String Comparison object to specify search type&lt;/param&gt;
        /// &lt;returns&gt;Updated string&lt;/returns&gt;
        public static string Replace(this string source, string oldString, string newString, StringComparison stringComparison)
        {
            // This initialisation ensures the first check starts at index zero of the source. On successive checks for
            // a match, the source is skipped to immediately after the last replaced occurrence for efficiency
            // and to avoid infinite loops when oldString and newString compare equal. 
            int index = -1 * newString.Length;

            // Determine if there are any matches left in source, starting from just after the result of replacing the last match.
            while ((index = source.IndexOf(oldString, index + newString.Length, stringComparison)) &gt;= 0)
            {
                // Remove the old text.
                source = source.Remove(index, oldString.Length);

                // Add the replacemenet text.
                source = source.Insert(index, newString);
            }

            return source;
        }

        /// &lt;summary&gt;
        /// Converts a literal string into a C# expression.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;s&quot;&gt;Current instance of the string.&lt;/param&gt;
        /// &lt;returns&gt;The string in a C# format.&lt;/returns&gt;
        public static string ToCSharpString(this string s)
        {
            if (s == null) return &quot;&lt;null&gt;&quot;;

            // http://stackoverflow.com/questions/323640/can-i-convert-a-c-sharp-string-value-to-an-escaped-string-literal

            var sb = new StringBuilder(s.Length + 2);
            for (var rp = 0; rp &lt; s.Length; rp++)
            {
                var c = s[rp];
                if (c &lt; ToCSharpEscapeChars.Length &amp;&amp; &#39;\0&#39; != ToCSharpEscapeChars[c])
                    sb.Append(&#39;\\&#39;).Append(ToCSharpEscapeChars[c]);
                else if (&#39;~&#39; &gt;= c &amp;&amp; c &gt;= &#39; &#39;)
                    sb.Append(c);
                else
                    sb.Append(@&quot;\x&quot;)
                      .Append(ToCSharpHexDigitLower[c &gt;&gt; 12 &amp; 0x0F])
                      .Append(ToCSharpHexDigitLower[c &gt;&gt; 8 &amp; 0x0F])
                      .Append(ToCSharpHexDigitLower[c &gt;&gt; 4 &amp; 0x0F])
                      .Append(ToCSharpHexDigitLower[c &amp; 0x0F]);
            }

            return sb.ToString();

            // requires full trust
            /*
            using (var writer = new StringWriter())
            using (var provider = CodeDomProvider.CreateProvider(&quot;CSharp&quot;))
            {
                provider.GenerateCodeFromExpression(new CodePrimitiveExpression(s), writer, null);
                return writer.ToString().Replace(string.Format(&quot;\&quot; +{0}\t\&quot;&quot;, Environment.NewLine), &quot;&quot;);
            }
            */
        }

        public static string EscapeRegexSpecialCharacters(this string text)
        {
            var regexSpecialCharacters = new Dictionary&lt;string, string&gt;
            {
                {&quot;.&quot;, @&quot;\.&quot;},
                {&quot;(&quot;, @&quot;\(&quot;},
                {&quot;)&quot;, @&quot;\)&quot;},
                {&quot;]&quot;, @&quot;\]&quot;},
                {&quot;[&quot;, @&quot;\[&quot;},
                {&quot;{&quot;, @&quot;\{&quot;},
                {&quot;}&quot;, @&quot;\}&quot;},
                {&quot;?&quot;, @&quot;\?&quot;},
                {&quot;!&quot;, @&quot;\!&quot;},
                {&quot;$&quot;, @&quot;\$&quot;},
                {&quot;^&quot;, @&quot;\^&quot;},
                {&quot;+&quot;, @&quot;\+&quot;},
                {&quot;*&quot;, @&quot;\*&quot;},
                {&quot;|&quot;, @&quot;\|&quot;},
                {&quot;&lt;&quot;, @&quot;\&lt;&quot;},
                {&quot;&gt;&quot;, @&quot;\&gt;&quot;}
            };
            return ReplaceMany(text, regexSpecialCharacters);
        }

        public static bool ContainsAny(this string haystack, IEnumerable&lt;string&gt; needles, StringComparison comparison = StringComparison.CurrentCulture)
        {
            if (haystack == null) throw new ArgumentNullException(&quot;haystack&quot;);
            if (string.IsNullOrEmpty(haystack) == false || needles.Any())
            {
                return needles.Any(value =&gt; haystack.IndexOf(value) &gt;= 0);
            }
            return false;
        }

        public static bool CsvContains(this string csv, string value)
        {
            if (string.IsNullOrEmpty(csv))
            {
                return false;
            }
            var idCheckList = csv.Split(new[] { &quot;,&quot; }, StringSplitOptions.RemoveEmptyEntries);
            return idCheckList.Contains(value);
        }

        // From: http://stackoverflow.com/a/961504/5018
        // filters control characters but allows only properly-formed surrogate sequences
        private static readonly Regex InvalidXmlChars =
            new Regex(
                @&quot;(?&lt;![\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F\uFEFF\uFFFE\uFFFF]&quot;,
                RegexOptions.Compiled);


        /// &lt;summary&gt;
        /// An extension method that returns a new string in which all occurrences of an 
        /// unicode characters that are invalid in XML files are replaced with an empty string. 
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;Current instance of the string&lt;/param&gt;
        /// &lt;returns&gt;Updated string&lt;/returns&gt;
        /// 
        /// &lt;summary&gt;
        /// removes any unusual unicode characters that can&#39;t be encoded into XML
        /// &lt;/summary&gt;
        internal static string ToValidXmlString(this string text)
        {
            return string.IsNullOrEmpty(text) ? text : InvalidXmlChars.Replace(text, &quot;&quot;);
        }

        /// &lt;summary&gt;
        /// Converts a string to a Guid - WARNING, depending on the string, this may not be unique
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal static Guid ToGuid(this string text)
        {
            var md5 = MD5.Create();
            byte[] myStringBytes = Encoding.ASCII.GetBytes(text);
            byte[] hash = md5.ComputeHash(myStringBytes);
            return new Guid(hash);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[33,9,33,97,1],[37,9,37,10,1],[38,13,38,114,1],[39,13,39,61,1],[39,61,39,65,1],[39,65,39,72,1],[39,13,39,72,1],[40,13,40,20,1],[40,22,40,32,1],[40,33,40,35,1],[40,36,40,43,1],[41,17,41,60,1],[42,9,42,10,1],[50,9,50,10,1],[51,13,51,60,1],[52,9,52,10,1],[55,9,55,10,1],[57,13,57,110,1],[57,111,57,127,0],[59,13,59,55,1],[60,13,60,31,1],[61,13,61,14,1],[62,17,62,57,1],[64,17,64,39,1],[64,40,64,56,1],[66,17,66,117,1],[68,13,68,29,1],[71,9,71,10,1],[84,9,84,10,1],[87,13,87,32,1],[89,13,89,78,1],[90,13,90,14,1],[94,17,94,87,1],[95,21,95,37,0],[98,17,98,95,1],[99,17,99,41,1],[99,41,99,64,1],[99,64,99,66,1],[99,17,99,66,1],[100,21,100,37,1],[102,17,102,29,1],[103,17,103,18,1],[104,21,104,75,1],[108,21,110,50,1],[112,13,112,14,1],[114,13,114,40,1],[115,9,115,10,1],[124,9,124,10,1],[125,13,125,34,1],[126,13,127,70,1],[128,9,128,10,1],[130,9,130,94,1],[131,9,131,79,1],[133,9,133,10,0],[134,13,134,82,0],[135,9,135,10,0],[143,9,143,10,1],[144,13,144,47,1],[145,13,145,14,1],[146,17,146,30,1],[149,13,149,14,0],[150,17,150,64,0],[151,17,151,28,0],[153,13,153,33,0],[154,13,154,14,0],[155,17,155,30,0],[157,9,157,10,1],[160,9,160,10,0],[162,13,162,31,0],[163,13,163,20,0],[163,22,163,27,0],[163,28,163,30,0],[163,31,163,62,0],[163,62,163,86,0],[163,86,163,87,0],[163,31,163,87,0],[164,13,164,14,0],[165,17,165,94,0],[166,13,166,14,0],[167,13,167,26,0],[168,9,168,10,0],[171,9,171,10,1],[172,13,172,50,1],[173,13,173,54,1],[174,18,174,27,1],[174,29,174,50,1],[174,52,174,55,1],[175,17,175,100,1],[176,13,176,44,1],[177,9,177,10,1],[179,9,179,97,1],[188,9,188,10,0],[190,13,190,39,0],[192,13,192,99,0],[193,9,193,10,0],[196,9,196,10,0],[197,13,197,52,0],[198,13,198,20,0],[198,22,198,27,0],[198,28,198,30,0],[198,31,198,46,0],[198,46,198,76,0],[198,76,198,77,0],[198,31,198,77,0],[199,13,199,14,0],[200,17,200,30,0],[201,13,201,14,0],[202,13,202,34,0],[203,9,203,10,0],[211,9,211,10,0],[212,13,212,45,0],[213,13,213,51,0],[214,13,214,29,0],[215,13,215,28,0],[216,13,216,33,0],[217,13,217,27,0],[218,9,218,10,0],[231,9,231,10,0],[233,18,233,27,0],[233,29,233,52,0],[233,54,233,57,0],[234,13,234,14,0],[235,17,235,84,0],[236,13,236,14,0],[238,13,238,52,0],[238,52,238,75,0],[238,75,238,87,0],[238,13,238,87,0],[240,13,240,35,0],[241,13,241,14,0],[242,17,242,79,0],[244,13,244,75,0],[245,9,245,10,0],[253,9,253,10,1],[254,13,254,31,1],[255,17,255,29,0],[257,13,257,43,1],[258,13,258,53,1],[262,13,262,61,1],[263,13,263,14,1],[264,17,264,74,1],[265,17,265,77,1],[266,13,266,14,1],[268,13,268,43,1],[269,13,269,14,1],[270,17,270,43,1],[271,13,271,14,1],[273,13,273,64,1],[275,13,275,20,1],[275,22,275,30,1],[275,31,275,33,1],[275,34,275,39,1],[276,13,276,14,1],[277,17,277,160,1],[278,17,278,59,1],[279,13,279,14,1],[281,13,281,56,1],[282,9,282,10,1],[290,9,290,10,1],[291,13,291,31,1],[292,17,292,29,0],[294,13,294,48,1],[296,13,296,64,1],[298,13,298,20,1],[298,22,298,30,1],[298,31,298,33,1],[298,34,298,39,1],[299,13,299,14,1],[300,17,300,93,1],[301,13,301,14,1],[303,13,303,46,1],[304,9,304,10,1],[308,9,308,10,1],[309,13,309,252,1],[310,13,310,14,0],[311,17,311,36,0],[312,17,312,29,0],[314,13,314,130,1],[315,13,315,14,0],[316,17,316,56,0],[317,17,317,37,0],[318,17,318,29,0],[320,13,320,73,1],[321,13,321,14,1],[322,17,322,35,1],[323,13,323,14,1],[324,13,324,25,1],[325,9,325,10,1],[328,9,328,10,0],[329,13,329,23,0],[343,21,343,33,0],[345,13,345,26,0],[346,9,346,10,0],[355,9,355,10,0],[356,13,356,45,0],[356,46,356,59,0],[357,13,357,70,0],[358,9,358,10,0],[361,9,361,10,0],[362,13,362,42,0],[363,13,363,20,0],[363,22,363,27,0],[363,28,363,30,0],[363,31,363,32,0],[364,13,364,14,0],[365,17,365,27,0],[368,25,368,43,0],[369,25,369,31,0],[371,25,371,43,0],[372,25,372,31,0],[374,25,374,42,0],[375,25,375,31,0],[377,25,377,42,0],[378,25,378,31,0],[380,25,380,42,0],[381,25,381,31,0],[383,25,383,42,0],[384,25,384,31,0],[386,25,386,42,0],[387,25,387,31,0],[389,25,389,40,0],[390,25,390,47,0],[391,25,391,26,0],[392,29,392,62,0],[393,25,393,26,0],[395,25,395,26,0],[396,29,396,42,0],[397,25,397,26,0],[398,25,398,31,0],[400,13,400,14,0],[401,13,401,34,0],[402,9,402,10,0],[405,9,405,10,1],[406,13,406,45,1],[406,46,406,59,0],[407,13,407,51,1],[407,52,407,65,0],[409,13,409,93,1],[410,13,410,14,1],[411,17,411,115,1],[412,13,412,14,1],[413,13,413,26,1],[414,9,414,10,1],[417,9,417,10,1],[418,13,418,45,1],[418,46,418,59,0],[419,13,419,51,1],[419,52,419,65,1],[421,13,421,95,1],[422,13,422,14,1],[423,17,423,61,1],[424,13,424,14,1],[425,13,425,26,1],[426,9,426,10,1],[429,9,429,10,1],[430,13,430,47,1],[430,48,430,61,1],[431,13,431,63,0],[432,9,432,10,1],[435,9,435,10,1],[436,13,436,107,1],[437,9,437,10,1],[440,9,440,10,1],[441,13,441,105,1],[442,9,442,10,1],[445,9,445,10,1],[446,13,446,113,1],[447,9,447,10,1],[450,9,450,10,0],[451,13,451,126,0],[452,9,452,10,0],[455,9,455,10,1],[456,13,456,126,1],[457,9,457,10,1],[463,9,463,10,1],[464,13,464,62,1],[465,9,465,10,1],[468,9,468,10,0],[469,13,469,66,0],[470,9,470,10,0],[478,9,478,10,0],[479,13,479,50,0],[480,13,482,43,0],[482,43,482,51,0],[482,51,484,45,0],[480,13,484,45,0],[485,9,485,10,0],[496,9,496,10,0],[498,13,498,14,0],[499,17,499,72,0],[500,17,500,29,0],[502,13,502,18,0],[503,13,503,14,0],[504,17,504,37,0],[505,17,505,30,0],[507,9,507,10,0],[519,9,519,10,1],[520,13,520,66,1],[521,9,521,10,1],[529,9,529,10,0],[531,13,531,63,0],[532,9,532,10,0],[540,9,540,10,1],[541,13,541,50,1],[541,51,541,92,0],[543,13,543,53,1],[544,13,544,81,1],[545,13,545,77,1],[546,13,546,37,1],[547,13,547,73,1],[548,9,548,10,1],[556,9,556,10,1],[557,13,557,45,1],[557,46,557,66,0],[559,13,559,54,1],[560,13,560,20,1],[560,22,560,27,1],[560,28,560,30,1],[560,31,560,36,1],[561,13,561,14,1],[562,17,562,64,1],[563,13,563,14,1],[564,13,564,34,1],[565,9,565,10,1],[568,9,568,10,0],[569,13,569,31,0],[570,13,570,40,0],[571,13,571,14,0],[572,17,572,103,0],[573,17,573,71,0],[574,13,574,14,0],[575,13,575,29,0],[576,9,576,10,0],[584,9,584,10,0],[585,13,585,31,0],[585,32,585,73,0],[587,13,587,45,0],[587,46,587,66,0],[589,13,589,55,0],[590,13,590,42,0],[592,9,592,10,0],[600,9,600,10,0],[601,13,601,31,0],[601,32,601,73,0],[606,13,606,14,0],[608,17,608,61,0],[609,17,609,92,0],[611,13,611,39,0],[612,13,612,14,0],[613,17,613,29,0],[615,9,615,10,0],[624,9,624,10,0],[625,13,625,78,0],[626,9,626,10,0],[634,9,634,10,1],[635,13,635,63,1],[636,9,636,10,1],[645,9,645,10,1],[646,13,646,99,1],[647,9,647,10,1],[650,9,650,10,1],[651,13,651,95,1],[652,9,652,10,1],[655,9,655,10,0],[656,13,656,93,0],[657,9,657,10,0],[660,9,660,10,1],[661,13,661,88,1],[662,9,662,10,1],[665,9,665,10,1],[666,13,666,91,1],[667,9,667,10,1],[672,9,672,10,0],[674,13,674,46,0],[675,9,675,10,0],[684,9,684,10,0],[685,13,685,48,0],[686,9,686,10,0],[695,9,695,10,0],[696,13,696,52,0],[697,13,697,14,0],[698,17,698,70,0],[699,17,699,44,0],[701,13,701,24,0],[702,9,702,10,0],[710,9,710,10,0],[712,13,712,62,0],[715,13,715,69,0],[718,13,718,70,0],[721,13,721,53,0],[724,13,724,20,0],[724,22,724,27,0],[724,28,724,30,0],[724,31,724,46,0],[725,13,725,14,0],[727,17,727,66,0],[728,13,728,14,0],[731,13,731,45,0],[732,9,732,10,0],[740,9,740,10,1],[742,13,742,63,1],[745,13,745,69,1],[748,13,748,70,1],[751,13,751,53,1],[754,13,754,20,1],[754,22,754,27,1],[754,28,754,30,1],[754,31,754,46,1],[755,13,755,14,1],[757,17,757,66,1],[758,13,758,14,1],[761,13,761,45,1],[762,9,762,10,1],[771,9,771,10,0],[772,13,772,31,0],[773,13,773,14,0],[774,17,774,58,0],[776,13,776,39,0],[777,13,777,28,0],[778,13,778,14,0],[779,17,779,36,0],[781,13,781,48,0],[782,13,782,43,0],[783,13,783,14,0],[784,17,784,29,0],[786,13,786,60,0],[787,18,787,27,0],[787,29,787,45,0],[787,47,787,50,0],[788,13,788,14,0],[789,17,789,36,0],[790,17,790,28,0],[793,25,793,42,0],[794,25,794,31,0],[797,25,797,42,0],[798,25,798,31,0],[801,25,801,41,0],[802,25,802,31,0],[804,13,804,14,0],[805,18,805,36,0],[805,38,805,56,0],[805,58,805,61,0],[806,13,806,14,0],[807,17,807,34,0],[808,13,808,14,0],[809,13,809,76,0],[810,9,810,10,0],[818,9,818,10,0],[819,13,819,31,0],[820,13,820,14,0],[821,17,821,58,0],[823,13,823,34,0],[824,13,824,14,0],[825,17,825,37,0],[827,13,827,31,0],[828,13,828,27,0],[829,13,829,35,0],[830,13,830,49,0],[831,13,831,29,0],[832,13,832,14,0],[833,17,833,29,0],[835,13,835,32,0],[836,13,836,30,0],[837,13,837,14,0],[838,17,838,43,0],[839,17,839,18,0],[840,21,840,27,0],[842,17,842,25,0],[843,13,843,14,0],[844,13,844,43,0],[845,13,845,66,0],[846,18,846,27,0],[846,29,846,38,0],[846,40,846,43,0],[847,13,847,14,0],[848,17,848,34,0],[849,17,849,28,0],[852,25,852,42,0],[853,25,853,31,0],[856,25,856,42,0],[857,25,857,31,0],[860,25,860,41,0],[861,25,861,31,0],[864,25,864,41,0],[865,25,865,31,0],[867,13,867,14,0],[868,13,868,40,0],[869,9,869,10,0],[877,9,877,10,0],[878,13,879,46,0],[879,46,879,58,0],[879,58,880,101,0],[878,13,880,101,0],[881,13,881,34,0],[882,9,882,10,0],[892,9,892,10,0],[894,13,894,40,0],[896,13,896,32,0],[896,33,896,56,0],[897,13,897,55,0],[899,13,899,32,0],[899,33,899,56,0],[901,13,901,58,0],[901,59,901,82,0],[903,13,903,60,0],[904,13,904,57,0],[905,13,905,39,0],[907,13,907,36,0],[908,9,908,10,0],[916,9,916,10,0],[917,13,917,62,0],[918,9,918,10,0],[921,9,921,10,0],[922,13,924,38,0],[925,9,925,10,0],[933,9,933,10,1],[934,13,936,72,1],[937,9,937,10,1],[945,9,945,10,1],[946,13,948,72,1],[949,9,949,10,1],[958,9,958,10,0],[959,13,961,79,0],[962,9,962,10,0],[971,9,971,10,0],[972,13,974,79,0],[975,9,975,10,0],[983,9,983,10,1],[984,13,986,81,1],[987,9,987,10,1],[995,9,995,10,0],[996,13,998,81,0],[999,9,999,10,0],[1010,13,1010,14,1],[1011,17,1011,58,1],[1012,21,1012,69,1],[1013,17,1013,37,1],[1014,21,1014,36,1],[1019,17,1019,131,1],[1020,17,1020,113,1],[1021,17,1021,34,1],[1022,17,1022,32,1],[1023,13,1023,14,1],[1034,9,1034,10,1],[1035,13,1035,70,1],[1036,9,1036,10,1],[1046,9,1046,10,1],[1047,13,1047,76,1],[1048,9,1048,10,1],[1074,9,1074,10,1],[1075,13,1075,44,1],[1076,13,1076,60,1],[1077,13,1079,58,1],[1080,9,1080,10,1],[1098,9,1098,10,0],[1099,13,1099,44,0],[1100,13,1100,60,0],[1101,13,1101,104,0],[1102,9,1102,10,0],[1113,9,1113,10,1],[1114,13,1114,69,1],[1115,9,1115,10,1],[1124,9,1124,10,0],[1125,13,1125,70,0],[1126,13,1126,64,0],[1126,65,1126,74,0],[1127,13,1127,65,0],[1128,9,1128,10,0],[1137,9,1137,10,1],[1138,13,1138,78,1],[1139,9,1139,10,1],[1148,9,1148,10,1],[1149,13,1149,111,1],[1150,9,1150,10,1],[1160,9,1160,10,0],[1161,13,1161,118,0],[1162,9,1162,10,0],[1178,9,1178,10,1],[1179,13,1179,44,1],[1180,13,1180,60,1],[1181,13,1181,126,1],[1182,9,1182,10,1],[1192,9,1192,10,1],[1193,13,1193,69,1],[1194,9,1194,10,1],[1203,9,1203,10,1],[1204,13,1204,78,1],[1205,9,1205,10,1],[1223,9,1223,10,1],[1224,13,1224,44,1],[1225,13,1225,60,1],[1226,13,1226,79,1],[1227,13,1229,115,1],[1230,9,1230,10,1],[1243,9,1243,10,1],[1244,13,1244,68,1],[1245,9,1245,10,1],[1257,9,1257,10,0],[1258,13,1258,79,0],[1259,9,1259,10,0],[1270,9,1270,10,0],[1271,13,1271,77,0],[1272,9,1272,10,0],[1284,9,1284,10,0],[1285,13,1285,88,0],[1286,9,1286,10,0],[1297,9,1297,10,1],[1298,13,1298,69,1],[1299,9,1299,10,1],[1308,9,1308,10,1],[1309,13,1309,71,1],[1310,9,1310,10,1],[1320,9,1320,10,1],[1321,13,1321,80,1],[1322,9,1322,10,1],[1335,9,1335,10,1],[1339,13,1339,47,1],[1342,13,1342,105,1],[1343,13,1343,14,1],[1345,17,1345,65,1],[1348,17,1348,58,1],[1349,13,1349,14,1],[1351,13,1351,27,1],[1352,9,1352,10,1],[1360,9,1360,10,0],[1361,13,1361,27,0],[1361,28,1361,44,0],[1365,13,1365,54,0],[1366,18,1366,28,0],[1366,30,1366,43,0],[1366,45,1366,49,0],[1367,13,1367,14,0],[1368,17,1368,31,0],[1369,17,1369,86,0],[1370,21,1370,68,0],[1371,22,1371,47,0],[1372,21,1372,34,0],[1374,21,1378,64,0],[1379,13,1379,14,0],[1381,13,1381,34,0],[1392,9,1392,10,0],[1395,9,1395,10,1],[1396,13,1414,15,1],[1415,13,1415,62,1],[1416,9,1416,10,1],[1419,9,1419,10,0],[1420,13,1420,34,0],[1420,35,1420,79,0],[1421,13,1421,74,0],[1422,13,1422,14,0],[1423,17,1423,45,0],[1423,45,1423,73,0],[1423,73,1423,75,0],[1423,17,1423,75,0],[1425,13,1425,26,0],[1426,9,1426,10,0],[1429,9,1429,10,0],[1430,13,1430,43,0],[1431,13,1431,14,0],[1432,17,1432,30,0],[1434,13,1434,95,0],[1435,13,1435,48,0],[1436,9,1436,10,0],[1440,9,1443,40,1],[1457,9,1457,10,1],[1458,13,1458,90,1],[1459,9,1459,10,1],[1467,9,1467,10,1],[1468,13,1468,36,1],[1469,13,1469,66,1],[1470,13,1470,58,1],[1471,13,1471,35,1],[1472,9,1472,10,1]]);
    </script>
  </body>
</html>