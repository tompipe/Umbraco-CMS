<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Routing\PublishedContentRequestEngine.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Globalization;
using System.IO;
using System.Web.Security;
using Umbraco.Core;
using Umbraco.Core.Configuration;
using Umbraco.Core.Configuration.UmbracoSettings;
using Umbraco.Core.IO;
using Umbraco.Core.Logging;
using Umbraco.Core.Security;

using umbraco;
using umbraco.cms.businesslogic.web;
using umbraco.cms.businesslogic.language;
using umbraco.cms.businesslogic.member;
using Umbraco.Core.Services;
using Umbraco.Web.Security;
using RenderingEngine = Umbraco.Core.RenderingEngine;

namespace Umbraco.Web.Routing
{
	internal class PublishedContentRequestEngine
	{	    
	    private readonly PublishedContentRequest _pcr;
	    private readonly RoutingContext _routingContext;
	    private readonly IWebRoutingSection _webRoutingSection;

	    /// &lt;summary&gt;
	    /// Initializes a new instance of the &lt;see cref=&quot;PublishedContentRequestEngine&quot;/&gt; class with a content request.
	    /// &lt;/summary&gt;
	    /// &lt;param name=&quot;webRoutingSection&quot;&gt;&lt;/param&gt;
	    /// &lt;param name=&quot;pcr&quot;&gt;The content request.&lt;/param&gt;
	    public PublishedContentRequestEngine(            
            IWebRoutingSection webRoutingSection,
            PublishedContentRequest pcr)
		{
	        if (pcr == null) throw new ArgumentException(&quot;pcr is null.&quot;);
	        if (webRoutingSection == null) throw new ArgumentNullException(&quot;webRoutingSection&quot;);
	       
	        _pcr = pcr;
	        _webRoutingSection = webRoutingSection;

	        _routingContext = pcr.RoutingContext;
			if (_routingContext == null) throw new ArgumentException(&quot;pcr.RoutingContext is null.&quot;);
			
			var umbracoContext = _routingContext.UmbracoContext;
			if (umbracoContext == null) throw new ArgumentException(&quot;pcr.RoutingContext.UmbracoContext is null.&quot;);
			if (umbracoContext.RoutingContext != _routingContext) throw new ArgumentException(&quot;RoutingContext confusion.&quot;);
			// no! not set yet.
			//if (umbracoContext.PublishedContentRequest != _pcr) throw new ArgumentException(&quot;PublishedContentRequest confusion.&quot;);
		}

        protected ProfilingLogger ProfilingLogger
	    {
            get { return _routingContext.UmbracoContext.Application.ProfilingLogger; }
	    }

	    protected ServiceContext Services
	    {
            get { return _routingContext.UmbracoContext.Application.Services; }

	    }

		#region Public

        /// &lt;summary&gt;
        /// Tries to route the request.
        /// &lt;/summary&gt;
	    internal bool TryRouteRequest()
	    {
            // disabled - is it going to change the routing?
            //_pcr.OnPreparing();

            FindDomain();
	        if (_pcr.IsRedirect) return false;
	        if (_pcr.HasPublishedContent) return true;
	        FindPublishedContent();
            if (_pcr.IsRedirect) return false;

            // don&#39;t handle anything - we just want to ensure that we find the content
            //HandlePublishedContent();
            //FindTemplate();
            //FollowExternalRedirect();
            //HandleWildcardDomains();

            // disabled - we just want to ensure that we find the content
            //_pcr.OnPrepared();

            return _pcr.HasPublishedContent;
	    }

		/// &lt;summary&gt;
		/// Prepares the request.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;
		/// Returns false if the request was not successfully prepared
		/// &lt;/returns&gt;
		public bool PrepareRequest()
		{
			// note - at that point the original legacy module did something do handle IIS custom 404 errors
			//   ie pages looking like /anything.aspx?404;/path/to/document - I guess the reason was to support
			//   &quot;directory urls&quot; without having to do wildcard mapping to ASP.NET on old IIS. This is a pain
			//   to maintain and probably not used anymore - removed as of 06/2012. @zpqrtbnk.
			//
			//   to trigger Umbraco&#39;s not-found, one should configure IIS and/or ASP.NET custom 404 errors
			//   so that they point to a non-existing page eg /redirect-404.aspx
			//   TODO: SD: We need more information on this for when we release 4.10.0 as I&#39;m not sure what this means.

            // trigger the Preparing event - at that point anything can still be changed
            // the idea is that it is possible to change the uri
            //
		    _pcr.OnPreparing();

			//find domain
			FindDomain();

			// if request has been flagged to redirect then return
			// whoever called us is in charge of actually redirecting
		    if (_pcr.IsRedirect)
		    {
		        return false;
		    }

		    // set the culture on the thread - once, so it&#39;s set when running document lookups
			Thread.CurrentThread.CurrentUICulture = Thread.CurrentThread.CurrentCulture = _pcr.Culture;

            //find the published content if it&#39;s not assigned. This could be manually assigned with a custom route handler, or
            // with something like EnsurePublishedContentRequestAttribute or UmbracoVirtualNodeRouteHandler. Those in turn call this method
            // to setup the rest of the pipeline but we don&#39;t want to run the finders since there&#39;s one assigned.
		    if (_pcr.PublishedContent == null)
		    {
                // find the document &amp; template
                FindPublishedContentAndTemplate();
		    }

            // handle wildcard domains
            HandleWildcardDomains();

            // set the culture on the thread -- again, &#39;cos it might have changed due to a finder or wildcard domain
            Thread.CurrentThread.CurrentUICulture = Thread.CurrentThread.CurrentCulture = _pcr.Culture;

			// trigger the Prepared event - at that point it is still possible to change about anything
            // even though the request might be flagged for redirection - we&#39;ll redirect _after_ the event
            //
            // also, OnPrepared() will make the PublishedContentRequest readonly, so nothing can change
            //
			_pcr.OnPrepared();

            // we don&#39;t take care of anything so if the content has changed, it&#39;s up to the user
            // to find out the appropriate template

            //complete the PCR and assign the remaining values
		    return ConfigureRequest();
		}

        /// &lt;summary&gt;
        /// Called by PrepareRequest once everything has been discovered, resolved and assigned to the PCR. This method
        /// finalizes the PCR with the values assigned.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// Returns false if the request was not successfully configured
        /// &lt;/returns&gt;
        /// &lt;remarks&gt;
        /// This method logic has been put into it&#39;s own method in case developers have created a custom PCR or are assigning their own values
        /// but need to finalize it themselves.
        /// &lt;/remarks&gt;
        public bool ConfigureRequest()
        {
            if (_pcr.HasPublishedContent == false)
            {
                return false;
            }

            // set the culture on the thread -- again, &#39;cos it might have changed in the event handler
            Thread.CurrentThread.CurrentUICulture = Thread.CurrentThread.CurrentCulture = _pcr.Culture;

            // if request has been flagged to redirect, or has no content to display,
            // then return - whoever called us is in charge of actually redirecting
            if (_pcr.IsRedirect || _pcr.HasPublishedContent == false)
            {
                return false;
            }

            // we may be 404 _and_ have a content

            // can&#39;t go beyond that point without a PublishedContent to render
            // it&#39;s ok not to have a template, in order to give MVC a chance to hijack routes

            // note - the page() ctor below will cause the &quot;page&quot; to get the value of all its
            // &quot;elements&quot; ie of all the IPublishedContent property. If we use the object value,
            // that will trigger macro execution - which can&#39;t happen because macro execution
            // requires that _pcr.UmbracoPage is already initialized = catch-22. The &quot;legacy&quot;
            // pipeline did _not_ evaluate the macros, ie it is using the data value, and we
            // have to keep doing it because of that catch-22.

            // assign the legacy page back to the docrequest
            // handlers like default.aspx will want it and most macros currently need it
            _pcr.UmbracoPage = new page(_pcr);

            // used by many legacy objects
            _routingContext.UmbracoContext.HttpContext.Items[&quot;pageID&quot;] = _pcr.PublishedContent.Id;
            _routingContext.UmbracoContext.HttpContext.Items[&quot;pageElements&quot;] = _pcr.UmbracoPage.Elements;

            return true;
        }

		/// &lt;summary&gt;
		/// Updates the request when there is no template to render the content.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;This is called from Mvc when there&#39;s a document to render but no template.&lt;/remarks&gt;
		public void UpdateRequestOnMissingTemplate()
		{
			// clear content
			var content = _pcr.PublishedContent;
			_pcr.PublishedContent = null;

			HandlePublishedContent(); // will go 404
			FindTemplate();

			// if request has been flagged to redirect then return
			// whoever called us is in charge of redirecting
			if (_pcr.IsRedirect)
				return;

			if (_pcr.HasPublishedContent == false)
			{
				// means the engine could not find a proper document to handle 404
				// restore the saved content so we know it exists
				_pcr.PublishedContent = content;
				return;
			}

			if (_pcr.HasTemplate == false)
			{
				// means we may have a document, but we have no template
				// at that point there isn&#39;t much we can do and there is no point returning
				// to Mvc since Mvc can&#39;t do much either
				return;
			}

            // see note in PrepareRequest()

			// assign the legacy page back to the docrequest
			// handlers like default.aspx will want it and most macros currently need it
			_pcr.UmbracoPage = new page(_pcr);

			// these two are used by many legacy objects
			_routingContext.UmbracoContext.HttpContext.Items[&quot;pageID&quot;] = _pcr.PublishedContent.Id;
			_routingContext.UmbracoContext.HttpContext.Items[&quot;pageElements&quot;] = _pcr.UmbracoPage.Elements;
		}

		#endregion

		#region Domain

		/// &lt;summary&gt;
		/// Finds the site root (if any) matching the http request, and updates the PublishedContentRequest accordingly.
		/// &lt;/summary&gt;        
		/// &lt;returns&gt;A value indicating whether a domain was found.&lt;/returns&gt;
		internal bool FindDomain()
		{
			const string tracePrefix = &quot;FindDomain: &quot;;

			// note - we are not handling schemes nor ports here.

			ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Uri=\&quot;{1}\&quot;&quot;, () =&gt; tracePrefix, () =&gt; _pcr.Uri);

			// try to find a domain matching the current request
            var domainAndUri = DomainHelper.DomainForUri(Services.DomainService.GetAll(false), _pcr.Uri);

			// handle domain
			if (domainAndUri != null &amp;&amp; domainAndUri.UmbracoDomain.LanguageIsoCode.IsNullOrWhiteSpace() == false)
			{
                // matching an existing domain
                ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Matches domain=\&quot;{1}\&quot;, rootId={2}, culture=\&quot;{3}\&quot;&quot;,
                    () =&gt; tracePrefix,
                    () =&gt; domainAndUri.UmbracoDomain.DomainName,
                    () =&gt; domainAndUri.UmbracoDomain.RootContentId,
                    () =&gt; domainAndUri.UmbracoDomain.LanguageIsoCode);

                _pcr.UmbracoDomain = domainAndUri.UmbracoDomain;
                _pcr.DomainUri = domainAndUri.Uri;
                _pcr.Culture = new CultureInfo(domainAndUri.UmbracoDomain.LanguageIsoCode);

                // canonical? not implemented at the moment
                // if (...)
                // {
                //  _pcr.RedirectUrl = &quot;...&quot;;
                //  return true;
                // }
            }
            else
			{
				// not matching any existing domain
				ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Matches no domain&quot;, () =&gt; tracePrefix);

                var defaultLanguage = Services.LocalizationService.GetAllLanguages().FirstOrDefault();
				_pcr.Culture = defaultLanguage == null ? CultureInfo.CurrentUICulture : new CultureInfo(defaultLanguage.IsoCode);
			}

			ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Culture=\&quot;{1}\&quot;&quot;, () =&gt; tracePrefix, () =&gt; _pcr.Culture.Name);

			return _pcr.UmbracoDomain != null;
		}

		/// &lt;summary&gt;
		/// Looks for wildcard domains in the path and updates &lt;c&gt;Culture&lt;/c&gt; accordingly.
		/// &lt;/summary&gt;
		internal void HandleWildcardDomains()
		{
			const string tracePrefix = &quot;HandleWildcardDomains: &quot;;

			if (_pcr.HasPublishedContent == false)
				return;

			var nodePath = _pcr.PublishedContent.Path;
			ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Path=\&quot;{1}\&quot;&quot;, () =&gt; tracePrefix, () =&gt; nodePath);
            var rootNodeId = _pcr.HasDomain ? _pcr.UmbracoDomain.RootContentId : (int?)null;
            var domain = DomainHelper.FindWildcardDomainInPath(Services.DomainService.GetAll(true), nodePath, rootNodeId);

			if (domain != null &amp;&amp; domain.LanguageIsoCode.IsNullOrWhiteSpace() == false)
			{
                _pcr.Culture = new CultureInfo(domain.LanguageIsoCode);
                ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Got domain on node {1}, set culture to \&quot;{2}\&quot;.&quot;, () =&gt; tracePrefix,
                    () =&gt; domain.RootContentId, () =&gt; _pcr.Culture.Name);
            }
			else
			{
				ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}No match.&quot;, () =&gt; tracePrefix);
			}
		}

		#endregion

		#region Rendering engine

        /// &lt;summary&gt;
        /// Finds the rendering engine to use to render a template specified by its alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The alias of the template.&lt;/param&gt;
        /// &lt;returns&gt;The rendering engine, or Unknown if the template was not found.&lt;/returns&gt;
        internal RenderingEngine FindTemplateRenderingEngine(string alias)
        {
            if (string.IsNullOrWhiteSpace(alias))
                return RenderingEngine.Unknown;

            alias = alias.Replace(&#39;\\&#39;, &#39;/&#39;); // forward slashes only

            // NOTE: we could start with what&#39;s the current default?

            if (FindTemplateRenderingEngineInDirectory(new DirectoryInfo(IOHelper.MapPath(SystemDirectories.MvcViews)),
                    alias, new[] { &quot;.cshtml&quot;, &quot;.vbhtml&quot; }))
                return RenderingEngine.Mvc;

            if (FindTemplateRenderingEngineInDirectory(new DirectoryInfo(IOHelper.MapPath(SystemDirectories.Masterpages)),
                    alias, new[] { &quot;.master&quot; }))
                return RenderingEngine.WebForms;

            return RenderingEngine.Unknown;
        }

        internal bool FindTemplateRenderingEngineInDirectory(DirectoryInfo directory, string alias, string[] extensions)
        {
            if (directory == null || directory.Exists == false)
                return false;

            var pos = alias.IndexOf(&#39;/&#39;);
            if (pos &gt; 0)
            {
                // recurse
                var subdir = directory.GetDirectories(alias.Substring(0, pos)).FirstOrDefault();
                alias = alias.Substring(pos + 1);
                return subdir != null &amp;&amp; FindTemplateRenderingEngineInDirectory(subdir, alias, extensions);
            }

            // look here
            return directory.GetFiles().Any(f =&gt; extensions.Any(e =&gt; f.Name.InvariantEquals(alias + e)));
        }

		#endregion

		#region Document and template

	    /// &lt;summary&gt;
	    /// Finds the Umbraco document (if any) matching the request, and updates the PublishedContentRequest accordingly.
	    /// &lt;/summary&gt;
	    /// &lt;returns&gt;A value indicating whether a document and template were found.&lt;/returns&gt;
	    private void FindPublishedContentAndTemplate()
		{
			const string tracePrefix = &quot;FindPublishedContentAndTemplate: &quot;;
			ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Path=\&quot;{1}\&quot;&quot;, () =&gt; tracePrefix, () =&gt; _pcr.Uri.AbsolutePath);

			// run the document finders
			FindPublishedContent();

            // if request has been flagged to redirect then return
            // whoever called us is in charge of actually redirecting
            // -- do not process anything any further --
            if (_pcr.IsRedirect)
	            return;

			// not handling umbracoRedirect here but after LookupDocument2
			// so internal redirect, 404, etc has precedence over redirect

			// handle not-found, redirects, access...
			HandlePublishedContent();

			// find a template
			FindTemplate();

			// handle umbracoRedirect
			FollowExternalRedirect();
		}

	    /// &lt;summary&gt;
	    /// Tries to find the document matching the request, by running the IPublishedContentFinder instances.
	    /// &lt;/summary&gt;
        /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;There is no finder collection.&lt;/exception&gt;
	    internal void FindPublishedContent()
		{
			const string tracePrefix = &quot;FindPublishedContent: &quot;;

			// look for the document
			// the first successful finder, if any, will set this.PublishedContent, and may also set this.Template
			// some finders may implement caching

            using (ProfilingLogger.DebugDuration&lt;PublishedContentRequestEngine&gt;(
				string.Format(&quot;{0}Begin finders&quot;, tracePrefix),
				string.Format(&quot;{0}End finders, {1}&quot;, tracePrefix, (_pcr.HasPublishedContent ? &quot;a document was found&quot; : &quot;no document was found&quot;))))
			{
			    if (_routingContext.PublishedContentFinders == null)
                    throw new InvalidOperationException(&quot;There is no finder collection.&quot;);

                //iterate but return on first one that finds it
			    var found = _routingContext.PublishedContentFinders.Any(finder =&gt; finder.TryFindContent(_pcr));
			}

		    // indicate that the published content (if any) we have at the moment is the
			// one that was found by the standard finders before anything else took place.
		    _pcr.SetIsInitialPublishedContent();
		}

		/// &lt;summary&gt;
		/// Handles the published content (if any).
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// Handles &quot;not found&quot;, internal redirects, access validation...
		/// things that must be handled in one place because they can create loops
		/// &lt;/remarks&gt;
		private void HandlePublishedContent()
		{
			const string tracePrefix = &quot;HandlePublishedContent: &quot;;

			// because these might loop, we have to have some sort of infinite loop detection 
			int i = 0, j = 0;
			const int maxLoop = 8;
			do
			{
				ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}{1}&quot;, () =&gt; tracePrefix, () =&gt; (i == 0 ? &quot;Begin&quot; : &quot;Loop&quot;));

				// handle not found
				if (_pcr.HasPublishedContent == false)
				{
					_pcr.Is404 = true;
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}No document, try last chance lookup&quot;, () =&gt; tracePrefix);

					// if it fails then give up, there isn&#39;t much more that we can do
					var lastChance = _routingContext.PublishedContentLastChanceFinder;
					if (lastChance == null || lastChance.TryFindContent(_pcr) == false)
					{
						ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Failed to find a document, give up&quot;, () =&gt; tracePrefix);
						break;
					}

					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Found a document&quot;, () =&gt; tracePrefix);
				}

				// follow internal redirects as long as it&#39;s not running out of control ie infinite loop of some sort
				j = 0;
				while (FollowInternalRedirects() &amp;&amp; j++ &lt; maxLoop)
				{ }
			    if (j == maxLoop) // we&#39;re running out of control
					break;

				// ensure access
				if (_pcr.HasPublishedContent)
					EnsurePublishedContentAccess();

				// loop while we don&#39;t have page, ie the redirect or access
				// got us to nowhere and now we need to run the notFoundLookup again
				// as long as it&#39;s not running out of control ie infinite loop of some sort

			} while (_pcr.HasPublishedContent == false &amp;&amp; i++ &lt; maxLoop);

			if (i == maxLoop || j == maxLoop)
			{
				ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Looks like we&#39;re running into an infinite loop, abort&quot;, () =&gt; tracePrefix);
				_pcr.PublishedContent = null;
			}

			ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}End&quot;, () =&gt; tracePrefix);
		}

		/// &lt;summary&gt;
		/// Follows internal redirections through the &lt;c&gt;umbracoInternalRedirectId&lt;/c&gt; document property.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;A value indicating whether redirection took place and led to a new published document.&lt;/returns&gt;
		/// &lt;remarks&gt;
		/// &lt;para&gt;Redirecting to a different site root and/or culture will not pick the new site root nor the new culture.&lt;/para&gt;
		/// &lt;para&gt;As per legacy, if the redirect does not work, we just ignore it.&lt;/para&gt;
		/// &lt;/remarks&gt;
		private bool FollowInternalRedirects()
		{
			const string tracePrefix = &quot;FollowInternalRedirects: &quot;;

			if (_pcr.PublishedContent == null)
				throw new InvalidOperationException(&quot;There is no PublishedContent.&quot;);

			bool redirect = false;
			var internalRedirect = _pcr.PublishedContent.GetPropertyValue&lt;string&gt;(Constants.Conventions.Content.InternalRedirectId);

			if (string.IsNullOrWhiteSpace(internalRedirect) == false)
			{
				ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Found umbracoInternalRedirectId={1}&quot;, () =&gt; tracePrefix, () =&gt; internalRedirect);

				int internalRedirectId;
				if (int.TryParse(internalRedirect, out internalRedirectId) == false)
					internalRedirectId = -1;

				if (internalRedirectId &lt;= 0)
				{
					// bad redirect - log and display the current page (legacy behavior)
					//_pcr.Document = null; // no! that would be to force a 404
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Failed to redirect to id={1}: invalid value&quot;, () =&gt; tracePrefix, () =&gt; internalRedirect);
				}
				else if (internalRedirectId == _pcr.PublishedContent.Id)
				{
					// redirect to self
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Redirecting to self, ignore&quot;, () =&gt; tracePrefix);
				}
				else
				{
					// redirect to another page
                    var node = _routingContext.UmbracoContext.ContentCache.GetById(internalRedirectId);
                    
                    if (node != null)
					{
                        _pcr.SetInternalRedirectPublishedContent(node); // don&#39;t use .PublishedContent here
                        redirect = true;
						ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Redirecting to id={1}&quot;, () =&gt; tracePrefix, () =&gt; internalRedirectId);
					}
					else
					{
						ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Failed to redirect to id={1}: no such published document&quot;, () =&gt; tracePrefix, () =&gt; internalRedirectId);
					}
				}
			}

			return redirect;
		}
        
		/// &lt;summary&gt;
		/// Ensures that access to current node is permitted.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;Redirecting to a different site root and/or culture will not pick the new site root nor the new culture.&lt;/remarks&gt;
		private void EnsurePublishedContentAccess()
		{
			const string tracePrefix = &quot;EnsurePublishedContentAccess: &quot;;

			if (_pcr.PublishedContent == null)
				throw new InvalidOperationException(&quot;There is no PublishedContent.&quot;);

			var path = _pcr.PublishedContent.Path;

		    var publicAccessAttempt = Services.PublicAccessService.IsProtected(path);

            if (publicAccessAttempt)
			{
				ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Page is protected, check for access&quot;, () =&gt; tracePrefix);

			    var membershipHelper = new MembershipHelper(_routingContext.UmbracoContext);

				if (membershipHelper.IsLoggedIn() == false)
				{
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Not logged in, redirect to login page&quot;, () =&gt; tracePrefix);

                    var loginPageId = publicAccessAttempt.Result.LoginNodeId;

					if (loginPageId != _pcr.PublishedContent.Id)
                        _pcr.PublishedContent = _routingContext.UmbracoContext.ContentCache.GetById(loginPageId);
				}
                else if (Services.PublicAccessService.HasAccess(_pcr.PublishedContent.Id, Services.ContentService, _pcr.GetRolesForLogin(membershipHelper.CurrentUserName)) == false)
				{
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Current member has not access, redirect to error page&quot;, () =&gt; tracePrefix);
				    var errorPageId = publicAccessAttempt.Result.NoAccessNodeId;
					if (errorPageId != _pcr.PublishedContent.Id)
                        _pcr.PublishedContent = _routingContext.UmbracoContext.ContentCache.GetById(errorPageId);
				}
				else
				{
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Current member has access&quot;, () =&gt; tracePrefix);
				}
			}
			else
			{
				ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Page is not protected&quot;, () =&gt; tracePrefix);
			}
		}

		/// &lt;summary&gt;
		/// Finds a template for the current node, if any.
		/// &lt;/summary&gt;
		private void FindTemplate()
		{
			// NOTE: at the moment there is only 1 way to find a template, and then ppl must
			// use the Prepared event to change the template if they wish. Should we also
			// implement an ITemplateFinder logic?

			const string tracePrefix = &quot;FindTemplate: &quot;;

            if (_pcr.PublishedContent == null)
            {
                _pcr.TemplateModel = null;
                return;
            }

			// read the alternate template alias, from querystring, form, cookie or server vars,
			// only if the published content is the initial once, else the alternate template
			// does not apply
            // + optionnally, apply the alternate template on internal redirects
            var useAltTemplate = _webRoutingSection.DisableAlternativeTemplates == false 
                &amp;&amp; (_pcr.IsInitialPublishedContent
                || (_webRoutingSection.InternalRedirectPreservesTemplate &amp;&amp; _pcr.IsInternalRedirectPublishedContent));
            string altTemplate = useAltTemplate
                ? _routingContext.UmbracoContext.HttpContext.Request[Constants.Conventions.Url.AltTemplate]
				: null;

			if (string.IsNullOrWhiteSpace(altTemplate))
			{
				// we don&#39;t have an alternate template specified. use the current one if there&#39;s one already,
				// which can happen if a content lookup also set the template (LookupByNiceUrlAndTemplate...),
				// else lookup the template id on the document then lookup the template with that id.

				if (_pcr.HasTemplate)
				{
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequest&gt;(&quot;{0}Has a template already, and no alternate template.&quot;, () =&gt; tracePrefix);
					return;
				}

				// TODO: When we remove the need for a database for templates, then this id should be irrelavent,
				// not sure how were going to do this nicely.

				var templateId = _pcr.PublishedContent.TemplateId;

				if (templateId &gt; 0)
				{
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Look for template id={1}&quot;, () =&gt; tracePrefix, () =&gt; templateId);
					var template = ApplicationContext.Current.Services.FileService.GetTemplate(templateId);
					if (template == null)
						throw new InvalidOperationException(&quot;The template with Id &quot; + templateId + &quot; does not exist, the page cannot render&quot;);
					_pcr.TemplateModel = template;
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Got template id={1} alias=\&quot;{2}\&quot;&quot;, () =&gt; tracePrefix, () =&gt; template.Id, () =&gt; template.Alias);
				}
				else
				{
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}No specified template.&quot;, () =&gt; tracePrefix);
				}
			}
			else
			{
				// we have an alternate template specified. lookup the template with that alias
				// this means the we override any template that a content lookup might have set
				// so /path/to/page/template1?altTemplate=template2 will use template2

				// ignore if the alias does not match - just trace

				if (_pcr.HasTemplate)
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Has a template already, but also an alternate template.&quot;, () =&gt; tracePrefix);
				ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Look for alternate template alias=\&quot;{1}\&quot;&quot;, () =&gt; tracePrefix, () =&gt; altTemplate);

				var template = ApplicationContext.Current.Services.FileService.GetTemplate(altTemplate);
				if (template != null)
				{
					_pcr.TemplateModel = template;
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Got template id={1} alias=\&quot;{2}\&quot;&quot;, () =&gt; tracePrefix, () =&gt; template.Id, () =&gt; template.Alias);
				}
				else
				{
					ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}The template with alias=\&quot;{1}\&quot; does not exist, ignoring.&quot;, () =&gt; tracePrefix, () =&gt; altTemplate);
				}
			}

			if (_pcr.HasTemplate == false)
			{
				ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}No template was found.&quot;, () =&gt; tracePrefix);

				// initial idea was: if we&#39;re not already 404 and UmbracoSettings.HandleMissingTemplateAs404 is true
				// then reset _pcr.Document to null to force a 404.
				//
				// but: because we want to let MVC hijack routes even though no template is defined, we decide that
				// a missing template is OK but the request will then be forwarded to MVC, which will need to take
				// care of everything.
				//
				// so, don&#39;t set _pcr.Document to null here
			}
			else
			{
				ProfilingLogger.Logger.Debug&lt;PublishedContentRequestEngine&gt;(&quot;{0}Running with template id={1} alias=\&quot;{2}\&quot;&quot;, () =&gt; tracePrefix, () =&gt; _pcr.TemplateModel.Id, () =&gt; _pcr.TemplateModel.Alias);
			}
		}

		/// &lt;summary&gt;
		/// Follows external redirection through &lt;c&gt;umbracoRedirect&lt;/c&gt; document property.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;As per legacy, if the redirect does not work, we just ignore it.&lt;/remarks&gt;
		private void FollowExternalRedirect()
		{
		    if (_pcr.HasPublishedContent == false) return;

		    var redirectId = _pcr.PublishedContent.GetPropertyValue(Constants.Conventions.Content.Redirect, -1);
		    var redirectUrl = &quot;#&quot;;
		    if (redirectId &gt; 0)
				redirectUrl = _routingContext.UrlProvider.GetUrl(redirectId);
		    if (redirectUrl != &quot;#&quot;)
		        _pcr.SetRedirect(redirectUrl);
		}
	
		#endregion
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[37,6,39,41,1],[40,3,40,4,1],[41,10,41,26,1],[41,27,41,71,1],[42,10,42,40,1],[42,41,42,94,0],[44,10,44,21,1],[45,10,45,49,1],[47,10,47,47,1],[48,4,48,32,1],[48,33,48,92,0],[50,4,50,56,1],[51,4,51,31,1],[51,32,51,106,0],[52,4,52,57,1],[52,58,52,115,0],[55,3,55,4,1],[59,17,59,18,1],[59,19,59,85,1],[59,86,59,87,1],[64,17,64,18,1],[64,19,64,78,1],[64,79,64,80,1],[74,6,74,7,0],[78,13,78,26,0],[79,10,79,30,0],[79,31,79,44,0],[80,10,80,39,0],[80,40,80,52,0],[81,10,81,33,0],[82,13,82,33,0],[82,34,82,47,0],[93,13,93,45,0],[94,6,94,7,0],[103,3,103,4,0],[116,7,116,26,0],[119,4,119,17,0],[123,7,123,27,0],[124,7,124,8,0],[125,11,125,24,0],[129,4,129,95,0],[134,7,134,41,0],[135,7,135,8,0],[137,17,137,51,0],[138,7,138,8,0],[141,13,141,37,0],[144,13,144,104,0],[151,4,151,22,0],[157,7,157,33,0],[158,3,158,4,0],[172,9,172,10,1],[173,13,173,51,1],[174,13,174,14,1],[175,17,175,30,1],[179,13,179,104,1],[183,13,183,70,1],[184,13,184,14,1],[185,17,185,30,1],[202,13,202,47,1],[205,13,205,99,1],[206,13,206,106,1],[208,13,208,25,1],[209,9,209,10,1],[216,3,216,4,0],[218,4,218,40,0],[219,4,219,33,0],[221,4,221,29,0],[222,4,222,19,0],[226,4,226,24,0],[227,5,227,12,0],[229,4,229,42,0],[230,4,230,5,0],[233,5,233,37,0],[234,5,234,12,0],[237,4,237,34,0],[238,4,238,5,0],[242,5,242,12,0],[249,4,249,38,0],[252,4,252,90,0],[253,4,253,97,0],[254,3,254,4,0],[265,3,265,4,1],[270,4,270,88,1],[270,88,270,99,0],[270,99,270,107,1],[270,107,270,115,0],[270,115,270,117,1],[270,4,270,117,1],[273,13,273,106,1],[276,4,276,105,1],[277,4,277,5,1],[279,17,280,27,1],[280,27,280,38,0],[280,38,281,27,1],[281,27,281,64,0],[281,64,282,27,1],[282,27,282,67,0],[282,67,283,27,1],[283,27,283,69,0],[283,69,283,71,1],[279,17,283,71,1],[285,17,285,65,1],[286,17,286,51,1],[287,17,287,92,1],[295,13,295,14,1],[297,4,297,5,1],[299,5,299,95,1],[299,95,299,106,0],[299,106,299,108,1],[299,5,299,108,1],[301,17,301,103,1],[302,5,302,118,1],[303,4,303,5,1],[305,4,305,92,1],[305,92,305,103,0],[305,103,305,111,1],[305,111,305,128,0],[305,128,305,130,1],[305,4,305,130,1],[307,4,307,38,1],[308,3,308,4,1],[314,3,314,4,1],[317,4,317,42,1],[318,5,318,12,0],[320,4,320,46,1],[321,4,321,89,1],[321,89,321,100,0],[321,100,321,108,1],[321,108,321,116,0],[321,116,321,118,1],[321,4,321,118,1],[322,13,322,93,1],[323,13,323,123,1],[325,4,325,79,1],[326,4,326,5,1],[327,17,327,72,1],[328,17,328,137,1],[328,137,328,148,0],[328,148,329,27,1],[329,27,329,47,0],[329,47,329,55,1],[329,55,329,72,0],[329,72,329,74,1],[328,17,329,74,1],[330,13,330,14,1],[332,4,332,5,1],[333,5,333,87,1],[333,87,333,98,0],[333,98,333,100,1],[333,5,333,100,1],[334,4,334,5,1],[335,3,335,4,1],[347,9,347,10,1],[348,13,348,50,1],[349,17,349,48,0],[351,13,351,46,1],[355,13,356,60,1],[357,17,357,44,1],[359,13,360,49,1],[361,17,361,49,1],[363,13,363,44,1],[364,9,364,10,1],[367,9,367,10,1],[368,13,368,64,1],[369,17,369,30,0],[371,13,371,42,1],[372,13,372,25,1],[373,13,373,14,1],[375,17,375,97,1],[376,17,376,50,1],[377,17,377,108,1],[381,13,381,50,1],[381,50,381,70,1],[381,70,381,103,1],[381,103,381,104,1],[381,50,381,104,1],[381,104,381,106,1],[381,13,381,106,1],[382,9,382,10,1],[393,3,393,4,0],[395,4,395,89,0],[395,89,395,100,0],[395,100,395,108,0],[395,108,395,129,0],[395,129,395,131,0],[395,4,395,131,0],[398,4,398,27,0],[403,13,403,33,0],[404,14,404,21,0],[410,4,410,29,0],[413,4,413,19,0],[416,4,416,29,0],[417,3,417,4,0],[424,3,424,4,1],[431,13,433,135,1],[434,4,434,5,1],[435,8,435,60,1],[436,21,436,91,0],[439,8,439,74,1],[439,74,439,101,1],[439,101,439,103,1],[439,8,439,103,1],[440,4,440,5,1],[444,7,444,43,1],[445,3,445,4,1],[455,3,455,4,0],[459,4,459,13,0],[459,15,459,20,0],[462,4,462,5,0],[463,5,463,81,0],[463,81,463,92,0],[463,92,463,100,0],[463,100,463,127,0],[463,127,463,129,0],[463,5,463,129,0],[466,5,466,43,0],[467,5,467,6,0],[468,6,468,24,0],[469,6,469,114,0],[469,114,469,125,0],[469,125,469,127,0],[469,6,469,127,0],[472,6,472,72,0],[473,6,473,73,0],[474,6,474,7,0],[475,7,475,114,0],[475,114,475,125,0],[475,125,475,127,0],[475,7,475,127,0],[476,7,476,13,0],[479,6,479,95,0],[479,95,479,106,0],[479,106,479,108,0],[479,6,479,108,0],[480,5,480,6,0],[483,5,483,11,0],[484,5,484,55,0],[485,5,485,6,0],[485,7,485,8,0],[486,8,486,25,0],[487,6,487,12,0],[490,5,490,34,0],[491,6,491,37,0],[497,4,497,5,0],[497,6,497,65,0],[499,4,499,37,0],[500,4,500,5,0],[501,5,501,131,0],[501,131,501,142,0],[501,142,501,144,0],[501,5,501,144,0],[502,5,502,34,0],[503,4,503,5,0],[505,4,505,80,0],[505,80,505,91,0],[505,91,505,93,0],[505,4,505,93,0],[506,3,506,4,0],[517,3,517,4,0],[520,4,520,38,0],[521,5,521,74,0],[523,4,523,26,0],[524,4,524,124,0],[526,4,526,61,0],[527,4,527,5,0],[528,5,528,113,0],[528,113,528,124,0],[528,124,528,132,0],[528,132,528,148,0],[528,148,528,150,0],[528,5,528,150,0],[531,5,531,73,0],[532,6,532,30,0],[534,5,534,33,0],[535,5,535,6,0],[538,6,538,122,0],[538,122,538,133,0],[538,133,538,141,0],[538,141,538,157,0],[538,157,538,159,0],[538,6,538,159,0],[539,5,539,6,0],[540,10,540,61,0],[541,5,541,6,0],[543,6,543,106,0],[543,106,543,117,0],[543,117,543,119,0],[543,6,543,119,0],[544,5,544,6,0],[546,5,546,6,0],[548,21,548,104,0],[550,21,550,38,0],[551,6,551,7,0],[552,25,552,72,0],[553,25,553,41,0],[554,7,554,101,0],[554,101,554,112,0],[554,112,554,120,0],[554,120,554,138,0],[554,138,554,140,0],[554,7,554,140,0],[555,6,555,7,0],[557,6,557,7,0],[558,7,558,136,0],[558,136,558,147,0],[558,147,558,155,0],[558,155,558,173,0],[558,173,558,175,0],[558,7,558,175,0],[559,6,559,7,0],[560,5,560,6,0],[561,4,561,5,0],[563,4,563,20,0],[564,3,564,4,0],[571,3,571,4,0],[574,4,574,38,0],[575,5,575,74,0],[577,4,577,42,0],[579,7,579,80,0],[581,13,581,37,0],[582,4,582,5,0],[583,5,583,113,0],[583,113,583,124,0],[583,124,583,126,0],[583,5,583,126,0],[585,8,585,84,0],[587,5,587,48,0],[588,5,588,6,0],[589,6,589,116,0],[589,116,589,127,0],[589,127,589,129,0],[589,6,589,129,0],[591,21,591,78,0],[593,6,593,50,0],[594,25,594,114,0],[595,5,595,6,0],[596,22,596,182,0],[597,5,597,6,0],[598,6,598,132,0],[598,132,598,143,0],[598,143,598,145,0],[598,6,598,145,0],[599,9,599,69,0],[600,6,600,50,0],[601,25,601,114,0],[602,5,602,6,0],[604,5,604,6,0],[605,6,605,104,0],[605,104,605,115,0],[605,115,605,117,0],[605,6,605,117,0],[606,5,606,6,0],[607,4,607,5,0],[609,4,609,5,0],[610,5,610,99,0],[610,99,610,110,0],[610,110,610,112,0],[610,5,610,112,0],[611,4,611,5,0],[612,3,612,4,0],[618,3,618,4,0],[625,13,625,47,0],[626,13,626,14,0],[627,17,627,43,0],[628,17,628,24,0],[635,13,637,119,0],[638,13,640,12,0],[642,4,642,47,0],[643,4,643,5,0],[648,5,648,26,0],[649,5,649,6,0],[650,6,650,123,0],[650,123,650,134,0],[650,134,650,136,0],[650,6,650,136,0],[651,6,651,13,0],[657,5,657,55,0],[659,5,659,24,0],[660,5,660,6,0],[661,6,661,103,0],[661,103,661,114,0],[661,114,661,122,0],[661,122,661,132,0],[661,132,661,134,0],[661,6,661,134,0],[662,6,662,93,0],[663,6,663,27,0],[664,7,664,125,0],[665,6,665,36,0],[666,6,666,112,0],[666,112,666,123,0],[666,123,666,131,0],[666,131,666,142,0],[666,142,666,150,0],[666,150,666,164,0],[666,164,666,166,0],[666,6,666,166,0],[667,5,667,6,0],[669,5,669,6,0],[670,6,670,101,0],[670,101,670,112,0],[670,112,670,114,0],[670,6,670,114,0],[671,5,671,6,0],[672,4,672,5,0],[674,4,674,5,0],[681,5,681,26,0],[682,6,682,134,0],[682,134,682,145,0],[682,145,682,147,0],[682,6,682,147,0],[683,5,683,119,0],[683,119,683,130,0],[683,130,683,138,0],[683,138,683,149,0],[683,149,683,151,0],[683,5,683,151,0],[685,5,685,93,0],[686,5,686,26,0],[687,5,687,6,0],[688,6,688,36,0],[689,6,689,112,0],[689,112,689,123,0],[689,123,689,131,0],[689,131,689,142,0],[689,142,689,150,0],[689,150,689,164,0],[689,164,689,166,0],[689,6,689,166,0],[690,5,690,6,0],[692,5,692,6,0],[693,6,693,136,0],[693,136,693,147,0],[693,147,693,155,0],[693,155,693,166,0],[693,166,693,168,0],[693,6,693,168,0],[694,5,694,6,0],[695,4,695,5,0],[697,4,697,34,0],[698,4,698,5,0],[699,5,699,100,0],[699,100,699,111,0],[699,111,699,113,0],[699,5,699,113,0],[709,4,709,5,0],[711,4,711,5,0],[712,5,712,120,0],[712,120,712,131,0],[712,131,712,139,0],[712,139,712,160,0],[712,160,712,168,0],[712,168,712,192,0],[712,192,712,194,0],[712,5,712,194,0],[713,4,713,5,0],[714,3,714,4,0],[721,3,721,4,0],[722,7,722,45,0],[722,46,722,53,0],[724,7,724,107,0],[725,7,725,29,0],[726,7,726,26,0],[727,5,727,66,0],[728,7,728,30,0],[729,11,729,41,0],[730,3,730,4,0]]);
    </script>
  </body>
</html>