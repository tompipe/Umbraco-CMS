<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Media\Exif\ExifBitConverter.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Text;

namespace Umbraco.Core.Media.Exif
{
    /// &lt;summary&gt;
    /// Converts between exif data types and array of bytes.
    /// &lt;/summary&gt;
    internal class ExifBitConverter : BitConverterEx
    {
        #region Constructors
        public ExifBitConverter(ByteOrder from, ByteOrder to)
            : base(from, to)
        {
            ;
        }
        #endregion

        #region Static Methods
        /// &lt;summary&gt;
        /// Returns an ASCII string converted from the given byte array.
        /// &lt;/summary&gt;
        public static string ToAscii(byte[] data, bool endatfirstnull, Encoding encoding)
        {
            int len = data.Length;
            if (endatfirstnull)
            {
                len = Array.IndexOf(data, (byte)0);
                if (len == -1) len = data.Length;
            }
            return encoding.GetString(data, 0, len);
        }

        /// &lt;summary&gt;
        /// Returns an ASCII string converted from the given byte array.
        /// &lt;/summary&gt;
        public static string ToAscii(byte[] data, Encoding encoding)
        {
            return ToAscii(data, true, encoding);
        }

        /// &lt;summary&gt;
        /// Returns a string converted from the given byte array.
        /// from the numeric value of each byte.
        /// &lt;/summary&gt;
        public static string ToString(byte[] data)
        {
            StringBuilder sb = new StringBuilder();
            foreach (byte b in data)
                sb.Append(b);
            return sb.ToString();
        }

        /// &lt;summary&gt;
        /// Returns a DateTime object converted from the given byte array.
        /// &lt;/summary&gt;
        public static DateTime ToDateTime(byte[] data, bool hastime)
        {
            string str = ToAscii(data, Encoding.ASCII);
            string[] parts = str.Split(new char[] { &#39;:&#39;, &#39; &#39; });
            try
            {
                if (hastime &amp;&amp; parts.Length == 6)
                {
                    // yyyy:MM:dd HH:mm:ss
                    // This is the expected format though some cameras
                    // can use single digits. See Issue 21.
                    return new DateTime(int.Parse(parts[0]), int.Parse(parts[1]), int.Parse(parts[2]), int.Parse(parts[3]), int.Parse(parts[4]), int.Parse(parts[5]));
                }
                else if (!hastime &amp;&amp; parts.Length == 3)
                {
                    // yyyy:MM:dd
                    return new DateTime(int.Parse(parts[0]), int.Parse(parts[1]), int.Parse(parts[2]));
                }
                else
                {
                    return DateTime.MinValue;
                }
            }
            catch (ArgumentOutOfRangeException)
            {
                return DateTime.MinValue;
            }
            catch (ArgumentException)
            {
                return DateTime.MinValue;
            }
        }

        /// &lt;summary&gt;
        /// Returns a DateTime object converted from the given byte array.
        /// &lt;/summary&gt;
        public static DateTime ToDateTime(byte[] data)
        {
            return ToDateTime(data, true);
        }

        /// &lt;summary&gt;
        /// Returns an unsigned rational number converted from the first 
        /// eight bytes of the given byte array. The first four bytes are
        /// assumed to be the numerator and the next four bytes are the
        /// denumerator.
        /// Numbers are converted from the given byte-order to platform byte-order.
        /// &lt;/summary&gt;
        public static MathEx.UFraction32 ToURational(byte[] data, ByteOrder frombyteorder)
        {
            byte[] num = new byte[4];
            byte[] den = new byte[4];
            Array.Copy(data, 0, num, 0, 4);
            Array.Copy(data, 4, den, 0, 4);
            return new MathEx.UFraction32(ToUInt32(num, 0, frombyteorder, BitConverterEx.SystemByteOrder), ToUInt32(den, 0, frombyteorder, BitConverterEx.SystemByteOrder));
        }

        /// &lt;summary&gt;
        /// Returns a signed rational number converted from the first 
        /// eight bytes of the given byte array. The first four bytes are
        /// assumed to be the numerator and the next four bytes are the
        /// denumerator.
        /// Numbers are converted from the given byte-order to platform byte-order.
        /// &lt;/summary&gt;
        public static MathEx.Fraction32 ToSRational(byte[] data, ByteOrder frombyteorder)
        {
            byte[] num = new byte[4];
            byte[] den = new byte[4];
            Array.Copy(data, 0, num, 0, 4);
            Array.Copy(data, 4, den, 0, 4);
            return new MathEx.Fraction32(ToInt32(num, 0, frombyteorder, BitConverterEx.SystemByteOrder), ToInt32(den, 0, frombyteorder, BitConverterEx.SystemByteOrder));
        }

        /// &lt;summary&gt;
        /// Returns an array of 16-bit unsigned integers converted from 
        /// the given byte array.
        /// Numbers are converted from the given byte-order to platform byte-order.
        /// &lt;/summary&gt;
        public static ushort[] ToUShortArray(byte[] data, int count, ByteOrder frombyteorder)
        {
            ushort[] numbers = new ushort[count];
            for (uint i = 0; i &lt; count; i++)
            {
                byte[] num = new byte[2];
                Array.Copy(data, i * 2, num, 0, 2);
                numbers[i] = ToUInt16(num, 0, frombyteorder, BitConverterEx.SystemByteOrder);
            }
            return numbers;
        }

        /// &lt;summary&gt;
        /// Returns an array of 32-bit unsigned integers converted from 
        /// the given byte array.
        /// Numbers are converted from the given byte-order to platform byte-order.
        /// &lt;/summary&gt;
        public static uint[] ToUIntArray(byte[] data, int count, ByteOrder frombyteorder)
        {
            uint[] numbers = new uint[count];
            for (uint i = 0; i &lt; count; i++)
            {
                byte[] num = new byte[4];
                Array.Copy(data, i * 4, num, 0, 4);
                numbers[i] = ToUInt32(num, 0, frombyteorder, BitConverterEx.SystemByteOrder);
            }
            return numbers;
        }

        /// &lt;summary&gt;
        /// Returns an array of 32-bit signed integers converted from 
        /// the given byte array.
        /// Numbers are converted from the given byte-order to platform byte-order.
        /// &lt;/summary&gt;
        public static int[] ToSIntArray(byte[] data, int count, ByteOrder byteorder)
        {
            int[] numbers = new int[count];
            for (uint i = 0; i &lt; count; i++)
            {
                byte[] num = new byte[4];
                Array.Copy(data, i * 4, num, 0, 4);
                numbers[i] = ToInt32(num, 0, byteorder, BitConverterEx.SystemByteOrder);
            }
            return numbers;
        }

        /// &lt;summary&gt;
        /// Returns an array of unsigned rational numbers converted from 
        /// the given byte array.
        /// Numbers are converted from the given byte-order to platform byte-order.
        /// &lt;/summary&gt;
        public static MathEx.UFraction32[] ToURationalArray(byte[] data, int count, ByteOrder frombyteorder)
        {
            MathEx.UFraction32[] numbers = new MathEx.UFraction32[count];
            for (uint i = 0; i &lt; count; i++)
            {
                byte[] num = new byte[4];
                byte[] den = new byte[4];
                Array.Copy(data, i * 8, num, 0, 4);
                Array.Copy(data, i * 8 + 4, den, 0, 4);
                numbers[i].Set(ToUInt32(num, 0, frombyteorder, BitConverterEx.SystemByteOrder), ToUInt32(den, 0, frombyteorder, BitConverterEx.SystemByteOrder));
            }
            return numbers;
        }

        /// &lt;summary&gt;
        /// Returns an array of signed rational numbers converted from 
        /// the given byte array.
        /// Numbers are converted from the given byte-order to platform byte-order.
        /// &lt;/summary&gt;
        public static MathEx.Fraction32[] ToSRationalArray(byte[] data, int count, ByteOrder frombyteorder)
        {
            MathEx.Fraction32[] numbers = new MathEx.Fraction32[count];
            for (uint i = 0; i &lt; count; i++)
            {
                byte[] num = new byte[4];
                byte[] den = new byte[4];
                Array.Copy(data, i * 8, num, 0, 4);
                Array.Copy(data, i * 8 + 4, den, 0, 4);
                numbers[i].Set(ToInt32(num, 0, frombyteorder, BitConverterEx.SystemByteOrder), ToInt32(den, 0, frombyteorder, BitConverterEx.SystemByteOrder));
            }
            return numbers;
        }

        /// &lt;summary&gt;
        /// Converts the given ascii string to an array of bytes optionally adding a null terminator.
        /// &lt;/summary&gt;
        public static byte[] GetBytes(string value, bool addnull, Encoding encoding)
        {
            if (addnull) value += &#39;\0&#39;;
            return encoding.GetBytes(value);
        }

        /// &lt;summary&gt;
        /// Converts the given ascii string to an array of bytes without adding a null terminator.
        /// &lt;/summary&gt;
        public static byte[] GetBytes(string value, Encoding encoding)
        {
            return GetBytes(value, false, encoding);
        }

        /// &lt;summary&gt;
        /// Converts the given datetime to an array of bytes with a null terminator.
        /// &lt;/summary&gt;
        public static byte[] GetBytes(DateTime value, bool hastime)
        {
            string str = &quot;&quot;;
            if (hastime)
                str = value.ToString(&quot;yyyy:MM:dd HH:mm:ss&quot;, System.Globalization.CultureInfo.InvariantCulture);
            else
                str = value.ToString(&quot;yyyy:MM:dd&quot;, System.Globalization.CultureInfo.InvariantCulture);
            return GetBytes(str, true, Encoding.ASCII);
        }

        /// &lt;summary&gt;
        /// Converts the given unsigned rational number to an array of bytes.
        /// Numbers are converted from the platform byte-order to the given byte-order.
        /// &lt;/summary&gt;
        public static byte[] GetBytes(MathEx.UFraction32 value, ByteOrder tobyteorder)
        {
            byte[] num = GetBytes(value.Numerator, BitConverterEx.SystemByteOrder, tobyteorder);
            byte[] den = GetBytes(value.Denominator, BitConverterEx.SystemByteOrder, tobyteorder);
            byte[] data = new byte[8];
            Array.Copy(num, 0, data, 0, 4);
            Array.Copy(den, 0, data, 4, 4);
            return data;
        }

        /// &lt;summary&gt;
        /// Converts the given signed rational number to an array of bytes.
        /// Numbers are converted from the platform byte-order to the given byte-order.
        /// &lt;/summary&gt;
        public static byte[] GetBytes(MathEx.Fraction32 value, ByteOrder tobyteorder)
        {
            byte[] num = GetBytes(value.Numerator, BitConverterEx.SystemByteOrder, tobyteorder);
            byte[] den = GetBytes(value.Denominator, BitConverterEx.SystemByteOrder, tobyteorder);
            byte[] data = new byte[8];
            Array.Copy(num, 0, data, 0, 4);
            Array.Copy(den, 0, data, 4, 4);
            return data;
        }

        /// &lt;summary&gt;
        /// Converts the given array of 16-bit unsigned integers to an array of bytes.
        /// Numbers are converted from the platform byte-order to the given byte-order.
        /// &lt;/summary&gt;
        public static byte[] GetBytes(ushort[] value, ByteOrder tobyteorder)
        {
            byte[] data = new byte[2 * value.Length];
            for (int i = 0; i &lt; value.Length; i++)
            {
                byte[] num = GetBytes(value[i], BitConverterEx.SystemByteOrder, tobyteorder);
                Array.Copy(num, 0, data, i * 2, 2);
            }
            return data;
        }

        /// &lt;summary&gt;
        /// Converts the given array of 32-bit unsigned integers to an array of bytes.
        /// Numbers are converted from the platform byte-order to the given byte-order.
        /// &lt;/summary&gt;
        public static byte[] GetBytes(uint[] value, ByteOrder tobyteorder)
        {
            byte[] data = new byte[4 * value.Length];
            for (int i = 0; i &lt; value.Length; i++)
            {
                byte[] num = GetBytes(value[i], BitConverterEx.SystemByteOrder, tobyteorder);
                Array.Copy(num, 0, data, i * 4, 4);
            }
            return data;
        }

        /// &lt;summary&gt;
        /// Converts the given array of 32-bit signed integers to an array of bytes.
        /// Numbers are converted from the platform byte-order to the given byte-order.
        /// &lt;/summary&gt;
        public static byte[] GetBytes(int[] value, ByteOrder tobyteorder)
        {
            byte[] data = new byte[4 * value.Length];
            for (int i = 0; i &lt; value.Length; i++)
            {
                byte[] num = GetBytes(value[i], BitConverterEx.SystemByteOrder, tobyteorder);
                Array.Copy(num, 0, data, i * 4, 4);
            }
            return data;
        }

        /// &lt;summary&gt;
        /// Converts the given array of unsigned rationals to an array of bytes.
        /// Numbers are converted from the platform byte-order to the given byte-order.
        /// &lt;/summary&gt;
        public static byte[] GetBytes(MathEx.UFraction32[] value, ByteOrder tobyteorder)
        {
            byte[] data = new byte[8 * value.Length];
            for (int i = 0; i &lt; value.Length; i++)
            {
                byte[] num = GetBytes(value[i].Numerator, BitConverterEx.SystemByteOrder, tobyteorder);
                byte[] den = GetBytes(value[i].Denominator, BitConverterEx.SystemByteOrder, tobyteorder);
                Array.Copy(num, 0, data, i * 8, 4);
                Array.Copy(den, 0, data, i * 8 + 4, 4);
            }
            return data;
        }

        /// &lt;summary&gt;
        /// Converts the given array of signed rationals to an array of bytes.
        /// Numbers are converted from the platform byte-order to the given byte-order.
        /// &lt;/summary&gt;
        public static byte[] GetBytes(MathEx.Fraction32[] value, ByteOrder tobyteorder)
        {
            byte[] data = new byte[8 * value.Length];
            for (int i = 0; i &lt; value.Length; i++)
            {
                byte[] num = GetBytes(value[i].Numerator, BitConverterEx.SystemByteOrder, tobyteorder);
                byte[] den = GetBytes(value[i].Denominator, BitConverterEx.SystemByteOrder, tobyteorder);
                Array.Copy(num, 0, data, i * 8, 4);
                Array.Copy(den, 0, data, i * 8 + 4, 4);
            }
            return data;
        }
        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[13,15,13,29,0],[14,9,14,10,0],[15,13,15,14,0],[16,9,16,10,0],[24,9,24,10,0],[25,13,25,35,0],[26,13,26,32,0],[27,13,27,14,0],[28,17,28,52,0],[29,17,29,31,0],[29,32,29,50,0],[30,13,30,14,0],[31,13,31,53,0],[32,9,32,10,0],[38,9,38,10,0],[39,13,39,50,0],[40,9,40,10,0],[47,9,47,10,0],[48,13,48,52,0],[49,13,49,20,0],[49,22,49,28,0],[49,29,49,31,0],[49,32,49,36,0],[50,17,50,30,0],[51,13,51,34,0],[52,9,52,10,0],[58,9,58,10,0],[59,13,59,56,0],[60,13,60,65,0],[62,13,62,14,0],[63,17,63,50,0],[64,17,64,18,0],[68,21,68,167,0],[70,22,70,56,0],[71,17,71,18,0],[73,21,73,104,0],[76,17,76,18,0],[77,21,77,46,0],[80,13,80,48,0],[81,13,81,14,0],[82,17,82,42,0],[84,13,84,38,0],[85,13,85,14,0],[86,17,86,42,0],[88,9,88,10,0],[94,9,94,10,0],[95,13,95,43,0],[96,9,96,10,0],[106,9,106,10,0],[107,13,107,38,0],[108,13,108,38,0],[109,13,109,44,0],[110,13,110,44,0],[111,13,111,173,0],[112,9,112,10,0],[122,9,122,10,0],[123,13,123,38,0],[124,13,124,38,0],[125,13,125,44,0],[126,13,126,44,0],[127,13,127,170,0],[128,9,128,10,0],[136,9,136,10,0],[137,13,137,50,0],[138,18,138,28,0],[138,30,138,39,0],[138,41,138,44,0],[139,13,139,14,0],[140,17,140,42,0],[141,17,141,52,0],[142,17,142,94,0],[143,13,143,14,0],[144,13,144,28,0],[145,9,145,10,0],[153,9,153,10,0],[154,13,154,46,0],[155,18,155,28,0],[155,30,155,39,0],[155,41,155,44,0],[156,13,156,14,0],[157,17,157,42,0],[158,17,158,52,0],[159,17,159,94,0],[160,13,160,14,0],[161,13,161,28,0],[162,9,162,10,0],[170,9,170,10,0],[171,13,171,44,0],[172,18,172,28,0],[172,30,172,39,0],[172,41,172,44,0],[173,13,173,14,0],[174,17,174,42,0],[175,17,175,52,0],[176,17,176,89,0],[177,13,177,14,0],[178,13,178,28,0],[179,9,179,10,0],[187,9,187,10,0],[188,13,188,74,0],[189,18,189,28,0],[189,30,189,39,0],[189,41,189,44,0],[190,13,190,14,0],[191,17,191,42,0],[192,17,192,42,0],[193,17,193,52,0],[194,17,194,56,0],[195,17,195,162,0],[196,13,196,14,0],[197,13,197,28,0],[198,9,198,10,0],[206,9,206,10,0],[207,13,207,72,0],[208,18,208,28,0],[208,30,208,39,0],[208,41,208,44,0],[209,13,209,14,0],[210,17,210,42,0],[211,17,211,42,0],[212,17,212,52,0],[213,17,213,56,0],[214,17,214,160,0],[215,13,215,14,0],[216,13,216,28,0],[217,9,217,10,0],[223,9,223,10,0],[224,13,224,25,0],[224,26,224,40,0],[225,13,225,45,0],[226,9,226,10,0],[232,9,232,10,0],[233,13,233,53,0],[234,9,234,10,0],[240,9,240,10,0],[241,13,241,29,0],[242,13,242,25,0],[243,17,243,112,0],[245,17,245,103,0],[246,13,246,56,0],[247,9,247,10,0],[254,9,254,10,0],[255,13,255,97,0],[256,13,256,99,0],[257,13,257,39,0],[258,13,258,44,0],[259,13,259,44,0],[260,13,260,25,0],[261,9,261,10,0],[268,9,268,10,0],[269,13,269,97,0],[270,13,270,99,0],[271,13,271,39,0],[272,13,272,44,0],[273,13,273,44,0],[274,13,274,25,0],[275,9,275,10,0],[282,9,282,10,0],[283,13,283,54,0],[284,18,284,27,0],[284,29,284,45,0],[284,47,284,50,0],[285,13,285,14,0],[286,17,286,94,0],[287,17,287,52,0],[288,13,288,14,0],[289,13,289,25,0],[290,9,290,10,0],[297,9,297,10,0],[298,13,298,54,0],[299,18,299,27,0],[299,29,299,45,0],[299,47,299,50,0],[300,13,300,14,0],[301,17,301,94,0],[302,17,302,52,0],[303,13,303,14,0],[304,13,304,25,0],[305,9,305,10,0],[312,9,312,10,0],[313,13,313,54,0],[314,18,314,27,0],[314,29,314,45,0],[314,47,314,50,0],[315,13,315,14,0],[316,17,316,94,0],[317,17,317,52,0],[318,13,318,14,0],[319,13,319,25,0],[320,9,320,10,0],[327,9,327,10,0],[328,13,328,54,0],[329,18,329,27,0],[329,29,329,45,0],[329,47,329,50,0],[330,13,330,14,0],[331,17,331,104,0],[332,17,332,106,0],[333,17,333,52,0],[334,17,334,56,0],[335,13,335,14,0],[336,13,336,25,0],[337,9,337,10,0],[344,9,344,10,0],[345,13,345,54,0],[346,18,346,27,0],[346,29,346,45,0],[346,47,346,50,0],[347,13,347,14,0],[348,17,348,104,0],[349,17,349,106,0],[350,17,350,52,0],[351,17,351,56,0],[352,13,352,14,0],[353,13,353,25,0],[354,9,354,10,0]]);
    </script>
  </body>
</html>