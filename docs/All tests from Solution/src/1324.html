<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Editors\DataTypeValidateAttribute.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Web.Http;
using System.Web.Http.Controllers;
using System.Web.Http.Filters;
using AutoMapper;
using Umbraco.Core;
using Umbraco.Core.Models;
using Umbraco.Core.Models.EntityBase;
using Umbraco.Core.PropertyEditors;
using Umbraco.Core.Services;
using Umbraco.Web.Models.ContentEditing;
using Umbraco.Web.WebApi;

namespace Umbraco.Web.Editors
{
    /// &lt;summary&gt;
    /// An action filter that wires up the persisted entity of the DataTypeSave model and validates the whole request
    /// &lt;/summary&gt;
    internal sealed class DataTypeValidateAttribute : ActionFilterAttribute
    {
        private readonly IDataTypeService _dataTypeService;

        public DataTypeValidateAttribute()
        {            
        }

        public DataTypeValidateAttribute(IDataTypeService dataTypeService)
        {
            if (dataTypeService == null) throw new ArgumentNullException(&quot;dataTypeService&quot;);
            _dataTypeService = dataTypeService;
        }

        private IDataTypeService DataTypeService
        {
            get { return _dataTypeService ?? ApplicationContext.Current.Services.DataTypeService; }
        }

        public override void OnActionExecuting(HttpActionContext actionContext)
        {
            var dataType = (DataTypeSave)actionContext.ActionArguments[&quot;dataType&quot;];

            dataType.Name = dataType.Name.CleanForXss(&#39;[&#39;, &#39;]&#39;, &#39;(&#39;, &#39;)&#39;, &#39;:&#39;);
            dataType.Alias = dataType.Name.CleanForXss(&#39;[&#39;, &#39;]&#39;, &#39;(&#39;, &#39;)&#39;, &#39;:&#39;);

            //Validate that the property editor exists
            var propertyEditor = PropertyEditorResolver.Current.GetByAlias(dataType.SelectedEditor);
            if (propertyEditor == null)
            {
                var message = string.Format(&quot;Property editor with id: {0} was not found&quot;, dataType.SelectedEditor);
                actionContext.Response = actionContext.Request.CreateErrorResponse(HttpStatusCode.NotFound, message);
                return;
            }

            //assign the prop editor to the model
            dataType.PropertyEditor = propertyEditor;

            //Validate the data type exists or create one if required
            IDataTypeDefinition persisted;
            switch (dataType.Action)
            {
                case ContentSaveAction.Save:
                    persisted = DataTypeService.GetDataTypeDefinitionById(Convert.ToInt32(dataType.Id));
                    if (persisted == null)
                    {
                        var message = string.Format(&quot;Data type with id: {0} was not found&quot;, dataType.Id);
                        actionContext.Response = actionContext.Request.CreateErrorResponse(HttpStatusCode.NotFound, message);
                        return;
                    }
                    //map the model to the persisted instance
                    Mapper.Map(dataType, persisted);
                    break;
                case ContentSaveAction.SaveNew:
                    //create the persisted model from mapping the saved model
                    persisted = Mapper.Map&lt;IDataTypeDefinition&gt;(dataType);
                    ((DataTypeDefinition)persisted).ResetIdentity();
                    break;
                default:
                    actionContext.Response = actionContext.Request.CreateErrorResponse(HttpStatusCode.NotFound, new ArgumentOutOfRangeException());
                    return;
            }

            //now assign the persisted entity to the model so we can use it in the action
            dataType.PersistedDataType = persisted;

            //Validate each field
            foreach (var preVal in dataType.PreValues)
            {
                var postedValue = preVal.Value;
                
                foreach (var v in propertyEditor.PreValueEditor.Fields.Where(x =&gt; x.Key == preVal.Key).SelectMany(x =&gt; x.Validators))
                {
                    foreach (var result in v.Validate(postedValue, null, propertyEditor))
                    {
                        //if there are no member names supplied then we assume that the validation message is for the overall property
                        // not a sub field on the property editor
                        if (!result.MemberNames.Any())
                        {
                            //add a model state error for the entire property
                            actionContext.ModelState.AddModelError(string.Format(&quot;{0}.{1}&quot;, &quot;Properties&quot;, preVal.Key), result.ErrorMessage);
                        }
                        else
                        {
                            //there&#39;s assigned field names so we&#39;ll combine the field name with the property name
                            // so that we can try to match it up to a real sub field of this editor
                            foreach (var field in result.MemberNames)
                            {
                                actionContext.ModelState.AddModelError(string.Format(&quot;{0}.{1}.{2}&quot;, &quot;Properties&quot;, preVal.Key, field), result.ErrorMessage);
                            }
                        }
                    }
                }
            }

            if (actionContext.ModelState.IsValid == false)
            {
                //if it is not valid, do not continue and return the model state
                actionContext.Response = actionContext.Request.CreateValidationErrorResponse(actionContext.ModelState);
                return;
            }

        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[26,9,26,43,0],[27,9,27,10,0],[28,9,28,10,0],[30,9,30,75,0],[31,9,31,10,0],[32,13,32,41,0],[32,42,32,93,0],[33,13,33,48,0],[34,9,34,10,0],[38,17,38,18,0],[38,19,38,98,0],[38,99,38,100,0],[42,9,42,10,0],[43,13,43,84,0],[45,13,45,80,0],[46,13,46,81,0],[49,13,49,101,0],[50,13,50,40,0],[51,13,51,14,0],[52,17,52,116,0],[53,17,53,118,0],[54,17,54,24,0],[58,13,58,54,0],[62,13,62,37,0],[65,21,65,105,0],[66,21,66,43,0],[67,21,67,22,0],[68,25,68,106,0],[69,25,69,126,0],[70,25,70,32,0],[73,21,73,53,0],[74,21,74,27,0],[77,21,77,75,0],[78,21,78,69,0],[79,21,79,27,0],[81,21,81,148,0],[82,21,82,28,0],[86,13,86,52,0],[89,13,89,20,0],[89,22,89,32,0],[89,33,89,35,0],[89,36,89,54,0],[90,13,90,14,0],[91,17,91,48,0],[93,17,93,24,0],[93,26,93,31,0],[93,32,93,34,0],[93,35,93,83,0],[93,83,93,102,0],[93,102,93,120,0],[93,120,93,132,0],[93,132,93,133,0],[93,35,93,133,0],[94,17,94,18,0],[95,21,95,28,0],[95,30,95,40,0],[95,41,95,43,0],[95,44,95,89,0],[96,21,96,22,0],[99,25,99,55,0],[100,25,100,26,0],[102,29,102,141,0],[103,25,103,26,0],[105,25,105,26,0],[108,29,108,36,0],[108,38,108,47,0],[108,48,108,50,0],[108,51,108,69,0],[109,29,109,30,0],[110,33,110,156,0],[111,29,111,30,0],[112,25,112,26,0],[113,21,113,22,0],[114,17,114,18,0],[115,13,115,14,0],[117,13,117,59,0],[118,13,118,14,0],[120,17,120,120,0],[121,17,121,24,0],[124,9,124,10,0]]);
    </script>
  </body>
</html>