<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\umbraco.presentation\item.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Web;
using System.Xml;
using StackExchange.Profiling;
using Umbraco.Core;
using Umbraco.Core.Configuration;
using Umbraco.Core.Models;
using Umbraco.Web;
using Umbraco.Core.Profiling;
using Umbraco.Core.Strings;

namespace umbraco
{
    /// &lt;summary&gt;
    /// 
    /// &lt;/summary&gt;
    public class item
    {
        private String _fieldContent = &quot;&quot;;
        private readonly String _fieldName;

        public String FieldContent
        {
            get { return _fieldContent; }
        }

        public item(string itemValue, IDictionary attributes)
        {
            _fieldContent = itemValue;
            ParseItem(attributes);
        }

        /// &lt;summary&gt;
        /// Creates a new Legacy item
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;attributes&quot;&gt;&lt;/param&gt;
        public item(IDictionary elements, IDictionary attributes)
            : this(null, elements, attributes)
        {
        }

        /// &lt;summary&gt;
        /// Creates an Item with a publishedContent item in order to properly recurse and return the value.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;publishedContent&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;attributes&quot;&gt;&lt;/param&gt;
        /// &lt;remarks&gt;
        /// THIS ENTIRE CLASS WILL BECOME LEGACY, THE FIELD RENDERING NEEDS TO BE REPLACES SO THAT IS WHY THIS
        /// CTOR IS INTERNAL.
        /// &lt;/remarks&gt;
        internal item(IPublishedContent publishedContent, IDictionary elements, IDictionary attributes)
        {
            _fieldName = helper.FindAttribute(attributes, &quot;field&quot;);

            if (_fieldName.StartsWith(&quot;#&quot;))
            {
                _fieldContent = library.GetDictionaryItem(_fieldName.Substring(1, _fieldName.Length - 1));
            }
            else
            {
                // Loop through XML children we need to find the fields recursive
                var recursive = helper.FindAttribute(attributes, &quot;recursive&quot;) == &quot;true&quot;;

                if (publishedContent == null)
                {
                    var recursiveVal = GetRecursiveValueLegacy(elements);
                    _fieldContent = recursiveVal.IsNullOrWhiteSpace() ? _fieldContent : recursiveVal;
                }

                //check for published content and get its value using that
                if (publishedContent != null &amp;&amp; (publishedContent.HasProperty(_fieldName) || recursive))
                {
                    var pval = publishedContent.GetPropertyValue(_fieldName, recursive);
                    var rval = pval == null ? string.Empty : pval.ToString();
                    _fieldContent = rval.IsNullOrWhiteSpace() ? _fieldContent : rval;
                }
                else
                {
                    //get the vaue the legacy way (this will not parse locallinks, etc... since that is handled with ipublishedcontent)
                    var elt = elements[_fieldName];
                    if (elt != null &amp;&amp; string.IsNullOrEmpty(elt.ToString()) == false)
                        _fieldContent = elt.ToString().Trim();
                }

                //now we check if the value is still empty and if so we&#39;ll check useIfEmpty
                if (string.IsNullOrEmpty(_fieldContent))
                {
                    var altFieldName = helper.FindAttribute(attributes, &quot;useIfEmpty&quot;);
                    if (string.IsNullOrEmpty(altFieldName) == false)
                    {
                        if (publishedContent != null &amp;&amp; (publishedContent.HasProperty(altFieldName) || recursive))
                        {
                            var pval = publishedContent.GetPropertyValue(altFieldName, recursive);
                            var rval = pval == null ? string.Empty : pval.ToString();
                            _fieldContent = rval.IsNullOrWhiteSpace() ? _fieldContent : rval;
                        }
                        else
                        {
                            //get the vaue the legacy way (this will not parse locallinks, etc... since that is handled with ipublishedcontent)
                            var elt = elements[altFieldName];
                            if (elt != null &amp;&amp; string.IsNullOrEmpty(elt.ToString()) == false)
                                _fieldContent = elt.ToString().Trim();
                        }
                    }
                }

            }

            ParseItem(attributes);
        }

        /// &lt;summary&gt;
        /// Returns the recursive value using a legacy strategy of looking at the xml cache and the splitPath in the elements collection
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private string GetRecursiveValueLegacy(IDictionary elements)
        {
            using (DisposableTimer.DebugDuration&lt;item&gt;(&quot;Checking recusively&quot;))
            {
                var content = &quot;&quot;;

                var umbracoXml = presentation.UmbracoContext.Current.GetXml();

                var splitpath = (String[])elements[&quot;splitpath&quot;];
                for (int i = 0; i &lt; splitpath.Length - 1; i++)
                {
                    XmlNode element = umbracoXml.GetElementById(splitpath[splitpath.Length - i - 1]);

                    if (element == null)
                        continue;

                    var xpath = UmbracoConfig.For.UmbracoSettings().Content.UseLegacyXmlSchema ? &quot;./data [@alias = &#39;{0}&#39;]&quot; : &quot;./{0}&quot;;
                    var currentNode = element.SelectSingleNode(string.Format(xpath, _fieldName));

                    //continue if all is null
                    if (currentNode == null || currentNode.FirstChild == null || string.IsNullOrEmpty(currentNode.FirstChild.Value) || string.IsNullOrEmpty(currentNode.FirstChild.Value.Trim()))
                        continue;

                    HttpContext.Current.Trace.Write(&quot;item.recursive&quot;, &quot;Item loaded from &quot; + splitpath[splitpath.Length - i - 1]);
                    content = currentNode.FirstChild.Value;
                    break;
                }

                return content;
            }
        }

        private void ParseItem(IDictionary attributes)
        {
            using (DisposableTimer.DebugDuration&lt;item&gt;(&quot;Start parsing &quot; + _fieldName))
            {
                HttpContext.Current.Trace.Write(&quot;item&quot;, &quot;Start parsing &#39;&quot; + _fieldName + &quot;&#39;&quot;);
                if (helper.FindAttribute(attributes, &quot;textIfEmpty&quot;) != &quot;&quot; &amp;&amp; _fieldContent == &quot;&quot;)
                    _fieldContent = helper.FindAttribute(attributes, &quot;textIfEmpty&quot;);

                _fieldContent = _fieldContent.Trim();

                // DATE FORMATTING FUNCTIONS
                if (helper.FindAttribute(attributes, &quot;formatAsDateWithTime&quot;) == &quot;true&quot;)
                {
                    if (_fieldContent == &quot;&quot;)
                        _fieldContent = DateTime.Now.ToString();
                    _fieldContent = Convert.ToDateTime(_fieldContent).ToLongDateString() +
                                    helper.FindAttribute(attributes, &quot;formatAsDateWithTimeSeparator&quot;) +
                                    Convert.ToDateTime(_fieldContent).ToShortTimeString();
                }
                else if (helper.FindAttribute(attributes, &quot;formatAsDate&quot;) == &quot;true&quot;)
                {
                    if (_fieldContent == &quot;&quot;)
                        _fieldContent = DateTime.Now.ToString();
                    _fieldContent = Convert.ToDateTime(_fieldContent).ToLongDateString();
                }


                // TODO: Needs revision to check if parameter-tags has attributes
                if (helper.FindAttribute(attributes, &quot;stripParagraph&quot;) == &quot;true&quot; &amp;&amp; _fieldContent.Length &gt; 5)
                {
                    _fieldContent = _fieldContent.Trim();
                    string fieldContentLower = _fieldContent.ToLower();

                    // the field starts with an opening p tag
                    if (fieldContentLower.Substring(0, 3) == &quot;&lt;p&gt;&quot;
                        // it ends with a closing p tag
                        &amp;&amp; fieldContentLower.Substring(_fieldContent.Length - 4, 4) == &quot;&lt;/p&gt;&quot;
                        // it doesn&#39;t contain multiple p-tags
                        &amp;&amp; fieldContentLower.IndexOf(&quot;&lt;p&gt;&quot;, 1) &lt; 0)
                    {
                        _fieldContent = _fieldContent.Substring(3, _fieldContent.Length - 7);
                    }
                }

                // CASING
                if (helper.FindAttribute(attributes, &quot;case&quot;) == &quot;lower&quot;)
                    _fieldContent = _fieldContent.ToLower();
                else if (helper.FindAttribute(attributes, &quot;case&quot;) == &quot;upper&quot;)
                    _fieldContent = _fieldContent.ToUpper();
                else if (helper.FindAttribute(attributes, &quot;case&quot;) == &quot;title&quot;)
                    _fieldContent = _fieldContent.ToCleanString(CleanStringType.Ascii | CleanStringType.Alias | CleanStringType.PascalCase);

                // OTHER FORMATTING FUNCTIONS
                // If we use masterpages, this is moved to the ItemRenderer to add support for before/after in inline XSLT
                if (!UmbracoConfig.For.UmbracoSettings().Templates.UseAspNetMasterPages)
                {
                    if (_fieldContent != &quot;&quot; &amp;&amp; helper.FindAttribute(attributes, &quot;insertTextBefore&quot;) != &quot;&quot;)
                        _fieldContent = HttpContext.Current.Server.HtmlDecode(helper.FindAttribute(attributes, &quot;insertTextBefore&quot;)) +
                                        _fieldContent;
                    if (_fieldContent != &quot;&quot; &amp;&amp; helper.FindAttribute(attributes, &quot;insertTextAfter&quot;) != &quot;&quot;)
                        _fieldContent += HttpContext.Current.Server.HtmlDecode(helper.FindAttribute(attributes, &quot;insertTextAfter&quot;));
                }
                if (helper.FindAttribute(attributes, &quot;urlEncode&quot;) == &quot;true&quot;)
                    _fieldContent = HttpUtility.UrlEncode(_fieldContent);
                if (helper.FindAttribute(attributes, &quot;htmlEncode&quot;) == &quot;true&quot;)
                    _fieldContent = HttpUtility.HtmlEncode(_fieldContent);
                if (helper.FindAttribute(attributes, &quot;convertLineBreaks&quot;) == &quot;true&quot;)
                    _fieldContent = _fieldContent.Replace(&quot;\n&quot;, &quot;&lt;br/&gt;\n&quot;);

                HttpContext.Current.Trace.Write(&quot;item&quot;, &quot;Done parsing &#39;&quot; + _fieldName + &quot;&#39;&quot;);
            }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[20,9,20,43,0],[20,9,20,43,0],[25,17,25,18,0],[25,19,25,40,0],[25,41,25,42,0],[28,9,28,62,0],[29,9,29,10,0],[30,13,30,39,0],[31,13,31,35,0],[32,9,32,10,0],[40,15,40,47,0],[41,9,41,10,0],[42,9,42,10,0],[54,9,54,104,0],[55,9,55,10,0],[56,13,56,68,0],[58,13,58,44,0],[59,13,59,14,0],[60,17,60,107,0],[61,13,61,14,0],[63,13,63,14,0],[65,17,65,89,0],[67,17,67,46,0],[68,17,68,18,0],[69,21,69,74,0],[70,21,70,102,0],[71,17,71,18,0],[74,17,74,105,0],[75,17,75,18,0],[76,21,76,89,0],[77,21,77,78,0],[78,21,78,86,0],[79,17,79,18,0],[81,17,81,18,0],[83,21,83,52,0],[84,21,84,86,0],[85,25,85,63,0],[86,17,86,18,0],[89,17,89,57,0],[90,17,90,18,0],[91,21,91,87,0],[92,21,92,69,0],[93,21,93,22,0],[94,25,94,115,0],[95,25,95,26,0],[96,29,96,99,0],[97,29,97,86,0],[98,29,98,94,0],[99,25,99,26,0],[101,25,101,26,0],[103,29,103,62,0],[104,29,104,94,0],[105,33,105,71,0],[106,25,106,26,0],[107,21,107,22,0],[108,17,108,18,0],[110,13,110,14,0],[112,13,112,35,0],[113,9,113,10,0],[121,9,121,10,0],[122,13,122,79,0],[123,13,123,14,0],[124,17,124,34,0],[126,17,126,79,0],[128,17,128,65,0],[129,22,129,31,0],[129,33,129,57,0],[129,59,129,62,0],[130,17,130,18,0],[131,21,131,102,0],[133,21,133,41,0],[134,25,134,34,0],[136,21,136,134,0],[137,21,137,98,0],[140,21,140,194,0],[141,25,141,34,0],[143,21,143,130,0],[144,21,144,60,0],[145,21,145,27,0],[148,17,148,32,0],[150,9,150,10,0],[153,9,153,10,0],[154,13,154,87,0],[155,13,155,14,0],[156,17,156,95,0],[157,17,157,98,0],[158,21,158,85,0],[160,17,160,54,0],[163,17,163,88,0],[164,17,164,18,0],[165,21,165,45,0],[166,25,166,65,0],[167,21,169,91,0],[170,17,170,18,0],[171,22,171,85,0],[172,17,172,18,0],[173,21,173,45,0],[174,25,174,65,0],[175,21,175,90,0],[176,17,176,18,0],[180,17,180,110,0],[181,17,181,18,0],[182,21,182,58,0],[183,21,183,72,0],[186,21,190,68,0],[191,21,191,22,0],[192,25,192,94,0],[193,21,193,22,0],[194,17,194,18,0],[197,17,197,73,0],[198,21,198,61,0],[199,22,199,78,0],[200,21,200,61,0],[201,22,201,78,0],[202,21,202,141,0],[206,17,206,89,0],[207,17,207,18,0],[208,21,208,107,0],[209,25,210,55,0],[211,21,211,106,0],[212,25,212,133,0],[213,17,213,18,0],[214,17,214,77,0],[215,21,215,74,0],[216,17,216,78,0],[217,21,217,75,0],[218,17,218,85,0],[219,21,219,76,0],[221,17,221,94,0],[222,13,222,14,0],[223,9,223,10,0]]);
    </script>
  </body>
</html>