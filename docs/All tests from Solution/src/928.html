<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\Scheduling\RecurringTaskBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Threading;
using System.Threading.Tasks;

namespace Umbraco.Web.Scheduling
{
    /// &lt;summary&gt;
    /// Provides a base class for recurring background tasks.
    /// &lt;/summary&gt;
    internal abstract class RecurringTaskBase : LatchedBackgroundTaskBase
    {
        private readonly IBackgroundTaskRunner&lt;RecurringTaskBase&gt; _runner;
        private readonly int _periodMilliseconds;
        private readonly Timer _timer;
        private bool _disposed;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;RecurringTaskBase&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;runner&quot;&gt;The task runner.&lt;/param&gt;
        /// &lt;param name=&quot;delayMilliseconds&quot;&gt;The delay.&lt;/param&gt;
        /// &lt;param name=&quot;periodMilliseconds&quot;&gt;The period.&lt;/param&gt;
        /// &lt;remarks&gt;The task will repeat itself periodically. Use this constructor to create a new task.&lt;/remarks&gt;
        protected RecurringTaskBase(IBackgroundTaskRunner&lt;RecurringTaskBase&gt; runner, int delayMilliseconds, int periodMilliseconds)
        {
            _runner = runner;
            _periodMilliseconds = periodMilliseconds;

            // note
            // must use the single-parameter constructor on Timer to avoid it from being GC&#39;d
            // read http://stackoverflow.com/questions/4962172/why-does-a-system-timers-timer-survive-gc-but-not-system-threading-timer

            _timer = new Timer(_ =&gt; Release());
            _timer.Change(delayMilliseconds, 0);
        }

        /// &lt;summary&gt;
        /// Implements IBackgroundTask.Run().
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Classes inheriting from &lt;c&gt;RecurringTaskBase&lt;/c&gt; must implement &lt;c&gt;PerformRun&lt;/c&gt;.&lt;/remarks&gt;
        public override void Run()
        {
            var shouldRepeat = PerformRun();
            if (shouldRepeat) Repeat();
        }

        /// &lt;summary&gt;
        /// Implements IBackgroundTask.RunAsync().
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Classes inheriting from &lt;c&gt;RecurringTaskBase&lt;/c&gt; must implement &lt;c&gt;PerformRun&lt;/c&gt;.&lt;/remarks&gt;
        public override async Task RunAsync(CancellationToken token)
        {
            var shouldRepeat = await PerformRunAsync(token);
            if (shouldRepeat) Repeat();
        }

        private void Repeat()
        {
            // again?
            if (_runner.IsCompleted) return; // fail fast

            if (_periodMilliseconds == 0) return; // safe

            Reset(); // re-latch

            // try to add again (may fail if runner has completed)
            // if added, re-start the timer, else kill it
            if (_runner.TryAdd(this))
                _timer.Change(_periodMilliseconds, 0);
            else
                Dispose(true);
        }

        /// &lt;summary&gt;
        /// Runs the background task.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A value indicating whether to repeat the task.&lt;/returns&gt;
        public abstract bool PerformRun();

        /// &lt;summary&gt;
        /// Runs the task asynchronously.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;token&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{T}&quot;/&gt; instance representing the execution of the background task,
        /// and returning a value indicating whether to repeat the task.&lt;/returns&gt;
        public abstract Task&lt;bool&gt; PerformRunAsync(CancellationToken token);

        protected override void DisposeResources()
        {
            base.DisposeResources();

            // stop the timer
            _timer.Change(Timeout.Infinite, Timeout.Infinite);
            _timer.Dispose();
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[23,9,23,132,1],[24,9,24,10,1],[25,13,25,30,1],[26,13,26,54,1],[32,13,32,37,1],[32,37,32,46,1],[32,46,32,48,1],[32,13,32,48,1],[33,13,33,49,1],[34,9,34,10,1],[41,9,41,10,1],[42,13,42,45,1],[43,13,43,30,1],[43,31,43,40,1],[44,9,44,10,1],[51,9,51,10,0],[52,13,52,61,0],[53,13,53,30,0],[53,31,53,40,0],[54,9,54,10,0],[57,9,57,10,1],[59,13,59,37,1],[59,38,59,45,1],[61,13,61,42,1],[61,43,61,50,0],[63,13,63,21,1],[67,13,67,38,1],[68,17,68,55,1],[70,17,70,31,0],[71,9,71,10,1],[88,9,88,10,1],[89,13,89,37,1],[92,13,92,63,1],[93,13,93,30,1],[94,9,94,10,1]]);
    </script>
  </body>
</html>