<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Cache\HttpRequestCacheProvider.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Web;

namespace Umbraco.Core.Cache
{
    /// &lt;summary&gt;
    /// A cache provider that caches items in the HttpContext.Items
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// If the Items collection is null, then this provider has no effect
    /// &lt;/remarks&gt;
    internal class HttpRequestCacheProvider : DictionaryCacheProviderBase
    {
        // context provider
        // the idea is that there is only one, application-wide HttpRequestCacheProvider instance,
        // that is initialized with a method that returns the &quot;current&quot; context.
        // NOTE
        //   but then it is initialized with () =&gt; new HttpContextWrapper(HttpContent.Current)
        //   which is higly inefficient because it creates a new wrapper each time we refer to _context()
        //   so replace it with _context1 and _context2 below + a way to get context.Items.
        //private readonly Func&lt;HttpContextBase&gt; _context;

        // NOTE
        //   and then in almost 100% cases _context2 will be () =&gt; HttpContext.Current
        //   so why not bring that logic in here and fallback on to HttpContext.Current when
        //   _context1 is null?
        //private readonly HttpContextBase _context1;
        //private readonly Func&lt;HttpContext&gt; _context2;
        private readonly HttpContextBase _context;

        private IDictionary ContextItems
        {
            //get { return _context1 != null ? _context1.Items : _context2().Items; }
            get { return _context != null ? _context.Items : HttpContext.Current.Items; }
        }

        private bool HasContextItems
        {
            get { return (_context != null &amp;&amp; _context.Items != null) || HttpContext.Current != null; }
        }

        // for unit tests
        public HttpRequestCacheProvider(HttpContextBase context)
        {
            _context = context;
        }

        // main constructor
        // will use HttpContext.Current
        public HttpRequestCacheProvider(/*Func&lt;HttpContext&gt; context*/)
        {
            //_context2 = context;
        }

        protected override IEnumerable&lt;DictionaryEntry&gt; GetDictionaryEntries()
        {
            const string prefix = CacheItemPrefix + &quot;-&quot;;

            if (HasContextItems == false) return Enumerable.Empty&lt;DictionaryEntry&gt;();

            return ContextItems.Cast&lt;DictionaryEntry&gt;()
                .Where(x =&gt; x.Key is string &amp;&amp; ((string)x.Key).StartsWith(prefix));
        }

        protected override void RemoveEntry(string key)
        {
            if (HasContextItems == false) return;

            ContextItems.Remove(key);
        }

        protected override object GetEntry(string key)
        {
            return HasContextItems ? ContextItems[key] : null;
        }

        #region Lock

        protected override IDisposable ReadLock
        {
            // there&#39;s no difference between ReadLock and WriteLock here
            get { return WriteLock; }
        }

        protected override IDisposable WriteLock
        {
            // NOTE
            //   could think about just overriding base.Locker to return a different
            //   object but then we&#39;d create a ReaderWriterLockSlim per request,
            //   which is less efficient than just using a basic monitor lock.

            get
            {
                return HasContextItems 
                    ? (IDisposable) new MonitorLock(ContextItems.SyncRoot) 
                    : new NoopLocker();
            }
        }

        #endregion

        #region Get

        public override object GetCacheItem(string cacheKey, Func&lt;object&gt; getCacheItem)
        {
            //no place to cache so just return the callback result
            if (HasContextItems == false) return getCacheItem();

            cacheKey = GetCacheKey(cacheKey);

            Lazy&lt;object&gt; result;

            using (WriteLock)
            {
                result = ContextItems[cacheKey] as Lazy&lt;object&gt;; // null if key not found

                // cannot create value within the lock, so if result.IsValueCreated is false, just
                // do nothing here - means that if creation throws, a race condition could cause
                // more than one thread to reach the return statement below and throw - accepted.

                if (result == null || GetSafeLazyValue(result, true) == null) // get non-created as NonCreatedValue &amp; exceptions as null
                {
                    result = GetSafeLazy(getCacheItem);
                    ContextItems[cacheKey] = result;
                }
            }

            // using GetSafeLazy and GetSafeLazyValue ensures that we don&#39;t cache
            // exceptions (but try again and again) and silently eat them - however at
            // some point we have to report them - so need to re-throw here

            // this does not throw anymore
            //return result.Value;

            var value = result.Value; // will not throw (safe lazy)
            var eh = value as ExceptionHolder;
            if (eh != null) throw eh.Exception; // throw once!
            return value;
        }

        #endregion

        #region Insert
        #endregion

        private class NoopLocker : DisposableObject
        {
            protected override void DisposeResources()
            { }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[37,17,37,18,1],[37,19,37,88,1],[37,89,37,90,1],[42,17,42,18,1],[42,19,42,102,1],[42,103,42,104,1],[46,9,46,65,1],[47,9,47,10,1],[48,13,48,32,1],[49,9,49,10,1],[53,9,53,71,1],[54,9,54,10,1],[56,9,56,10,1],[59,9,59,10,1],[62,13,62,42,1],[62,43,62,86,0],[64,13,65,29,1],[65,29,65,82,1],[65,82,65,84,1],[64,13,65,84,1],[66,9,66,10,1],[69,9,69,10,1],[70,13,70,42,1],[70,43,70,50,0],[72,13,72,38,1],[73,9,73,10,1],[76,9,76,10,1],[77,13,77,63,1],[78,9,78,10,1],[85,17,85,18,1],[85,19,85,36,1],[85,37,85,38,1],[96,13,96,14,1],[97,17,99,40,1],[100,13,100,14,1],[108,9,108,10,1],[110,13,110,42,1],[110,43,110,65,0],[112,13,112,46,1],[116,13,116,30,1],[117,13,117,14,1],[118,17,118,65,1],[124,17,124,78,1],[125,17,125,18,1],[126,21,126,56,1],[127,21,127,53,1],[128,17,128,18,1],[129,13,129,14,1],[138,13,138,38,1],[139,13,139,47,1],[140,13,140,28,1],[140,29,140,48,1],[141,13,141,26,1],[142,9,142,10,1],[152,13,152,14,0],[152,15,152,16,0]]);
    </script>
  </body>
</html>