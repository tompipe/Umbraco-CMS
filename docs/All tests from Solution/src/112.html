<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Tests\CodeFirst\TopologicalSorter.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;

namespace Umbraco.Tests.CodeFirst
{
    public class TopologicalSorter
    {
        #region - Private Members -

        private readonly int[] _vertices; // list of vertices
        private readonly int[,] _matrix; // adjacency matrix
        private int _numVerts; // current number of vertices
        private readonly int[] _sortedArray;

        #endregion

        #region - CTors -

        public TopologicalSorter(int size)
        {
            _vertices = new int[size];
            _matrix = new int[size, size];
            _numVerts = 0;
            for (int i = 0; i &lt; size; i++)
                for (int j = 0; j &lt; size; j++)
                    _matrix[i, j] = 0;
            _sortedArray = new int[size]; // sorted vert labels
        }

        #endregion

        #region - Public Methods -

        public int AddVertex(int vertex)
        {
            _vertices[_numVerts++] = vertex;
            return _numVerts - 1;
        }

        public void AddEdge(int start, int end)
        {
            _matrix[start, end] = 1;
        }

        public int[] Sort() // toplogical sort
        {
            while (_numVerts &gt; 0) // while vertices remain,
            {
                // get a vertex with no successors, or -1
                int currentVertex = noSuccessors();
                if (currentVertex == -1) // must be a cycle                
                    throw new Exception(&quot;Graph has cycles&quot;);

                // insert vertex label in sorted array (start at end)
                _sortedArray[_numVerts - 1] = _vertices[currentVertex];

                deleteVertex(currentVertex); // delete vertex
            }

            // vertices all gone; return sortedArray
            return _sortedArray;
        }

        #endregion

        #region - Private Helper Methods -

        // returns vert with no successors (or -1 if no such verts)
        private int noSuccessors()
        {
            for (int row = 0; row &lt; _numVerts; row++)
            {
                bool isEdge = false; // edge from row to column in adjMat
                for (int col = 0; col &lt; _numVerts; col++)
                {
                    if (_matrix[row, col] &gt; 0) // if edge to another,
                    {
                        isEdge = true;
                        break; // this vertex has a successor try another
                    }
                }
                if (!isEdge) // if no edges, has no successors
                    return row;
            }
            return -1; // no
        }

        private void deleteVertex(int delVert)
        {
            // if not last vertex, delete from vertexList
            if (delVert != _numVerts - 1)
            {
                for (int j = delVert; j &lt; _numVerts - 1; j++)
                    _vertices[j] = _vertices[j + 1];

                for (int row = delVert; row &lt; _numVerts - 1; row++)
                    moveRowUp(row, _numVerts);

                for (int col = delVert; col &lt; _numVerts - 1; col++)
                    moveColLeft(col, _numVerts - 1);
            }
            _numVerts--; // one less vertex
        }

        private void moveRowUp(int row, int length)
        {
            for (int col = 0; col &lt; length; col++)
                _matrix[row, col] = _matrix[row + 1, col];
        }

        private void moveColLeft(int col, int length)
        {
            for (int row = 0; row &lt; length; row++)
                _matrix[row, col] = _matrix[row, col + 1];
        }

        #endregion
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[18,9,18,43,1],[19,9,19,10,1],[20,13,20,39,1],[21,13,21,43,1],[22,13,22,27,1],[23,18,23,27,1],[23,29,23,37,1],[23,39,23,42,1],[24,22,24,31,1],[24,33,24,41,1],[24,43,24,46,1],[25,21,25,39,1],[26,13,26,42,1],[27,9,27,10,1],[34,9,34,10,1],[35,13,35,45,1],[36,13,36,34,1],[37,9,37,10,1],[40,9,40,10,1],[41,13,41,37,1],[42,9,42,10,1],[45,9,45,10,1],[46,13,46,34,1],[47,13,47,14,1],[49,17,49,52,1],[50,17,50,41,1],[51,21,51,61,0],[54,17,54,72,1],[56,17,56,45,1],[57,13,57,14,1],[60,13,60,33,1],[61,9,61,10,1],[69,9,69,10,1],[70,18,70,29,1],[70,31,70,46,1],[70,48,70,53,1],[71,13,71,14,1],[72,17,72,37,1],[73,22,73,33,1],[73,35,73,50,1],[73,52,73,57,1],[74,17,74,18,1],[75,21,75,47,1],[76,21,76,22,1],[77,25,77,39,1],[78,25,78,31,1],[80,17,80,18,1],[81,17,81,29,1],[82,21,82,32,1],[83,13,83,14,1],[84,13,84,23,0],[85,9,85,10,1],[88,9,88,10,1],[90,13,90,42,1],[91,13,91,14,1],[92,22,92,37,1],[92,39,92,56,1],[92,58,92,61,1],[93,21,93,53,1],[95,22,95,39,1],[95,41,95,60,1],[95,62,95,67,1],[96,21,96,47,1],[98,22,98,39,1],[98,41,98,60,1],[98,62,98,67,1],[99,21,99,53,1],[100,13,100,14,1],[101,13,101,25,1],[102,9,102,10,1],[105,9,105,10,1],[106,18,106,29,1],[106,31,106,43,1],[106,45,106,50,1],[107,17,107,59,1],[108,9,108,10,1],[111,9,111,10,1],[112,18,112,29,1],[112,31,112,43,1],[112,45,112,50,1],[113,17,113,59,1],[114,9,114,10,1]]);
    </script>
  </body>
</html>