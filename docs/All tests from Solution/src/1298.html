<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Web\HealthCheck\Checks\Permissions\FolderAndFilePermissionsCheck.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using Umbraco.Core.IO;
using Umbraco.Core.Services;
using Umbraco.Web.Install;

namespace Umbraco.Web.HealthCheck.Checks.Permissions
{
    internal enum PermissionCheckRequirement
    {
        Required,
        Optional
    }

    internal enum PermissionCheckFor
    {
        Folder,
        File
    }

    [HealthCheck(
        &quot;53DBA282-4A79-4B67-B958-B29EC40FCC23&quot;,
        &quot;Folder &amp; File Permissions&quot;,
        Description = &quot;Checks that the web server folder and file permissions are set correctly for Umbraco to run.&quot;,
        Group = &quot;Permissions&quot;)]
    public class FolderAndFilePermissionsCheck : HealthCheck
    {
        private readonly ILocalizedTextService _textService;

        public FolderAndFilePermissionsCheck(HealthCheckContext healthCheckContext) : base(healthCheckContext)
        {
            _textService = healthCheckContext.ApplicationContext.Services.TextService;
        }

        /// &lt;summary&gt;
        /// Get the status for this health check
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public override IEnumerable&lt;HealthCheckStatus&gt; GetStatus()
        {
            //return the statuses
            return new[] { CheckFolderPermissions(), CheckFilePermissions() };
        }

        /// &lt;summary&gt;
        /// Executes the action and returns it&#39;s status
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;action&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public override HealthCheckStatus ExecuteAction(HealthCheckAction action)
        {
            throw new InvalidOperationException(&quot;FolderAndFilePermissionsCheck has no executable actions&quot;);
        }

        private HealthCheckStatus CheckFolderPermissions()
        {
            // Create lists of paths to check along with a flag indicating if modify rights are required
            // in ALL circumstances or just some
            var pathsToCheck = new Dictionary&lt;string, PermissionCheckRequirement&gt;
            {
                { SystemDirectories.AppCode, PermissionCheckRequirement.Optional },
                { SystemDirectories.Data, PermissionCheckRequirement.Required },
                { SystemDirectories.Packages, PermissionCheckRequirement.Required},
                { SystemDirectories.Preview, PermissionCheckRequirement.Required },
                { SystemDirectories.AppPlugins, PermissionCheckRequirement.Required },
                { SystemDirectories.Bin, PermissionCheckRequirement.Optional },
                { SystemDirectories.Config, PermissionCheckRequirement.Optional },
                { SystemDirectories.Css, PermissionCheckRequirement.Optional },
                { SystemDirectories.Masterpages, PermissionCheckRequirement.Optional },
                { SystemDirectories.Media, PermissionCheckRequirement.Optional },
                { SystemDirectories.Scripts, PermissionCheckRequirement.Optional },
                { SystemDirectories.Umbraco, PermissionCheckRequirement.Optional },
                { SystemDirectories.UmbracoClient, PermissionCheckRequirement.Optional },
                { SystemDirectories.UserControls, PermissionCheckRequirement.Optional },
                { SystemDirectories.MvcViews, PermissionCheckRequirement.Optional },
                { SystemDirectories.Xslt, PermissionCheckRequirement.Optional },
            };

            // Run checks for required and optional paths for modify permission
            List&lt;string&gt; requiredFailedPaths;
            List&lt;string&gt; optionalFailedPaths;
            var requiredPathCheckResult = FilePermissionHelper.TestDirectories(GetPathsToCheck(pathsToCheck, PermissionCheckRequirement.Required), out requiredFailedPaths);
            var optionalPathCheckResult = FilePermissionHelper.TestDirectories(GetPathsToCheck(pathsToCheck, PermissionCheckRequirement.Optional), out optionalFailedPaths);

            return GetStatus(requiredPathCheckResult, requiredFailedPaths, optionalPathCheckResult, optionalFailedPaths, PermissionCheckFor.Folder);
        }

        private HealthCheckStatus CheckFilePermissions()
        {
            // Create lists of paths to check along with a flag indicating if modify rights are required
            // in ALL circumstances or just some
            var pathsToCheck = new Dictionary&lt;string, PermissionCheckRequirement&gt;
            {
                { &quot;~/Web.config&quot;, PermissionCheckRequirement.Optional },
            };

            // Run checks for required and optional paths for modify permission
            List&lt;string&gt; requiredFailedPaths;
            List&lt;string&gt; optionalFailedPaths;
            var requiredPathCheckResult = FilePermissionHelper.TestFiles(GetPathsToCheck(pathsToCheck, PermissionCheckRequirement.Required), out requiredFailedPaths);
            var optionalPathCheckResult = FilePermissionHelper.TestFiles(GetPathsToCheck(pathsToCheck, PermissionCheckRequirement.Optional), out optionalFailedPaths);

            return GetStatus(requiredPathCheckResult, requiredFailedPaths, optionalPathCheckResult, optionalFailedPaths, PermissionCheckFor.File);
        }

        private static string[] GetPathsToCheck(Dictionary&lt;string, PermissionCheckRequirement&gt; pathsToCheck,
            PermissionCheckRequirement requirement)
        {
            return pathsToCheck
                .Where(x =&gt; x.Value == requirement)
                .Select(x =&gt; IOHelper.MapPath(x.Key))
                .OrderBy(x =&gt; x)
                .ToArray();
        }

        private HealthCheckStatus GetStatus(bool requiredPathCheckResult, List&lt;string&gt; requiredFailedPaths,
            bool optionalPathCheckResult, IEnumerable&lt;string&gt; optionalFailedPaths,
            PermissionCheckFor checkingFor)
        {
            // Return error if any required parths fail the check, or warning if any optional ones do
            var resultType = StatusResultType.Success;
            var messageKey = string.Format(&quot;healthcheck/{0}PermissionsCheckMessage&quot;,
                checkingFor == PermissionCheckFor.Folder ? &quot;folder&quot; : &quot;file&quot;);
            var message = _textService.Localize(messageKey);
            if (requiredPathCheckResult == false)
            {
                resultType = StatusResultType.Error;
                messageKey = string.Format(&quot;healthcheck/required{0}PermissionFailed&quot;,
                    checkingFor == PermissionCheckFor.Folder ? &quot;Folder&quot; : &quot;File&quot;);
                message = GetMessageForPathCheckFailure(messageKey, requiredFailedPaths);
            }
            else if (optionalPathCheckResult == false)
            {
                resultType = StatusResultType.Warning;
                messageKey = string.Format(&quot;healthcheck/optional{0}PermissionFailed&quot;,
                    checkingFor == PermissionCheckFor.Folder ? &quot;Folder&quot; : &quot;File&quot;);
                message = GetMessageForPathCheckFailure(messageKey, optionalFailedPaths);
            }

            var actions = new List&lt;HealthCheckAction&gt;();
            return
                new HealthCheckStatus(message)
                {
                    ResultType = resultType,
                    Actions = actions
                };
        }

        private string GetMessageForPathCheckFailure(string messageKey, IEnumerable&lt;string&gt; failedPaths)
        {
            var rootFolder = IOHelper.MapPath(&quot;/&quot;);
            var failedFolders = failedPaths
                .Select(x =&gt; ParseFolderFromFullPath(rootFolder, x));
            return _textService.Localize(messageKey,
                new[] { string.Join(&quot;, &quot;, failedFolders) });
        }

        private string ParseFolderFromFullPath(string rootFolder, string filePath)
        {
            return filePath.Replace(rootFolder, string.Empty);
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[31,87,31,111,0],[32,9,32,10,0],[33,13,33,87,0],[34,9,34,10,0],[41,9,41,10,0],[43,13,43,79,0],[44,9,44,10,0],[52,9,52,10,0],[53,13,53,108,0],[57,9,57,10,0],[60,13,78,15,0],[83,13,83,173,0],[84,13,84,173,0],[86,13,86,149,0],[87,9,87,10,0],[90,9,90,10,0],[93,13,96,15,0],[101,13,101,167,0],[102,13,102,167,0],[104,13,104,147,0],[105,9,105,10,0],[109,9,109,10,0],[110,13,111,29,0],[111,29,111,51,0],[111,51,112,30,0],[112,30,112,53,0],[112,53,113,31,0],[113,31,113,32,0],[113,32,114,28,0],[110,13,114,28,0],[115,9,115,10,0],[120,9,120,10,0],[122,13,122,55,0],[123,13,124,79,0],[125,13,125,61,0],[126,13,126,50,0],[127,13,127,14,0],[128,17,128,53,0],[129,17,130,83,0],[131,17,131,90,0],[132,13,132,14,0],[133,18,133,55,0],[134,13,134,14,0],[135,17,135,55,0],[136,17,137,83,0],[138,17,138,90,0],[139,13,139,14,0],[141,13,141,57,0],[142,13,147,19,0],[148,9,148,10,0],[151,9,151,10,0],[152,13,152,52,0],[153,13,154,30,0],[154,30,154,68,0],[154,68,154,70,0],[153,13,154,70,0],[155,13,156,61,0],[157,9,157,10,0],[160,9,160,10,0],[161,13,161,63,0],[162,9,162,10,0]]);
    </script>
  </body>
</html>