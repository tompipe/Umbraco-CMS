<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\umbraco.cms\businesslogic\macro\Macro.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using Umbraco.Core;
using Umbraco.Core.Cache;
using Umbraco.Core.IO;
using Umbraco.Core.Logging;
using Umbraco.Core.Models;
using Umbraco.Core.Services;
using umbraco.DataLayer;
using umbraco.BusinessLogic;
using System.Linq;

namespace umbraco.cms.businesslogic.macro
{
	/// &lt;summary&gt;
	/// The Macro component are one of the umbraco essentials, used for drawing dynamic content in the public website of umbraco.
	/// 
	/// A Macro is a placeholder for either a xsl transformation, a custom .net control or a .net usercontrol.
	/// 
	/// The Macro is representated in templates and content as a special html element, which are being parsed out and replaced with the
	/// output of either the .net control or the xsl transformation when a page is being displayed to the visitor.
	/// 
	/// A macro can have a variety of properties which are used to transfer userinput to either the usercontrol/custom control or the xsl
	/// 
	/// &lt;/summary&gt;
    [Obsolete(&quot;This is no longer used, use the IMacroService and related models instead&quot;)]
	public class Macro
	{
        //initialize empty model
	    internal IMacro MacroEntity = new Umbraco.Core.Models.Macro();
        
        /// &lt;summary&gt;
        /// Unused, please do not use
        /// &lt;/summary&gt;
        [Obsolete(&quot;Obsolete, For querying the database use the new UmbracoDatabase object ApplicationContext.Current.DatabaseContext.Database&quot;, false)]
        protected static ISqlHelper SqlHelper
        {
            get { return Application.SqlHelper; }
        }

		/// &lt;summary&gt;
		/// id
		/// &lt;/summary&gt;
		public int Id 
		{
			get { return MacroEntity.Id; }
		}
		
		/// &lt;summary&gt;
		/// If set to true, the macro can be inserted on documents using the richtexteditor.
		/// &lt;/summary&gt;
		public bool UseInEditor 
		{
            get { return MacroEntity.UseInEditor; }
			set { MacroEntity.UseInEditor = value; }
		}

		/// &lt;summary&gt;
		/// The cache refreshrate - the maximum amount of time the macro should remain cached in the umbraco
		/// runtime layer.
		/// 
		/// The macro caches are refreshed whenever a document is changed
		/// &lt;/summary&gt;
		public int RefreshRate
		{
            get { return MacroEntity.CacheDuration; }
			set { MacroEntity.CacheDuration = value; }
		}

        /// &lt;summary&gt;
		/// The alias of the macro - are used for retrieving the macro when parsing the {?UMBRACO_MACRO}{/?UMBRACO_MACRO} element,
		/// by using the alias instead of the Id, it&#39;s possible to distribute macroes from one installation to another - since the id
		/// is given by an autoincrementation in the database table, and might be used by another macro in the foreing umbraco
        /// &lt;/summary&gt;
		public string Alias
		{
			get { return MacroEntity.Alias; }
			set { MacroEntity.Alias = value; }
		}
		
		/// &lt;summary&gt;
		/// The userfriendly name
		/// &lt;/summary&gt;
		public string Name
		{
            get { return MacroEntity.Name; }
            set { MacroEntity.Name = value; }
		}

		/// &lt;summary&gt;
		/// If the macro is a wrapper for a custom control, this is the assemly name from which to load the macro
		/// 
		/// specified like: /bin/mydll (without the .dll extension)
		/// &lt;/summary&gt;
		public string Assembly
		{
            get { return MacroEntity.ControlAssembly; }
            set { MacroEntity.ControlAssembly = value; }
		}

		/// &lt;summary&gt;
		/// The relative path to the usercontrol or the assembly type of the macro when using .Net custom controls
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// When using a user control the value is specified like: /usercontrols/myusercontrol.ascx (with the .ascx postfix)
		/// &lt;/remarks&gt;
		public string Type
		{
            get { return MacroEntity.ControlType; }
            set { MacroEntity.ControlType = value; }
		}

		/// &lt;summary&gt;
		/// The xsl file used to transform content
		/// 
		/// Umbraco assumes that the xslfile is present in the &quot;/xslt&quot; folder
		/// &lt;/summary&gt;
		public string Xslt
		{
            get { return MacroEntity.XsltPath; }
            set { MacroEntity.XsltPath = value; }
		}

	    /// &lt;summary&gt;
	    /// This field is used to store the file value for any scripting macro such as python, ruby, razor macros or Partial View Macros        
	    /// &lt;/summary&gt;
	    /// &lt;remarks&gt;
	    /// Depending on how the file is stored depends on what type of macro it is. For example if the file path is a full virtual path
	    /// starting with the ~/Views/MacroPartials then it is deemed to be a Partial View Macro, otherwise the file extension of the file
	    /// saved will determine which macro engine will be used to execute the file.
	    /// &lt;/remarks&gt;
	    public string ScriptingFile
	    {
	        get { return MacroEntity.ScriptPath; }
            set { MacroEntity.ScriptPath = value; }
	    }

	    /// &lt;summary&gt;
	    /// The python file used to be executed
	    /// 
	    /// Umbraco assumes that the python file is present in the &quot;/python&quot; folder
	    /// &lt;/summary&gt;
	    public bool RenderContent
	    {
            get { return MacroEntity.DontRender == false; }
            set { MacroEntity.DontRender = value == false; }
	    }

	    /// &lt;summary&gt;
	    /// Gets or sets a value indicating whether [cache personalized].
	    /// &lt;/summary&gt;
	    /// &lt;value&gt;&lt;c&gt;true&lt;/c&gt; if [cache personalized]; otherwise, &lt;c&gt;false&lt;/c&gt;.&lt;/value&gt;
	    public bool CachePersonalized
	    {
            get { return MacroEntity.CacheByMember; }
            set { MacroEntity.CacheByMember = value; }
	    }

	    /// &lt;summary&gt;
	    /// Gets or sets a value indicating whether the macro is cached for each individual page.
	    /// &lt;/summary&gt;
	    /// &lt;value&gt;&lt;c&gt;true&lt;/c&gt; if [cache by page]; otherwise, &lt;c&gt;false&lt;/c&gt;.&lt;/value&gt;
	    public bool CacheByPage
	    {
            get { return MacroEntity.CacheByPage; }
            set { MacroEntity.CacheByPage = value; }
	    }

	    /// &lt;summary&gt;
	    /// Properties which are used to send parameters to the xsl/usercontrol/customcontrol of the macro
	    /// &lt;/summary&gt;
	    public MacroProperty[] Properties
	    {
	        get
	        {
	            return MacroEntity.Properties.Select(x =&gt; new MacroProperty
	                {
	                    Alias = x.Alias,
	                    Name = x.Name,
                        SortOrder = x.SortOrder,
                        Macro = this,
                        ParameterEditorAlias = x.EditorAlias
	                }).ToArray();
	        }
	    }

        /// &lt;summary&gt;
        /// Macro initializer
        /// &lt;/summary&gt;
        [Obsolete(&quot;This should no longer be used, use the IMacroService and related models instead&quot;)]
        public Macro()
		{
		}

        /// &lt;summary&gt;
        /// Macro initializer
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Id&quot;&gt;The id of the macro&lt;/param&gt;
        [Obsolete(&quot;This should no longer be used, use the IMacroService and related models instead&quot;)]
        public Macro(int Id)
		{
            Setup(Id);
		}

        [Obsolete(&quot;This should no longer be used, use the IMacroService and related models instead&quot;)]
        internal Macro(IMacro macro)
        {
            MacroEntity = macro;
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;Macro&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The alias.&lt;/param&gt;
        [Obsolete(&quot;This should no longer be used, use the IMacroService and related models instead&quot;)]
        public Macro(string alias)
        {
            Setup(alias);
        }

        /// &lt;summary&gt;
        /// Used to persist object changes to the database. In Version3.0 it&#39;s just a stub for future compatibility
        /// &lt;/summary&gt;
        [Obsolete(&quot;This should no longer be used, use the IMacroService and related models instead&quot;)]
        public virtual void Save()
	    {
	        //event
	        var e = new SaveEventArgs();
	        FireBeforeSave(e);

	        if (e.Cancel == false)
	        {
	            ApplicationContext.Current.Services.MacroService.Save(MacroEntity);

	            FireAfterSave(e);
	        }
	    }

	    /// &lt;summary&gt;
		/// Deletes the current macro
		/// &lt;/summary&gt;
		public void Delete() 
		{
            //event
            var e = new DeleteEventArgs();
            FireBeforeDelete(e);

		    if (e.Cancel == false)
		    {
		        ApplicationContext.Current.Services.MacroService.Delete(MacroEntity);

		        FireAfterDelete(e);
		    }
		}

        [Obsolete(&quot;This is no longer used, use the IMacroService and related models instead&quot;)]
        public static Macro Import(XmlNode n)
        {
            var alias = XmlHelper.GetNodeValue(n.SelectSingleNode(&quot;alias&quot;));
            //check to see if the macro alreay exists in the system
            //it&#39;s better if it does and we keep using it, alias *should* be unique remember
            
            var m = Macro.GetByAlias(alias);


            if (m == null)
            {
                m = MakeNew(XmlHelper.GetNodeValue(n.SelectSingleNode(&quot;name&quot;)));
            }
            try
            {
                m.Alias = alias;
                m.Assembly = XmlHelper.GetNodeValue(n.SelectSingleNode(&quot;scriptAssembly&quot;));
                m.Type = XmlHelper.GetNodeValue(n.SelectSingleNode(&quot;scriptType&quot;));
                m.Xslt = XmlHelper.GetNodeValue(n.SelectSingleNode(&quot;xslt&quot;));
                m.RefreshRate = int.Parse(XmlHelper.GetNodeValue(n.SelectSingleNode(&quot;refreshRate&quot;)));

                // we need to validate if the usercontrol is missing the tilde prefix requirement introduced in v6
                if (string.IsNullOrEmpty(m.Assembly) &amp;&amp; string.IsNullOrEmpty(m.Type) == false &amp;&amp; m.Type.StartsWith(&quot;~&quot;) == false)
                {
                    m.Type = &quot;~/&quot; + m.Type;
                }

                if (n.SelectSingleNode(&quot;scriptingFile&quot;) != null)
                {
                    m.ScriptingFile = XmlHelper.GetNodeValue(n.SelectSingleNode(&quot;scriptingFile&quot;));
                }

                try
                {
                    m.UseInEditor = bool.Parse(XmlHelper.GetNodeValue(n.SelectSingleNode(&quot;useInEditor&quot;)));
                }
                catch (Exception macroExp)
                {
                    LogHelper.Error&lt;Macro&gt;(&quot;Error creating macro property&quot;, macroExp);
                }

                // macro properties
                foreach (XmlNode mp in n.SelectNodes(&quot;properties/property&quot;))
                {
                    try
                    {
                        var propertyAlias = mp.Attributes.GetNamedItem(&quot;alias&quot;).Value;
                        var property = m.Properties.SingleOrDefault(p =&gt; p.Alias == propertyAlias);
                        if (property != null)
                        {
                            property.Name = mp.Attributes.GetNamedItem(&quot;name&quot;).Value;
                            property.ParameterEditorAlias = mp.Attributes.GetNamedItem(&quot;propertyType&quot;).Value;

                            property.Save();
                        }
                        else
                        {
                            MacroProperty.MakeNew(
                                m,
                                propertyAlias,
                                mp.Attributes.GetNamedItem(&quot;name&quot;).Value,
                                mp.Attributes.GetNamedItem(&quot;propertyType&quot;).Value
                                );
                        }
                    }
                    catch (Exception macroPropertyExp)
                    {
                        LogHelper.Error&lt;Macro&gt;(&quot;Error creating macro property&quot;, macroPropertyExp);
                    }
                }

                m.Save();
            }
            catch (Exception ex)
            {
                LogHelper.Error&lt;Macro&gt;(&quot;An error occurred importing a macro&quot;, ex);
                return null;
            }

            return m;
        }

		private void Setup(int id)
		{
            var macro = ApplicationContext.Current.Services.MacroService.GetById(id);

            if (macro == null)
                throw new ArgumentException(string.Format(&quot;No Macro exists with id &#39;{0}&#39;&quot;, id));

		    MacroEntity = macro;
		}

        private void Setup(string alias)
        {
            var macro = ApplicationContext.Current.Services.MacroService.GetByAlias(alias);

            if (macro == null)
                throw new ArgumentException(string.Format(&quot;No Macro exists with alias &#39;{0}&#39;&quot;, alias));

            MacroEntity = macro;
        }

	    /// &lt;summary&gt;
	    /// Get an xmlrepresentation of the macro, used for exporting the macro to a package for distribution
	    /// &lt;/summary&gt;
	    /// &lt;param name=&quot;xd&quot;&gt;Current xmldocument context&lt;/param&gt;
	    /// &lt;returns&gt;An xmlrepresentation of the macro&lt;/returns&gt;
	    public XmlNode ToXml(XmlDocument xd)
	    {
            var serializer = new EntityXmlSerializer();
            var xml = serializer.Serialize(MacroEntity);
            return xml.GetXmlNode(xd);
	    }

	    [Obsolete(&quot;This does nothing&quot;)]
        public void RefreshProperties()
        {           
        }


		#region STATICS

		/// &lt;summary&gt;
		/// Creates a new macro given the name
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;Name&quot;&gt;Userfriendly name&lt;/param&gt;
		/// &lt;returns&gt;The newly macro&lt;/returns&gt;
		public static Macro MakeNew(string Name) 
		{
		    var macro = new Umbraco.Core.Models.Macro
		        {
                    Name = Name,
                    Alias = Name.Replace(&quot; &quot;, String.Empty)
		        };

		    ApplicationContext.Current.Services.MacroService.Save(macro);

            var newMacro = new Macro(macro);
           
            //fire new event
            var e = new NewEventArgs();
            newMacro.OnNew(e);
            
            return newMacro;
		}

		/// &lt;summary&gt;
		/// Retrieve all macroes
		/// &lt;/summary&gt;
		/// &lt;returns&gt;A list of all macroes&lt;/returns&gt;
		public static Macro[] GetAll()
		{
		    return ApplicationContext.Current.Services.MacroService.GetAll()
		                             .Select(x =&gt; new Macro(x))
		                             .ToArray();
		}

		/// &lt;summary&gt;
		/// Static contructor for retrieving a macro given an alias
		/// &lt;/summary&gt;
        /// &lt;param name=&quot;alias&quot;&gt;The alias of the macro&lt;/param&gt;
		/// &lt;returns&gt;If the macro with the given alias exists, it returns the macro, else null&lt;/returns&gt;
        public static Macro GetByAlias(string alias)
		{
		    return ApplicationContext.Current.ApplicationCache.RuntimeCache.GetCacheItem&lt;Macro&gt;(
		        GetCacheKey(alias),
		        timeout:        TimeSpan.FromMinutes(30),
		        getCacheItem:   () =&gt;
		            {
                        var macro = ApplicationContext.Current.Services.MacroService.GetByAlias(alias);
		                if (macro == null) return null;
		                return new Macro(macro);
		            });
		}

        public static Macro GetById(int id)
        {
            return ApplicationContext.Current.ApplicationCache.RuntimeCache.GetCacheItem&lt;Macro&gt;(
                GetCacheKey(string.Format(&quot;macro_via_id_{0}&quot;, id)),
                timeout:        TimeSpan.FromMinutes(30),
                getCacheItem:   () =&gt;
                    {
                        var macro = ApplicationContext.Current.Services.MacroService.GetById(id);
                        if (macro == null) return null;
                        return new Macro(macro);
                    });
        }

        public static MacroTypes FindMacroType(string xslt, string scriptFile, string scriptType, string scriptAssembly)
        {
            if (string.IsNullOrEmpty(xslt) == false)
                return MacroTypes.XSLT;
	        
			if (string.IsNullOrEmpty(scriptFile) == false)
			{
				//we need to check if the file path saved is a virtual path starting with ~/Views/MacroPartials, if so then this is 
				//a partial view macro, not a script macro
				//we also check if the file exists in ~/App_Plugins/[Packagename]/Views/MacroPartials, if so then it is also a partial view.
				return (scriptFile.InvariantStartsWith(SystemDirectories.MvcViews + &quot;/MacroPartials/&quot;)
				        || (Regex.IsMatch(scriptFile, &quot;~/App_Plugins/.+?/Views/MacroPartials&quot;, RegexOptions.Compiled | RegexOptions.IgnoreCase)))
					       ? MacroTypes.PartialView
					       : MacroTypes.Script;
			}

	        if (string.IsNullOrEmpty(scriptType) == false &amp;&amp; scriptType.InvariantContains(&quot;.ascx&quot;))
		        return MacroTypes.UserControl;
	        
			if (string.IsNullOrEmpty(scriptType) == false &amp;&amp; !string.IsNullOrEmpty(scriptAssembly))
		        return MacroTypes.CustomControl;

	        return MacroTypes.Unknown;
        }

        public static string GenerateCacheKeyFromCode(string input)
        {
            if (String.IsNullOrEmpty(input))
                throw new ArgumentNullException(&quot;input&quot;, &quot;An MD5 hash cannot be generated when &#39;input&#39; parameter is null!&quot;);

            // step 1, calculate MD5 hash from input
            var md5 = MD5.Create();
            var inputBytes = Encoding.ASCII.GetBytes(input);
            var hash = md5.ComputeHash(inputBytes);

            // step 2, convert byte array to hex string
            var sb = new StringBuilder();
            for (var i = 0; i &lt; hash.Length; i++)
            {
                sb.Append(hash[i].ToString(&quot;X2&quot;));
            }
            return sb.ToString();
        }

        #region Macro Refactor
        
        private static string GetCacheKey(string alias)
        {
            return CacheKeys.MacroCacheKey + alias;
        }

        #endregion


        //Macro events

        //Delegates
        public delegate void SaveEventHandler(Macro sender, SaveEventArgs e);
        public delegate void NewEventHandler(Macro sender, NewEventArgs e);
        public delegate void DeleteEventHandler(Macro sender, DeleteEventArgs e);

        /// &lt;summary&gt;
        /// Occurs when a macro is saved.
        /// &lt;/summary&gt;
        public static event SaveEventHandler BeforeSave;
        protected virtual void FireBeforeSave(SaveEventArgs e) {
            if (BeforeSave != null)
                BeforeSave(this, e);
        }

        public static event SaveEventHandler AfterSave;
        protected virtual void FireAfterSave(SaveEventArgs e) {
            if (AfterSave != null)
                AfterSave(this, e);
        }

        public static event NewEventHandler New;
        protected virtual void OnNew(NewEventArgs e) {
            if (New != null)
                New(this, e);
        }

        public static event DeleteEventHandler BeforeDelete;
        protected virtual void FireBeforeDelete(DeleteEventArgs e) {
            if (BeforeDelete != null)
                BeforeDelete(this, e);
        }

        public static event DeleteEventHandler AfterDelete;
        protected virtual void FireAfterDelete(DeleteEventArgs e) {
            if (AfterDelete != null)
                AfterDelete(this, e);
        }
		#endregion
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[33,6,33,68,0],[33,6,33,68,0],[33,6,33,68,0],[33,6,33,68,0],[41,17,41,18,0],[41,19,41,48,0],[41,49,41,50,0],[49,8,49,9,0],[49,10,49,32,0],[49,33,49,34,0],[57,17,57,18,0],[57,19,57,50,0],[57,51,57,52,0],[58,8,58,9,0],[58,10,58,42,0],[58,43,58,44,0],[69,17,69,18,0],[69,19,69,52,0],[69,53,69,54,0],[70,8,70,9,0],[70,10,70,44,0],[70,45,70,46,0],[80,8,80,9,0],[80,10,80,35,0],[80,36,80,37,0],[81,8,81,9,0],[81,10,81,36,0],[81,37,81,38,0],[89,17,89,18,0],[89,19,89,43,0],[89,44,89,45,0],[90,17,90,18,0],[90,19,90,44,0],[90,45,90,46,0],[100,17,100,18,0],[100,19,100,54,0],[100,55,100,56,0],[101,17,101,18,0],[101,19,101,55,0],[101,56,101,57,0],[112,17,112,18,0],[112,19,112,50,0],[112,51,112,52,0],[113,17,113,18,0],[113,19,113,51,0],[113,52,113,53,0],[123,17,123,18,0],[123,19,123,47,0],[123,48,123,49,0],[124,17,124,18,0],[124,19,124,48,0],[124,49,124,50,0],[137,14,137,15,0],[137,16,137,46,0],[137,47,137,48,0],[138,17,138,18,0],[138,19,138,50,0],[138,51,138,52,0],[148,17,148,18,0],[148,19,148,58,0],[148,59,148,60,0],[149,17,149,18,0],[149,19,149,59,0],[149,60,149,61,0],[158,17,158,18,0],[158,19,158,52,0],[158,53,158,54,0],[159,17,159,18,0],[159,19,159,53,0],[159,54,159,55,0],[168,17,168,18,0],[168,19,168,50,0],[168,51,168,52,0],[169,17,169,18,0],[169,19,169,51,0],[169,52,169,53,0],[178,10,178,11,0],[179,14,179,56,0],[179,56,186,19,0],[186,19,186,31,0],[179,14,186,31,0],[187,10,187,11,0],[194,9,194,23,0],[195,3,195,4,0],[196,3,196,4,0],[203,9,203,29,0],[204,3,204,4,0],[205,13,205,23,0],[206,3,206,4,0],[209,9,209,37,0],[210,9,210,10,0],[211,13,211,33,0],[212,9,212,10,0],[219,9,219,35,0],[220,9,220,10,0],[221,13,221,26,0],[222,9,222,10,0],[229,6,229,7,0],[231,10,231,38,0],[232,10,232,28,0],[234,10,234,32,0],[235,10,235,11,0],[236,14,236,81,0],[238,14,238,31,0],[239,10,239,11,0],[240,6,240,7,0],[246,3,246,4,0],[248,13,248,43,0],[249,13,249,33,0],[251,7,251,29,0],[252,7,252,8,0],[253,11,253,80,0],[255,11,255,30,0],[256,7,256,8,0],[257,3,257,4,0],[261,9,261,10,0],[262,13,262,77,0],[266,13,266,45,0],[269,13,269,27,0],[270,13,270,14,0],[271,17,271,81,0],[272,13,272,14,0],[274,13,274,14,0],[275,17,275,33,0],[276,17,276,91,0],[277,17,277,83,0],[278,17,278,77,0],[279,17,279,102,0],[282,17,282,130,0],[283,17,283,18,0],[284,21,284,44,0],[285,17,285,18,0],[287,17,287,65,0],[288,17,288,18,0],[289,21,289,99,0],[290,17,290,18,0],[293,17,293,18,0],[294,21,294,107,0],[295,17,295,18,0],[296,17,296,43,0],[297,17,297,18,0],[298,21,298,87,0],[299,17,299,18,0],[302,17,302,24,0],[302,26,302,36,0],[302,37,302,39,0],[302,40,302,76,0],[303,17,303,18,0],[305,21,305,22,0],[306,25,306,87,0],[307,25,307,74,0],[307,74,307,98,0],[307,98,307,100,0],[307,25,307,100,0],[308,25,308,46,0],[309,25,309,26,0],[310,29,310,86,0],[311,29,311,110,0],[313,29,313,45,0],[314,25,314,26,0],[316,25,316,26,0],[317,29,322,35,0],[323,25,323,26,0],[324,21,324,22,0],[325,21,325,55,0],[326,21,326,22,0],[327,25,327,99,0],[328,21,328,22,0],[329,17,329,18,0],[331,17,331,26,0],[332,13,332,14,0],[333,13,333,33,0],[334,13,334,14,0],[335,17,335,83,0],[336,17,336,29,0],[339,13,339,22,0],[340,9,340,10,0],[343,3,343,4,0],[344,13,344,86,0],[346,13,346,31,0],[347,17,347,97,0],[349,7,349,27,0],[350,3,350,4,0],[353,9,353,10,0],[354,13,354,92,0],[356,13,356,31,0],[357,17,357,103,0],[359,13,359,33,0],[360,9,360,10,0],[368,6,368,7,0],[369,13,369,56,0],[370,13,370,57,0],[371,13,371,39,0],[372,6,372,7,0],[376,9,376,10,0],[377,9,377,10,0],[388,3,388,4,0],[389,7,393,13,0],[395,7,395,68,0],[397,13,397,45,0],[400,13,400,40,0],[401,13,401,31,0],[403,13,403,29,0],[404,3,404,4,0],[411,3,411,4,0],[412,7,413,45,0],[413,45,413,57,0],[413,57,414,43,0],[412,7,414,43,0],[415,3,415,4,0],[423,3,423,4,0],[424,7,428,15,0],[428,15,428,16,0],[428,16,429,25,0],[429,25,429,104,0],[429,104,430,19,0],[430,19,430,37,0],[430,37,430,38,0],[430,38,430,50,0],[430,50,431,19,0],[431,19,431,43,0],[431,43,432,15,0],[432,15,432,16,0],[432,16,432,18,0],[424,7,432,18,0],[433,3,433,4,0],[436,9,436,10,0],[437,13,441,21,0],[441,21,441,22,0],[441,22,442,25,0],[442,25,442,98,0],[442,98,443,25,0],[443,25,443,43,0],[443,43,443,44,0],[443,44,443,56,0],[443,56,444,25,0],[444,25,444,49,0],[444,49,445,21,0],[445,21,445,22,0],[445,22,445,24,0],[437,13,445,24,0],[446,9,446,10,0],[449,9,449,10,1],[450,13,450,53,1],[451,17,451,40,1],[453,4,453,50,1],[454,4,454,5,1],[458,5,461,33,1],[464,10,464,97,1],[465,11,465,41,1],[467,4,467,91,1],[468,11,468,43,1],[470,10,470,36,1],[471,9,471,10,1],[474,9,474,10,0],[475,13,475,45,0],[476,17,476,125,0],[479,13,479,36,0],[480,13,480,61,0],[481,13,481,52,0],[484,13,484,42,0],[485,18,485,27,0],[485,29,485,44,0],[485,46,485,49,0],[486,13,486,14,0],[487,17,487,51,0],[488,13,488,14,0],[489,13,489,34,0],[490,9,490,10,0],[495,9,495,10,0],[496,13,496,52,0],[497,9,497,10,0],[513,64,513,65,0],[514,13,514,36,0],[515,17,515,37,0],[516,9,516,10,0],[519,63,519,64,0],[520,13,520,35,0],[521,17,521,36,0],[522,9,522,10,0],[525,54,525,55,0],[526,13,526,29,0],[527,17,527,30,0],[528,9,528,10,0],[531,68,531,69,0],[532,13,532,38,0],[533,17,533,39,0],[534,9,534,10,0],[537,67,537,68,0],[538,13,538,37,0],[539,17,539,38,0],[540,9,540,10,0]]);
    </script>
  </body>
</html>