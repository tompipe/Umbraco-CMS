<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Media\Exif\MathEx.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Text;

namespace Umbraco.Core.Media.Exif
{
    /// &lt;summary&gt;
    /// Contains extended Math functions.
    /// &lt;/summary&gt;
    internal static class MathEx
    {
        /// &lt;summary&gt;
        /// Returns the greatest common divisor of two numbers.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;a&quot;&gt;First number.&lt;/param&gt;
        /// &lt;param name=&quot;b&quot;&gt;Second number.&lt;/param&gt;
        public static uint GCD(uint a, uint b)
        {
            while (b != 0)
            {
                uint rem = a % b;
                a = b;
                b = rem;
            }

            return a;
        }

        /// &lt;summary&gt;
        /// Returns the greatest common divisor of two numbers.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;a&quot;&gt;First number.&lt;/param&gt;
        /// &lt;param name=&quot;b&quot;&gt;Second number.&lt;/param&gt;
        public static ulong GCD(ulong a, ulong b)
        {
            while (b != 0)
            {
                ulong rem = a % b;
                a = b;
                b = rem;
            }

            return a;
        }

        /// &lt;summary&gt;
        /// Represents a generic rational number represented by 32-bit signed numerator and denominator.
        /// &lt;/summary&gt;
        public struct Fraction32 : IComparable, IFormattable, IComparable&lt;Fraction32&gt;, IEquatable&lt;Fraction32&gt;
        {
            #region Constants
            private const uint MaximumIterations = 10000000;
            #endregion

            #region Member Variables
            private bool mIsNegative;
            private int mNumerator;
            private int mDenominator;
            private double mError;
            #endregion

            #region Properties
            /// &lt;summary&gt;
            /// Gets or sets the numerator.
            /// &lt;/summary&gt;
            public int Numerator
            {
                get
                {
                    return (mIsNegative ? -1 : 1) * mNumerator;
                }
                set
                {
                    if (value &lt; 0)
                    {
                        mIsNegative = true;
                        mNumerator = -1 * value;
                    }
                    else
                    {
                        mIsNegative = false;
                        mNumerator = value;
                    }
                    Reduce(ref mNumerator, ref mDenominator);
                }
            }
            /// &lt;summary&gt;
            /// Gets or sets the denominator.
            /// &lt;/summary&gt;
            public int Denominator
            {
                get
                {
                    return ((int)mDenominator);
                }
                set
                {
                    mDenominator = System.Math.Abs(value);
                    Reduce(ref mNumerator, ref mDenominator);
                }
            }

            /// &lt;summary&gt;
            /// Gets the error term.
            /// &lt;/summary&gt;
            public double Error
            {
                get
                {
                    return mError;
                }
            }

            /// &lt;summary&gt;
            /// Gets or sets a value determining id the fraction is a negative value.
            /// &lt;/summary&gt;
            public bool IsNegative
            {
                get
                {
                    return mIsNegative;
                }
                set
                {
                    mIsNegative = value;
                }
            }
            #endregion

            #region Predefined Values
            public static readonly Fraction32 NaN = new Fraction32(0, 0);
            public static readonly Fraction32 NegativeInfinity = new Fraction32(-1, 0);
            public static readonly Fraction32 PositiveInfinity = new Fraction32(1, 0);
            #endregion

            #region Static Methods
            /// &lt;summary&gt;
            /// Returns a value indicating whether the specified number evaluates to a value
            /// that is not a number.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;f&quot;&gt;A fraction.&lt;/param&gt;
            /// &lt;returns&gt;true if f evaluates to Fraction.NaN; otherwise, false.&lt;/returns&gt;
            public static bool IsNan(Fraction32 f)
            {
                return (f.Numerator == 0 &amp;&amp; f.Denominator == 0);
            }
            /// &lt;summary&gt;
            /// Returns a value indicating whether the specified number evaluates to negative
            /// infinity.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;f&quot;&gt;A fraction.&lt;/param&gt;
            /// &lt;returns&gt;true if f evaluates to Fraction.NegativeInfinity; otherwise, false.&lt;/returns&gt;
            public static bool IsNegativeInfinity(Fraction32 f)
            {
                return (f.Numerator &lt; 0 &amp;&amp; f.Denominator == 0);
            }
            /// &lt;summary&gt;
            /// Returns a value indicating whether the specified number evaluates to positive
            /// infinity.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;f&quot;&gt;A fraction.&lt;/param&gt;
            /// &lt;returns&gt;true if f evaluates to Fraction.PositiveInfinity; otherwise, false.&lt;/returns&gt;
            public static bool IsPositiveInfinity(Fraction32 f)
            {
                return (f.Numerator &gt; 0 &amp;&amp; f.Denominator == 0);
            }
            /// &lt;summary&gt;
            /// Returns a value indicating whether the specified number evaluates to negative
            /// or positive infinity.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;f&quot;&gt;A fraction.&lt;/param&gt;
            /// &lt;returns&gt;true if f evaluates to Fraction.NegativeInfinity or Fraction.PositiveInfinity; otherwise, false.&lt;/returns&gt;
            public static bool IsInfinity(Fraction32 f)
            {
                return (f.Denominator == 0);
            }
            /// &lt;summary&gt;
            /// Returns the multiplicative inverse of a given value.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;f&quot;&gt;A fraction.&lt;/param&gt;
            /// &lt;returns&gt;Multiplicative inverse of f.&lt;/returns&gt;
            public static Fraction32 Inverse(Fraction32 f)
            {
                return new Fraction32(f.Denominator, f.Numerator);
            }

            /// &lt;summary&gt;
            /// Converts the string representation of a fraction to a fraction object.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;s&quot;&gt;A string formatted as numerator/denominator&lt;/param&gt;
            /// &lt;returns&gt;A fraction object converted from s.&lt;/returns&gt;
            /// &lt;exception cref=&quot;System.ArgumentNullException&quot;&gt;s is null&lt;/exception&gt;
            /// &lt;exception cref=&quot;System.FormatException&quot;&gt;s is not in the correct format&lt;/exception&gt;
            /// &lt;exception cref=&quot;System.OverflowException&quot;&gt;
            /// s represents a number less than System.UInt32.MinValue or greater than 
            /// System.UInt32.MaxValue.
            /// &lt;/exception&gt;
            public static Fraction32 Parse(string s)
            {
                return FromString(s);
            }

            /// &lt;summary&gt;
            /// Converts the string representation of a fraction to a fraction object.
            /// A return value indicates whether the conversion succeeded.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;s&quot;&gt;A string formatted as numerator/denominator&lt;/param&gt;
            /// &lt;returns&gt;true if s was converted successfully; otherwise, false.&lt;/returns&gt;
            public static bool TryParse(string s, out Fraction32 f)
            {
                try
                {
                    f = Parse(s);
                    return true;
                }
                catch
                {
                    f = new Fraction32();
                    return false;
                }
            }
            #endregion

            #region Operators
            #region Arithmetic Operators
            // Multiplication
            public static Fraction32 operator *(Fraction32 f, int n)
            {
                return new Fraction32(f.Numerator * n, f.Denominator * System.Math.Abs(n));
            }
            public static Fraction32 operator *(int n, Fraction32 f)
            {
                return f * n;
            }
            public static Fraction32 operator *(Fraction32 f, float n)
            {
                return new Fraction32(((float)f) * n);
            }
            public static Fraction32 operator *(float n, Fraction32 f)
            {
                return f * n;
            }
            public static Fraction32 operator *(Fraction32 f, double n)
            {
                return new Fraction32(((double)f) * n);
            }
            public static Fraction32 operator *(double n, Fraction32 f)
            {
                return f * n;
            }
            public static Fraction32 operator *(Fraction32 f1, Fraction32 f2)
            {
                return new Fraction32(f1.Numerator * f2.Numerator, f1.Denominator * f2.Denominator);
            }
            // Divison
            public static Fraction32 operator /(Fraction32 f, int n)
            {
                return new Fraction32(f.Numerator / n, f.Denominator / System.Math.Abs(n));
            }
            public static Fraction32 operator /(Fraction32 f, float n)
            {
                return new Fraction32(((float)f) / n);
            }
            public static Fraction32 operator /(Fraction32 f, double n)
            {
                return new Fraction32(((double)f) / n);
            }
            public static Fraction32 operator /(Fraction32 f1, Fraction32 f2)
            {
                return f1 * Inverse(f2);
            }
            // Addition
            public static Fraction32 operator +(Fraction32 f, int n)
            {
                return f + new Fraction32(n, 1);
            }
            public static Fraction32 operator +(int n, Fraction32 f)
            {
                return f + n;
            }
            public static Fraction32 operator +(Fraction32 f, float n)
            {
                return new Fraction32(((float)f) + n);
            }
            public static Fraction32 operator +(float n, Fraction32 f)
            {
                return f + n;
            }
            public static Fraction32 operator +(Fraction32 f, double n)
            {
                return new Fraction32(((double)f) + n);
            }
            public static Fraction32 operator +(double n, Fraction32 f)
            {
                return f + n;
            }
            public static Fraction32 operator +(Fraction32 f1, Fraction32 f2)
            {
                int n1 = f1.Numerator, d1 = f1.Denominator;
                int n2 = f2.Numerator, d2 = f2.Denominator;

                return new Fraction32(n1 * d2 + n2 * d1, d1 * d2);
            }
            // Subtraction
            public static Fraction32 operator -(Fraction32 f, int n)
            {
                return f - new Fraction32(n, 1);
            }
            public static Fraction32 operator -(int n, Fraction32 f)
            {
                return new Fraction32(n, 1) - f;
            }
            public static Fraction32 operator -(Fraction32 f, float n)
            {
                return new Fraction32(((float)f) - n);
            }
            public static Fraction32 operator -(float n, Fraction32 f)
            {
                return new Fraction32(n) - f;
            }
            public static Fraction32 operator -(Fraction32 f, double n)
            {
                return new Fraction32(((double)f) - n);
            }
            public static Fraction32 operator -(double n, Fraction32 f)
            {
                return new Fraction32(n) - f;
            }
            public static Fraction32 operator -(Fraction32 f1, Fraction32 f2)
            {
                int n1 = f1.Numerator, d1 = f1.Denominator;
                int n2 = f2.Numerator, d2 = f2.Denominator;

                return new Fraction32(n1 * d2 - n2 * d1, d1 * d2);
            }
            // Increment
            public static Fraction32 operator ++(Fraction32 f)
            {
                return f + new Fraction32(1, 1);
            }
            // Decrement
            public static Fraction32 operator --(Fraction32 f)
            {
                return f - new Fraction32(1, 1);
            }
            #endregion
            #region Casts To Integral Types
            public static explicit operator int(Fraction32 f)
            {
                return f.Numerator / f.Denominator;
            }
            public static explicit operator float(Fraction32 f)
            {
                return ((float)f.Numerator) / ((float)f.Denominator);
            }
            public static explicit operator double(Fraction32 f)
            {
                return ((double)f.Numerator) / ((double)f.Denominator);
            }
            #endregion
            #region Comparison Operators
            public static bool operator ==(Fraction32 f1, Fraction32 f2)
            {
                return (f1.Numerator == f2.Numerator) &amp;&amp; (f1.Denominator == f2.Denominator);
            }
            public static bool operator !=(Fraction32 f1, Fraction32 f2)
            {
                return (f1.Numerator != f2.Numerator) || (f1.Denominator != f2.Denominator);
            }
            public static bool operator &lt;(Fraction32 f1, Fraction32 f2)
            {
                return (f1.Numerator * f2.Denominator) &lt; (f2.Numerator * f1.Denominator);
            }
            public static bool operator &gt;(Fraction32 f1, Fraction32 f2)
            {
                return (f1.Numerator * f2.Denominator) &gt; (f2.Numerator * f1.Denominator);
            }
            #endregion
            #endregion

            #region Constructors
            private Fraction32(int numerator, int denominator, double error)
            {
                mIsNegative = false;
                if (numerator &lt; 0)
                {
                    numerator = -numerator;
                    mIsNegative = !mIsNegative;
                }
                if (denominator &lt; 0)
                {
                    denominator = -denominator;
                    mIsNegative = !mIsNegative;
                }

                mNumerator = numerator;
                mDenominator = denominator;
                mError = error;

                if (mDenominator != 0)
                    Reduce(ref mNumerator, ref mDenominator);
            }

            public Fraction32(int numerator, int denominator)
                : this(numerator, denominator, 0)
            {
                ;
            }

            public Fraction32(int numerator)
                : this(numerator, (int)1)
            {
                ;
            }

            public Fraction32(Fraction32 f)
                : this(f.Numerator, f.Denominator, f.Error)
            {
                ;
            }

            public Fraction32(float value)
                : this((double)value)
            {
                ;
            }

            public Fraction32(double value)
                : this(FromDouble(value))
            {
                ;
            }

            public Fraction32(string s)
                : this(FromString(s))
            {
                ;
            }
            #endregion

            #region Instance Methods
            /// &lt;summary&gt;
            /// Sets the value of this instance to the fraction represented
            /// by the given numerator and denominator.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;numerator&quot;&gt;The new numerator.&lt;/param&gt;
            /// &lt;param name=&quot;denominator&quot;&gt;The new denominator.&lt;/param&gt;
            public void Set(int numerator, int denominator)
            {
                mIsNegative = false;
                if (numerator &lt; 0)
                {
                    mIsNegative = !mIsNegative;
                    numerator = -numerator;
                }
                if (denominator &lt; 0)
                {
                    mIsNegative = !mIsNegative;
                    denominator = -denominator;
                }

                mNumerator = numerator;
                mDenominator = denominator;

                if (mDenominator != 0)
                    Reduce(ref mNumerator, ref mDenominator);
            }

            /// &lt;summary&gt;
            /// Indicates whether this instance and a specified object are equal value-wise.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;obj&quot;&gt;Another object to compare to.&lt;/param&gt;
            /// &lt;returns&gt;true if obj and this instance are the same type and represent 
            /// the same value; otherwise, false.&lt;/returns&gt;
            public override bool Equals(object obj)
            {
                if (obj == null)
                    return false;

                if (obj is Fraction32)
                    return Equals((Fraction32)obj);
                else
                    return false;
            }

            /// &lt;summary&gt;
            /// Indicates whether this instance and a specified object are equal value-wise.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;obj&quot;&gt;Another fraction object to compare to.&lt;/param&gt;
            /// &lt;returns&gt;true if obj and this instance represent the same value; 
            /// otherwise, false.&lt;/returns&gt;
            public bool Equals(Fraction32 obj)
            {
                return (mIsNegative == obj.IsNegative) &amp;&amp; (mNumerator == obj.Numerator) &amp;&amp; (mDenominator == obj.Denominator);
            }

            /// &lt;summary&gt;
            /// Returns the hash code for this instance.
            /// &lt;/summary&gt;
            /// &lt;returns&gt; A 32-bit signed integer that is the hash code for this instance.&lt;/returns&gt;
            public override int GetHashCode()
            {
                return mDenominator ^ ((mIsNegative ? -1 : 1) * mNumerator);
            }

            /// &lt;summary&gt;
            /// Returns a string representation of the fraction.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;format&quot;&gt;A numeric format string.&lt;/param&gt;
            /// &lt;param name=&quot;formatProvider&quot;&gt;
            /// An System.IFormatProvider that supplies culture-specific 
            /// formatting information.
            /// &lt;/param&gt;
            /// &lt;returns&gt;
            /// The string representation of the value of this instance as 
            /// specified by format and provider.
            /// &lt;/returns&gt;
            /// &lt;exception cref=&quot;System.FormatException&quot;&gt;
            /// format is invalid or not supported.
            /// &lt;/exception&gt;
            public string ToString(string format, IFormatProvider formatProvider)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append(((mIsNegative ? -1 : 1) * mNumerator).ToString(format, formatProvider));
                sb.Append(&#39;/&#39;);
                sb.Append(mDenominator.ToString(format, formatProvider));
                return sb.ToString();
            }

            /// &lt;summary&gt;
            /// Returns a string representation of the fraction.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;format&quot;&gt;A numeric format string.&lt;/param&gt;
            /// &lt;returns&gt;
            /// The string representation of the value of this instance as 
            /// specified by format.
            /// &lt;/returns&gt;
            /// &lt;exception cref=&quot;System.FormatException&quot;&gt;
            /// format is invalid or not supported.
            /// &lt;/exception&gt;
            public string ToString(string format)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append(((mIsNegative ? -1 : 1) * mNumerator).ToString(format));
                sb.Append(&#39;/&#39;);
                sb.Append(mDenominator.ToString(format));
                return sb.ToString();
            }

            /// &lt;summary&gt;
            /// Returns a string representation of the fraction.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;formatProvider&quot;&gt;
            /// An System.IFormatProvider that supplies culture-specific 
            /// formatting information.
            /// &lt;/param&gt;
            /// &lt;returns&gt;
            /// The string representation of the value of this instance as 
            /// specified by provider.
            /// &lt;/returns&gt;
            public string ToString(IFormatProvider formatProvider)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append(((mIsNegative ? -1 : 1) * mNumerator).ToString(formatProvider));
                sb.Append(&#39;/&#39;);
                sb.Append(mDenominator.ToString(formatProvider));
                return sb.ToString();
            }

            /// &lt;summary&gt;
            /// Returns a string representation of the fraction.
            /// &lt;/summary&gt;
            /// &lt;returns&gt;A string formatted as numerator/denominator.&lt;/returns&gt;
            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();
                sb.Append(((mIsNegative ? -1 : 1) * mNumerator).ToString());
                sb.Append(&#39;/&#39;);
                sb.Append(mDenominator.ToString());
                return sb.ToString();
            }

            /// &lt;summary&gt;
            /// Compares this instance to a specified object and returns an indication of
            /// their relative values.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;obj&quot;&gt;An object to compare, or null.&lt;/param&gt;
            /// &lt;returns&gt;
            /// A signed number indicating the relative values of this instance and value.
            /// Less than zero: This instance is less than obj.
            /// Zero: This instance is equal to obj. 
            /// Greater than zero: This instance is greater than obj or obj is null.
            /// &lt;/returns&gt;
            /// &lt;exception cref=&quot;System.ArgumentException&quot;&gt;obj is not a Fraction.&lt;/exception&gt;
            public int CompareTo(object obj)
            {
                if (!(obj is Fraction32))
                    throw new ArgumentException(&quot;obj must be of type Fraction&quot;, &quot;obj&quot;);

                return CompareTo((Fraction32)obj);
            }

            /// &lt;summary&gt;
            /// Compares this instance to a specified object and returns an indication of
            /// their relative values.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;obj&quot;&gt;An fraction to compare with this instance.&lt;/param&gt;
            /// &lt;returns&gt;
            /// A signed number indicating the relative values of this instance and value.
            /// Less than zero: This instance is less than obj.
            /// Zero: This instance is equal to obj. 
            /// Greater than zero: This instance is greater than obj or obj is null.
            /// &lt;/returns&gt;
            public int CompareTo(Fraction32 obj)
            {
                if (this &lt; obj)
                    return -1;
                else if (this &gt; obj)
                    return 1;
                return 0;
            }
            #endregion

            #region Private Helper Methods
            /// &lt;summary&gt;
            /// Converts the given floating-point number to its rational representation.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;value&quot;&gt;The floating-point number to be converted.&lt;/param&gt;
            /// &lt;returns&gt;The rational representation of value.&lt;/returns&gt;
            private static Fraction32 FromDouble(double value)
            {
                if (double.IsNaN(value))
                    return Fraction32.NaN;
                else if (double.IsNegativeInfinity(value))
                    return Fraction32.NegativeInfinity;
                else if (double.IsPositiveInfinity(value))
                    return Fraction32.PositiveInfinity;

                bool isneg = (value &lt; 0);
                if (isneg) value = -value;

                double f = value;
                double forg = f;
                int lnum = 0;
                int lden = 1;
                int num = 1;
                int den = 0;
                double lasterr = 1.0;
                int a = 0;
                int currIteration = 0;
                while (true)
                {
                    if (++currIteration &gt; MaximumIterations) break;

                    a = (int)Math.Floor(f);
                    f = f - (double)a;
                    if (Math.Abs(f) &lt; double.Epsilon)
                        break;
                    f = 1.0 / f;
                    if (double.IsInfinity(f))
                        break;
                    int cnum = num * a + lnum;
                    int cden = den * a + lden;
                    if (Math.Abs((double)cnum / (double)cden - forg) &lt; double.Epsilon)
                        break;
                    double err = ((double)cnum / (double)cden - (double)num / (double)den) / ((double)num / (double)den);
                    // Are we converging?
                    if (err &gt;= lasterr)
                        break;
                    lasterr = err;
                    lnum = num;
                    lden = den;
                    num = cnum;
                    den = cden;
                }

                if (den &gt; 0)
                    lasterr = value - ((double)num / (double)den);
                else
                    lasterr = double.PositiveInfinity;

                return new Fraction32((isneg ? -1 : 1) * num, den, lasterr);
            }

            /// &lt;summary&gt;Converts the string representation of a fraction to a Fraction type.&lt;/summary&gt;
            /// &lt;param name=&quot;s&quot;&gt;The input string formatted as numerator/denominator.&lt;/param&gt;
            /// &lt;exception cref=&quot;System.ArgumentNullException&quot;&gt;s is null.&lt;/exception&gt;
            /// &lt;exception cref=&quot;System.FormatException&quot;&gt;s is not formatted as numerator/denominator.&lt;/exception&gt;
            /// &lt;exception cref=&quot;System.OverflowException&quot;&gt;
            /// s represents numbers less than System.Int32.MinValue or greater than 
            /// System.Int32.MaxValue.
            /// &lt;/exception&gt;
            private static Fraction32 FromString(string s)
            {
                if (s == null)
                    throw new ArgumentNullException(&quot;s&quot;);

                string[] sa = s.Split(&#39;/&#39;);
                int numerator = 1;
                int denominator = 1;

                if (sa.Length == 1)
                {
                    // Try to parse as int
                    if (int.TryParse(sa[0], out numerator))
                    {
                        denominator = 1;
                    }
                    else
                    {
                        // Parse as double
                        double dval = double.Parse(sa[0]);
                        return FromDouble(dval);
                    }
                }
                else if (sa.Length == 2)
                {
                    numerator = int.Parse(sa[0]);
                    denominator = int.Parse(sa[1]);
                }
                else
                    throw new FormatException(&quot;The input string must be formatted as n/d where n and d are integers&quot;);

                return new Fraction32(numerator, denominator);
            }

            /// &lt;summary&gt;
            /// Reduces the given numerator and denominator by dividing with their
            /// greatest common divisor.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;numerator&quot;&gt;numerator to be reduced.&lt;/param&gt;
            /// &lt;param name=&quot;denominator&quot;&gt;denominator to be reduced.&lt;/param&gt;
            private static void Reduce(ref int numerator, ref int denominator)
            {
                uint gcd = MathEx.GCD((uint)numerator, (uint)denominator);
                if (gcd == 0) gcd = 1;
                numerator = numerator / (int)gcd;
                denominator = denominator / (int)gcd;
            }
            #endregion
        }

        /// &lt;summary&gt;
        /// Represents a generic rational number represented by 32-bit unsigned numerator and denominator.
        /// &lt;/summary&gt;
        public struct UFraction32 : IComparable, IFormattable, IComparable&lt;UFraction32&gt;, IEquatable&lt;UFraction32&gt;
        {
            #region Constants
            private const uint MaximumIterations = 10000000;
            #endregion

            #region Member Variables
            private uint mNumerator;
            private uint mDenominator;
            private double mError;
            #endregion

            #region Properties
            /// &lt;summary&gt;
            /// Gets or sets the numerator.
            /// &lt;/summary&gt;
            public uint Numerator
            {
                get
                {
                    return mNumerator;
                }
                set
                {
                    mNumerator = value;
                    Reduce(ref mNumerator, ref mDenominator);
                }
            }
            /// &lt;summary&gt;
            /// Gets or sets the denominator.
            /// &lt;/summary&gt;
            public uint Denominator
            {
                get
                {
                    return mDenominator;
                }
                set
                {
                    mDenominator = value;
                    Reduce(ref mNumerator, ref mDenominator);
                }
            }


            /// &lt;summary&gt;
            /// Gets the error term.
            /// &lt;/summary&gt;
            public double Error
            {
                get
                {
                    return mError;
                }
            }
            #endregion

            #region Predefined Values
            public static readonly UFraction32 NaN = new UFraction32(0, 0);
            public static readonly UFraction32 Infinity = new UFraction32(1, 0);
            #endregion

            #region Static Methods
            /// &lt;summary&gt;
            /// Returns a value indicating whether the specified number evaluates to a value
            /// that is not a number.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;f&quot;&gt;A fraction.&lt;/param&gt;
            /// &lt;returns&gt;true if f evaluates to Fraction.NaN; otherwise, false.&lt;/returns&gt;
            public static bool IsNan(UFraction32 f)
            {
                return (f.Numerator == 0 &amp;&amp; f.Denominator == 0);
            }
            /// &lt;summary&gt;
            /// Returns a value indicating whether the specified number evaluates to infinity.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;f&quot;&gt;A fraction.&lt;/param&gt;
            /// &lt;returns&gt;true if f evaluates to Fraction.Infinity; otherwise, false.&lt;/returns&gt;
            public static bool IsInfinity(UFraction32 f)
            {
                return (f.Denominator == 0);
            }

            /// &lt;summary&gt;
            /// Converts the string representation of a fraction to a fraction object.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;s&quot;&gt;A string formatted as numerator/denominator&lt;/param&gt;
            /// &lt;returns&gt;A fraction object converted from s.&lt;/returns&gt;
            /// &lt;exception cref=&quot;System.ArgumentNullException&quot;&gt;s is null&lt;/exception&gt;
            /// &lt;exception cref=&quot;System.FormatException&quot;&gt;s is not in the correct format&lt;/exception&gt;
            /// &lt;exception cref=&quot;System.OverflowException&quot;&gt;
            /// s represents a number less than System.UInt32.MinValue or greater than 
            /// System.UInt32.MaxValue.
            /// &lt;/exception&gt;
            public static UFraction32 Parse(string s)
            {
                return FromString(s);
            }

            /// &lt;summary&gt;
            /// Converts the string representation of a fraction to a fraction object.
            /// A return value indicates whether the conversion succeeded.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;s&quot;&gt;A string formatted as numerator/denominator&lt;/param&gt;
            /// &lt;returns&gt;true if s was converted successfully; otherwise, false.&lt;/returns&gt;
            public static bool TryParse(string s, out UFraction32 f)
            {
                try
                {
                    f = Parse(s);
                    return true;
                }
                catch
                {
                    f = new UFraction32();
                    return false;
                }
            }
            #endregion

            #region Operators
            #region Arithmetic Operators
            // Multiplication
            public static UFraction32 operator *(UFraction32 f, uint n)
            {
                return new UFraction32(f.Numerator * n, f.Denominator * n);
            }
            public static UFraction32 operator *(uint n, UFraction32 f)
            {
                return f * n;
            }
            public static UFraction32 operator *(UFraction32 f, float n)
            {
                return new UFraction32(((float)f) * n);
            }
            public static UFraction32 operator *(float n, UFraction32 f)
            {
                return f * n;
            }
            public static UFraction32 operator *(UFraction32 f, double n)
            {
                return new UFraction32(((double)f) * n);
            }
            public static UFraction32 operator *(double n, UFraction32 f)
            {
                return f * n;
            }
            public static UFraction32 operator *(UFraction32 f1, UFraction32 f2)
            {
                return new UFraction32(f1.Numerator * f2.Numerator, f1.Denominator * f2.Denominator);
            }
            // Divison
            public static UFraction32 operator /(UFraction32 f, uint n)
            {
                return new UFraction32(f.Numerator / n, f.Denominator / n);
            }
            public static UFraction32 operator /(UFraction32 f, float n)
            {
                return new UFraction32(((float)f) / n);
            }
            public static UFraction32 operator /(UFraction32 f, double n)
            {
                return new UFraction32(((double)f) / n);
            }
            public static UFraction32 operator /(UFraction32 f1, UFraction32 f2)
            {
                return f1 * Inverse(f2);
            }
            // Addition
            public static UFraction32 operator +(UFraction32 f, uint n)
            {
                return f + new UFraction32(n, 1);
            }
            public static UFraction32 operator +(uint n, UFraction32 f)
            {
                return f + n;
            }
            public static UFraction32 operator +(UFraction32 f, float n)
            {
                return new UFraction32(((float)f) + n);
            }
            public static UFraction32 operator +(float n, UFraction32 f)
            {
                return f + n;
            }
            public static UFraction32 operator +(UFraction32 f, double n)
            {
                return new UFraction32(((double)f) + n);
            }
            public static UFraction32 operator +(double n, UFraction32 f)
            {
                return f + n;
            }
            public static UFraction32 operator +(UFraction32 f1, UFraction32 f2)
            {
                uint n1 = f1.Numerator, d1 = f1.Denominator;
                uint n2 = f2.Numerator, d2 = f2.Denominator;

                return new UFraction32(n1 * d2 + n2 * d1, d1 * d2);
            }
            // Subtraction
            public static UFraction32 operator -(UFraction32 f, uint n)
            {
                return f - new UFraction32(n, 1);
            }
            public static UFraction32 operator -(uint n, UFraction32 f)
            {
                return new UFraction32(n, 1) - f;
            }
            public static UFraction32 operator -(UFraction32 f, float n)
            {
                return new UFraction32(((float)f) - n);
            }
            public static UFraction32 operator -(float n, UFraction32 f)
            {
                return new UFraction32(n) - f;
            }
            public static UFraction32 operator -(UFraction32 f, double n)
            {
                return new UFraction32(((double)f) - n);
            }
            public static UFraction32 operator -(double n, UFraction32 f)
            {
                return new UFraction32(n) - f;
            }
            public static UFraction32 operator -(UFraction32 f1, UFraction32 f2)
            {
                uint n1 = f1.Numerator, d1 = f1.Denominator;
                uint n2 = f2.Numerator, d2 = f2.Denominator;

                return new UFraction32(n1 * d2 - n2 * d1, d1 * d2);
            }
            // Increment
            public static UFraction32 operator ++(UFraction32 f)
            {
                return f + new UFraction32(1, 1);
            }
            // Decrement
            public static UFraction32 operator --(UFraction32 f)
            {
                return f - new UFraction32(1, 1);
            }
            #endregion
            #region Casts To Integral Types
            public static explicit operator uint(UFraction32 f)
            {
                return ((uint)f.Numerator) / ((uint)f.Denominator);
            }
            public static explicit operator float(UFraction32 f)
            {
                return ((float)f.Numerator) / ((float)f.Denominator);
            }
            public static explicit operator double(UFraction32 f)
            {
                return ((double)f.Numerator) / ((double)f.Denominator);
            }
            #endregion
            #region Comparison Operators
            public static bool operator ==(UFraction32 f1, UFraction32 f2)
            {
                return (f1.Numerator == f2.Numerator) &amp;&amp; (f1.Denominator == f2.Denominator);
            }
            public static bool operator !=(UFraction32 f1, UFraction32 f2)
            {
                return (f1.Numerator != f2.Numerator) || (f1.Denominator != f2.Denominator);
            }
            public static bool operator &lt;(UFraction32 f1, UFraction32 f2)
            {
                return (f1.Numerator * f2.Denominator) &lt; (f2.Numerator * f1.Denominator);
            }
            public static bool operator &gt;(UFraction32 f1, UFraction32 f2)
            {
                return (f1.Numerator * f2.Denominator) &gt; (f2.Numerator * f1.Denominator);
            }
            #endregion
            #endregion

            #region Constructors
            public UFraction32(uint numerator, uint denominator, double error)
            {
                mNumerator = numerator;
                mDenominator = denominator;
                mError = error;

                if (mDenominator != 0)
                    Reduce(ref mNumerator, ref mDenominator);
            }

            public UFraction32(uint numerator, uint denominator)
                : this(numerator, denominator, 0)
            {
                ;
            }

            public UFraction32(uint numerator)
                : this(numerator, (uint)1)
            {
                ;
            }

            public UFraction32(UFraction32 f)
                : this(f.Numerator, f.Denominator, f.Error)
            {
                ;
            }

            public UFraction32(float value)
                : this((double)value)
            {
                ;
            }

            public UFraction32(double value)
                : this(FromDouble(value))
            {
                ;
            }

            public UFraction32(string s)
                : this(FromString(s))
            {
                ;
            }
            #endregion

            #region Instance Methods
            /// &lt;summary&gt;
            /// Sets the value of this instance to the fraction represented
            /// by the given numerator and denominator.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;numerator&quot;&gt;The new numerator.&lt;/param&gt;
            /// &lt;param name=&quot;denominator&quot;&gt;The new denominator.&lt;/param&gt;
            public void Set(uint numerator, uint denominator)
            {
                mNumerator = numerator;
                mDenominator = denominator;

                if (mDenominator != 0)
                    Reduce(ref mNumerator, ref mDenominator);
            }

            /// &lt;summary&gt;
            /// Returns the multiplicative inverse of a given value.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;f&quot;&gt;A fraction.&lt;/param&gt;
            /// &lt;returns&gt;Multiplicative inverse of f.&lt;/returns&gt;
            public static UFraction32 Inverse(UFraction32 f)
            {
                return new UFraction32(f.Denominator, f.Numerator);
            }

            /// &lt;summary&gt;
            /// Indicates whether this instance and a specified object are equal value-wise.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;obj&quot;&gt;Another object to compare to.&lt;/param&gt;
            /// &lt;returns&gt;true if obj and this instance are the same type and represent 
            /// the same value; otherwise, false.&lt;/returns&gt;
            public override bool Equals(object obj)
            {
                if (obj == null)
                    return false;

                if (obj is UFraction32)
                    return Equals((UFraction32)obj);
                else
                    return false;
            }

            /// &lt;summary&gt;
            /// Indicates whether this instance and a specified object are equal value-wise.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;obj&quot;&gt;Another fraction object to compare to.&lt;/param&gt;
            /// &lt;returns&gt;true if obj and this instance represent the same value; 
            /// otherwise, false.&lt;/returns&gt;
            public bool Equals(UFraction32 obj)
            {
                return (mNumerator == obj.Numerator) &amp;&amp; (mDenominator == obj.Denominator);
            }

            /// &lt;summary&gt;
            /// Returns the hash code for this instance.
            /// &lt;/summary&gt;
            /// &lt;returns&gt; A 32-bit signed integer that is the hash code for this instance.&lt;/returns&gt;
            public override int GetHashCode()
            {
                return ((int)mDenominator) ^ ((int)mNumerator);
            }

            /// &lt;summary&gt;
            /// Returns a string representation of the fraction.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;format&quot;&gt;A numeric format string.&lt;/param&gt;
            /// &lt;param name=&quot;formatProvider&quot;&gt;
            /// An System.IFormatProvider that supplies culture-specific 
            /// formatting information.
            /// &lt;/param&gt;
            /// &lt;returns&gt;
            /// The string representation of the value of this instance as 
            /// specified by format and provider.
            /// &lt;/returns&gt;
            /// &lt;exception cref=&quot;System.FormatException&quot;&gt;
            /// format is invalid or not supported.
            /// &lt;/exception&gt;
            public string ToString(string format, IFormatProvider formatProvider)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append(mNumerator.ToString(format, formatProvider));
                sb.Append(&#39;/&#39;);
                sb.Append(mDenominator.ToString(format, formatProvider));
                return sb.ToString();
            }

            /// &lt;summary&gt;
            /// Returns a string representation of the fraction.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;format&quot;&gt;A numeric format string.&lt;/param&gt;
            /// &lt;returns&gt;
            /// The string representation of the value of this instance as 
            /// specified by format.
            /// &lt;/returns&gt;
            /// &lt;exception cref=&quot;System.FormatException&quot;&gt;
            /// format is invalid or not supported.
            /// &lt;/exception&gt;
            public string ToString(string format)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append(mNumerator.ToString(format));
                sb.Append(&#39;/&#39;);
                sb.Append(mDenominator.ToString(format));
                return sb.ToString();
            }

            /// &lt;summary&gt;
            /// Returns a string representation of the fraction.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;formatProvider&quot;&gt;
            /// An System.IFormatProvider that supplies culture-specific 
            /// formatting information.
            /// &lt;/param&gt;
            /// &lt;returns&gt;
            /// The string representation of the value of this instance as 
            /// specified by provider.
            /// &lt;/returns&gt;
            public string ToString(IFormatProvider formatProvider)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append(mNumerator.ToString(formatProvider));
                sb.Append(&#39;/&#39;);
                sb.Append(mDenominator.ToString(formatProvider));
                return sb.ToString();
            }

            /// &lt;summary&gt;
            /// Returns a string representation of the fraction.
            /// &lt;/summary&gt;
            /// &lt;returns&gt;A string formatted as numerator/denominator.&lt;/returns&gt;
            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();
                sb.Append(mNumerator.ToString());
                sb.Append(&#39;/&#39;);
                sb.Append(mDenominator.ToString());
                return sb.ToString();
            }

            /// &lt;summary&gt;
            /// Compares this instance to a specified object and returns an indication of
            /// their relative values.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;obj&quot;&gt;An object to compare, or null.&lt;/param&gt;
            /// &lt;returns&gt;
            /// A signed number indicating the relative values of this instance and value.
            /// Less than zero: This instance is less than obj.
            /// Zero: This instance is equal to obj. 
            /// Greater than zero: This instance is greater than obj or obj is null.
            /// &lt;/returns&gt;
            /// &lt;exception cref=&quot;System.ArgumentException&quot;&gt;obj is not a Fraction.&lt;/exception&gt;
            public int CompareTo(object obj)
            {
                if (!(obj is UFraction32))
                    throw new ArgumentException(&quot;obj must be of type UFraction32&quot;, &quot;obj&quot;);

                return CompareTo((UFraction32)obj);
            }

            /// &lt;summary&gt;
            /// Compares this instance to a specified object and returns an indication of
            /// their relative values.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;obj&quot;&gt;An fraction to compare with this instance.&lt;/param&gt;
            /// &lt;returns&gt;
            /// A signed number indicating the relative values of this instance and value.
            /// Less than zero: This instance is less than obj.
            /// Zero: This instance is equal to obj. 
            /// Greater than zero: This instance is greater than obj or obj is null.
            /// &lt;/returns&gt;
            public int CompareTo(UFraction32 obj)
            {
                if (this &lt; obj)
                    return -1;
                else if (this &gt; obj)
                    return 1;
                return 0;
            }
            #endregion

            #region Private Helper Methods
            /// &lt;summary&gt;
            /// Converts the given floating-point number to its rational representation.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;value&quot;&gt;The floating-point number to be converted.&lt;/param&gt;
            /// &lt;returns&gt;The rational representation of value.&lt;/returns&gt;
            private static UFraction32 FromDouble(double value)
            {
                if (value &lt; 0)
                    throw new ArgumentException(&quot;value cannot be negative.&quot;, &quot;value&quot;);

                if (double.IsNaN(value))
                    return UFraction32.NaN;
                else if (double.IsInfinity(value))
                    return UFraction32.Infinity;

                double f = value;
                double forg = f;
                uint lnum = 0;
                uint lden = 1;
                uint num = 1;
                uint den = 0;
                double lasterr = 1.0;
                uint a = 0;
                int currIteration = 0;
                while (true)
                {
                    if (++currIteration &gt; MaximumIterations) break;

                    a = (uint)Math.Floor(f);
                    f = f - (double)a;
                    if (Math.Abs(f) &lt; double.Epsilon)
                        break;
                    f = 1.0 / f;
                    if (double.IsInfinity(f))
                        break;
                    uint cnum = num * a + lnum;
                    uint cden = den * a + lden;
                    if (Math.Abs((double)cnum / (double)cden - forg) &lt; double.Epsilon)
                        break;
                    double err = ((double)cnum / (double)cden - (double)num / (double)den) / ((double)num / (double)den);
                    // Are we converging?
                    if (err &gt;= lasterr)
                        break;
                    lasterr = err;
                    lnum = num;
                    lden = den;
                    num = cnum;
                    den = cden;
                }
                uint fnum = num * a + lnum;
                uint fden = den * a + lden;

                if (fden &gt; 0)
                    lasterr = value - ((double)fnum / (double)fden);
                else
                    lasterr = double.PositiveInfinity;

                return new UFraction32(fnum, fden, lasterr);
            }

            /// &lt;summary&gt;Converts the string representation of a fraction to a Fraction type.&lt;/summary&gt;
            /// &lt;param name=&quot;s&quot;&gt;The input string formatted as numerator/denominator.&lt;/param&gt;
            /// &lt;exception cref=&quot;System.ArgumentNullException&quot;&gt;s is null.&lt;/exception&gt;
            /// &lt;exception cref=&quot;System.FormatException&quot;&gt;s is not formatted as numerator/denominator.&lt;/exception&gt;
            /// &lt;exception cref=&quot;System.OverflowException&quot;&gt;
            /// s represents numbers less than System.UInt32.MinValue or greater than 
            /// System.UInt32.MaxValue.
            /// &lt;/exception&gt;
            private static UFraction32 FromString(string s)
            {
                if (s == null)
                    throw new ArgumentNullException(&quot;s&quot;);

                string[] sa = s.Split(&#39;/&#39;);
                uint numerator = 1;
                uint denominator = 1;

                if (sa.Length == 1)
                {
                    // Try to parse as uint
                    if (uint.TryParse(sa[0], out numerator))
                    {
                        denominator = 1;
                    }
                    else
                    {
                        // Parse as double
                        double dval = double.Parse(sa[0]);
                        return FromDouble(dval);
                    }
                }
                else if (sa.Length == 2)
                {
                    numerator = uint.Parse(sa[0]);
                    denominator = uint.Parse(sa[1]);
                }
                else
                    throw new FormatException(&quot;The input string must be formatted as n/d where n and d are integers&quot;);

                return new UFraction32(numerator, denominator);
            }

            /// &lt;summary&gt;
            /// Reduces the given numerator and denominator by dividing with their
            /// greatest common divisor.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;numerator&quot;&gt;numerator to be reduced.&lt;/param&gt;
            /// &lt;param name=&quot;denominator&quot;&gt;denominator to be reduced.&lt;/param&gt;
            private static void Reduce(ref uint numerator, ref uint denominator)
            {
                uint gcd = MathEx.GCD(numerator, denominator);
                numerator = numerator / gcd;
                denominator = denominator / gcd;
            }
            #endregion
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[17,9,17,10,0],[18,13,18,27,0],[19,13,19,14,0],[20,17,20,34,0],[21,17,21,23,0],[22,17,22,25,0],[23,13,23,14,0],[25,13,25,22,0],[26,9,26,10,0],[34,9,34,10,0],[35,13,35,27,0],[36,13,36,14,0],[37,17,37,35,0],[38,17,38,23,0],[39,17,39,25,0],[40,13,40,14,0],[42,13,42,22,0],[43,9,43,10,0],[68,17,68,18,0],[69,21,69,64,0],[70,17,70,18,0],[72,17,72,18,0],[73,21,73,35,0],[74,21,74,22,0],[75,25,75,44,0],[76,25,76,49,0],[77,21,77,22,0],[79,21,79,22,0],[80,25,80,45,0],[81,25,81,44,0],[82,21,82,22,0],[83,21,83,62,0],[84,17,84,18,0],[92,17,92,18,0],[93,21,93,48,0],[94,17,94,18,0],[96,17,96,18,0],[97,21,97,59,0],[98,21,98,62,0],[99,17,99,18,0],[108,17,108,18,0],[109,21,109,35,0],[110,17,110,18,0],[119,17,119,18,0],[120,21,120,40,0],[121,17,121,18,0],[123,17,123,18,0],[124,21,124,41,0],[125,17,125,18,0],[130,13,130,74,0],[131,13,131,88,0],[132,13,132,87,0],[143,13,143,14,0],[144,17,144,65,0],[145,13,145,14,0],[153,13,153,14,0],[154,17,154,64,0],[155,13,155,14,0],[163,13,163,14,0],[164,17,164,64,0],[165,13,165,14,0],[173,13,173,14,0],[174,17,174,45,0],[175,13,175,14,0],[182,13,182,14,0],[183,17,183,67,0],[184,13,184,14,0],[198,13,198,14,0],[199,17,199,38,0],[200,13,200,14,0],[209,13,209,14,0],[211,17,211,18,0],[212,21,212,34,0],[213,21,213,33,0],[215,17,215,22,0],[216,17,216,18,0],[217,21,217,42,0],[218,21,218,34,0],[220,13,220,14,0],[227,13,227,14,0],[228,17,228,92,0],[229,13,229,14,0],[231,13,231,14,0],[232,17,232,30,0],[233,13,233,14,0],[235,13,235,14,0],[236,17,236,55,0],[237,13,237,14,0],[239,13,239,14,0],[240,17,240,30,0],[241,13,241,14,0],[243,13,243,14,0],[244,17,244,56,0],[245,13,245,14,0],[247,13,247,14,0],[248,17,248,30,0],[249,13,249,14,0],[251,13,251,14,0],[252,17,252,101,0],[253,13,253,14,0],[256,13,256,14,0],[257,17,257,92,0],[258,13,258,14,0],[260,13,260,14,0],[261,17,261,55,0],[262,13,262,14,0],[264,13,264,14,0],[265,17,265,56,0],[266,13,266,14,0],[268,13,268,14,0],[269,17,269,41,0],[270,13,270,14,0],[273,13,273,14,0],[274,17,274,49,0],[275,13,275,14,0],[277,13,277,14,0],[278,17,278,30,0],[279,13,279,14,0],[281,13,281,14,0],[282,17,282,55,0],[283,13,283,14,0],[285,13,285,14,0],[286,17,286,30,0],[287,13,287,14,0],[289,13,289,14,0],[290,17,290,56,0],[291,13,291,14,0],[293,13,293,14,0],[294,17,294,30,0],[295,13,295,14,0],[297,13,297,14,0],[298,17,298,38,0],[298,40,298,59,0],[299,17,299,38,0],[299,40,299,59,0],[301,17,301,67,0],[302,13,302,14,0],[305,13,305,14,0],[306,17,306,49,0],[307,13,307,14,0],[309,13,309,14,0],[310,17,310,49,0],[311,13,311,14,0],[313,13,313,14,0],[314,17,314,55,0],[315,13,315,14,0],[317,13,317,14,0],[318,17,318,46,0],[319,13,319,14,0],[321,13,321,14,0],[322,17,322,56,0],[323,13,323,14,0],[325,13,325,14,0],[326,17,326,46,0],[327,13,327,14,0],[329,13,329,14,0],[330,17,330,38,0],[330,40,330,59,0],[331,17,331,38,0],[331,40,331,59,0],[333,17,333,67,0],[334,13,334,14,0],[337,13,337,14,0],[338,17,338,49,0],[339,13,339,14,0],[342,13,342,14,0],[343,17,343,49,0],[344,13,344,14,0],[348,13,348,14,0],[349,17,349,52,0],[350,13,350,14,0],[352,13,352,14,0],[353,17,353,70,0],[354,13,354,14,0],[356,13,356,14,0],[357,17,357,72,0],[358,13,358,14,0],[362,13,362,14,0],[363,17,363,93,0],[364,13,364,14,0],[366,13,366,14,0],[367,17,367,93,0],[368,13,368,14,0],[370,13,370,14,0],[371,17,371,90,0],[372,13,372,14,0],[374,13,374,14,0],[375,17,375,90,0],[376,13,376,14,0],[382,13,382,14,0],[383,17,383,37,0],[384,17,384,35,0],[385,17,385,18,0],[386,21,386,44,0],[387,21,387,48,0],[388,17,388,18,0],[389,17,389,37,0],[390,17,390,18,0],[391,21,391,48,0],[392,21,392,48,0],[393,17,393,18,0],[395,17,395,40,0],[396,17,396,44,0],[397,17,397,32,0],[399,17,399,39,0],[400,21,400,62,0],[401,13,401,14,0],[404,19,404,50,0],[405,13,405,14,0],[406,17,406,18,0],[407,13,407,14,0],[410,19,410,42,0],[411,13,411,14,0],[412,17,412,18,0],[413,13,413,14,0],[416,19,416,60,0],[417,13,417,14,0],[418,17,418,18,0],[419,13,419,14,0],[422,19,422,38,0],[423,13,423,14,0],[424,17,424,18,0],[425,13,425,14,0],[428,19,428,42,0],[429,13,429,14,0],[430,17,430,18,0],[431,13,431,14,0],[434,19,434,38,0],[435,13,435,14,0],[436,17,436,18,0],[437,13,437,14,0],[448,13,448,14,0],[449,17,449,37,0],[450,17,450,35,0],[451,17,451,18,0],[452,21,452,48,0],[453,21,453,44,0],[454,17,454,18,0],[455,17,455,37,0],[456,17,456,18,0],[457,21,457,48,0],[458,21,458,48,0],[459,17,459,18,0],[461,17,461,40,0],[462,17,462,44,0],[464,17,464,39,0],[465,21,465,62,0],[466,13,466,14,0],[475,13,475,14,0],[476,17,476,33,0],[477,21,477,34,0],[479,17,479,39,0],[480,21,480,52,0],[482,21,482,34,0],[483,13,483,14,0],[492,13,492,14,0],[493,17,493,126,0],[494,13,494,14,0],[501,13,501,14,0],[502,17,502,77,0],[503,13,503,14,0],[521,13,521,14,0],[522,17,522,56,0],[523,17,523,99,0],[524,17,524,32,0],[525,17,525,74,0],[526,17,526,38,0],[527,13,527,14,0],[541,13,541,14,0],[542,17,542,56,0],[543,17,543,83,0],[544,17,544,32,0],[545,17,545,58,0],[546,17,546,38,0],[547,13,547,14,0],[561,13,561,14,0],[562,17,562,56,0],[563,17,563,91,0],[564,17,564,32,0],[565,17,565,66,0],[566,17,566,38,0],[567,13,567,14,0],[574,13,574,14,0],[575,17,575,56,0],[576,17,576,77,0],[577,17,577,32,0],[578,17,578,52,0],[579,17,579,38,0],[580,13,580,14,0],[595,13,595,14,0],[596,17,596,42,0],[597,21,597,88,0],[599,17,599,51,0],[600,13,600,14,0],[614,13,614,14,0],[615,17,615,32,0],[616,21,616,31,0],[617,22,617,37,0],[618,21,618,30,0],[619,17,619,26,0],[620,13,620,14,0],[630,13,630,14,0],[631,17,631,41,0],[632,21,632,43,0],[633,22,633,59,0],[634,21,634,56,0],[635,22,635,59,0],[636,21,636,56,0],[638,17,638,42,0],[639,17,639,27,0],[639,28,639,43,0],[641,17,641,34,0],[642,17,642,33,0],[643,17,643,30,0],[644,17,644,30,0],[645,17,645,29,0],[646,17,646,29,0],[647,17,647,38,0],[648,17,648,27,0],[649,17,649,39,0],[650,17,650,29,0],[651,17,651,18,0],[652,21,652,61,0],[652,62,652,68,0],[654,21,654,44,0],[655,21,655,39,0],[656,21,656,54,0],[657,25,657,31,0],[658,21,658,33,0],[659,21,659,46,0],[660,25,660,31,0],[661,21,661,47,0],[662,21,662,47,0],[663,21,663,87,0],[664,25,664,31,0],[665,21,665,122,0],[667,21,667,40,0],[668,25,668,31,0],[669,21,669,35,0],[670,21,670,32,0],[671,21,671,32,0],[672,21,672,32,0],[673,21,673,32,0],[674,17,674,18,0],[676,17,676,29,0],[677,21,677,67,0],[679,21,679,55,0],[681,17,681,77,0],[682,13,682,14,0],[693,13,693,14,0],[694,17,694,31,0],[695,21,695,58,0],[697,17,697,44,0],[698,17,698,35,0],[699,17,699,37,0],[701,17,701,36,0],[702,17,702,18,0],[704,21,704,60,0],[705,21,705,22,0],[706,25,706,41,0],[707,21,707,22,0],[709,21,709,22,0],[711,25,711,59,0],[712,25,712,49,0],[714,17,714,18,0],[715,22,715,41,0],[716,17,716,18,0],[717,21,717,50,0],[718,21,718,52,0],[719,17,719,18,0],[721,21,721,119,0],[723,17,723,63,0],[724,13,724,14,0],[733,13,733,14,0],[734,17,734,75,0],[735,17,735,30,0],[735,31,735,39,0],[736,17,736,50,0],[737,17,737,54,0],[738,13,738,14,0],[764,17,764,18,0],[765,21,765,39,0],[766,17,766,18,0],[768,17,768,18,0],[769,21,769,40,0],[770,21,770,62,0],[771,17,771,18,0],[779,17,779,18,0],[780,21,780,41,0],[781,17,781,18,0],[783,17,783,18,0],[784,21,784,42,0],[785,21,785,62,0],[786,17,786,18,0],[796,17,796,18,0],[797,21,797,35,0],[798,17,798,18,0],[803,13,803,76,0],[804,13,804,81,0],[815,13,815,14,0],[816,17,816,65,0],[817,13,817,14,0],[824,13,824,14,0],[825,17,825,45,0],[826,13,826,14,0],[840,13,840,14,0],[841,17,841,38,0],[842,13,842,14,0],[851,13,851,14,0],[853,17,853,18,0],[854,21,854,34,0],[855,21,855,33,0],[857,17,857,22,0],[858,17,858,18,0],[859,21,859,43,0],[860,21,860,34,0],[862,13,862,14,0],[869,13,869,14,0],[870,17,870,76,0],[871,13,871,14,0],[873,13,873,14,0],[874,17,874,30,0],[875,13,875,14,0],[877,13,877,14,0],[878,17,878,56,0],[879,13,879,14,0],[881,13,881,14,0],[882,17,882,30,0],[883,13,883,14,0],[885,13,885,14,0],[886,17,886,57,0],[887,13,887,14,0],[889,13,889,14,0],[890,17,890,30,0],[891,13,891,14,0],[893,13,893,14,0],[894,17,894,102,0],[895,13,895,14,0],[898,13,898,14,0],[899,17,899,76,0],[900,13,900,14,0],[902,13,902,14,0],[903,17,903,56,0],[904,13,904,14,0],[906,13,906,14,0],[907,17,907,57,0],[908,13,908,14,0],[910,13,910,14,0],[911,17,911,41,0],[912,13,912,14,0],[915,13,915,14,0],[916,17,916,50,0],[917,13,917,14,0],[919,13,919,14,0],[920,17,920,30,0],[921,13,921,14,0],[923,13,923,14,0],[924,17,924,56,0],[925,13,925,14,0],[927,13,927,14,0],[928,17,928,30,0],[929,13,929,14,0],[931,13,931,14,0],[932,17,932,57,0],[933,13,933,14,0],[935,13,935,14,0],[936,17,936,30,0],[937,13,937,14,0],[939,13,939,14,0],[940,17,940,39,0],[940,41,940,60,0],[941,17,941,39,0],[941,41,941,60,0],[943,17,943,68,0],[944,13,944,14,0],[947,13,947,14,0],[948,17,948,50,0],[949,13,949,14,0],[951,13,951,14,0],[952,17,952,50,0],[953,13,953,14,0],[955,13,955,14,0],[956,17,956,56,0],[957,13,957,14,0],[959,13,959,14,0],[960,17,960,47,0],[961,13,961,14,0],[963,13,963,14,0],[964,17,964,57,0],[965,13,965,14,0],[967,13,967,14,0],[968,17,968,47,0],[969,13,969,14,0],[971,13,971,14,0],[972,17,972,39,0],[972,41,972,60,0],[973,17,973,39,0],[973,41,973,60,0],[975,17,975,68,0],[976,13,976,14,0],[979,13,979,14,0],[980,17,980,50,0],[981,13,981,14,0],[984,13,984,14,0],[985,17,985,50,0],[986,13,986,14,0],[990,13,990,14,0],[991,17,991,68,0],[992,13,992,14,0],[994,13,994,14,0],[995,17,995,70,0],[996,13,996,14,0],[998,13,998,14,0],[999,17,999,72,0],[1000,13,1000,14,0],[1004,13,1004,14,0],[1005,17,1005,93,0],[1006,13,1006,14,0],[1008,13,1008,14,0],[1009,17,1009,93,0],[1010,13,1010,14,0],[1012,13,1012,14,0],[1013,17,1013,90,0],[1014,13,1014,14,0],[1016,13,1016,14,0],[1017,17,1017,90,0],[1018,13,1018,14,0],[1024,13,1024,14,0],[1025,17,1025,40,0],[1026,17,1026,44,0],[1027,17,1027,32,0],[1029,17,1029,39,0],[1030,21,1030,62,0],[1031,13,1031,14,0],[1034,19,1034,50,0],[1035,13,1035,14,0],[1036,17,1036,18,0],[1037,13,1037,14,0],[1040,19,1040,43,0],[1041,13,1041,14,0],[1042,17,1042,18,0],[1043,13,1043,14,0],[1046,19,1046,60,0],[1047,13,1047,14,0],[1048,17,1048,18,0],[1049,13,1049,14,0],[1052,19,1052,38,0],[1053,13,1053,14,0],[1054,17,1054,18,0],[1055,13,1055,14,0],[1058,19,1058,42,0],[1059,13,1059,14,0],[1060,17,1060,18,0],[1061,13,1061,14,0],[1064,19,1064,38,0],[1065,13,1065,14,0],[1066,17,1066,18,0],[1067,13,1067,14,0],[1078,13,1078,14,0],[1079,17,1079,40,0],[1080,17,1080,44,0],[1082,17,1082,39,0],[1083,21,1083,62,0],[1084,13,1084,14,0],[1092,13,1092,14,0],[1093,17,1093,68,0],[1094,13,1094,14,0],[1103,13,1103,14,0],[1104,17,1104,33,0],[1105,21,1105,34,0],[1107,17,1107,40,0],[1108,21,1108,53,0],[1110,21,1110,34,0],[1111,13,1111,14,0],[1120,13,1120,14,0],[1121,17,1121,91,0],[1122,13,1122,14,0],[1129,13,1129,14,0],[1130,17,1130,64,0],[1131,13,1131,14,0],[1149,13,1149,14,0],[1150,17,1150,56,0],[1151,17,1151,72,0],[1152,17,1152,32,0],[1153,17,1153,74,0],[1154,17,1154,38,0],[1155,13,1155,14,0],[1169,13,1169,14,0],[1170,17,1170,56,0],[1171,17,1171,56,0],[1172,17,1172,32,0],[1173,17,1173,58,0],[1174,17,1174,38,0],[1175,13,1175,14,0],[1189,13,1189,14,0],[1190,17,1190,56,0],[1191,17,1191,64,0],[1192,17,1192,32,0],[1193,17,1193,66,0],[1194,17,1194,38,0],[1195,13,1195,14,0],[1202,13,1202,14,0],[1203,17,1203,56,0],[1204,17,1204,50,0],[1205,17,1205,32,0],[1206,17,1206,52,0],[1207,17,1207,38,0],[1208,13,1208,14,0],[1223,13,1223,14,0],[1224,17,1224,43,0],[1225,21,1225,91,0],[1227,17,1227,52,0],[1228,13,1228,14,0],[1242,13,1242,14,0],[1243,17,1243,32,0],[1244,21,1244,31,0],[1245,22,1245,37,0],[1246,21,1246,30,0],[1247,17,1247,26,0],[1248,13,1248,14,0],[1258,13,1258,14,0],[1259,17,1259,31,0],[1260,21,1260,87,0],[1262,17,1262,41,0],[1263,21,1263,44,0],[1264,22,1264,51,0],[1265,21,1265,49,0],[1267,17,1267,34,0],[1268,17,1268,33,0],[1269,17,1269,31,0],[1270,17,1270,31,0],[1271,17,1271,30,0],[1272,17,1272,30,0],[1273,17,1273,38,0],[1274,17,1274,28,0],[1275,17,1275,39,0],[1276,17,1276,29,0],[1277,17,1277,18,0],[1278,21,1278,61,0],[1278,62,1278,68,0],[1280,21,1280,45,0],[1281,21,1281,39,0],[1282,21,1282,54,0],[1283,25,1283,31,0],[1284,21,1284,33,0],[1285,21,1285,46,0],[1286,25,1286,31,0],[1287,21,1287,48,0],[1288,21,1288,48,0],[1289,21,1289,87,0],[1290,25,1290,31,0],[1291,21,1291,122,0],[1293,21,1293,40,0],[1294,25,1294,31,0],[1295,21,1295,35,0],[1296,21,1296,32,0],[1297,21,1297,32,0],[1298,21,1298,32,0],[1299,21,1299,32,0],[1300,17,1300,18,0],[1301,17,1301,44,0],[1302,17,1302,44,0],[1304,17,1304,30,0],[1305,21,1305,69,0],[1307,21,1307,55,0],[1309,17,1309,61,0],[1310,13,1310,14,0],[1321,13,1321,14,0],[1322,17,1322,31,0],[1323,21,1323,58,0],[1325,17,1325,44,0],[1326,17,1326,36,0],[1327,17,1327,38,0],[1329,17,1329,36,0],[1330,17,1330,18,0],[1332,21,1332,61,0],[1333,21,1333,22,0],[1334,25,1334,41,0],[1335,21,1335,22,0],[1337,21,1337,22,0],[1339,25,1339,59,0],[1340,25,1340,49,0],[1342,17,1342,18,0],[1343,22,1343,41,0],[1344,17,1344,18,0],[1345,21,1345,51,0],[1346,21,1346,53,0],[1347,17,1347,18,0],[1349,21,1349,119,0],[1351,17,1351,64,0],[1352,13,1352,14,0],[1361,13,1361,14,0],[1362,17,1362,63,0],[1363,17,1363,45,0],[1364,17,1364,49,0],[1365,13,1365,14,0]]);
    </script>
  </body>
</html>