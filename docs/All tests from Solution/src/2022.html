<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Models\Property.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using Umbraco.Core.Models.EntityBase;

namespace Umbraco.Core.Models
{
    /// &lt;summary&gt;
    /// A Property contains a single piece of data
    /// &lt;/summary&gt;
    [Serializable]
    [DataContract(IsReference = true)]
    public class Property : Entity
    {
        private PropertyType _propertyType;
        private Guid _version;
        private object _value;
        private readonly PropertyTags _tagSupport = new PropertyTags();

        protected Property()
        {
            
        }

        public Property(PropertyType propertyType)
        {
            _propertyType = propertyType;
        }

        public Property(PropertyType propertyType, object value)
        {
            _propertyType = propertyType;
            Value = value;
        }

        public Property(int id, Guid version, PropertyType propertyType, object value)
        {
            Id = id;
            _propertyType = propertyType;
            _version = version;
            Value = value;
        }

        private static readonly Lazy&lt;PropertySelectors&gt; Ps = new Lazy&lt;PropertySelectors&gt;();

        private class PropertySelectors
        {
            public readonly PropertyInfo ValueSelector = ExpressionHelper.GetPropertyInfo&lt;Property, object&gt;(x =&gt; x.Value);
            public readonly PropertyInfo VersionSelector = ExpressionHelper.GetPropertyInfo&lt;Property, Guid&gt;(x =&gt; x.Version);
        }

        private static readonly DelegateEqualityComparer&lt;object&gt; ValueComparer = new DelegateEqualityComparer&lt;object&gt;(
            (o, o1) =&gt;
            {
                if (o == null &amp;&amp; o1 == null) return true;

                //custom comparer for strings.                        
                if (o is string || o1 is string)
                {
                    //if one is null and another is empty then they are the same
                    if ((o as string).IsNullOrWhiteSpace() &amp;&amp; (o1 as string).IsNullOrWhiteSpace())
                    {
                        return true;
                    }
                    if (o == null || o1 == null) return false;
                    return o.Equals(o1);
                }

                if (o == null || o1 == null) return false;

                //Custom comparer for enumerable if it is enumerable
                var enum1 = o as IEnumerable;
                var enum2 = o1 as IEnumerable;
                if (enum1 != null &amp;&amp; enum2 != null)
                {
                    return enum1.Cast&lt;object&gt;().UnsortedSequenceEqual(enum2.Cast&lt;object&gt;());
                }
                return o.Equals(o1);
            }, o =&gt; o.GetHashCode());
        
        /// &lt;summary&gt;
        /// Returns the instance of the tag support, by default tags are not enabled
        /// &lt;/summary&gt;
        internal PropertyTags TagSupport
        {
            get { return _tagSupport; }
        }

        /// &lt;summary&gt;
        /// Returns the Alias of the PropertyType, which this Property is based on
        /// &lt;/summary&gt;
        [DataMember]
        public string Alias { get { return _propertyType.Alias; } }

        /// &lt;summary&gt;
        /// Returns the Id of the PropertyType, which this Property is based on
        /// &lt;/summary&gt;
        [IgnoreDataMember]
        internal int PropertyTypeId { get { return _propertyType.Id; } }

        /// &lt;summary&gt;
        /// Returns the DatabaseType that the underlaying DataType is using to store its values
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// Only used internally when saving the property value.
        /// &lt;/remarks&gt;
        [IgnoreDataMember]
        internal DataTypeDatabaseType DataTypeDatabaseType
        {
            get { return _propertyType.DataTypeDatabaseType; }
        }

        /// &lt;summary&gt;
        /// Returns the PropertyType, which this Property is based on
        /// &lt;/summary&gt;
        [IgnoreDataMember]
        public PropertyType PropertyType { get { return _propertyType; } }
        
        /// &lt;summary&gt;
        /// Gets or Sets the version id for the Property
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// The version will be the same for all Property objects in a collection on a Content 
        /// object, so not sure how much this makes sense but adding it to align with:
        /// umbraco.interfaces.IProperty
        /// &lt;/remarks&gt;
        [DataMember]
        public Guid Version
        {
            get { return _version; }
            set { SetPropertyValueAndDetectChanges(value, ref _version, Ps.Value.VersionSelector); }
        }

        private static void ThrowTypeException(object value, Type expected, string alias)
        {
            throw new InvalidOperationException(string.Format(&quot;Value \&quot;{0}\&quot; of type \&quot;{1}\&quot; could not be converted&quot;
                + &quot; to type \&quot;{2}\&quot; which is expected by property type \&quot;{3}\&quot;.&quot;,
                value, value.GetType(), expected, alias));
        }

        /// &lt;summary&gt;
        /// Gets or Sets the value of the Property
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// Setting the value will trigger a type validation. 
        /// The type of the value has to be valid in order to be saved.
        /// &lt;/remarks&gt;
        [DataMember]
        public object Value
        {
            get { return _value; }
            set
            {
                var isOfExpectedType = _propertyType.IsPropertyTypeValid(value);

                if (isOfExpectedType == false) // isOfExpectedType is true if value is null - so if false, value is *not* null
                {
                    // &quot;garbage-in&quot;, accept what we can &amp; convert
                    // throw only if conversion is not possible

                    var s = value.ToString();

                    switch (_propertyType.DataTypeDatabaseType)
                    {
                        case DataTypeDatabaseType.Nvarchar:
                        case DataTypeDatabaseType.Ntext:
                            value = s;
                            break;
                        case DataTypeDatabaseType.Integer:
                            if (s.IsNullOrWhiteSpace()) value = null; // assume empty means null
                            else
                            {
                                var convInt = value.TryConvertTo&lt;int&gt;();
                                if (convInt == false) ThrowTypeException(value, typeof(int), _propertyType.Alias);
                                value = convInt.Result;
                            }
                            break;
                        case DataTypeDatabaseType.Decimal:
                            if (s.IsNullOrWhiteSpace()) value = null; // assume empty means null
                            else
                            {
                                var convDecimal = value.TryConvertTo&lt;decimal&gt;();
                                if (convDecimal == false) ThrowTypeException(value, typeof (decimal), _propertyType.Alias);
                                // need to normalize the value (change the scaling factor and remove trailing zeroes)
                                // because the underlying database is going to mess with the scaling factor anyways.
                                value = convDecimal.Result.Normalize();
                            }
                            break;
                        case DataTypeDatabaseType.Date:
                            if (s.IsNullOrWhiteSpace()) value = null; // assume empty means null
                            else
                            {
                                var convDateTime = value.TryConvertTo&lt;DateTime&gt;();
                                if (convDateTime == false) ThrowTypeException(value, typeof (DateTime), _propertyType.Alias);
                                value = convDateTime.Result;
                            }
                            break;
                    }
                }

                SetPropertyValueAndDetectChanges(value, ref _value, Ps.Value.ValueSelector, ValueComparer);
            }
        }

        /// &lt;summary&gt;
        /// Boolean indicating whether the current value is valid
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// A valid value implies that it is ready for publishing.
        /// Invalid property values can be saved, but not published.
        /// &lt;/remarks&gt;
        /// &lt;returns&gt;True is property value is valid, otherwise false&lt;/returns&gt;
        public bool IsValid()
        {
            return IsValid(Value);
        }

        /// &lt;summary&gt;
        /// Boolean indicating whether the passed in value is valid
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;True is property value is valid, otherwise false&lt;/returns&gt;
        public bool IsValid(object value)
        {
            return _propertyType.IsPropertyValueValid(value);
        }

        public override object DeepClone()
        {
            var clone = (Property)base.DeepClone();
            //turn off change tracking
            clone.DisableChangeTracking();
            //need to manually assign since this is a readonly property
            clone._propertyType = (PropertyType)PropertyType.DeepClone();
            //this shouldn&#39;t really be needed since we&#39;re not tracking
            clone.ResetDirtyProperties(false);
            //re-enable tracking
            clone.EnableChangeTracking();
            
            return clone;
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[20,9,20,72,0],[20,9,20,72,1],[20,9,20,72,1],[20,9,20,72,1],[22,9,22,29,0],[23,9,23,10,0],[25,9,25,10,0],[27,9,27,51,1],[28,9,28,10,1],[29,13,29,42,1],[30,9,30,10,1],[32,9,32,65,1],[33,9,33,10,1],[34,13,34,42,1],[35,13,35,27,1],[36,9,36,10,1],[38,9,38,87,1],[39,9,39,10,1],[40,13,40,21,1],[41,13,41,42,1],[42,13,42,32,1],[43,13,43,27,1],[44,9,44,10,1],[46,9,46,92,1],[50,13,50,123,1],[51,13,51,125,1],[54,9,56,13,1],[56,13,56,14,1],[56,14,57,17,1],[57,17,57,45,1],[57,45,57,46,1],[57,46,57,58,1],[57,58,60,17,1],[60,17,60,49,1],[60,49,61,17,1],[61,17,61,18,1],[61,18,63,21,1],[63,21,63,99,1],[63,99,64,21,1],[64,21,64,22,1],[64,22,65,25,1],[65,25,65,37,1],[65,37,67,21,1],[67,21,67,49,1],[67,49,67,50,1],[67,50,67,63,1],[67,63,68,21,1],[68,21,68,41,1],[68,41,71,17,1],[71,17,71,45,1],[71,45,71,46,1],[71,46,71,59,1],[71,59,74,17,1],[74,17,74,46,1],[74,46,75,17,1],[75,17,75,47,1],[75,47,76,17,1],[76,17,76,52,1],[76,52,77,17,1],[77,17,77,18,0],[77,18,78,21,1],[78,21,78,93,0],[78,93,80,17,1],[80,17,80,37,1],[80,37,81,13,1],[81,13,81,14,1],[81,14,81,21,1],[81,21,81,36,0],[81,36,81,38,1],[54,9,81,38,1],[88,17,88,18,1],[88,19,88,38,1],[88,39,88,40,1],[95,35,95,36,1],[95,37,95,64,1],[95,65,95,66,1],[101,43,101,44,1],[101,45,101,69,1],[101,70,101,71,1],[112,17,112,18,1],[112,19,112,61,1],[112,62,112,63,1],[119,48,119,49,1],[119,50,119,71,1],[119,72,119,73,1],[132,17,132,18,1],[132,19,132,35,1],[132,36,132,37,1],[133,17,133,18,1],[133,19,133,99,1],[133,100,133,101,1],[137,9,137,10,0],[138,13,140,59,0],[153,17,153,18,1],[153,19,153,33,1],[153,34,153,35,1],[155,13,155,14,1],[156,17,156,81,1],[158,17,158,47,1],[159,17,159,18,1],[163,21,163,46,1],[165,21,165,64,1],[169,29,169,39,1],[170,29,170,35,1],[172,29,172,56,1],[172,57,172,70,0],[174,29,174,30,1],[175,33,175,73,1],[176,33,176,54,1],[176,55,176,115,0],[177,33,177,56,1],[178,29,178,30,1],[179,29,179,35,1],[181,29,181,56,1],[181,57,181,70,1],[183,29,183,30,1],[184,33,184,81,1],[185,33,185,58,1],[185,59,185,124,0],[188,33,188,72,1],[189,29,189,30,1],[190,29,190,35,1],[192,29,192,56,1],[192,57,192,70,0],[194,29,194,30,1],[195,33,195,83,1],[196,33,196,59,1],[196,60,196,126,0],[197,33,197,61,1],[198,29,198,30,1],[199,29,199,35,1],[201,17,201,18,1],[203,17,203,108,1],[204,13,204,14,1],[216,9,216,10,1],[217,13,217,35,1],[218,9,218,10,1],[226,9,226,10,1],[227,13,227,62,1],[228,9,228,10,1],[231,9,231,10,1],[232,13,232,52,1],[234,13,234,43,1],[236,13,236,74,1],[238,13,238,47,1],[240,13,240,42,1],[242,13,242,26,1],[243,9,243,10,1]]);
    </script>
  </body>
</html>