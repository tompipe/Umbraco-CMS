<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Tests\PublishedContent\StronglyTypedModels\TypedModelBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Data.Entity.Design.PluralizationServices;
using System.Globalization;
using System.Reflection;
using System.Linq;
using Umbraco.Core;
using Umbraco.Core.Models;
using Umbraco.Core.Models.PublishedContent;
using Umbraco.Web;

namespace Umbraco.Tests.PublishedContent.StronglyTypedModels
{
    /// &lt;summary&gt;
    /// Represents the abstract base class for a &#39;TypedModel&#39;, which basically wraps IPublishedContent
    /// underneath a strongly typed model like &quot;Textpage&quot; and &quot;Subpage&quot;.
    /// Because IPublishedContent is used under the hood there is no need for additional mapping, so the
    /// only added cost should be the creation of the objects, which the IPublishedContent instance is 
    /// passed into.
    /// 
    /// This base class exposes a simple way to write property getters by convention without
    /// using the string alias of a PropertyType (this is resolved by the use of the Property delegate).
    /// 
    /// This base class also exposes query options like Parent, Children, Ancestors and Descendants,
    /// which can be used for collections of strongly typed child models/objects. These types of collections
    /// typically corresponds to &#39;allowed child content types&#39; on a Doc Type (at different levels).
    /// 
    /// The IPublishedContent properties are also exposed through this base class, but only
    /// by casting the typed model to IPublishedContent, so the properties doesn&#39;t show up by default:
    /// ie. ((IPublishedContent)textpage).Url
    /// &lt;/summary&gt;
    public abstract class TypedModelBase : PublishedContentWrapped // IPublishedContent
    {
        protected TypedModelBase(IPublishedContent publishedContent)
            : base(publishedContent)
        { }

        protected readonly Func&lt;MethodBase&gt; Property = MethodBase.GetCurrentMethod;
        protected readonly Func&lt;MethodBase&gt; ContentTypeAlias = MethodBase.GetCurrentMethod;

        #region Properties

        protected T Resolve&lt;T&gt;(MethodBase methodBase)
        {
            var propertyTypeAlias = methodBase.ToUmbracoAlias();
            return Resolve&lt;T&gt;(propertyTypeAlias);
        }

        protected T Resolve&lt;T&gt;(string propertyTypeAlias)
        {
            return Content.GetPropertyValue&lt;T&gt;(propertyTypeAlias);
        }

        protected T Resolve&lt;T&gt;(MethodBase methodBase, T ifCannotConvert)
        {
            var propertyTypeAlias = methodBase.ToUmbracoAlias();
            return Resolve&lt;T&gt;(propertyTypeAlias, ifCannotConvert);
        }

        protected T Resolve&lt;T&gt;(string propertyTypeAlias, T ifCannotConvert)
        {
            return Content.GetPropertyValue&lt;T&gt;(propertyTypeAlias, false, ifCannotConvert);
        }

        protected T Resolve&lt;T&gt;(MethodBase methodBase, bool recursive, T ifCannotConvert)
        {
            var propertyTypeAlias = methodBase.ToUmbracoAlias();
            return Resolve&lt;T&gt;(propertyTypeAlias, recursive, ifCannotConvert);
        }

        protected T Resolve&lt;T&gt;(string propertyTypeAlias, bool recursive, T ifCannotConvert)
        {
            return Content.GetPropertyValue&lt;T&gt;(propertyTypeAlias, recursive, ifCannotConvert);
        }
        #endregion

        #region Querying
        protected T Parent&lt;T&gt;() where T : TypedModelBase
        {
            var constructorInfo = typeof(T).GetConstructor(new[] { typeof(IPublishedContent) });
            if (constructorInfo == null)
                throw new Exception(&quot;No valid constructor found&quot;);

            return (T) constructorInfo.Invoke(new object[] {Content.Parent});
        }

        protected IEnumerable&lt;T&gt; Children&lt;T&gt;(MethodBase methodBase) where T : TypedModelBase
        {
            var docTypeAlias = methodBase.CleanCallingMethodName();
            return Children&lt;T&gt;(docTypeAlias);
        }

        protected IEnumerable&lt;T&gt; Children&lt;T&gt;(string docTypeAlias) where T : TypedModelBase
        {
            var constructorInfo = typeof(T).GetConstructor(new[] { typeof(IPublishedContent) });
            if(constructorInfo == null)
                throw new Exception(&quot;No valid constructor found&quot;);

            string singularizedDocTypeAlias = docTypeAlias.ToSingular();

            return Content.Children.Where(x =&gt; x.DocumentTypeAlias == singularizedDocTypeAlias)
                .Select(x =&gt; (T)constructorInfo.Invoke(new object[] { x }));
        }

        protected IEnumerable&lt;T&gt; Ancestors&lt;T&gt;(MethodBase methodBase) where T : TypedModelBase
        {
            var docTypeAlias = methodBase.CleanCallingMethodName();
            return Ancestors&lt;T&gt;(docTypeAlias);
        }

        protected IEnumerable&lt;T&gt; Ancestors&lt;T&gt;(string docTypeAlias) where T : TypedModelBase
        {
            var constructorInfo = typeof(T).GetConstructor(new[] { typeof(IPublishedContent) });
            if (constructorInfo == null)
                throw new Exception(&quot;No valid constructor found&quot;);

            string singularizedDocTypeAlias = docTypeAlias.ToSingular();

            return Content.Ancestors().Where(x =&gt; x.DocumentTypeAlias == singularizedDocTypeAlias)
                .Select(x =&gt; (T)constructorInfo.Invoke(new object[] { x }));
        }

        protected IEnumerable&lt;T&gt; Descendants&lt;T&gt;(MethodBase methodBase) where T : TypedModelBase
        {
            var docTypeAlias = methodBase.CleanCallingMethodName();
            return Descendants&lt;T&gt;(docTypeAlias);
        }

        protected IEnumerable&lt;T&gt; Descendants&lt;T&gt;(string docTypeAlias) where T : TypedModelBase
        {
            var constructorInfo = typeof(T).GetConstructor(new[] { typeof(IPublishedContent) });
            if (constructorInfo == null)
                throw new Exception(&quot;No valid constructor found&quot;);

            string singularizedDocTypeAlias = docTypeAlias.ToSingular();

            return Content.Descendants().Where(x =&gt; x.DocumentTypeAlias == singularizedDocTypeAlias)
                .Select(x =&gt; (T)constructorInfo.Invoke(new object[] { x }));
        }
        #endregion
    }

    /// &lt;summary&gt;
    /// Extension methods for MethodBase, which are used to clean the name of the calling method &quot;get_BodyText&quot;
    /// to &quot;BodyText&quot; and then make it camel case according to the UmbracoAlias convention &quot;bodyText&quot;.
    /// There is also a string extension for making plural words singular, which is used when going from
    /// something like &quot;Subpages&quot; to &quot;Subpage&quot; for Children/Ancestors/Descendants Doc Type aliases.
    /// &lt;/summary&gt;
    public static class TypeExtensions
    {
        public static string CleanCallingMethodName(this MethodBase methodBase)
        {
            return methodBase.Name.Replace(&quot;get_&quot;, &quot;&quot;);
        }

        public static string ToUmbracoAlias(this MethodBase methodBase)
        {
            return methodBase.CleanCallingMethodName().ToUmbracoAlias();
        }

        public static string ToSingular(this string pluralWord)
        {
            var service = PluralizationService.CreateService(new CultureInfo(&quot;en-US&quot;));
            if (service.IsPlural(pluralWord))
                return service.Singularize(pluralWord);

            return pluralWord;
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[35,15,35,37,0],[36,9,36,10,0],[36,11,36,12,0],[38,9,38,84,0],[39,9,39,92,0],[44,9,44,10,0],[45,13,45,65,0],[46,13,46,50,0],[47,9,47,10,0],[50,9,50,10,0],[51,13,51,67,0],[52,9,52,10,0],[55,9,55,10,0],[56,13,56,65,0],[57,13,57,67,0],[58,9,58,10,0],[61,9,61,10,0],[62,13,62,91,0],[63,9,63,10,0],[66,9,66,10,0],[67,13,67,65,0],[68,13,68,78,0],[69,9,69,10,0],[72,9,72,10,0],[73,13,73,95,0],[74,9,74,10,0],[79,9,79,10,0],[80,13,80,97,0],[81,13,81,41,0],[82,17,82,67,0],[84,13,84,78,0],[85,9,85,10,0],[88,9,88,10,0],[89,13,89,68,0],[90,13,90,46,0],[91,9,91,10,0],[94,9,94,10,0],[95,13,95,97,0],[96,13,96,40,0],[97,17,97,67,0],[99,13,99,73,0],[101,13,101,48,0],[101,48,101,95,0],[101,95,102,30,0],[102,30,102,75,0],[102,75,102,77,0],[101,13,102,77,0],[103,9,103,10,0],[106,9,106,10,0],[107,13,107,68,0],[108,13,108,47,0],[109,9,109,10,0],[112,9,112,10,0],[113,13,113,97,0],[114,13,114,41,0],[115,17,115,67,0],[117,13,117,73,0],[119,13,119,51,0],[119,51,119,98,0],[119,98,120,30,0],[120,30,120,75,0],[120,75,120,77,0],[119,13,120,77,0],[121,9,121,10,0],[124,9,124,10,0],[125,13,125,68,0],[126,13,126,49,0],[127,9,127,10,0],[130,9,130,10,0],[131,13,131,97,0],[132,13,132,41,0],[133,17,133,67,0],[135,13,135,73,0],[137,13,137,53,0],[137,53,137,100,0],[137,100,138,30,0],[138,30,138,75,0],[138,75,138,77,0],[137,13,138,77,0],[139,9,139,10,0],[152,9,152,10,0],[153,13,153,56,0],[154,9,154,10,0],[157,9,157,10,0],[158,13,158,73,0],[159,9,159,10,0],[162,9,162,10,0],[163,13,163,88,0],[164,13,164,46,0],[165,17,165,56,0],[167,13,167,31,0],[168,9,168,10,0]]);
    </script>
  </body>
</html>