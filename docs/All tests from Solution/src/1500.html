<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\Strings\DefaultShortStringHelper.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Globalization;
using Umbraco.Core.Configuration;
using Umbraco.Core.Configuration.UmbracoSettings;

namespace Umbraco.Core.Strings
{
    /// &lt;summary&gt;
    /// New default implementation of string functions for short strings such as aliases or url segments.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// &lt;para&gt;Not optimized to work on large bodies of text.&lt;/para&gt;
    /// &lt;para&gt;Meant to replace &lt;c&gt;LegacyShortStringHelper&lt;/c&gt; where/when backward compatibility is not an issue.&lt;/para&gt;
    /// &lt;para&gt;NOTE: pre-filters run _before_ the string is re-encoded.&lt;/para&gt;
    /// &lt;/remarks&gt;
    public class DefaultShortStringHelper : IShortStringHelper
    {
        private readonly IUmbracoSettingsSection _umbracoSettings;

        #region Ctor and vars

        [Obsolete(&quot;Use the other ctor that specifies all dependencies&quot;)]
        public DefaultShortStringHelper()
        {
            _umbracoSettings = _umbracoSettings;
            InitializeLegacyUrlReplaceCharacters();
        }

        public DefaultShortStringHelper(IUmbracoSettingsSection umbracoSettings)
        {
            _umbracoSettings = umbracoSettings;
            InitializeLegacyUrlReplaceCharacters();
        }

        /// &lt;summary&gt;
        /// Freezes the helper so it can prevents its configuration from being modified.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Will be called by &lt;c&gt;ShortStringHelperResolver&lt;/c&gt; when resolution freezes.&lt;/remarks&gt;
        public void Freeze()
        {
            _frozen = true;
        }

        // see notes for CleanAsciiString
        //// beware! the order is quite important here!
        //const string ValidStringCharactersSource = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
        //readonly static char[] ValidStringCharacters;

        private CultureInfo _defaultCulture = CultureInfo.InvariantCulture;
        private bool _frozen;
        private readonly Dictionary&lt;CultureInfo, Dictionary&lt;CleanStringType, Config&gt;&gt; _configs = new Dictionary&lt;CultureInfo, Dictionary&lt;CleanStringType, Config&gt;&gt;();

        // see notes for CleanAsciiString
        //static DefaultShortStringHelper()
        //{
        //    ValidStringCharacters = ValidStringCharactersSource.ToCharArray();
        //}

        #endregion

        #region Filters

        private readonly Dictionary&lt;string, string&gt; _urlReplaceCharacters = new Dictionary&lt;string, string&gt;();

        private void InitializeLegacyUrlReplaceCharacters()
        {
            foreach (var node in _umbracoSettings.RequestHandler.CharCollection)
            {
                if(string.IsNullOrEmpty(node.Char) == false)
                    _urlReplaceCharacters[node.Char] = node.Replacement;
            }
        }

        /// &lt;summary&gt;
        /// Returns a new string in which characters have been replaced according to the Umbraco settings UrlReplaceCharacters.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;s&quot;&gt;The string to filter.&lt;/param&gt;
        /// &lt;returns&gt;The filtered string.&lt;/returns&gt;
        public string ApplyUrlReplaceCharacters(string s)
        {
            return s.ReplaceMany(_urlReplaceCharacters);
        }

        // ok to be static here because it&#39;s not configureable in any way
        private static readonly char[] InvalidFileNameChars =
            Path.GetInvalidFileNameChars()
            .Union(&quot;!*&#39;();:@&amp;=+$,/?%#[]-~{}\&quot;&lt;&gt;\\^`| &quot;.ToCharArray())
            .Distinct()
            .ToArray();

        public static bool IsValidFileNameChar(char c)
        {
            return InvalidFileNameChars.Contains(c) == false;
        }

        public static string CutMaxLength(string text, int length)
        {
            return text.Length &lt;= length ? text : text.Substring(0, length);
        }

        #endregion

        #region Configuration

        private void EnsureNotFrozen()
        {
            if (_frozen)
                throw new InvalidOperationException(&quot;Cannot configure the helper once it is frozen.&quot;);            
        }

        /// &lt;summary&gt;
        /// Sets a default culture.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The default culture.&lt;/param&gt;
        /// &lt;returns&gt;The short string helper.&lt;/returns&gt;
        public DefaultShortStringHelper WithDefaultCulture(CultureInfo culture)
        {
            EnsureNotFrozen();
            _defaultCulture = culture;
            return this;
        }

        public DefaultShortStringHelper WithConfig(Config config)
        {
            return WithConfig(_defaultCulture, CleanStringType.RoleMask, config);
        }

        public DefaultShortStringHelper WithConfig(CleanStringType stringRole, Config config)
        {
            return WithConfig(_defaultCulture, stringRole, config);
        }

        public DefaultShortStringHelper WithConfig(CultureInfo culture, CleanStringType stringRole, Config config)
        {
            if (config == null)
                throw new ArgumentNullException(&quot;config&quot;);

            EnsureNotFrozen();
            if (_configs.ContainsKey(culture) == false)
                _configs[culture] = new Dictionary&lt;CleanStringType, Config&gt;();
            _configs[culture][stringRole] = config.Clone(); // clone so it can&#39;t be changed
            return this;
        }

        /// &lt;summary&gt;
        /// Sets the default configuration.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;The short string helper.&lt;/returns&gt;
        public DefaultShortStringHelper WithDefaultConfig()
        {
            return WithConfig(CleanStringType.UrlSegment, new Config
            {
                PreFilter = ApplyUrlReplaceCharacters,
                PostFilter = x =&gt; CutMaxLength(x, 240),
                IsTerm = (c, leading) =&gt; char.IsLetterOrDigit(c) || c == &#39;_&#39;, // letter, digit or underscore
                StringType = (_umbracoSettings.RequestHandler.ConvertUrlsToAscii ? CleanStringType.Ascii : CleanStringType.Utf8) | CleanStringType.LowerCase,
                BreakTermsOnUpper = false,
                Separator = &#39;-&#39;
            }).WithConfig(CleanStringType.FileName, new Config
            {
                PreFilter = ApplyUrlReplaceCharacters,
                IsTerm = (c, leading) =&gt; char.IsLetterOrDigit(c) || c == &#39;_&#39;, // letter, digit or underscore
                StringType = CleanStringType.Utf8 | CleanStringType.LowerCase,
                BreakTermsOnUpper = false,
                Separator = &#39;-&#39;
            }).WithConfig(CleanStringType.Alias, new Config
            {
                PreFilter = ApplyUrlReplaceCharacters,
                IsTerm = (c, leading) =&gt; leading 
                    ? char.IsLetter(c) // only letters
                    : (char.IsLetterOrDigit(c) || c == &#39;_&#39;), // letter, digit or underscore
                StringType = CleanStringType.Ascii | CleanStringType.UmbracoCase,
                BreakTermsOnUpper = false
            }).WithConfig(CleanStringType.UnderscoreAlias, new Config
            {
                PreFilter = ApplyUrlReplaceCharacters,
                IsTerm = (c, leading) =&gt; char.IsLetterOrDigit(c) || c == &#39;_&#39;, // letter, digit or underscore
                StringType = CleanStringType.Ascii | CleanStringType.UmbracoCase,
                BreakTermsOnUpper = false
            }).WithConfig(CleanStringType.ConvertCase, new Config
            {
                PreFilter = null,
                IsTerm = (c, leading) =&gt; char.IsLetterOrDigit(c) || c == &#39;_&#39;, // letter, digit or underscore
                StringType = CleanStringType.Ascii,
                BreakTermsOnUpper = true
            });
        }

        public sealed class Config
        {
            public Config()
            {
                StringType = CleanStringType.Utf8 | CleanStringType.Unchanged;
                PreFilter = null;
                PostFilter = null;
                IsTerm = (c, leading) =&gt; leading ? char.IsLetter(c) : char.IsLetterOrDigit(c);
                BreakTermsOnUpper = false;
                CutAcronymOnNonUpper = false;
                GreedyAcronyms = false;
                Separator = Char.MinValue;
            }

            public Config Clone()
            {
                return new Config
                {
                    PreFilter = PreFilter,
                    PostFilter =  PostFilter,
                    IsTerm = IsTerm,
                    StringType = StringType,
                    BreakTermsOnUpper = BreakTermsOnUpper,
                    CutAcronymOnNonUpper =  CutAcronymOnNonUpper,
                    GreedyAcronyms =  GreedyAcronyms,
                    Separator = Separator
                };
            }

            public Func&lt;string, string&gt; PreFilter { get; set; }
            public Func&lt;string, string&gt; PostFilter { get; set; }
            public Func&lt;char, bool, bool&gt; IsTerm { get; set; }

            public CleanStringType StringType { get; set; }

            // indicate whether an uppercase within a term eg &quot;fooBar&quot; is to break
            // into a new term, or to be considered as part of the current term
            public bool BreakTermsOnUpper { get; set; }

            // indicate whether a non-uppercase within an acronym eg &quot;FOOBar&quot; is to cut
            // the acronym (at &quot;B&quot; or &quot;a&quot; depending on GreedyAcronyms) or to give
            // up the acronym and treat the term as a word
            public bool CutAcronymOnNonUpper { get; set; }

            // indicates whether acronyms parsing is greedy ie whether &quot;FOObar&quot; is
            // &quot;FOO&quot; + &quot;bar&quot; (greedy) or &quot;FO&quot; + &quot;Obar&quot; (non-greedy)
            public bool GreedyAcronyms { get; set; }

            // the separator char
            // but then how can we tell we dont want any?
            public char Separator { get; set; }

            // extends the config
            public CleanStringType StringTypeExtend(CleanStringType stringType)
            {
                var st = StringType;
                foreach (var mask in new[] { CleanStringType.CaseMask, CleanStringType.CodeMask })
                {
                    var a = stringType &amp; mask;
                    if (a == 0) continue;

                    st = st &amp; ~mask; // clear what we have
                    st = st | a; // set the new value
                }
                return st;
            }

            internal static readonly Config NotConfigured = new Config();
        }

        private Config GetConfig(CleanStringType stringType, CultureInfo culture)
        {
            stringType = stringType &amp; CleanStringType.RoleMask;

            Dictionary&lt;CleanStringType, Config&gt; config;
            if (_configs.ContainsKey(culture))
            {
                config = _configs[culture];
                if (config.ContainsKey(stringType)) // have we got a config for _that_ role?
                    return config[stringType];
                if (config.ContainsKey(CleanStringType.RoleMask)) // have we got a generic config for _all_ roles?
                    return config[CleanStringType.RoleMask];
            }
            else if (_configs.ContainsKey(_defaultCulture))
            {
                config = _configs[_defaultCulture];
                if (config.ContainsKey(stringType)) // have we got a config for _that_ role?
                    return config[stringType];
                if (config.ContainsKey(CleanStringType.RoleMask)) // have we got a generic config for _all_ roles?
                    return config[CleanStringType.RoleMask];
            }

            return Config.NotConfigured;
        }

        #endregion

        #region JavaScript

        private const string SssjsFormat = @&quot;
var UMBRACO_FORCE_SAFE_ALIAS = {0};
var UMBRACO_FORCE_SAFE_ALIAS_URL = &#39;{1}&#39;;
var UMBRACO_FORCE_SAFE_ALIAS_TIMEOUT = 666;
var UMBRACO_FORCE_SAFE_ALIAS_TMKEY = &#39;safe-alias-tmout&#39;;

function getSafeAliasFromServer(value, callback) {{
    $.getJSON(UMBRACO_FORCE_SAFE_ALIAS_URL + &#39;ToSafeAlias?value=&#39; + encodeURIComponent(value), function(json) {{
        if (json.alias) {{ callback(json.alias); }}
    }});
}}

function getSafeAlias(input, value, immediate, callback) {{
    if (!UMBRACO_FORCE_SAFE_ALIAS) {{
        callback(value);
        return;
    }}
    var timeout = input.data(UMBRACO_FORCE_SAFE_ALIAS_TMKEY);
    if (timeout) clearTimeout(timeout);
    input.data(UMBRACO_FORCE_SAFE_ALIAS_TMKEY, setTimeout(function() {{
        input.removeData(UMBRACO_FORCE_SAFE_ALIAS_TMKEY);
        getSafeAliasFromServer(value, function(alias) {{ callback(alias); }});
    }}, UMBRACO_FORCE_SAFE_ALIAS_TIMEOUT));
}}

function validateSafeAlias(input, value, immediate, callback) {{
    if (!UMBRACO_FORCE_SAFE_ALIAS) {{
        callback(true);
        return;
    }}
    var timeout = input.data(UMBRACO_FORCE_SAFE_ALIAS_TMKEY);
    if (timeout) clearTimeout(timeout);
    input.data(UMBRACO_FORCE_SAFE_ALIAS_TMKEY, setTimeout(function() {{
        input.removeData(UMBRACO_FORCE_SAFE_ALIAS_TMKEY);
        getSafeAliasFromServer(value, function(alias) {{ callback(value.toLowerCase() == alias.toLowerCase()); }});
    }}, UMBRACO_FORCE_SAFE_ALIAS_TIMEOUT));
}}
&quot;;

        /// &lt;summary&gt;
        /// Gets the JavaScript code defining client-side short string services.
        /// &lt;/summary&gt;
        public string GetShortStringServicesJavaScript(string controllerPath)
        {
                return string.Format(SssjsFormat,
                    _umbracoSettings.Content.ForceSafeAliases ? &quot;true&quot; : &quot;false&quot;, controllerPath);
        }

        #endregion

        #region IShortStringHelper CleanFor...

        /// &lt;summary&gt;
        /// Cleans a string to produce a string that can safely be used in an alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe alias.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The string will be cleaned in the context of the default culture.&lt;/para&gt;
        /// &lt;para&gt;Safe aliases are Ascii only.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public virtual string CleanStringForSafeAlias(string text)
        {
            return CleanStringForSafeAlias(text, _defaultCulture);
        }

        /// &lt;summary&gt;
        /// Cleans a string, in the context of a specified culture, to produce a string that can safely be used in an alias.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The safe alias.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Safe aliases are Ascii only.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public virtual string CleanStringForSafeAlias(string text, CultureInfo culture)
        {
            return CleanString(text, CleanStringType.Alias, culture);
        }

        /// &lt;summary&gt;
        /// Cleans a string to produce a string that can safely be used in an url segment.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe url segment.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The string will be cleaned in the context of the default culture.&lt;/para&gt;
        /// &lt;para&gt;Url segments are Ascii only (no accents...).&lt;/para&gt;
        /// &lt;/remarks&gt;
        public virtual string CleanStringForUrlSegment(string text)
        {
            return CleanStringForUrlSegment(text, _defaultCulture);
        }

        /// &lt;summary&gt;
        /// Cleans a string, in the context of a specified culture, to produce a string that can safely be used in an url segment.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The safe url segment.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Url segments are Ascii only (no accents...).&lt;/para&gt;
        /// &lt;/remarks&gt;
        public virtual string CleanStringForUrlSegment(string text, CultureInfo culture)
        {
            return CleanString(text, CleanStringType.UrlSegment, culture);
        }

        /// &lt;summary&gt;
        /// Cleans a string, in the context of the default culture, to produce a string that can safely be used as a filename,
        /// both internally (on disk) and externally (as a url).
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;returns&gt;The safe filename.&lt;/returns&gt;
        /// &lt;remarks&gt;Legacy says this was used to &quot;overcome an issue when Umbraco is used in IE in an intranet environment&quot; but that issue is not documented.&lt;/remarks&gt;
        public virtual string CleanStringForSafeFileName(string text)
        {
            return CleanStringForSafeFileName(text, _defaultCulture);
        }

        /// &lt;summary&gt;
        /// Cleans a string to produce a string that can safely be used as a filename,
        /// both internally (on disk) and externally (as a url).
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to filter.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The safe filename.&lt;/returns&gt;
        public virtual string CleanStringForSafeFileName(string text, CultureInfo culture)
        {
            if (string.IsNullOrWhiteSpace(text))
                return string.Empty;

            text = text.ReplaceMany(Path.GetInvalidFileNameChars(), &#39;-&#39;);

            var name = Path.GetFileNameWithoutExtension(text);
            var ext = Path.GetExtension(text); // includes the dot, empty if no extension

            Debug.Assert(name != null, &quot;name != null&quot;);
            if (name.Length &gt; 0)
                name = CleanString(name, CleanStringType.FileName, culture);
            Debug.Assert(ext != null, &quot;ext != null&quot;);
            if (ext.Length &gt; 0)
                ext = CleanString(ext.Substring(1), CleanStringType.FileName, culture);

            return ext.Length &gt; 0 ? (name + &quot;.&quot; + ext) : name;
        }

        #endregion

        #region CleanString

        // MS rules &amp; guidelines:
        // - Do capitalize both characters of two-character acronyms, except the first word of a camel-cased identifier.
        //     eg &quot;DBRate&quot; (pascal) or &quot;ioHelper&quot; (camel) - &quot;SpecialDBRate&quot; (pascal) or &quot;specialIOHelper&quot; (camel)
        // - Do capitalize only the first character of acronyms with three or more characters, except the first word of a camel-cased identifier.
        //     eg &quot;XmlWriter (pascal) or &quot;htmlReader&quot; (camel) - &quot;SpecialXmlWriter&quot; (pascal) or &quot;specialHtmlReader&quot; (camel)
        // - Do not capitalize any of the characters of any acronyms, whatever their length, at the beginning of a camel-cased identifier.
        //     eg &quot;xmlWriter&quot; or &quot;dbWriter&quot; (camel)
        //
        // Our additional stuff:
        // - Leading digits are removed.
        // - Many consecutive separators are folded into one unique separator.

        const byte StateBreak = 1;
        const byte StateUp = 2;
        const byte StateWord = 3;
        const byte StateAcronym = 4;

        /// &lt;summary&gt;
        /// Cleans a string.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to clean.&lt;/param&gt;
        /// &lt;param name=&quot;stringType&quot;&gt;A flag indicating the target casing and encoding of the string. By default, 
        /// strings are cleaned up to camelCase and Ascii.&lt;/param&gt;
        /// &lt;returns&gt;The clean string.&lt;/returns&gt;
        /// &lt;remarks&gt;The string is cleaned in the context of the default culture.&lt;/remarks&gt;
        public string CleanString(string text, CleanStringType stringType)
        {
            return CleanString(text, stringType, _defaultCulture, null);
        }

        /// &lt;summary&gt;
        /// Cleans a string, using a specified separator.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to clean.&lt;/param&gt;
        /// &lt;param name=&quot;stringType&quot;&gt;A flag indicating the target casing and encoding of the string. By default, 
        /// strings are cleaned up to camelCase and Ascii.&lt;/param&gt;
        /// &lt;param name=&quot;separator&quot;&gt;The separator.&lt;/param&gt;
        /// &lt;returns&gt;The clean string.&lt;/returns&gt;
        /// &lt;remarks&gt;The string is cleaned in the context of the default culture.&lt;/remarks&gt;
        public string CleanString(string text, CleanStringType stringType, char separator)
        {
            return CleanString(text, stringType, _defaultCulture, separator);
        }

        /// &lt;summary&gt;
        /// Cleans a string in the context of a specified culture.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to clean.&lt;/param&gt;
        /// &lt;param name=&quot;stringType&quot;&gt;A flag indicating the target casing and encoding of the string. By default, 
        /// strings are cleaned up to camelCase and Ascii.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The clean string.&lt;/returns&gt;
        public string CleanString(string text, CleanStringType stringType, CultureInfo culture)
        {
            return CleanString(text, stringType, culture, null);
        }

        /// &lt;summary&gt;
        /// Cleans a string in the context of a specified culture, using a specified separator.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to clean.&lt;/param&gt;
        /// &lt;param name=&quot;stringType&quot;&gt;A flag indicating the target casing and encoding of the string. By default, 
        /// strings are cleaned up to camelCase and Ascii.&lt;/param&gt;
        /// &lt;param name=&quot;separator&quot;&gt;The separator.&lt;/param&gt;
        /// &lt;param name=&quot;culture&quot;&gt;The culture.&lt;/param&gt;
        /// &lt;returns&gt;The clean string.&lt;/returns&gt;
        public string CleanString(string text, CleanStringType stringType, char separator, CultureInfo culture)
        {
            return CleanString(text, stringType, culture, separator);
        }

        protected virtual string CleanString(string text, CleanStringType stringType, CultureInfo culture, char? separator)
        {
            // be safe
            if (text == null)
                throw new ArgumentNullException(&quot;text&quot;);
            if (culture == null)
                throw new ArgumentNullException(&quot;culture&quot;);

            // get config
            var config = GetConfig(stringType, culture);
            stringType = config.StringTypeExtend(stringType);

            // apply defaults
            if ((stringType &amp; CleanStringType.CaseMask) == CleanStringType.None)
                stringType |= CleanStringType.CamelCase;
            if ((stringType &amp; CleanStringType.CodeMask) == CleanStringType.None)
                stringType |= CleanStringType.Ascii;

            // use configured unless specified
            separator = separator ?? config.Separator;

            // apply pre-filter
            if (config.PreFilter != null)
                text = config.PreFilter(text);

            // apply replacements
            //if (config.Replacements != null)
            //    text = ReplaceMany(text, config.Replacements);

            // recode
            var codeType = stringType &amp; CleanStringType.CodeMask;
            text = codeType == CleanStringType.Ascii 
                ? Utf8ToAsciiConverter.ToAsciiString(text) 
                : RemoveSurrogatePairs(text);

            // clean
            text = CleanCodeString(text, stringType, separator.Value, culture, config);

            // apply post-filter
            if (config.PostFilter != null)
                text = config.PostFilter(text);
            
            return text;
        }

        private static string RemoveSurrogatePairs(string text)
        {
            var input = text.ToCharArray();
            var output = new char[input.Length];
            var opos = 0;

            for (var ipos = 0; ipos &lt; input.Length; ipos++)
            {
                var c = input[ipos];
                if (char.IsSurrogate(c)) // ignore high surrogate
                {
                    ipos++; // and skip low surrogate
                    output[opos++] = &#39;?&#39;;
                }
                else
                {
                    output[opos++] = c;
                }
            }

            return new string(output, 0, opos);
        }

        // here was a subtle, ascii-optimized version of the cleaning code, and I was
        // very proud of it until benchmarking showed it was an order of magnitude slower
        // that the utf8 version. Micro-optimizing sometimes isn&#39;t such a good idea.

        // note: does NOT support surrogate pairs in text
        internal string CleanCodeString(string text, CleanStringType caseType, char separator, CultureInfo culture, Config config)
        {
            int opos = 0, ipos = 0;
            var state = StateBreak;

            caseType &amp;= CleanStringType.CaseMask;

            // if we apply global ToUpper or ToLower to text here
            // then we cannot break words on uppercase chars
            var input = text;

            // it&#39;s faster to use an array than a StringBuilder
            var ilen = input.Length;
            var output = new char[ilen * 2]; // twice the length should be OK in all cases

            for (var i = 0; i &lt; ilen; i++)
            {
                var c = input[i];
                // leading as long as StateBreak and ipos still zero
                var leading = state == StateBreak &amp;&amp; ipos == 0;
                var isTerm = config.IsTerm(c, leading);

                //var isDigit = char.IsDigit(c);
                var isUpper = char.IsUpper(c); // false for digits, symbols...
                //var isLower = char.IsLower(c); // false for digits, symbols...

                // what should I do with surrogates?
                // no idea, really, so they are not supported at the moment
                var isPair = char.IsSurrogate(c);
                if (isPair)
                    throw new NotSupportedException(&quot;Surrogate pairs are not supported.&quot;);

                switch (state)
                {
                    // within a break
                    case StateBreak:
                        // begin a new term if char is a term char,
                        // and ( pos &gt; 0 or it&#39;s also a valid leading char )
                        if (isTerm)
                        {
                            ipos = i;
                            if (opos &gt; 0 &amp;&amp; separator != char.MinValue)
                                output[opos++] = separator;
                            state = isUpper ? StateUp : StateWord;
                        }
                        break;

                    // within a term / word
                    case StateWord:
                        // end a term if char is not a term char,
                        // or ( it&#39;s uppercase and we break terms on uppercase)
                        if (isTerm == false || (config.BreakTermsOnUpper &amp;&amp; isUpper))
                        {
                            CopyTerm(input, ipos, output, ref opos, i - ipos, caseType, culture, false);
                            ipos = i;
                            state = isTerm ? StateUp : StateBreak;
                            if (state != StateBreak &amp;&amp; separator != char.MinValue)
                                output[opos++] = separator;
                        }
                        break;

                    // within a term / acronym
                    case StateAcronym:
                        // end an acronym if char is not a term char,
                        // or if it&#39;s not uppercase / config
                        if (isTerm == false || (config.CutAcronymOnNonUpper &amp;&amp; isUpper == false))
                        {
                            // whether it&#39;s part of the acronym depends on whether we&#39;re greedy
                            if (isTerm &amp;&amp; config.GreedyAcronyms == false)
                                i -= 1; // handle that char again, in another state - not part of the acronym
                            if (i - ipos &gt; 1) // single-char can&#39;t be an acronym
                            {
                                CopyTerm(input, ipos, output, ref opos, i - ipos, caseType, culture, true);
                                ipos = i;
                                state = isTerm ? StateWord : StateBreak;
                                if (state != StateBreak &amp;&amp; separator != char.MinValue)
                                    output[opos++] = separator;
                            }
                            else if (isTerm)
                            {
                                state = StateWord;
                            }
                        }
                        else if (isUpper == false) // isTerm == true
                        {
                            // it&#39;s a term char and we don&#39;t cut...
                            // keep moving forward as a word
                            state = StateWord;
                        }
                        break;

                    // within a term / uppercase = could be a word or an acronym
                    case StateUp:
                        if (isTerm)
                        {
                            // add that char to the term and pick word or acronym
                            state = isUpper ? StateAcronym : StateWord;
                        }
                        else
                        {
                            // single char, copy then break
                            CopyTerm(input, ipos, output, ref opos, 1, caseType, culture, false);
                            state = StateBreak;
                        }
                        break;

                    default:
                        throw new Exception(&quot;Invalid state.&quot;);
                }
            }

            switch (state)
            {
                case StateBreak:
                    break;

                case StateWord:
                    CopyTerm(input, ipos, output, ref opos, input.Length - ipos, caseType, culture, false);
                    break;

                case StateAcronym:
                case StateUp:
                    CopyTerm(input, ipos, output, ref opos, input.Length - ipos, caseType, culture, true);
                    break;

                default:
                    throw new Exception(&quot;Invalid state.&quot;);
            }

            return new string(output, 0, opos);
        }

        // note: supports surrogate pairs in input string
        internal void CopyTerm(string input, int ipos, char[] output, ref int opos, int len,
            CleanStringType caseType, CultureInfo culture, bool isAcronym)
        {
            var term = input.Substring(ipos, len);

            if (isAcronym)
            {
                if ((caseType == CleanStringType.CamelCase &amp;&amp; len &lt;= 2 &amp;&amp; opos &gt; 0) ||
                        (caseType == CleanStringType.PascalCase &amp;&amp; len &lt;= 2) ||
                        (caseType == CleanStringType.UmbracoCase))
                    caseType = CleanStringType.Unchanged;
            }

            // note: MSDN seems to imply that ToUpper or ToLower preserve the length
            // of the string, but that this behavior is not guaranteed and could change.

            char c;
            int i;
            string s;
            switch (caseType)
            {
                //case CleanStringType.LowerCase:
                //case CleanStringType.UpperCase:
                case CleanStringType.Unchanged:
                    term.CopyTo(0, output, opos, len);
                    opos += len;
                    break;

                case CleanStringType.LowerCase:
                    term = term.ToLower(culture);
                    term.CopyTo(0, output, opos, term.Length);
                    opos += term.Length;
                    break;

                case CleanStringType.UpperCase:
                    term = term.ToUpper(culture);
                    term.CopyTo(0, output, opos, term.Length);
                    opos += term.Length;
                    break;

                case CleanStringType.CamelCase:
                    c = term[0];
                    i = 1;
                    if (char.IsSurrogate(c))
                    {
                        s = term.Substring(ipos, 2);
                        s = opos == 0 ? s.ToLower(culture) : s.ToUpper(culture);
                        s.CopyTo(0, output, opos, s.Length);
                        opos += s.Length;
                        i++; // surrogate pair len is 2
                    }
                    else
                    {
                        output[opos] = opos++ == 0 ? char.ToLower(c, culture) : char.ToUpper(c, culture);
                    }
                    if (len &gt; i)
                    {
                        term = term.Substring(i).ToLower(culture);
                        term.CopyTo(0, output, opos, term.Length);
                        opos += term.Length;
                    }
                    break;

                case CleanStringType.PascalCase:
                    c = term[0];
                    i = 1;
                    if (char.IsSurrogate(c))
                    {
                        s = term.Substring(ipos, 2);
                        s = s.ToUpper(culture);
                        s.CopyTo(0, output, opos, s.Length);
                        opos += s.Length;
                        i++; // surrogate pair len is 2
                    }
                    else
                    {
                        output[opos++] = char.ToUpper(c, culture);
                    }
                    if (len &gt; i)
                    {
                        term = term.Substring(i).ToLower(culture);
                        term.CopyTo(0, output, opos, term.Length);
                        opos += term.Length;
                    }
                    break;

                case CleanStringType.UmbracoCase:
                    c = term[0];
                    i = 1;
                    if (char.IsSurrogate(c))
                    {
                        s = term.Substring(ipos, 2);
                        s = opos == 0 ? s : s.ToUpper(culture);
                        s.CopyTo(0, output, opos, s.Length);
                        opos += s.Length;
                        i++; // surrogate pair len is 2
                    }
                    else
                    {
                        output[opos] = opos++ == 0 ? c : char.ToUpper(c, culture);
                    }
                    if (len &gt; i)
                    {
                        term = term.Substring(i);
                        term.CopyTo(0, output, opos, term.Length);
                        opos += term.Length;                        
                    }
                    break;

                default:
                    throw new ArgumentOutOfRangeException(&quot;caseType&quot;);
            }
        }

        #endregion

        #region SplitPascalCasing

        /// &lt;summary&gt;
        /// Splits a Pascal-cased string into a phrase separated by a separator.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The text to split.&lt;/param&gt;
        /// &lt;param name=&quot;separator&quot;&gt;The separator, which defaults to a whitespace.&lt;/param&gt;
        /// &lt;returns&gt;The splitted text.&lt;/returns&gt;
        /// &lt;remarks&gt;Supports Utf8 and Ascii strings, not Unicode strings.&lt;/remarks&gt;
        // NOTE does not support surrogates pairs at the moment
        public virtual string SplitPascalCasing(string text, char separator)
        {
            // be safe
            if (text == null)
                throw new ArgumentNullException(&quot;text&quot;);

            var input = text.ToCharArray();
            var output = new char[input.Length * 2];
            var opos = 0;
            var a = input.Length &gt; 0 ? input[0] : char.MinValue;
            var upos = char.IsUpper(a) ? 1 : 0;

            for (var i = 1; i &lt; input.Length; i++)
            {
                var c = input[i];
                if (char.IsUpper(c))
                {
                    output[opos++] = a;
                    if (upos == 0)
                    {
                        if (opos &gt; 0)
                            output[opos++] = separator;
                        upos = i + 1;
                    }
                }
                else
                {
                    if (upos &gt; 0)
                    {
                        if (upos &lt; i &amp;&amp; opos &gt; 0)
                            output[opos++] = separator;
                        upos = 0;
                    }
                    output[opos++] = a;
                }
                a = c;
            }
            if (a != char.MinValue)
                output[opos++] = a;
            return new string(output, 0, opos);
        }

        #endregion

        #region ReplaceMany

        /// &lt;summary&gt;
        /// Returns a new string in which all occurences of specified strings are replaced by other specified strings.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The string to filter.&lt;/param&gt;
        /// &lt;param name=&quot;replacements&quot;&gt;The replacements definition.&lt;/param&gt;
        /// &lt;returns&gt;The filtered string.&lt;/returns&gt;
        public virtual string ReplaceMany(string text, IDictionary&lt;string, string&gt; replacements)
        {
            // be safe
            if (text == null)
                throw new ArgumentNullException(&quot;text&quot;);
            if (replacements == null)
                throw new ArgumentNullException(&quot;replacements&quot;);

            // Have done various tests, implementing my own &quot;super fast&quot; state machine to handle 
            // replacement of many items, or via regexes, but on short strings and not too
            // many replacements (which prob. is going to be our case) nothing can beat this...
            // (at least with safe and checked code -- we don&#39;t want unsafe/unchecked here)

            // Note that it will do chained-replacements ie replaced items can be replaced
            // in turn by another replacement (ie the order of replacements is important)

            return replacements.Aggregate(text, (current, kvp) =&gt; current.Replace(kvp.Key, kvp.Value));
        }

        /// &lt;summary&gt;
        /// Returns a new string in which all occurences of specified characters are replaced by a specified character.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;The string to filter.&lt;/param&gt;
        /// &lt;param name=&quot;chars&quot;&gt;The characters to replace.&lt;/param&gt;
        /// &lt;param name=&quot;replacement&quot;&gt;The replacement character.&lt;/param&gt;
        /// &lt;returns&gt;The filtered string.&lt;/returns&gt;
        public virtual string ReplaceMany(string text, char[] chars, char replacement)
        {
            // be safe
            if (text == null)
                throw new ArgumentNullException(&quot;text&quot;);
            if (chars == null)
                throw new ArgumentNullException(&quot;chars&quot;);

            // see note above

            return chars.Aggregate(text, (current, c) =&gt; current.Replace(c, replacement));
        }

        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[27,9,27,42,0],[28,9,28,10,0],[29,13,29,49,0],[30,13,30,52,0],[31,9,31,10,0],[33,9,33,81,1],[34,9,34,10,1],[35,13,35,48,1],[36,13,36,52,1],[37,9,37,10,1],[44,9,44,10,1],[45,13,45,28,1],[46,9,46,10,1],[53,9,53,76,1],[53,9,53,76,0],[55,9,55,165,1],[55,9,55,165,0],[67,9,67,110,1],[67,9,67,110,0],[70,9,70,10,1],[71,13,71,20,1],[71,22,71,30,1],[71,31,71,33,1],[71,34,71,80,1],[72,13,72,14,1],[73,17,73,61,1],[74,21,74,73,1],[75,13,75,14,1],[76,9,76,10,1],[84,9,84,10,1],[85,13,85,57,1],[86,9,86,10,1],[89,9,93,24,1],[96,9,96,10,1],[97,13,97,62,1],[98,9,98,10,1],[101,9,101,10,1],[102,13,102,77,1],[103,9,103,10,1],[110,9,110,10,1],[111,13,111,25,1],[112,17,112,103,0],[113,9,113,10,1],[121,9,121,10,0],[122,13,122,31,0],[123,13,123,39,0],[124,13,124,25,0],[125,9,125,10,0],[128,9,128,10,0],[129,13,129,82,0],[130,9,130,10,0],[133,9,133,10,1],[134,13,134,68,1],[135,9,135,10,1],[138,9,138,10,1],[139,13,139,32,1],[140,17,140,59,0],[142,13,142,31,1],[143,13,143,56,1],[144,17,144,79,1],[145,13,145,60,1],[146,13,146,25,1],[147,9,147,10,1],[154,9,154,10,1],[155,13,158,35,1],[158,35,158,55,1],[158,55,159,42,1],[159,42,159,77,1],[159,77,166,42,1],[166,42,166,77,1],[166,77,173,42,1],[173,42,175,60,1],[175,60,181,42,1],[181,42,181,77,1],[181,77,187,42,1],[187,42,187,77,1],[187,77,190,16,1],[155,13,190,16,1],[191,9,191,10,1],[195,13,195,28,1],[196,13,196,14,1],[197,17,197,79,1],[198,17,198,34,1],[199,17,199,35,1],[200,17,200,42,1],[200,42,200,94,1],[200,94,200,95,1],[200,17,200,95,1],[201,17,201,43,1],[202,17,202,46,1],[203,17,203,40,1],[204,17,204,43,1],[205,13,205,14,1],[208,13,208,14,1],[209,17,219,19,1],[220,13,220,14,1],[222,53,222,57,1],[222,58,222,62,1],[223,54,223,58,1],[223,59,223,63,1],[224,52,224,56,1],[224,57,224,61,1],[226,49,226,53,1],[226,54,226,58,1],[230,45,230,49,1],[230,50,230,54,1],[235,48,235,52,1],[235,53,235,57,1],[239,42,239,46,1],[239,47,239,51,1],[243,37,243,41,1],[243,42,243,46,1],[247,13,247,14,1],[248,17,248,37,1],[249,17,249,24,1],[249,26,249,34,1],[249,35,249,37,1],[249,38,249,98,1],[250,17,250,18,1],[251,21,251,47,1],[252,21,252,32,1],[252,33,252,42,1],[254,21,254,37,1],[255,21,255,33,1],[256,17,256,18,1],[257,17,257,27,1],[258,13,258,14,1],[260,13,260,74,1],[264,9,264,10,1],[265,13,265,64,1],[268,13,268,47,1],[269,13,269,14,1],[270,17,270,44,1],[271,17,271,52,1],[272,21,272,47,1],[273,17,273,66,0],[274,21,274,61,0],[275,13,275,14,0],[276,18,276,60,1],[277,13,277,14,0],[278,17,278,52,0],[279,17,279,52,0],[280,21,280,47,0],[281,17,281,66,0],[282,21,282,61,0],[283,13,283,14,0],[285,13,285,41,1],[286,9,286,10,1],[335,9,335,10,0],[336,17,337,99,0],[338,9,338,10,0],[354,9,354,10,1],[355,13,355,67,1],[356,9,356,10,1],[368,9,368,10,1],[369,13,369,70,1],[370,9,370,10,1],[382,9,382,10,1],[383,13,383,68,1],[384,9,384,10,1],[396,9,396,10,1],[397,13,397,75,1],[398,9,398,10,1],[408,9,408,10,1],[409,13,409,70,1],[410,9,410,10,1],[420,9,420,10,1],[421,13,421,49,1],[422,17,422,37,0],[424,13,424,74,1],[426,13,426,63,1],[427,13,427,47,1],[429,13,429,56,1],[430,13,430,33,1],[431,17,431,77,1],[432,13,432,54,1],[433,13,433,32,1],[434,17,434,88,1],[436,13,436,63,1],[437,9,437,10,1],[469,9,469,10,1],[470,13,470,73,1],[471,9,471,10,1],[483,9,483,10,0],[484,13,484,78,0],[485,9,485,10,0],[496,9,496,10,1],[497,13,497,65,1],[498,9,498,10,1],[510,9,510,10,0],[511,13,511,70,0],[512,9,512,10,0],[515,9,515,10,1],[517,13,517,30,1],[518,17,518,57,0],[519,13,519,33,1],[520,17,520,60,0],[523,13,523,57,1],[524,13,524,62,1],[527,13,527,81,1],[528,17,528,57,0],[529,13,529,81,1],[530,17,530,53,0],[533,13,533,55,1],[536,13,536,42,1],[537,17,537,47,1],[544,13,544,66,1],[545,13,547,46,1],[550,13,550,88,1],[553,13,553,43,1],[554,17,554,48,1],[556,13,556,25,1],[557,9,557,10,1],[560,9,560,10,1],[561,13,561,44,1],[562,13,562,49,1],[563,13,563,26,1],[565,18,565,30,1],[565,32,565,51,1],[565,53,565,59,1],[566,13,566,14,1],[567,17,567,37,1],[568,17,568,41,1],[569,17,569,18,0],[570,21,570,28,0],[571,21,571,42,0],[572,17,572,18,0],[574,17,574,18,1],[575,21,575,40,1],[576,17,576,18,1],[577,13,577,14,1],[579,13,579,48,1],[580,9,580,10,1],[588,9,588,10,1],[589,13,589,25,1],[589,27,589,35,1],[590,13,590,36,1],[592,13,592,50,1],[596,13,596,30,1],[599,13,599,37,1],[600,13,600,45,1],[602,18,602,27,1],[602,29,602,37,1],[602,39,602,42,1],[603,13,603,14,1],[604,17,604,34,1],[606,17,606,64,1],[607,17,607,56,1],[610,17,610,47,1],[615,17,615,50,1],[616,17,616,28,1],[617,21,617,91,0],[619,17,619,31,1],[625,25,625,36,1],[626,25,626,26,1],[627,29,627,38,1],[628,29,628,72,1],[629,33,629,60,1],[630,29,630,67,1],[631,25,631,26,1],[632,25,632,31,1],[638,25,638,86,1],[639,25,639,26,1],[640,29,640,105,1],[641,29,641,38,1],[642,29,642,67,1],[643,29,643,83,1],[644,33,644,60,1],[645,25,645,26,1],[646,25,646,31,1],[652,25,652,98,1],[653,25,653,26,1],[655,29,655,74,1],[656,33,656,40,1],[657,29,657,46,1],[658,29,658,30,1],[659,33,659,108,1],[660,33,660,42,1],[661,33,661,73,1],[662,33,662,87,1],[663,37,663,64,1],[664,29,664,30,1],[665,34,665,45,1],[666,29,666,30,1],[667,33,667,51,1],[668,29,668,30,1],[669,25,669,26,1],[670,30,670,51,1],[671,25,671,26,1],[674,29,674,47,1],[675,25,675,26,1],[676,25,676,31,1],[680,25,680,36,1],[681,25,681,26,1],[683,29,683,72,1],[684,25,684,26,1],[686,25,686,26,1],[688,29,688,98,1],[689,29,689,48,1],[690,25,690,26,1],[691,25,691,31,1],[694,25,694,63,0],[696,13,696,14,1],[698,13,698,27,1],[701,21,701,27,1],[704,21,704,108,1],[705,21,705,27,1],[709,21,709,107,1],[710,21,710,27,1],[713,21,713,59,0],[716,13,716,48,1],[717,9,717,10,1],[722,9,722,10,1],[723,13,723,51,1],[725,13,725,27,1],[726,13,726,14,1],[727,17,729,67,1],[730,21,730,58,1],[731,13,731,14,1],[739,13,739,30,1],[744,21,744,55,1],[745,21,745,33,1],[746,21,746,27,1],[749,21,749,50,1],[750,21,750,63,1],[751,21,751,41,1],[752,21,752,27,1],[755,21,755,50,1],[756,21,756,63,1],[757,21,757,41,1],[758,21,758,27,1],[761,21,761,33,1],[762,21,762,27,1],[763,21,763,45,1],[764,21,764,22,0],[765,25,765,53,0],[766,25,766,81,0],[767,25,767,61,0],[768,25,768,42,0],[769,25,769,29,0],[770,21,770,22,0],[772,21,772,22,1],[773,25,773,106,1],[774,21,774,22,1],[775,21,775,33,1],[776,21,776,22,1],[777,25,777,67,1],[778,25,778,67,1],[779,25,779,45,1],[780,21,780,22,1],[781,21,781,27,1],[784,21,784,33,1],[785,21,785,27,1],[786,21,786,45,1],[787,21,787,22,0],[788,25,788,53,0],[789,25,789,48,0],[790,25,790,61,0],[791,25,791,42,0],[792,25,792,29,0],[793,21,793,22,0],[795,21,795,22,1],[796,25,796,67,1],[797,21,797,22,1],[798,21,798,33,1],[799,21,799,22,1],[800,25,800,67,1],[801,25,801,67,1],[802,25,802,45,1],[803,21,803,22,1],[804,21,804,27,1],[807,21,807,33,1],[808,21,808,27,1],[809,21,809,45,1],[810,21,810,22,0],[811,25,811,53,0],[812,25,812,64,0],[813,25,813,61,0],[814,25,814,42,0],[815,25,815,29,0],[816,21,816,22,0],[818,21,818,22,1],[819,25,819,83,1],[820,21,820,22,1],[821,21,821,33,1],[822,21,822,22,1],[823,25,823,50,1],[824,25,824,67,1],[825,25,825,45,1],[826,21,826,22,1],[827,21,827,27,1],[830,21,830,71,0],[832,9,832,10,1],[847,9,847,10,1],[849,13,849,30,1],[850,17,850,57,0],[852,13,852,44,1],[853,13,853,53,1],[854,13,854,26,1],[855,13,855,65,1],[856,13,856,48,1],[858,18,858,27,1],[858,29,858,45,1],[858,47,858,50,1],[859,13,859,14,1],[860,17,860,34,1],[861,17,861,37,1],[862,17,862,18,1],[863,21,863,40,1],[864,21,864,35,1],[865,21,865,22,1],[866,25,866,38,1],[867,29,867,56,1],[868,25,868,38,1],[869,21,869,22,1],[870,17,870,18,1],[872,17,872,18,1],[873,21,873,34,1],[874,21,874,22,1],[875,25,875,50,1],[876,29,876,56,1],[877,25,877,34,1],[878,21,878,22,1],[879,21,879,40,1],[880,17,880,18,1],[881,17,881,23,1],[882,13,882,14,1],[883,13,883,36,1],[884,17,884,36,1],[885,13,885,48,1],[886,9,886,10,1],[899,9,899,10,1],[901,13,901,30,1],[902,17,902,57,0],[903,13,903,38,1],[904,17,904,65,0],[914,13,914,67,1],[914,67,914,102,1],[914,102,914,104,1],[914,13,914,104,1],[915,9,915,10,1],[925,9,925,10,1],[927,13,927,30,1],[928,17,928,57,0],[929,13,929,31,1],[930,17,930,58,0],[934,13,934,58,1],[934,58,934,89,1],[934,89,934,91,1],[934,13,934,91,1],[935,9,935,10,1]]);
    </script>
  </body>
</html>