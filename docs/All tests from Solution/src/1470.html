<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\Tom Pipe\Documents\Hexadigital\Code\Umbraco\Umbraco-CMS\src\Umbraco.Core\ObjectResolution\LazyManyObjectsResolverBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Web;
using Umbraco.Core.Logging;

namespace Umbraco.Core.ObjectResolution
{
    /// &lt;summary&gt;
    /// The base class for all lazy many-objects resolvers.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TResolver&quot;&gt;The type of the concrete resolver class.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TResolved&quot;&gt;The type of the resolved objects.&lt;/typeparam&gt;
    /// &lt;remarks&gt;
    /// &lt;para&gt;This is a special case resolver for when types get lazily resolved in order to resolve the actual types. This is useful
    /// for when there is some processing overhead (i.e. Type finding in assemblies) to return the Types used to instantiate the instances. 
    /// In some these cases we don&#39;t want to have to type-find during application startup, only when we need to resolve the instances.&lt;/para&gt;
    /// &lt;para&gt;Important notes about this resolver: it does not support Insert or Remove and therefore does not support any ordering unless 
    /// the types are marked with the WeightAttribute.&lt;/para&gt;
    /// &lt;/remarks&gt;
    public abstract class LazyManyObjectsResolverBase&lt;TResolver, TResolved&gt; : ManyObjectsResolverBase&lt;TResolver, TResolved&gt;
        where TResolved : class
        where TResolver : ResolverBase
    {
        #region Constructors

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;ManyObjectsResolverBase{TResolver, TResolved}&quot;/&gt; class with an empty list of objects,
        /// and an optional lifetime scope.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;serviceProvider&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;logger&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;scope&quot;&gt;The lifetime scope of instantiated objects, default is per Application.&lt;/param&gt;
        /// &lt;remarks&gt;If &lt;paramref name=&quot;scope&quot;/&gt; is per HttpRequest then there must be a current HttpContext.&lt;/remarks&gt;
        /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;&lt;paramref name=&quot;scope&quot;/&gt; is per HttpRequest but the current HttpContext is null.&lt;/exception&gt;
        protected LazyManyObjectsResolverBase(IServiceProvider serviceProvider, ILogger logger, ObjectLifetimeScope scope = ObjectLifetimeScope.Application)
            : base(serviceProvider, logger, scope)
        {
            Initialize();
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        [Obsolete(&quot;Use ctor specifying IServiceProvider instead&quot;)]
        protected LazyManyObjectsResolverBase(ObjectLifetimeScope scope = ObjectLifetimeScope.Application)
            : base(scope)
        {
            Initialize();
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        [Obsolete(&quot;Use ctor specifying IServiceProvider instead&quot;)]
        protected LazyManyObjectsResolverBase(HttpContextBase httpContext)
            : base(httpContext)
        {
            Initialize();
        }

        protected LazyManyObjectsResolverBase(IServiceProvider serviceProvider, ILogger logger, IEnumerable&lt;Lazy&lt;Type&gt;&gt; lazyTypeList, ObjectLifetimeScope scope = ObjectLifetimeScope.Application)
            : this(serviceProvider, logger, scope)
        {
            AddTypes(lazyTypeList);
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        [Obsolete(&quot;Use ctor specifying IServiceProvider instead&quot;)]
        protected LazyManyObjectsResolverBase(IEnumerable&lt;Lazy&lt;Type&gt;&gt; lazyTypeList, ObjectLifetimeScope scope = ObjectLifetimeScope.Application)
            : this(new ActivatorServiceProvider(), LoggerResolver.Current.Logger, lazyTypeList, scope)
        {
        }

        protected LazyManyObjectsResolverBase(IServiceProvider serviceProvider, ILogger logger, Func&lt;IEnumerable&lt;Type&gt;&gt; typeListProducerList, ObjectLifetimeScope scope = ObjectLifetimeScope.Application)
            : this(serviceProvider, logger, scope)
        {
            _typeListProducerList.Add(typeListProducerList);
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        [Obsolete(&quot;Use ctor specifying IServiceProvider instead&quot;)]
        protected LazyManyObjectsResolverBase(Func&lt;IEnumerable&lt;Type&gt;&gt; typeListProducerList, ObjectLifetimeScope scope = ObjectLifetimeScope.Application)
            : this(new ActivatorServiceProvider(), LoggerResolver.Current.Logger, typeListProducerList, scope)
        {
        }

        protected LazyManyObjectsResolverBase(IServiceProvider serviceProvider, ILogger logger, HttpContextBase httpContext, IEnumerable&lt;Lazy&lt;Type&gt;&gt; lazyTypeList)
            : this(serviceProvider, logger, httpContext)
        {
            AddTypes(lazyTypeList);
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        [Obsolete(&quot;Use ctor specifying IServiceProvider instead&quot;)]
        protected LazyManyObjectsResolverBase(HttpContextBase httpContext, IEnumerable&lt;Lazy&lt;Type&gt;&gt; lazyTypeList)
            : this(new ActivatorServiceProvider(), LoggerResolver.Current.Logger, httpContext, lazyTypeList)
        {
        }

        protected LazyManyObjectsResolverBase(IServiceProvider serviceProvider, ILogger logger, HttpContextBase httpContext, Func&lt;IEnumerable&lt;Type&gt;&gt; typeListProducerList)
            : this(serviceProvider, logger, httpContext)
        {
            _typeListProducerList.Add(typeListProducerList);
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        [Obsolete(&quot;Use ctor specifying IServiceProvider instead&quot;)]
        protected LazyManyObjectsResolverBase(HttpContextBase httpContext, Func&lt;IEnumerable&lt;Type&gt;&gt; typeListProducerList)
            : this(new ActivatorServiceProvider(), LoggerResolver.Current.Logger, httpContext, typeListProducerList)
        {
        }

        #endregion

        private readonly List&lt;Lazy&lt;Type&gt;&gt; _lazyTypeList = new List&lt;Lazy&lt;Type&gt;&gt;();
        private readonly List&lt;Func&lt;IEnumerable&lt;Type&gt;&gt;&gt; _typeListProducerList = new List&lt;Func&lt;IEnumerable&lt;Type&gt;&gt;&gt;();
        private readonly List&lt;Type&gt; _excludedTypesList = new List&lt;Type&gt;();
        private Lazy&lt;List&lt;Type&gt;&gt; _resolvedTypes;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;ManyObjectsResolverBase{TResolver, TResolved}&quot;/&gt; class with an empty list of objects,
        /// with creation of objects based on an HttpRequest lifetime scope.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;serviceProvider&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;logger&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;httpContext&quot;&gt;The HttpContextBase corresponding to the HttpRequest.&lt;/param&gt;
        /// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;&lt;paramref name=&quot;httpContext&quot;/&gt; is &lt;c&gt;null&lt;/c&gt;.&lt;/exception&gt;
        protected LazyManyObjectsResolverBase(IServiceProvider serviceProvider, ILogger logger, HttpContextBase httpContext)
            : base(serviceProvider, logger, httpContext)
        {
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;ManyObjectsResolverBase{TResolver, TResolved}&quot;/&gt; class with an initial list of object types,
        /// and an optional lifetime scope.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;serviceProvider&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;logger&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;value&quot;&gt;The list of object types.&lt;/param&gt;
        /// &lt;param name=&quot;scope&quot;&gt;The lifetime scope of instantiated objects, default is per Application.&lt;/param&gt;
        /// &lt;remarks&gt;If &lt;paramref name=&quot;scope&quot;/&gt; is per HttpRequest then there must be a current HttpContext.&lt;/remarks&gt;
        /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;&lt;paramref name=&quot;scope&quot;/&gt; is per HttpRequest but the current HttpContext is null.&lt;/exception&gt;
        protected LazyManyObjectsResolverBase(IServiceProvider serviceProvider, ILogger logger, IEnumerable&lt;Type&gt; value, ObjectLifetimeScope scope = ObjectLifetimeScope.Application)
            : base(serviceProvider, logger, value, scope)
        {
        }

        private void Initialize()
        {
            _resolvedTypes = new Lazy&lt;List&lt;Type&gt;&gt;(() =&gt;
            {
                var resolvedTypes = new List&lt;Type&gt;();

                // get the types by evaluating the lazy &amp; producers
                var types = new List&lt;Type&gt;();
                types.AddRange(_lazyTypeList.Select(x =&gt; x.Value));
                types.AddRange(_typeListProducerList.SelectMany(x =&gt; x()));

                // we need to validate each resolved type now since we could
                // not do it before evaluating the lazy &amp; producers
                foreach (var type in types.Where(x =&gt; _excludedTypesList.Contains(x) == false))
                {
                    AddValidAndNoDuplicate(resolvedTypes, type);
                }

                return resolvedTypes;
            });
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether the resolver has resolved types to create instances from.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;To be used in unit tests.&lt;/remarks&gt;
        public bool HasResolvedTypes
        {
            get { return _resolvedTypes.IsValueCreated; }
        }

        /// &lt;summary&gt;
        /// Gets the list of types to create instances from.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;When called, will get the types from the lazy list.&lt;/remarks&gt;
        protected override IEnumerable&lt;Type&gt; InstanceTypes
        {
            get { return _resolvedTypes.Value; }
        }

        /// &lt;summary&gt;
        /// Ensures that type is valid and not a duplicate
        /// then appends the type to the end of the list
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt;
        private void AddValidAndNoDuplicate(List&lt;Type&gt; list, Type type)
        {
            EnsureCorrectType(type);
            if (list.Contains(type))
            {
                throw new InvalidOperationException(string.Format(
                    &quot;Type {0} is already in the collection of types.&quot;, type.FullName));
            }
            list.Add(type);
        }

        #region Types collection manipulation

        /// &lt;summary&gt;
        /// Removes types from the list of types, once it has been lazily evaluated, and before actual objects are instanciated.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;The type to remove.&lt;/param&gt;
        public override void RemoveType(Type value)
        {
            EnsureSupportsRemove();

            _excludedTypesList.Add(value);
        }

        /// &lt;summary&gt;
        /// Lazily adds types from lazy types.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;types&quot;&gt;The lazy types, to add.&lt;/param&gt;
        protected void AddTypes(IEnumerable&lt;Lazy&lt;Type&gt;&gt; types)
        {
            EnsureSupportsAdd();

            using (Resolution.Configuration)
            using (GetWriteLock())
            {
                foreach (var t in types)
                {
                    _lazyTypeList.Add(t);
                }
            }
        }

        /// &lt;summary&gt;
        /// Lazily adds types from a function producing types.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;typeListProducer&quot;&gt;The functions producing types, to add.&lt;/param&gt;
        public void AddTypeListDelegate(Func&lt;IEnumerable&lt;Type&gt;&gt; typeListProducer)
        {
            EnsureSupportsAdd();

            using (Resolution.Configuration)
            using (GetWriteLock())
            {
                _typeListProducerList.Add(typeListProducer);
            }
        }

        /// &lt;summary&gt;
        /// Lazily adds a type from a lazy type.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;The lazy type, to add.&lt;/param&gt;
        public void AddType(Lazy&lt;Type&gt; value)
        {
            EnsureSupportsAdd();

            using (Resolution.Configuration)
            using (GetWriteLock())
            {
                _lazyTypeList.Add(value);
            }
        }

        /// &lt;summary&gt;
        /// Lazily adds a type from an actual type.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;value&quot;&gt;The actual type, to add.&lt;/param&gt;
        /// &lt;remarks&gt;The type is converted to a lazy type.&lt;/remarks&gt;
        public override void AddType(Type value)
        {
            AddType(new Lazy&lt;Type&gt;(() =&gt; value));
        }

        /// &lt;summary&gt;
        /// Clears all lazy types
        /// &lt;/summary&gt;
        public override void Clear()
        {
            EnsureSupportsClear();

            using (Resolution.Configuration)
            using (GetWriteLock())
            {
                _lazyTypeList.Clear();
            }
        }

        #endregion

        #region Types collection manipulation support

        /// &lt;summary&gt;
        /// Gets a &lt;c&gt;false&lt;/c&gt; value indicating that the resolver does NOT support inserting types.
        /// &lt;/summary&gt;
        protected override bool SupportsInsert
        {
            get { return false; }
        }

        #endregion
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[38,15,38,51,1],[39,9,39,10,1],[40,13,40,26,1],[41,9,41,10,1],[46,15,46,26,0],[47,9,47,10,0],[48,13,48,26,0],[49,9,49,10,0],[54,15,54,32,0],[55,9,55,10,0],[56,13,56,26,0],[57,9,57,10,0],[60,15,60,51,1],[61,9,61,10,1],[62,13,62,36,1],[63,9,63,10,1],[68,15,68,103,0],[69,9,69,10,0],[70,9,70,10,0],[73,15,73,51,1],[74,9,74,10,1],[75,13,75,61,1],[76,9,76,10,1],[81,15,81,111,0],[82,9,82,10,0],[83,9,83,10,0],[86,15,86,57,0],[87,9,87,10,0],[88,13,88,36,0],[89,9,89,10,0],[94,15,94,109,0],[95,9,95,10,0],[96,9,96,10,0],[99,15,99,57,0],[100,9,100,10,0],[101,13,101,61,0],[102,9,102,10,0],[107,15,107,117,0],[108,9,108,10,0],[109,9,109,10,0],[113,9,113,82,0],[113,9,113,82,0],[113,9,113,82,1],[113,9,113,82,0],[113,9,113,82,0],[114,9,114,116,0],[114,9,114,116,0],[114,9,114,116,0],[114,9,114,116,0],[114,9,114,116,1],[115,9,115,75,0],[115,9,115,75,0],[115,9,115,75,1],[115,9,115,75,0],[115,9,115,75,0],[127,15,127,57,0],[128,9,128,10,0],[129,9,129,10,0],[142,15,142,58,0],[143,9,143,10,0],[144,9,144,10,0],[147,9,147,10,1],[148,13,149,13,1],[149,13,149,14,1],[149,14,150,17,1],[150,17,150,54,1],[150,54,153,17,1],[153,17,153,46,1],[153,46,154,17,1],[154,17,154,58,1],[154,58,154,65,1],[154,65,154,68,1],[154,17,154,68,1],[154,68,155,17,1],[155,17,155,70,1],[155,70,155,73,1],[155,73,155,76,1],[155,17,155,76,1],[155,76,159,17,1],[159,17,159,24,1],[159,24,159,26,1],[159,26,159,34,1],[159,34,159,35,1],[159,35,159,37,1],[159,37,159,38,1],[159,38,159,55,1],[159,55,159,94,1],[159,94,159,95,1],[159,38,159,95,1],[159,95,160,17,1],[160,17,160,18,1],[160,18,161,21,1],[161,21,161,65,1],[161,65,162,17,1],[162,17,162,18,1],[162,18,164,17,1],[164,17,164,38,1],[164,38,165,13,1],[165,13,165,14,1],[165,14,165,16,1],[148,13,165,16,1],[166,9,166,10,1],[174,17,174,18,1],[174,19,174,56,1],[174,57,174,58,1],[183,17,183,18,1],[183,19,183,47,1],[183,48,183,49,1],[193,9,193,10,1],[194,13,194,37,1],[195,13,195,37,1],[196,13,196,14,1],[197,17,198,88,1],[200,13,200,28,1],[201,9,201,10,1],[210,9,210,10,1],[211,13,211,36,1],[213,13,213,43,1],[214,9,214,10,1],[221,9,221,10,1],[222,13,222,33,1],[224,13,224,45,1],[225,13,225,35,1],[226,13,226,14,1],[227,17,227,24,1],[227,26,227,31,1],[227,32,227,34,1],[227,35,227,40,1],[228,17,228,18,1],[229,21,229,42,1],[230,17,230,18,1],[231,13,231,14,1],[232,9,232,10,1],[239,9,239,10,1],[240,13,240,33,1],[242,13,242,45,1],[243,13,243,35,1],[244,13,244,14,1],[245,17,245,61,1],[246,13,246,14,1],[247,9,247,10,1],[254,9,254,10,1],[255,13,255,33,1],[257,13,257,45,1],[258,13,258,35,1],[259,13,259,14,1],[260,17,260,42,1],[261,13,261,14,1],[262,9,262,10,1],[270,9,270,10,1],[271,13,271,42,1],[271,42,271,47,1],[271,47,271,50,1],[271,13,271,50,1],[272,9,272,10,1],[278,9,278,10,0],[279,13,279,35,0],[281,13,281,45,0],[282,13,282,35,0],[283,13,283,14,0],[284,17,284,39,0],[285,13,285,14,0],[286,9,286,10,0],[297,17,297,18,0],[297,19,297,32,0],[297,33,297,34,0]]);
    </script>
  </body>
</html>